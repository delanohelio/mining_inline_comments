{"pr_number": 975, "pr_title": "Fixes #974: OrElseCursor doesn't properly support continuations.", "pr_createdAt": "2020-06-17T19:55:56Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/975", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTY0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441809641", "bodyText": "These two new methods could probably use javadoc comments", "author": "alecgrieser", "createdAt": "2020-06-17T20:20:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/RecordCursor.java", "diffHunk": "@@ -781,12 +781,23 @@ public boolean isLimitReached() {\n      * @param func function to be called if the cursor is empty to give another source of records\n      * @return a new cursor that returns the same records as this cursor \n      * or the result of {@code func} if this cursor does not produce any records\n+     * @deprecated because it does not support continuations and is easy to misuse.\n+     *             Use {@link #flatMapPipelined(Function, BiFunction, byte[], int)} instead.\n      */\n+    @API(API.Status.DEPRECATED)\n+    @Deprecated\n     @Nonnull\n     default RecordCursor<T> orElse(@Nonnull Function<Executor, RecordCursor<T>> func) {\n         return new OrElseCursor<>(this, func);\n     }\n \n+    @Nonnull", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNTU4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441835584", "bodyText": "Done.", "author": "nschiefer", "createdAt": "2020-06-17T21:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMDQ2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441810465", "bodyText": "Given that this is private anyway, is there a reason to not use the proto-generated enum?", "author": "alecgrieser", "createdAt": "2020-06-17T20:21:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -154,4 +214,76 @@ public boolean accept(@Nonnull RecordCursorVisitor visitor) {\n         }\n         return visitor.visitLeave(this);\n     }\n+\n+    private enum State {", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNTk5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441835994", "bodyText": "No, except that it was my understanding that we did not idiomatically use protobuf generated classes except when interfacing directly with protobufs. I'd be more than happy to drop this enum.", "author": "nschiefer", "createdAt": "2020-06-17T21:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMDQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzODgyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441838827", "bodyText": "I think we probably generally want to keep generated proto out of our API...though we maybe have already broken that rule. But directly interfacing with protos in private methods seems fine to me. This also isn't super high priority", "author": "alecgrieser", "createdAt": "2020-06-17T21:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMDQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTQ1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441811452", "bodyText": "Should this constructor be deprecated, too?", "author": "alecgrieser", "createdAt": "2020-06-17T20:23:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -57,7 +65,44 @@\n     public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor, RecordCursor<T>> func) {", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNjMzNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441836337", "bodyText": "Our various analyzers do not understand transitive dependencies, so marking this as \"deprecated\" creates a warning in the deprecated RecordCursor.orElse() method. I can suppress the warning, but I don't actually mind this constructor sticking around.", "author": "nschiefer", "createdAt": "2020-06-17T21:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNzUwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441837508", "bodyText": "Interesting. I thought using deprecated code in @Deprecated methods was generally allowed. If it's not, I think depreciating this constructor and then suppressing deprecation warnings in the deprecated orElse method is still the call.", "author": "alecgrieser", "createdAt": "2020-06-17T21:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MjA3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441842077", "bodyText": "Okay, that's fine with me.", "author": "nschiefer", "createdAt": "2020-06-17T21:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTc0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441811746", "bodyText": "This feels like it should be INTERNAL, but I could be wrong", "author": "alecgrieser", "createdAt": "2020-06-17T20:24:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -57,7 +65,44 @@\n     public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor, RecordCursor<T>> func) {\n         this.inner = inner;\n         this.func = func;\n-        this.first = true;\n+        this.state = State.UNDECIDED;\n+    }\n+\n+    public OrElseCursor(@Nonnull Function<byte[], ? extends RecordCursor<T>> innerFunc,", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNjUxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441836510", "bodyText": "Sure, why not.", "author": "nschiefer", "createdAt": "2020-06-17T21:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNjk1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441816955", "bodyText": "Okay, trying to think about how this interacts with in-band vs out of band limits. I...think it's right that if the child hits an in-band limit (which would only happen if, say, one had a filter over a row limited cursor, and the inner child of that filter stopped hit its limit prior to it no longer returning results) without hitting a value, then it goes down the else path, but I'm not actually sure if that's right. I guess it's consistent with the prior behavior.", "author": "alecgrieser", "createdAt": "2020-06-17T20:34:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/cursors/OrElseCursor.java", "diffHunk": "@@ -66,22 +111,37 @@ public OrElseCursor(@Nonnull RecordCursor<T> inner, @Nonnull Function<Executor,\n         if (nextResult != null && !nextResult.hasNext()) {\n             return CompletableFuture.completedFuture(nextResult);\n         }\n-        if (first) {\n-            return inner.onNext().thenCompose(result -> {\n-                first = false;\n-                if (result.hasNext() || result.getNoNextReason().isOutOfBand()) {\n-                    // Either have result or do not know whether to select else yet or not.\n-                    return CompletableFuture.completedFuture(result);\n-                } else {\n-                    other = func.apply(getExecutor());\n-                    return other.onNext();\n-                }\n-            }).thenApply(this::postProcess);\n-        }\n-        if (other != null) {\n-            return other.onNext().thenApply(this::postProcess);\n+        final CompletableFuture<RecordCursorResult<T>> innerFuture;\n+        switch (state) {\n+            case USE_INNER:\n+                innerFuture = inner.onNext();\n+                break;\n+            case USE_OTHER:\n+                innerFuture = other.onNext();\n+                break;\n+            case UNDECIDED:\n+                innerFuture = inner.onNext().thenCompose(result -> {\n+                    if (result.hasNext()) {\n+                        // Inner cursor has produced a value, so we take the inner branch.\n+                        state = State.USE_INNER;\n+                        return CompletableFuture.completedFuture(result);\n+                    } else if (result.getNoNextReason().isOutOfBand()) {", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNjcxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441836714", "bodyText": "I believe that what we have here exactly matches what happened before, and I would like to keep it that way.", "author": "nschiefer", "createdAt": "2020-06-17T21:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNjk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNzgwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441837805", "bodyText": "Okay, sounds good.", "author": "alecgrieser", "createdAt": "2020-06-17T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxNjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzg4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441823882", "bodyText": "Given that the continuations for the cursors from the JoinedRecordPlan won't be valid any more, it seems like the planHash on this class should change (at least--perhaps ideally--if there are any outer joined types in joinedTypes).", "author": "alecgrieser", "createdAt": "2020-06-17T20:45:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/synthetic/JoinedRecordPlan.java", "diffHunk": "@@ -222,10 +222,14 @@ public JoinedRecordPlan(@Nonnull JoinedRecordType joinedRecordType, @Nonnull Lis\n \n     private RecordCursor<EvaluationContext> query(int depth, @Nonnull FDBRecordStore store, @Nonnull EvaluationContext context,\n                                                   @Nullable byte[] continuation, @Nonnull ExecuteProperties executeProperties) {\n-        RecordCursor<FDBQueriedRecord<Message>> records = queries.get(depth).execute(store, context, continuation, executeProperties);\n+        final RecordCursor<FDBQueriedRecord<Message>> records;\n         final JoinedType joinedType = joinedTypes.get(depth + 1);\n         if (joinedType.constituent.isOuterJoined()) {\n-            records = records.orElse(executor -> RecordCursor.fromFuture(executor, CompletableFuture.completedFuture(null)));\n+            records = RecordCursor.orElse(innerContinuation -> queries.get(depth).execute(store, context, innerContinuation, executeProperties),", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MjI5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441842295", "bodyText": "This class is package-private and minimally used so I don't think it's worth the additional code complexity.", "author": "nschiefer", "createdAt": "2020-06-17T21:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NDE2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441844162", "bodyText": "Yeah, package-private and we don't seem to be leaking the continuations from that planner, though maybe that's a sign that it shouldn't be PlanHashable, though not necessarily for this PR or anything. Okay, that's fine then.", "author": "alecgrieser", "createdAt": "2020-06-17T21:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyMzg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjQzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441826435", "bodyText": "The name here should probably reflect the fact that it returns on OrElse cursor", "author": "alecgrieser", "createdAt": "2020-06-17T20:50:35Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/RecordCursorTest.java", "diffHunk": "@@ -1012,21 +1014,97 @@ public void testFlatMapReasons() throws Exception {\n     public void testOrElseReasons() throws Exception {\n         // Don't take else path if inside stops prematurely.\n         final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n-        final Function<Executor, RecordCursor<Integer>> orElse = x -> RecordCursor.fromList(Collections.singletonList(0));\n-        RecordCursor<Integer> cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) -> RecordCursor.fromList(Collections.singletonList(0), cont);\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, null);\n         assertEquals(Collections.emptyList(), cursor.asList().join());\n         RecordCursorResult<Integer> noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, noNextResult.getNoNextReason());\n-        cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list, noNextResult.getContinuation().toBytes()), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, noNextResult.getContinuation().toBytes());\n         assertEquals(Collections.singletonList(0), cursor.asList().join());\n         noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, noNextResult.getNoNextReason());\n     }\n \n+    @Test\n+    public void orElseWithEventuallyNonEmptyInner() {\n+        final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, nextResult.getContinuation().toBytes());\n+\n+        // Choose the inner branch since we eventually get a value\n+        assertEquals(Collections.singletonList(5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Test\n+    public void orElseContinueWithInnerBranchAfterDecision() {\n+        final List<Integer> longList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, null);\n+\n+        RecordCursorResult<Integer> nextResult = null;\n+        for (int i = 0; i < 3; i++) { // three rounds with no results\n+            nextResult = cursor.getNext();\n+            assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, nextResult.getContinuation().toBytes());\n+        }\n+\n+        // Choose the inner branch\n+        assertEquals(ImmutableList.of(11, 12), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        byte[] continuation = nextResult.getContinuation().toBytes();\n+        while (continuation != null) {\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, continuation);\n+            nextResult = cursor.getNext();\n+            continuation = nextResult.getContinuation().toBytes();\n+        }\n+    }\n+\n+    @Test\n+    public void orElseContinueWithElseBranchAfterDecision() {\n+        final List<Integer> innerList = Arrays.asList(1, 2, 3, 4, 5);\n+        final List<Integer> elseList = Arrays.asList(-1, -2, -3, -4, -5);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) ->\n+                new FakeOutOfBandCursor<>(RecordCursor.fromList(elseList, cont), 3, RecordCursor.NoNextReason.TIME_LIMIT_REACHED);\n+\n+        // Go through inner cursor to determine that it's empty.\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, nextResult.getContinuation().toBytes());\n+\n+        // Switch to else branch, but get stuck with an out-of-band limit.\n+        assertEquals(ImmutableList.of(-1, -2, -3), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        // Continue else branch\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(innerList, cont), 3)\n+                .filter(i -> false), orElse, nextResult.getContinuation().toBytes());\n+        assertEquals(ImmutableList.of(-4, -5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Nonnull\n+    private static RecordCursor<Integer> getFilteredFakeOutOfBandCursor(@Nonnull List<Integer> list, int limit, int threshold,", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzODkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441838922", "bodyText": "Done.", "author": "nschiefer", "createdAt": "2020-06-17T21:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441826835", "bodyText": "It feels like this loop should assert something, even if it's just that it never gets \"0\" back (so that we know it never hits the else branch), though having it assert about the real contents would be better.", "author": "alecgrieser", "createdAt": "2020-06-17T20:51:26Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/RecordCursorTest.java", "diffHunk": "@@ -1012,21 +1014,97 @@ public void testFlatMapReasons() throws Exception {\n     public void testOrElseReasons() throws Exception {\n         // Don't take else path if inside stops prematurely.\n         final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n-        final Function<Executor, RecordCursor<Integer>> orElse = x -> RecordCursor.fromList(Collections.singletonList(0));\n-        RecordCursor<Integer> cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+        final BiFunction<Executor, byte[], RecordCursor<Integer>> orElse = (x, cont) -> RecordCursor.fromList(Collections.singletonList(0), cont);\n+        RecordCursor<Integer> cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, null);\n         assertEquals(Collections.emptyList(), cursor.asList().join());\n         RecordCursorResult<Integer> noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, noNextResult.getNoNextReason());\n-        cursor = new FakeOutOfBandCursor<>(RecordCursor.fromList(list, noNextResult.getContinuation().toBytes()), 3)\n-                .filter(i -> false)\n-                .orElse(orElse);\n+\n+        cursor = RecordCursor.orElse(cont -> new FakeOutOfBandCursor<>(RecordCursor.fromList(list, cont), 3)\n+                .filter(i -> false), orElse, noNextResult.getContinuation().toBytes());\n         assertEquals(Collections.singletonList(0), cursor.asList().join());\n         noNextResult = cursor.getNext();\n         assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, noNextResult.getNoNextReason());\n     }\n \n+    @Test\n+    public void orElseWithEventuallyNonEmptyInner() {\n+        final List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, null);\n+        assertEquals(Collections.emptyList(), cursor.asList().join());\n+        RecordCursorResult<Integer> nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+        cursor = getFilteredFakeOutOfBandCursor(list, 3, 4, nextResult.getContinuation().toBytes());\n+\n+        // Choose the inner branch since we eventually get a value\n+        assertEquals(Collections.singletonList(5), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.SOURCE_EXHAUSTED, nextResult.getNoNextReason());\n+    }\n+\n+    @Test\n+    public void orElseContinueWithInnerBranchAfterDecision() {\n+        final List<Integer> longList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18);\n+        RecordCursor<Integer> cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, null);\n+\n+        RecordCursorResult<Integer> nextResult = null;\n+        for (int i = 0; i < 3; i++) { // three rounds with no results\n+            nextResult = cursor.getNext();\n+            assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, nextResult.getContinuation().toBytes());\n+        }\n+\n+        // Choose the inner branch\n+        assertEquals(ImmutableList.of(11, 12), cursor.asList().join());\n+        nextResult = cursor.getNext();\n+        assertEquals(RecordCursor.NoNextReason.TIME_LIMIT_REACHED, nextResult.getNoNextReason());\n+\n+        byte[] continuation = nextResult.getContinuation().toBytes();\n+        while (continuation != null) {\n+            cursor = getFilteredFakeOutOfBandCursor(longList, 3, 10, continuation);\n+            nextResult = cursor.getNext();\n+            continuation = nextResult.getContinuation().toBytes();", "originalCommit": "8fbb4025a8590c561b511e5daa799d1f86241c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MzgyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441843828", "bodyText": "Okay, I changed this to assert about the real contents.\nThere is an interesting philosophical question here about testing (i.e., should you assert on everything you can think of, or just the bare minimum behavior you are trying to demonstrate). I'm happy to go along, though.", "author": "nschiefer", "createdAt": "2020-06-17T21:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NDU5MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441844591", "bodyText": "I suppose so. It does seem weird to have this loop at all if it's not going to assert on anything (unless the point is just to prove it eventually completes or something)", "author": "alecgrieser", "createdAt": "2020-06-17T21:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NTYxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/975#discussion_r441845613", "bodyText": "Right, I was trying to demonstrate that the cursor can indeed be restarted without falling over on continuation parsing exceptions (as happened during testing).", "author": "nschiefer", "createdAt": "2020-06-17T21:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgzNQ=="}], "type": "inlineReview"}, {"oid": "f034a282e40428c450e82cd72d902fd73b6e5cdb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f034a282e40428c450e82cd72d902fd73b6e5cdb", "message": "Fixes #974: OrElseCursor doesn't properly support continuations.\n\nUse a new structured continuation object and protobuf serialization to\nrecord the complete state of the OrElseCursor, including which branch\nwas chosen. Rewrite OrElseCursor's logic in a simpler state-machine\nstyle, which makes it easy to resume the cursor before it has made a\ndecision about which branch to take.\n\nTo avoid problems like we saw with the FlatMapPipelinedCursor's\ncontinuations, deprecate the RecordCursor.orElse() fluent method and\nreplace it with a static method that interprets the continuation.\n\nBecause this changes the continuation format, this is a breaking change.", "committedDate": "2020-06-17T21:46:26Z", "type": "commit"}, {"oid": "f034a282e40428c450e82cd72d902fd73b6e5cdb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f034a282e40428c450e82cd72d902fd73b6e5cdb", "message": "Fixes #974: OrElseCursor doesn't properly support continuations.\n\nUse a new structured continuation object and protobuf serialization to\nrecord the complete state of the OrElseCursor, including which branch\nwas chosen. Rewrite OrElseCursor's logic in a simpler state-machine\nstyle, which makes it easy to resume the cursor before it has made a\ndecision about which branch to take.\n\nTo avoid problems like we saw with the FlatMapPipelinedCursor's\ncontinuations, deprecate the RecordCursor.orElse() fluent method and\nreplace it with a static method that interprets the continuation.\n\nBecause this changes the continuation format, this is a breaking change.", "committedDate": "2020-06-17T21:46:26Z", "type": "forcePushed"}]}