{"pr_number": 902, "pr_title": "Fixes #901: False positive of uniqueness violations prevents building indexes", "pr_createdAt": "2020-04-14T04:17:52Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/902", "timeline": [{"oid": "edfad1aae47d67c4f91f9042283550d8815e82cb", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/edfad1aae47d67c4f91f9042283550d8815e82cb", "message": "Fixes #901: False positive of uniqueness violations prevents building indexes", "committedDate": "2020-04-14T04:25:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2MzczMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r407863732", "bodyText": "Maybe I can just change the signature of updateUniquenessViolations rather than adding a new one.", "author": "nblintao", "createdAt": "2020-04-14T04:43:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexMaintainer.java", "diffHunk": "@@ -114,11 +114,28 @@ public Subspace getSecondarySubspace() {\n      * @param valueKey the indexed key that is (apparently) not unique\n      * @param primaryKey the primary key of one record that is causing a violation\n      * @param existingKey the primary key of another record that is causing a violation (or <code>null</code> if none specified)\n-     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it\n+     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it. When\n+     * <code>true</code>, it is favored use {@link #removeUniquenessViolationsAsync(Tuple, Tuple)} instead.\n      */\n     @Nonnull\n     public abstract void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove);\n \n+    /**\n+     * Remove a uniqueness violation within the database. This is used to keep track of\n+     * uniqueness violations that occur when an index is in write-only mode, both during\n+     * the built itself and by other writes. This means that the writes will succeed, but\n+     * it will cause a later attempt to make the index readable to fail.\n+     *\n+     * This will remove the last uniqueness violation entry when removing the second last one under the same\n+     * <code>valueKey</code>, in contrast to {@link #updateUniquenessViolations(Tuple, Tuple, Tuple, boolean)} which\n+     * may not.\n+     * @param valueKey the indexed key that is (apparently) not unique\n+     * @param primaryKey the primary key of one record that is causing a violation\n+     * @return a future that is complete when the uniqueness violation is removed\n+     */\n+    @Nonnull\n+    public abstract CompletableFuture<Void> removeUniquenessViolationsAsync(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey);", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwODU1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r410508559", "bodyText": "Yeah, it does seem a little weird that updateUniquenessViolations(valueKey, primaryKey, existingKey, false) doesn't call this, other than the fact that it would require async-ness.\nI think it's probably better, in the long run, to have the Async version of updateUniquenessViolations be the thing. So, either we do something like just break the API by making it async (maybe on 2.9?) or do something like add an Async version, and by default, the async version calls the synchronous version and then returns AsyncUtil.DONE, but then we reverse that in the StandardIndexMaintainer.", "author": "alecgrieser", "createdAt": "2020-04-17T23:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2MzczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwOTQ5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r410509490", "bodyText": "I think we probably also want to set the streaming mode on this scan properties to CursorStreamingMode.WANT_ALL", "author": "alecgrieser", "createdAt": "2020-04-17T23:09:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/StandardIndexMaintainer.java", "diffHunk": "@@ -359,6 +363,26 @@ public void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple p\n         }\n     }\n \n+    @Nonnull\n+    @Override\n+    public CompletableFuture<Void> removeUniquenessViolationsAsync(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey) {\n+        Subspace uniqueValueSubspace = state.store.indexUniquenessViolationsSubspace(state.index).subspace(valueKey);\n+        state.transaction.clear(uniqueValueSubspace.pack(primaryKey));\n+        // Remove the last entry if it was the second last entry in the unique value subspace.\n+        RecordCursor<KeyValue> uniquenessViolationEntries = KeyValueCursor.Builder.withSubspace(uniqueValueSubspace)\n+                .setContext(state.context)\n+                .setScanProperties(new ScanProperties(ExecuteProperties.newBuilder()\n+                        .setReturnedRowLimit(2)\n+                        .setIsolationLevel(IsolationLevel.SERIALIZABLE)\n+                        .build()))", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NzE3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r412577171", "bodyText": "Fancy! Done.", "author": "nblintao", "createdAt": "2020-04-22T00:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwOTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDE0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r410510142", "bodyText": "Is there a reason to not do something like:\nif (!MoreAsyncUtil.isCompletedNormally(updateOrdinaryIndex)) {\n    futures.add(updateOridnaryIndex);\n}\nThen I think it would look for uniqueness violations in parallel with updating the ranked set. (And the check for if it's completed normally is just to avoid waiting on done futures, but it should be optional.)\nI didn't leave a comment about it, but I think the same thing applies to the TimeWindowLeaderboardIndexMaintainer.", "author": "alecgrieser", "createdAt": "2020-04-17T23:12:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexMaintainer.java", "diffHunk": "@@ -116,7 +116,7 @@ public RankIndexMaintainer(IndexMaintainerState state) {\n         final List<CompletableFuture<Void>> futures = new ArrayList<>();\n         for (IndexEntry indexEntry : indexEntries) {\n             // First maintain an ordinary B-tree index by score.\n-            updateOneKey(savedRecord, remove, indexEntry);\n+            CompletableFuture<Void> updateOrdinaryIndex = updateOneKeyAsync(savedRecord, remove, indexEntry);", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r412548404", "bodyText": "Oh, I didn't know the rank set was not dependent on the original index. Fixed.", "author": "nblintao", "createdAt": "2020-04-21T22:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMjUyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418332520", "bodyText": "The actual keys aren't dependent, for sure. In theory, we \"shouldn't\" update the keys in the ranked set unless the regular Index update succeeds, which is what the precommit check is for.", "author": "alecgrieser", "createdAt": "2020-04-30T22:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3OTE4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r411379187", "bodyText": "I think I'm ok with this change, but I do know of at least one down-stream project that overrides updateOneKey.  If we were really concerned about compatibility, this could be changed to something like:\nprotected <M extends Message> CompletableFuture<Void> updateOneKeyAsync(@Nonnull final FDBIndexableRecord<M> savedRecord,\n                                                                        final boolean remove,\n                                                                        @Nonnull final IndexEntry indexEntry) {\n    updateOneKey(savedRecord, remove, indexEntry);\n    return postUpdateOneKeyAsync(savedRecord, remove, indexEntry).\n}\n\nThis is kind of convoluted and gross though, so I'm not strongly advocating for it....just that it is a consideration.", "author": "scgray", "createdAt": "2020-04-20T13:31:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/StandardIndexMaintainer.java", "diffHunk": "@@ -304,10 +304,11 @@ public boolean skipUpdateForUnchangedKeys() {\n      * @param savedRecord the record being indexed\n      * @param remove <code>true</code> if removing from index\n      * @param indexEntry the entry for the index to be updated\n+     * @return a future completed when the key is updated\n      */\n-    protected <M extends Message> void updateOneKey(@Nonnull final FDBIndexableRecord<M> savedRecord,\n-                                                    final boolean remove,\n-                                                    @Nonnull final IndexEntry indexEntry) {\n+    protected <M extends Message> CompletableFuture<Void> updateOneKeyAsync(@Nonnull final FDBIndexableRecord<M> savedRecord,", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MjE3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r411382175", "bodyText": "Not for this PR, but I think it would make some sense to cache subspace computations that happen at high frequently (e.g. on every record that is accessed or changed), so we don't compute state.store.indexUniquenessViolationsSubspace(state.index) on every key.", "author": "scgray", "createdAt": "2020-04-20T13:36:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/StandardIndexMaintainer.java", "diffHunk": "@@ -359,6 +363,26 @@ public void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple p\n         }\n     }\n \n+    @Nonnull\n+    @Override\n+    public CompletableFuture<Void> removeUniquenessViolationsAsync(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey) {\n+        Subspace uniqueValueSubspace = state.store.indexUniquenessViolationsSubspace(state.index).subspace(valueKey);", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MzMzNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r411383337", "bodyText": "<p>This will", "author": "scgray", "createdAt": "2020-04-20T13:37:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexMaintainer.java", "diffHunk": "@@ -114,11 +114,28 @@ public Subspace getSecondarySubspace() {\n      * @param valueKey the indexed key that is (apparently) not unique\n      * @param primaryKey the primary key of one record that is causing a violation\n      * @param existingKey the primary key of another record that is causing a violation (or <code>null</code> if none specified)\n-     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it\n+     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it. When\n+     * <code>true</code>, it is favored use {@link #removeUniquenessViolationsAsync(Tuple, Tuple)} instead.\n      */\n     @Nonnull\n     public abstract void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove);\n \n+    /**\n+     * Remove a uniqueness violation within the database. This is used to keep track of\n+     * uniqueness violations that occur when an index is in write-only mode, both during\n+     * the built itself and by other writes. This means that the writes will succeed, but\n+     * it will cause a later attempt to make the index readable to fail.\n+     *\n+     * This will remove the last uniqueness violation entry when removing the second last one under the same", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNDMwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r412614302", "bodyText": "Done.", "author": "nblintao", "createdAt": "2020-04-22T02:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4NDE0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r411384145", "bodyText": "It would be really useful too have a description of why this has to be done (TBH, I'm not clear on it myself)", "author": "scgray", "createdAt": "2020-04-20T13:38:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexMaintainer.java", "diffHunk": "@@ -114,11 +114,28 @@ public Subspace getSecondarySubspace() {\n      * @param valueKey the indexed key that is (apparently) not unique\n      * @param primaryKey the primary key of one record that is causing a violation\n      * @param existingKey the primary key of another record that is causing a violation (or <code>null</code> if none specified)\n-     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it\n+     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it. When\n+     * <code>true</code>, it is favored use {@link #removeUniquenessViolationsAsync(Tuple, Tuple)} instead.\n      */\n     @Nonnull\n     public abstract void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove);\n \n+    /**\n+     * Remove a uniqueness violation within the database. This is used to keep track of\n+     * uniqueness violations that occur when an index is in write-only mode, both during\n+     * the built itself and by other writes. This means that the writes will succeed, but\n+     * it will cause a later attempt to make the index readable to fail.\n+     *\n+     * This will remove the last uniqueness violation entry when removing the second last one under the same\n+     * <code>valueKey</code>, in contrast to {@link #updateUniquenessViolations(Tuple, Tuple, Tuple, boolean)} which\n+     * may not.", "originalCommit": "edfad1aae47d67c4f91f9042283550d8815e82cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "741e609983655554be41ed5a77f9f11ce5411ae7", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/741e609983655554be41ed5a77f9f11ce5411ae7", "message": "Move uniqueness APIs down to StandardIndexMaintainer & Fixed a bug in removeUniquenessViolationsAsync & Improved tests\n\nThe main problem fixed by this PR is that: `FDBRecordStore.resolveUniquenessViolation` used to be relied on to delete the last uniqueness violation entry when delete the second last one. But this is not the only way the uniqueness violation is resolved. It doesn't cover the case that the violation is resolved when record is deleted organically. To resolve this problem, now it will delete the last entry as part of deleting records (See `removeUniquenessViolationsAsync`).\n\nThis change also tries to consolidate uniqueness logic at `StandardIndexMaintainer` level:\n- `FDBRecordStore .addUniquenessCheck`  -> `StandardIndexMaintainer.checkUniqueness`\n- `IndexMaintainer.updateUniquenessViolations` -> `StandardIndexMaintainer .addUniquenessViolations` and `StandardIndexMaintainer.removeUniquenessViolationsAsync`", "committedDate": "2020-04-22T01:40:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Mzc5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418283792", "bodyText": "Could we just return the future considering updateOneKey is now async?", "author": "nblintao", "createdAt": "2020-04-30T20:56:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/StandardIndexMaintainer.java", "diffHunk": "@@ -345,18 +350,74 @@ public boolean skipUpdateForUnchangedKeys() {\n                 state.store.countKeyValue(FDBStoreTimer.Counts.SAVE_INDEX_KEY, FDBStoreTimer.Counts.SAVE_INDEX_KEY_BYTES, FDBStoreTimer.Counts.SAVE_INDEX_VALUE_BYTES,\n                         keyBytes, valueBytes);\n             }\n+            return AsyncUtil.DONE;\n         }\n     }\n \n-    @Override\n-    @Nonnull\n-    public void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove) {\n+    protected <M extends Message> void checkUniqueness(@Nonnull FDBIndexableRecord<M> savedRecord, @Nonnull IndexEntry indexEntry) {\n+        Tuple valueKey = indexEntry.getKey();\n+        AsyncIterable<KeyValue> kvs = state.transaction.getRange(state.indexSubspace.range(valueKey));\n+        Tuple primaryKey = savedRecord.getPrimaryKey();\n+        final CompletableFuture<Void> checker = state.store.getContext().instrument(FDBStoreTimer.Events.CHECK_INDEX_UNIQUENESS,\n+                AsyncUtil.forEach(kvs, kv -> {\n+                    Tuple existingEntry = unpackKey(getIndexSubspace(), kv);\n+                    Tuple existingKey = state.index.getEntryPrimaryKey(existingEntry);\n+                    if (!TupleHelpers.equals(primaryKey, existingKey)) {\n+                        if (state.store.isIndexWriteOnly(state.index)) {\n+                            addUniquenessViolations(valueKey, primaryKey, existingKey);\n+                            addUniquenessViolations(valueKey, existingKey, primaryKey);\n+                        } else {\n+                            throw new RecordIndexUniquenessViolation(state.index, indexEntry, primaryKey, existingKey);\n+                        }\n+                    }\n+                }, getExecutor()));\n+        state.store.getRecordContext().addCommitCheck(checker);", "originalCommit": "741e609983655554be41ed5a77f9f11ce5411ae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0NTA2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418345065", "bodyText": "I believe the purpose of making it a pre-commit check is that it means that if someone violates a uniqueness constraint, then we don't accidentally commit the transaction.\nI could see an argument being made, though, that we'd want to fail fast...if we can. I think we definitely want preserve the behavior where committing is not allowed if there's a uniqueness constraint violation caused by a record insert, though.", "author": "alecgrieser", "createdAt": "2020-04-30T23:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Mzc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0NTM3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418345370", "bodyText": "(It's possibly worth memorializing this with a comment--something like, \"add a pre-commit check to prevent accidentally committing and getting into an invalid state\" or something.)", "author": "alecgrieser", "createdAt": "2020-04-30T23:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Mzc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NzI3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r419597277", "bodyText": "Added the comment.", "author": "nblintao", "createdAt": "2020-05-04T17:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4Mzc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzNzc0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418337746", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void addUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey) {\n          \n          \n            \n                protected void addUniquenessViolation(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey) {", "author": "alecgrieser", "createdAt": "2020-04-30T23:05:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/indexes/StandardIndexMaintainer.java", "diffHunk": "@@ -352,20 +354,54 @@ public boolean skipUpdateForUnchangedKeys() {\n         }\n     }\n \n-    @Override\n-    @Nonnull\n-    public void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove) {\n+    protected <M extends Message> void checkUniqueness(@Nonnull FDBIndexableRecord<M> savedRecord, @Nonnull IndexEntry indexEntry) {\n+        Tuple valueKey = indexEntry.getKey();\n+        AsyncIterable<KeyValue> kvs = state.transaction.getRange(state.indexSubspace.range(valueKey));\n+        Tuple primaryKey = savedRecord.getPrimaryKey();\n+        final CompletableFuture<Void> checker = state.store.getContext().instrument(FDBStoreTimer.Events.CHECK_INDEX_UNIQUENESS,\n+                AsyncUtil.forEach(kvs, kv -> {\n+                    Tuple existingEntry = unpackKey(getIndexSubspace(), kv);\n+                    Tuple existingKey = state.index.getEntryPrimaryKey(existingEntry);\n+                    if (!TupleHelpers.equals(primaryKey, existingKey)) {\n+                        if (state.store.isIndexWriteOnly(state.index)) {\n+                            addUniquenessViolations(valueKey, primaryKey, existingKey);\n+                            addUniquenessViolations(valueKey, existingKey, primaryKey);\n+                        } else {\n+                            throw new RecordIndexUniquenessViolation(state.index, indexEntry, primaryKey, existingKey);\n+                        }\n+                    }\n+                }, getExecutor()));\n+        state.store.getRecordContext().addCommitCheck(checker);\n+    }\n+\n+    /**\n+     * Add a uniqueness violation within the database. This is used to keep track of\n+     * uniqueness violations that occur when an index is in write-only mode, both during\n+     * the built itself and by other writes. This means that the writes will succeed, but\n+     * it will cause a later attempt to make the index readable to fail.\n+     * @param valueKey the indexed key that is (apparently) not unique\n+     * @param primaryKey the primary key of one record that is causing a violation\n+     * @param existingKey the primary key of another record that is causing a violation (or <code>null</code> if none specified)\n+     */\n+    protected void addUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey) {", "originalCommit": "741e609983655554be41ed5a77f9f11ce5411ae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NzU4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r419597583", "bodyText": "Fixed.", "author": "nblintao", "createdAt": "2020-05-04T17:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzNzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0MzExOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r418343119", "bodyText": "I suppose it's reasonable that IndexMaintainer wouldn't have a method for updating uniqueness violations and that that would be something that only lives within the implementations, though it wasn't entirely obvious to me that that's right.", "author": "alecgrieser", "createdAt": "2020-04-30T23:22:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexMaintainer.java", "diffHunk": "@@ -106,35 +106,6 @@ public Subspace getSecondarySubspace() {\n     public abstract <M extends Message> CompletableFuture<Void> update(@Nullable FDBIndexableRecord<M> oldRecord,\n                                                                        @Nullable FDBIndexableRecord<M> newRecord);\n \n-    /**\n-     * Remove or add a uniqueness violation within the database. This is used to keep track of\n-     * uniqueness violations that occur when an index is in write-only mode, both during\n-     * the built itself and by other writes. This means that the writes will succeed, but\n-     * it will cause a later attempt to make the index readable to fail.\n-     * @param valueKey the indexed key that is (apparently) not unique\n-     * @param primaryKey the primary key of one record that is causing a violation\n-     * @param existingKey the primary key of another record that is causing a violation (or <code>null</code> if none specified)\n-     * @param remove <code>true</code> if removing the violation and <code>false</code> if adding it. When\n-     * <code>true</code>, it is favored use {@link #removeUniquenessViolationsAsync(Tuple, Tuple)} instead.\n-     */\n-    @Nonnull\n-    public abstract void updateUniquenessViolations(@Nonnull Tuple valueKey, @Nonnull Tuple primaryKey, @Nullable Tuple existingKey, boolean remove);", "originalCommit": "741e609983655554be41ed5a77f9f11ce5411ae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b372076c5079f2edbe15d61db17193f9ce35c40d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b372076c5079f2edbe15d61db17193f9ce35c40d", "message": "Fixes #901: False positive of uniqueness violations prevents building indexes", "committedDate": "2020-05-04T17:27:52Z", "type": "commit"}, {"oid": "b8af8c1631ca36ae99171f089387f51aff0544a9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b8af8c1631ca36ae99171f089387f51aff0544a9", "message": "Move uniqueness APIs down to StandardIndexMaintainer & Fixed a bug in removeUniquenessViolationsAsync & Improved tests\n\nThe main problem fixed by this PR is that: `FDBRecordStore.resolveUniquenessViolation` used to be relied on to delete the last uniqueness violation entry when delete the second last one. But this is not the only way the uniqueness violation is resolved. It doesn't cover the case that the violation is resolved when record is deleted organically. To resolve this problem, now it will delete the last entry as part of deleting records (See `removeUniquenessViolationsAsync`).\n\nThis change also tries to consolidate uniqueness logic at `StandardIndexMaintainer` level:\n- `FDBRecordStore .addUniquenessCheck`  -> `StandardIndexMaintainer.checkUniqueness`\n- `IndexMaintainer.updateUniquenessViolations` -> `StandardIndexMaintainer .addUniquenessViolations` and `StandardIndexMaintainer.removeUniquenessViolationsAsync`", "committedDate": "2020-05-04T17:28:43Z", "type": "commit"}, {"oid": "dc302044b94da787ce720c937217306328347b18", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/dc302044b94da787ce720c937217306328347b18", "message": "Change `addUniquenessViolations` to `addUniquenessViolation`", "committedDate": "2020-05-04T17:29:44Z", "type": "commit"}, {"oid": "436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "message": "Add to \"Breaking Changes\" part of 2.9 release ntoes", "committedDate": "2020-05-04T17:32:17Z", "type": "commit"}, {"oid": "436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "message": "Add to \"Breaking Changes\" part of 2.9 release ntoes", "committedDate": "2020-05-04T17:32:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM1MzU4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r428353582", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `FDBRecordStore` does not have `addUniquenessCheck` anymore, which is replaced by `checkUniqueness` in `StandardIndexMaintainer` now; `IndexMaintainer` does not have `updateUniquenessViolations` anymore, which is replaced by `addUniquenessViolation` and `removeUniquenessViolationsAsync` in `StandardIndexMaintainer` now; `StandardIndexMaintainer` now has `updateOneKeyAsync` in replace of `updateOneKey` .\n          \n          \n            \n            `FDBRecordStore` does not have `addUniquenessCheck` anymore, which is replaced by `checkUniqueness` in `StandardIndexMaintainer` now; `IndexMaintainer` does not have `updateUniquenessViolations` anymore, which is replaced by `addUniquenessViolation` and `removeUniquenessViolationsAsync` in `StandardIndexMaintainer` now; `StandardIndexMaintainer` now has `updateOneKeyAsync` in place of `updateOneKey` .", "author": "alecgrieser", "createdAt": "2020-05-20T22:56:32Z", "path": "docs/ReleaseNotes.md", "diffHunk": "@@ -12,11 +12,13 @@ This version of the Record Layer requires a FoundationDB server version of at le\n \n Additionally, builds for the project now require JDK 11. The project is still targetting JDK 1.8 for both source and binary compatibility, so projects importing the library that have not yet upgraded to the newer JDK should still be able to import the project as before, but developers may need to update their local development environment if they have not already done so. \n \n+`FDBRecordStore` does not have `addUniquenessCheck` anymore, which is replaced by `checkUniqueness` in `StandardIndexMaintainer` now; `IndexMaintainer` does not have `updateUniquenessViolations` anymore, which is replaced by `addUniquenessViolation` and `removeUniquenessViolationsAsync` in `StandardIndexMaintainer` now; `StandardIndexMaintainer` now has `updateOneKeyAsync` in replace of `updateOneKey` .", "originalCommit": "436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM1Mzg0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r428353840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // The uniqueness violation entry of the remained primary key will de removed as part of\n          \n          \n            \n                            // The uniqueness violation entry of the remained primary key will be removed as part of", "author": "alecgrieser", "createdAt": "2020-05-20T22:57:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStore.java", "diffHunk": "@@ -1228,12 +1206,13 @@ public void addRecordWriteConflict(@Nonnull Tuple primaryKey) {\n \n     @Override\n     @Nonnull\n-    public CompletableFuture<Void> resolveUniquenessViolation(@Nonnull Index index, @Nonnull Tuple valueKey, @Nullable Tuple primaryKey) {\n+    public CompletableFuture<Void> resolveUniquenessViolation(@Nonnull Index index, @Nonnull Tuple valueKey, @Nullable Tuple remainPrimaryKey) {\n         return scanUniquenessViolations(index, valueKey).forEachAsync(uniquenessViolation -> {\n-            if (primaryKey == null || !primaryKey.equals(uniquenessViolation.getPrimaryKey())) {\n+            if (remainPrimaryKey == null || !remainPrimaryKey.equals(uniquenessViolation.getPrimaryKey())) {\n                 return deleteRecordAsync(uniquenessViolation.getPrimaryKey()).thenApply(ignore -> null);\n             } else {\n-                getIndexMaintainer(index).updateUniquenessViolations(valueKey, primaryKey, null, true);\n+                // The uniqueness violation entry of the remained primary key will de removed as part of", "originalCommit": "436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM1MzkzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/902#discussion_r428353930", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // removeUniquenessViolationsAsync when deleting the second last record that contains the value key.\n          \n          \n            \n                            // removeUniquenessViolationsAsync when deleting the second to last record that contains the value key.", "author": "alecgrieser", "createdAt": "2020-05-20T22:57:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStore.java", "diffHunk": "@@ -1228,12 +1206,13 @@ public void addRecordWriteConflict(@Nonnull Tuple primaryKey) {\n \n     @Override\n     @Nonnull\n-    public CompletableFuture<Void> resolveUniquenessViolation(@Nonnull Index index, @Nonnull Tuple valueKey, @Nullable Tuple primaryKey) {\n+    public CompletableFuture<Void> resolveUniquenessViolation(@Nonnull Index index, @Nonnull Tuple valueKey, @Nullable Tuple remainPrimaryKey) {\n         return scanUniquenessViolations(index, valueKey).forEachAsync(uniquenessViolation -> {\n-            if (primaryKey == null || !primaryKey.equals(uniquenessViolation.getPrimaryKey())) {\n+            if (remainPrimaryKey == null || !remainPrimaryKey.equals(uniquenessViolation.getPrimaryKey())) {\n                 return deleteRecordAsync(uniquenessViolation.getPrimaryKey()).thenApply(ignore -> null);\n             } else {\n-                getIndexMaintainer(index).updateUniquenessViolations(valueKey, primaryKey, null, true);\n+                // The uniqueness violation entry of the remained primary key will de removed as part of\n+                // removeUniquenessViolationsAsync when deleting the second last record that contains the value key.", "originalCommit": "436c16c0b52a6bfb5a03b23c970f4ed44d80ca33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "faa4bf4656e7b9df0bd58bee4336518e5726b3c6", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/faa4bf4656e7b9df0bd58bee4336518e5726b3c6", "message": "Fix typos for PR #902\r\n\r\nTrying to commit suggested changes from GitHub UI for the first time. Let's see how it goes.\n\nCo-authored-by: Alec Grieser <alloc@apple.com>", "committedDate": "2020-05-20T23:11:00Z", "type": "commit"}]}