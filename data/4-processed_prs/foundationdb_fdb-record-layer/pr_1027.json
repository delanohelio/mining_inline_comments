{"pr_number": 1027, "pr_title": "Resolves #1026: index matching mechanics", "pr_createdAt": "2020-09-02T19:20:24Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027", "timeline": [{"oid": "373fbaa243b8f9e7cb50e51d670a635864498e4e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/373fbaa243b8f9e7cb50e51d670a635864498e4e", "message": "matching infrastructure", "committedDate": "2020-09-07T02:32:44Z", "type": "forcePushed"}, {"oid": "092eb0e6a147083ef8e8bb500532ed906e1f153d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/092eb0e6a147083ef8e8bb500532ed906e1f153d", "message": "matching infrastructure", "committedDate": "2020-09-08T02:13:16Z", "type": "forcePushed"}, {"oid": "5bad47891396a177a93528308f4358fcd5079525", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5bad47891396a177a93528308f4358fcd5079525", "message": "matching infrastructure", "committedDate": "2020-09-10T00:44:55Z", "type": "forcePushed"}, {"oid": "611fc2573e94fb481dd8fc1aba5d552c655ff9da", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/611fc2573e94fb481dd8fc1aba5d552c655ff9da", "message": "matching infrastructure", "committedDate": "2020-09-10T00:48:08Z", "type": "forcePushed"}, {"oid": "4845f5a0ecbc9ac1de8b15b8228611e8d2a79ff5", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4845f5a0ecbc9ac1de8b15b8228611e8d2a79ff5", "message": "matching infrastructure", "committedDate": "2020-09-10T16:06:17Z", "type": "forcePushed"}, {"oid": "3df1e5fd4a3617c1f20db07da319cbb5fded903d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/3df1e5fd4a3617c1f20db07da319cbb5fded903d", "message": "matching infrastructure", "committedDate": "2020-09-10T22:04:22Z", "type": "forcePushed"}, {"oid": "a53f90baded58b14a92142133c10370e0baeb056", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/a53f90baded58b14a92142133c10370e0baeb056", "message": "matching infrastructure", "committedDate": "2020-09-15T20:36:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1NzQ2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r490557460", "bodyText": "Primitives aren't nullable.", "author": "MMcM", "createdAt": "2020-09-17T20:56:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -172,6 +172,7 @@ public RecordQueryCoveringIndexPlan rebase(@Nonnull final AliasMap translationMa\n         return new RecordQueryCoveringIndexPlan(indexPlan, recordTypeName, availableFields, toRecord);\n     }\n \n+    @Nonnull", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzY4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r491187681", "bodyText": "Most classes in this package seem to have this; what is the intention behind removing it? Should it have some other status instead?", "author": "MMcM", "createdAt": "2020-09-18T20:58:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -158,14 +163,48 @@\n  * This class is immutable, all perceived \"mutations\" cause a new object to be created.\n  *\n  */\n-@API(API.Status.EXPERIMENTAL)", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0OTcwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506749707", "bodyText": "That got lost in a previous merge. Added it back in.", "author": "normen662", "createdAt": "2020-10-16T22:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4ODE5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r491188194", "bodyText": "Many of the existing methods, and the new toString, agree that map isn't nullable.", "author": "MMcM", "createdAt": "2020-09-18T20:59:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -158,14 +163,48 @@\n  * This class is immutable, all perceived \"mutations\" cause a new object to be created.\n  *\n  */\n-@API(API.Status.EXPERIMENTAL)\n public class AliasMap {\n     private final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map;\n \n+    /**\n+     * Private constructor. Use static factory methods/builders to instantiate alias maps.\n+     * @param map the backing bi-map\n+     */\n     private AliasMap(final ImmutableBiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n         this.map = map;\n     }\n \n+    /**\n+     * Define equality based on the equality of the backing bimap.\n+     * @param o other object\n+     * @return {@code true} if {@code o} is equal to {@code this}, {@code false} otherwise.\n+     */\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        final AliasMap aliasMap = (AliasMap)o;\n+        return Objects.equals(map, aliasMap.map);", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MDI5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506750295", "bodyText": "It's just coding style really and due to copy/pastes I cannot even claim that it's always like that. Should I always revert to the selfish method call .equals() if it's provably non null?", "author": "normen662", "createdAt": "2020-10-16T22:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4ODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1NDE1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r516254158", "bodyText": "I don't think we have strong guidelines on this. And that we can accommodate some variation.\nBut it feels a little odd to have variation among methods in the same class defined adjacently. Which I guess argues for making toString consistent at least.", "author": "MMcM", "createdAt": "2020-11-02T21:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4ODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MTU2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r491191564", "bodyText": "I have no particular objection to a deep immutable copy, but the existing sources and targets expose views into the backing collection, so it seems there should be a consistent principle.", "author": "MMcM", "createdAt": "2020-09-18T21:08:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -176,191 +215,275 @@ public boolean containsTarget(@Nonnull final CorrelationIdentifier alias) {\n \n     /**\n      * Returns the set of {@link CorrelationIdentifier}s that are mapped by this {@code AliasMap}.\n-     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for.\n+     * @return a set of {@link CorrelationIdentifier}s that this map contains mappings for\n      */\n     @Nonnull\n     public Set<CorrelationIdentifier> sources() {\n         return map.keySet();\n     }\n \n     /**\n-     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of {@link CorrelationIdentifier}s\n-     * returned by {@link #sources()}.\n+     * Returns the set of all {@link CorrelationIdentifier}s that this map maps to using the set of\n+     * {@link CorrelationIdentifier}s returned by {@link #sources()}.\n      * @return a set of {@link CorrelationIdentifier}s that this map maps to.\n      */\n     @Nonnull\n     public Set<CorrelationIdentifier> targets() {\n         return map.values();\n     }\n \n+    /**\n+     * Returns the size of the alias map, i.e., the number of contained bindings.\n+     * @return the size of the alias map.\n+     */\n     public int size() {\n         return map.size();\n     }\n \n+    /**\n+     * Create a builder for a new alias map using the bindings of this map.\n+     * @return a new builder derived from the contents of this map.\n+     */\n     @Nonnull\n     public Builder derived() {\n-        return new Builder(map);\n+        return builder().putAll(this);\n+    }\n+\n+    /**\n+     * Create a builder for a new alias map using the bindings of this map.\n+     * @param expectedAdditionalElements the number of additional elements that the caller expects to add before\n+     *        build is called.\n+     * @return a new builder derived from the contents of this map.\n+     */\n+    @Nonnull\n+    public Builder derived(final int expectedAdditionalElements) {\n+        return builder(expectedAdditionalElements).putAll(this);\n     }\n \n+    /**\n+     * Returns the set of entries in this map.\n+     * @return the set of entries\n+     */\n     @Nonnull\n-    public Builder derived(int expectedAdditionalElements) {\n-        return new Builder(size() + expectedAdditionalElements).putAll(this);\n+    public Set<Map.Entry<CorrelationIdentifier, CorrelationIdentifier>> entrySet() {\n+        return map.entrySet()\n+                .stream()\n+                .map(e -> new AbstractMap.SimpleImmutableEntry<>(e.getKey(), e.getValue()))\n+                .collect(ImmutableSet.toImmutableSet());", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MTQ3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506751477", "bodyText": "Yikes, the backing map is already immutable AND this method is not even called. I made it a non copying getter.", "author": "normen662", "createdAt": "2020-10-16T22:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5Nzk4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r491197982", "bodyText": "What does that consideration imply? That such a map has one item from aliases and one from otherAliases?", "author": "MMcM", "createdAt": "2020-09-18T21:25:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/AliasMap.java", "diffHunk": "@@ -377,36 +500,118 @@ private Builder(final int expectedSize) {\n             this.map = HashBiMap.create(expectedSize);\n         }\n \n-        private Builder(final BiMap<CorrelationIdentifier, CorrelationIdentifier> map) {\n-            this.map = HashBiMap.create(map);\n-        }\n-\n+        /**\n+         * Put a new binding between {@code source} and {@code target}. Note that if there is already a binding for\n+         * {@code source}, the binding will remain untouched if {@code target.equals(oldTarget)}, it will be\n+         * replaced with {@code source -> target} otherwise. Also, putting a binding for a {@code target} that already\n+         * exists will fail.\n+         * @param source a source alias\n+         * @param target a target alias\n+         * @throws IllegalArgumentException if {@code target} is already contained in the builder\n+         * @return {@code this} that has been modified to contain {@code source -> target}\n+         */\n         @Nonnull\n         public Builder put(@Nonnull final CorrelationIdentifier source, @Nonnull final CorrelationIdentifier target) {\n             map.put(source, target);\n             return this;\n         }\n \n+        /**\n+         * Put all binding that are contained in another {@link AliasMap}. Note that if there are already bindings for\n+         * sources contained in {@code other}, these bindings will remain untouched if {@code target.equals(oldTarget)},\n+         * they will be replaced otherwise. Also, this call will fail if a target contained in {@code other} already\n+         * exists in {@code this},\n+         * @param other another {@link AliasMap}\n+         * @throws IllegalArgumentException if any target contained in {@code other} is already contained in the builder\n+         * @return {@code this} that has been modified to contain all bindings from {@code other}\n+         */\n         @Nonnull\n         public Builder putAll(@Nonnull final AliasMap other) {\n-            map.putAll(other.map);\n+            other.sources()\n+                    .forEach(source -> put(source,\n+                            Objects.requireNonNull(other.getTarget(source))));\n+            return this;\n+        }\n+\n+        /**\n+         * Method to update the builder to contain entries {@code a -> a, b -> b, ...} for each alias contained\n+         * in the set of {@link CorrelationIdentifier}s passed in.\n+         * @param aliases set of aliases that this method should create identity-bindings for\n+         * @return {@code this} that has been modified to contain identity-bindings for all aliases contained in\n+         *         {@code aliases}\n+         */\n+        @Nonnull\n+        public Builder identitiesFor(final Set<CorrelationIdentifier> aliases) {\n+            aliases.forEach(id -> put(id, id));\n+            return this;\n+        }\n+\n+        /**\n+         * Method to update the builder to additionally contain the {@code zip} of two parallel lists of aliases.\n+         * @param left one list\n+         * @param right other list\n+         * @return {@code this} that has been modified to contain the zip of left and right as bindings {@code l -> r};\n+         */\n+        @Nonnull\n+        public Builder zip(@Nonnull final List<CorrelationIdentifier> left, @Nonnull final List<CorrelationIdentifier> right) {\n+            final int size = left.size();\n+            Verify.verify(size == right.size());\n+\n+            for (int i = 0; i < size; i ++) {\n+                final CorrelationIdentifier leftId = left.get(i);\n+                put(leftId, right.get(i));\n+            }\n+\n             return this;\n         }\n \n+        /**\n+         * Build a new {@link AliasMap}. This will entail a copy of the mappings in order to gain immutability guarantees.\n+         * @return a new {@link AliasMap}\n+         */\n         @Nonnull\n         public AliasMap build() {\n             return new AliasMap(ImmutableBiMap.copyOf(map));\n         }\n     }\n \n     /**\n-     * An predicate that tests for a match between quantifiers also taking into account an equivalence maps between\n-     * {@link CorrelationIdentifier}s.\n+     * Find matches between two sets of aliases, given their depends-on sets and a\n+     * {@link MatchPredicate}.\n+     * This method creates an underlying {@link PredicatedMatcher} to do the work.\n+     * @param aliases a set of aliases\n+     * @param dependsOnFn a function that returns the set of dependencies for a given alias within {@code aliases}\n+     * @param otherAliases a set of other aliases\n+     * @param otherDependsOnFn a function that returns the set of dependencies for a given alias within {@code otherAliases}\n+     * @param matchPredicate match predicate. see {@link MatchPredicate}\n+     *        for more info\n+     * @return an iterable of {@link AliasMap}s where each individual {@link AliasMap} is considered one match", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MjEzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506752136", "bodyText": "No, it means that we normally have a conceptual map (just a function really), one for the this side (usually the query) and one distinct function for the other side (e.g. the materialized view side). They could be merged together as you usually have distinct sets of quantifiers but I think this is cleaner.", "author": "normen662", "createdAt": "2020-10-16T22:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5Nzk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NDYxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492244610", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                         * Method that skips advances to the next element on the given zero-indexed level.\n          \n          \n            \n                         * Method that advances to the next element on the given zero-indexed level.", "author": "MMcM", "createdAt": "2020-09-21T17:55:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CrossProduct.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * CrossProduct.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Utility class to provide helpers related to enumeration of cross products.\n+ *\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class CrossProduct {\n+\n+    private CrossProduct() {\n+        // prevent instantiation\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link EnumeratingIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements EnumeratingIterable<T> {\n+        @Nonnull\n+        private final List<Iterable<T>> sources;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements EnumeratingIterator<T> {\n+            // state\n+            private int bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = 0;\n+                this.state = Lists.newArrayListWithCapacity(sources.size());\n+                sources.forEach(source -> this.state.add(null));\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                if (sources.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound.\n+                //\n+                int currentLevel = bound == 0 ? 0 : bound - 1;\n+\n+                //\n+                // For permutation of elements we return, we need to bind n elements (n == sources.size()).\n+                // We maintain an iterator through the iterators over sources (that is stable) for each level up to\n+                // currentLevel. That's the state!\n+                // The iterator for levels greater than currentLevel may be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use an integer value \"bound\" that keep track of the level that is currently bound by iterators.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(sources.get(currentLevel).iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item. Doing so may exhaust currentIterator in which case we\n+                    // couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = currentIterator.hasNext();\n+                    if (isDown) {\n+                        bound += 1;\n+                    } else {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound < sources.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < sources.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound -= 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MjI2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506752267", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-10-16T22:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NDYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NTE4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492245188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects\n          \n          \n            \n                 * {@link ComplexIterable}. Iterators created by this class, however, avoid building complex state objects", "author": "MMcM", "createdAt": "2020-09-21T17:56:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/CrossProduct.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * CrossProduct.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.PeekingIterator;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Utility class to provide helpers related to enumeration of cross products.\n+ *\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class CrossProduct {\n+\n+    private CrossProduct() {\n+        // prevent instantiation\n+    }\n+\n+    /**\n+     * A complex iterable implementing {@link EnumeratingIterable} that is used for sets of cardinality greater\n+     * than 1 (i.e., the regular case).\n+     * @param <T> type\n+     */\n+    private static class ComplexIterable<T> implements EnumeratingIterable<T> {\n+        @Nonnull\n+        private final List<Iterable<T>> sources;\n+\n+        private class ComplexIterator extends AbstractIterator<List<T>> implements EnumeratingIterator<T> {\n+            // state\n+            private int bound;\n+            private final List<PeekingIterator<T>> state;\n+\n+            private ComplexIterator() {\n+                this.bound = 0;\n+                this.state = Lists.newArrayListWithCapacity(sources.size());\n+                sources.forEach(source -> this.state.add(null));\n+            }\n+\n+            @Nullable\n+            @Override\n+            protected List<T> computeNext() {\n+                if (sources.isEmpty()) {\n+                    return endOfData();\n+                }\n+\n+                //\n+                // If nothing is bound yet, we are at the beginning and should start at level 0, otherwise\n+                // we conceptually start at the level of the finest granularity bound.\n+                //\n+                int currentLevel = bound == 0 ? 0 : bound - 1;\n+\n+                //\n+                // For permutation of elements we return, we need to bind n elements (n == sources.size()).\n+                // We maintain an iterator through the iterators over sources (that is stable) for each level up to\n+                // currentLevel. That's the state!\n+                // The iterator for levels greater than currentLevel may be null. The iterators\n+                // for levels below current level must be on a valid element. The iterator for the currentLevel\n+                // maybe null or a valid element.\n+                //\n+\n+                //\n+                // We also use an integer value \"bound\" that keep track of the level that is currently bound by iterators.\n+                //\n+                do {\n+                    //\n+                    // Set the currentIterator. That is the iterator at level currentLevel. If it is null,\n+                    // we create a new iterator over the set.\n+                    //\n+                    final PeekingIterator<T> currentIterator;\n+                    if (state.get(currentLevel) == null) {\n+                        currentIterator = Iterators.peekingIterator(sources.get(currentLevel).iterator());\n+                        state.set(currentLevel, currentIterator);\n+                    } else {\n+                        currentIterator = state.get(currentLevel);\n+                        unbind(currentLevel);\n+                        currentIterator.next();\n+                    }\n+\n+                    //\n+                    // Search currentLevel for a next item. Doing so may exhaust currentIterator in which case we\n+                    // couldn't find another element on the current level.\n+                    // In that case we need to abandon the current level and search on the level above (making that\n+                    // level the current level). If we reach level -1 (i.e., we reach the end of the iterator at level 0\n+                    // we are done.\n+                    // If we do find an element not violating any constraints on the current level we conceptually\n+                    // bind the element we found and continue on downward.\n+                    //\n+                    final boolean isDown = currentIterator.hasNext();\n+                    if (isDown) {\n+                        bound += 1;\n+                    } else {\n+                        // back tracking -- need to clear out the current iterator\n+                        state.set(currentLevel, null);\n+                    }\n+                    currentLevel = isDown\n+                                   ? currentLevel + 1\n+                                   : currentLevel - 1;\n+                    \n+                    if (currentLevel == -1) {\n+                        return endOfData();\n+                    }\n+                } while (bound < sources.size()); // as long as we still have to find a binding\n+\n+                return state.stream()\n+                        .map(PeekingIterator::peek)\n+                        .collect(ImmutableList.toImmutableList());\n+            }\n+\n+            private void unbind(final int level) {\n+                // reset all the following ones\n+                for (int i = level; i < sources.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound -= 1;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            /**\n+             * Method that skips advances to the next element on the given zero-indexed level.\n+             * @param level level to advance\n+             */\n+            @Override\n+            public void skip(final int level) {\n+                if (level >= sources.size()) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n+\n+                if (state.get(level) == null) {\n+                    throw new UnsupportedOperationException(\"cannot skip/unbind as level is not bound at all\");\n+                }\n+\n+                // reset all the following ones\n+                for (int i = level + 1; i < sources.size(); i ++ ) {\n+                    // either iterator is on a valid item or iterator is null\n+                    if (state.get(i) != null) {\n+                        bound -= 1;\n+                        state.set(i, null);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ComplexIterable(@Nonnull final List<Iterable<T>> sources) {\n+            Verify.verify(sources.size() > 1);\n+            this.sources = ImmutableList.copyOf(sources);\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public EnumeratingIterator<T> iterator() {\n+            return new ComplexIterator();\n+        }\n+    }\n+\n+    /**\n+     * An implementation of {@link EnumeratingIterable} that is optimized to work for single item\n+     * input sets. The case where the input set is exactly one item is trivial and also properly handled by\n+     * {@link ComplexIterable}. Iterators created by this class, however, avoid to build complex state objects", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTUxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492251510", "bodyText": "I think this example may have changed its mind about how to number the elements midstream.\nI believe that skip(2) means advance the third level, of which the simplest case is e0, e1, e2', ..., where e2' is the successor of e2. If there is no such successor, then e1' the successor of e1 and so on.", "author": "MMcM", "createdAt": "2020-09-21T18:07:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/EnumeratingIterator.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * EnumeratingIterator.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * An iterator extending {@link Iterator} providing the ability to skip a certain prefix.\n+ * @param <T> type\n+ */\n+public interface EnumeratingIterator<T> extends Iterator<List<T>> {\n+    /**\n+     * Instructs the iterator to advance to the next possible ordering using the given zero-indexed level.\n+     *\n+     * Example 1: If the last returned ordering of the iterator {@code it} is {@code (e0, e1, e2, e3)} and\n+     *            {@code it.skip(2)} is called, the state of the iterator is advanced in a way that either\n+     *            reaches the end of iteration or the next item that is returned is {@code (e0', e1', e3', e4')}\n+     *            where the prefix {@code (e1', e2', e3')} is not equal to {code (e1, e2, e3)}.", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MzMxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506753312", "bodyText": "Yeah -- the explanation is not good. Changing completely.", "author": "normen662", "createdAt": "2020-10-16T22:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTkwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492251900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Iterators created by this class, avoid to build complex state objects during their lifecycle.\n          \n          \n            \n                 * Iterators created by this class, avoid building complex state objects during their lifecycle.", "author": "MMcM", "createdAt": "2020-09-21T18:08:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/EnumeratingIterable.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * EnumeratingIterable.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.google.common.collect.AbstractIterator;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+/**\n+ * Iterable that provides special iterators of type {@link EnumeratingIterator}.\n+ * @param <T> type\n+ */\n+public interface EnumeratingIterable<T> extends Iterable<List<T>> {\n+    @Nonnull\n+    @Override\n+    EnumeratingIterator<T> iterator();\n+\n+    static <T> EnumeratingIterable<T> emptyIterable() {\n+        return new EmptyIterable<>();\n+    }\n+\n+    /**\n+     * An implementation of {@link EnumeratingIterable} that is optimized to work for empty\n+     * input sets.\n+     * Iterators created by this class, avoid to build complex state objects during their lifecycle.", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MjQ4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506752484", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-10-16T22:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjcwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492252700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * If the underlying DAG is mutated gainst assumptions, the semantics of this class is defined in a way that calls to\n          \n          \n            \n             * If the underlying DAG is mutated against assumptions, the semantics of this class is defined in a way that calls to", "author": "MMcM", "createdAt": "2020-09-21T18:10:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/ExpressionRefTraversal.java", "diffHunk": "@@ -21,49 +21,58 @@\n package com.apple.foundationdb.record.query.plan.temp;\n \n import com.apple.foundationdb.annotation.API;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n import com.google.common.graph.EndpointPair;\n import com.google.common.graph.ImmutableNetwork;\n import com.google.common.graph.MutableNetwork;\n import com.google.common.graph.Network;\n import com.google.common.graph.NetworkBuilder;\n \n import javax.annotation.Nonnull;\n-import java.util.List;\n import java.util.Set;\n+import java.util.function.BiConsumer;\n \n /**\n- * Utility class to provide a view on a graph given by a root expression reference (to a {@link RelationalExpression}\n- * that allows to perform traversal operations that are normally not possible on instances of {@link ExpressionRef}\n- * such as {@link #getLeaves()} and {@link FullyTraversableExpressionRef#getParentRefs()}.\n+ * Utility class to provide a graph view of a expression reference DAG given by a root expression reference\n+ * (to a {@link RelationalExpression} that allows to perform traversal operations that are normally not possible\n+ * on instances of {@link ExpressionRef} such as {@link #getLeafRefs()} and {@link #getParentRefs}.\n+ *\n+ * The implementation of this class assumes that the original DAG is not mutated after the traversal is created.\n+ * If the underlying DAG is mutated gainst assumptions, the semantics of this class is defined in a way that calls to", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MjY2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506752666", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-10-16T22:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NjM3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492256378", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * that can be matches against a query graph. The match candidate does not keep the root to the graph to be matched but\n          \n          \n            \n             * that can be matched against a query graph. The match candidate does not keep the root to the graph to be matched but", "author": "MMcM", "createdAt": "2020-09-21T18:16:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/MatchCandidate.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * MatchCandidate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Case class to represent a match candidate. A match candidate on code level is just a name and a data flow graph\n+ * that can be matches against a query graph. The match candidate does not keep the root to the graph to be matched but", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc2MDI4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506760288", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-10-16T23:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NjM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2MDM3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492260378", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tag-exception tha is specifically thrown by implementations of {@link Debugger} to signal the planner to restart\n          \n          \n            \n             * Tag-exception that is specifically thrown by implementations of {@link Debugger} to signal the planner to restart", "author": "MMcM", "createdAt": "2020-09-21T18:23:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/debug/RestartException.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * RestartException.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.debug;\n+\n+/**\n+ * Tag-exception tha is specifically thrown by implementations of {@link Debugger} to signal the planner to restart", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Nzc4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492267787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The life cycle of an accumulator (after it's creation) spans multiple calls to {@link #accumulate} which cause the\n          \n          \n            \n             * The life cycle of an accumulator (after its creation) spans multiple calls to {@link #accumulate} which cause the", "author": "MMcM", "createdAt": "2020-09-21T18:37:13Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matching/MatchAccumulator.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * MatchAccumulator.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matching;\n+\n+/**\n+ * Class to used to accumulate the individual match results (the results of applying the {@link MatchFunction}) into\n+ * an object of type {@code R}. This class provides an interface for clients that in its concept is not entirely unlike\n+ * {@link java.util.stream.Collector}. Instances of this class, however, are meant to be mutable while collectors\n+ * are essentially stateless lambda factories.\n+ *\n+ * The life cycle of an accumulator (after it's creation) spans multiple calls to {@link #accumulate} which cause the", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc2MDM2Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506760363", "bodyText": "Done.", "author": "normen662", "createdAt": "2020-10-16T23:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Nzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2OTMwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492269307", "bodyText": "I'm not sure how helpful explaining \"bijective\" that way is: if you know \"injective\" and \"surjective,\" you know it. I would spell it out: every element of this collection has a corresponding element of the other collection and vice versa.", "author": "MMcM", "createdAt": "2020-09-21T18:40:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matching/BaseMatcher.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * BaseMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matching;\n+\n+import com.apple.foundationdb.record.query.plan.temp.AliasMap;\n+import com.apple.foundationdb.record.query.plan.temp.CorrelationIdentifier;\n+import com.apple.foundationdb.record.query.plan.temp.EnumeratingIterable;\n+import com.apple.foundationdb.record.query.plan.temp.TransitiveClosure;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.apple.foundationdb.record.query.plan.temp.TopologicalSort.anyTopologicalOrderPermutation;\n+import static com.apple.foundationdb.record.query.plan.temp.TopologicalSort.topologicalOrderPermutations;\n+\n+/**\n+ * Abstract base class for all matchers. Matching is an algorithm that <em>matches</em> two collections of things of type\n+ * {@code T} resulting in a bijective mapping (injective and surjective) between the elements of the respective", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MjQxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492272410", "bodyText": "Could this be QUANTIFIERS spelled out or something like that?", "author": "MMcM", "createdAt": "2020-09-21T18:45:51Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/debug/Commands.java", "diffHunk": "@@ -0,0 +1,623 @@\n+/*\n+ * Commands.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.debug;\n+\n+import com.apple.foundationdb.record.query.plan.temp.CascadesPlanner;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.debug.Debugger;\n+import com.apple.foundationdb.record.query.plan.temp.debug.Debugger.Event;\n+import com.apple.foundationdb.record.query.plan.temp.debug.RestartException;\n+import com.google.auto.service.AutoService;\n+import com.google.common.base.Enums;\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.jline.reader.ParsedLine;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class containing all implementations of {@link Command}\n+ * in a <em>sealed trait</em> style (except it's not sealed).\n+ */\n+public class Commands {\n+    /**\n+     * Interface for all kinds of commands. Commands are typed by event. When we receive a callback from the\n+     * planner we also receive that callback using some sort of event. The kind of event defines the context for\n+     * all actions taken place while the REPL has control. So for instance it may be useful for a command\n+     * \"current\" to know the current event so it can properly print out information depending on the specifics\n+     * of the event.\n+     *\n+     * All commands are <em>discovered</em> through a {@link java.util.ServiceLoader}. In order to create the\n+     * correct information in the meta-info of the jar, we use the {@link AutoService} annotation for all\n+     * discoverable commands.\n+     *\n+     * @param <E> the type of the event\n+     */\n+    public interface Command<E extends Event> {\n+        /**\n+         * Method that is called from the REPL when a command is interpreted that starts with the string that\n+         * {@link #getCommandToken()} returns.\n+         * @param plannerRepl the REPL\n+         * @param event the current event\n+         * @param parsedLine the tokenized input string\n+         * @return {@code true} if planning should continue afterwards, {@code false} if the REPL should prompt\n+         *         for the next command after the execution of this command has finished.\n+         */\n+        boolean executeCommand(@Nonnull PlannerRepl plannerRepl, @Nonnull E event, @Nonnull ParsedLine parsedLine);\n+\n+        /**\n+         * The command in as a string.\n+         * @return the comman token\n+         */\n+        @Nonnull\n+        String getCommandToken();\n+\n+        void printUsage(@Nonnull final PlannerRepl plannerRepl);\n+    }\n+\n+    /**\n+     * Break point command.\n+     *\n+     * Supports:\n+     * <ul>\n+     * <li>{@code break [list]} -- show all currently defined break points</li>\n+     * <li>{@code break yield <identifier>} -- set a break point when the specified expression is yielded</li>\n+     * <li>{@code break remove <index>} -- remove the break point at the specified index</li>\n+     * <li>{@code break <rule> [<location>]} -- set a break point when the specified event happens</li>\n+     * </ul>\n+     *\n+     */\n+    @AutoService(Command.class)\n+    public static class BreakCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final List<String> words = parsedLine.words();\n+\n+            if (words.size() == 1) {\n+                listBreakPoints(plannerRepl);\n+                return false;\n+            }\n+\n+            if (words.size() >= 2) {\n+                final String word1 = words.get(1).toUpperCase();\n+                if (words.size() == 2) {\n+                    if (\"LIST\".equals(word1.toUpperCase())) {\n+                        listBreakPoints(plannerRepl);\n+                        return false;\n+                    }\n+                }\n+\n+                if (\"YIELD\".equals(word1.toUpperCase())) {\n+                    if (words.size() == 3) {\n+                        final String word2 = words.get(2);\n+                        if (!plannerRepl.isValidEntityName(word2)) {\n+                            plannerRepl.printlnError(\"invalid identifier\");\n+                            return false;\n+                        }\n+                        plannerRepl.addBreakPoint(new PlannerRepl.OnYieldBreakPoint(word2.toLowerCase()));\n+                        return false;\n+                    }\n+                    plannerRepl.printlnError(\"usage: break yield identifier\");\n+                    return false;\n+                }\n+\n+                if (\"REMOVE\".equals(word1.toUpperCase())) {\n+                    if (words.size() == 3) {\n+                        final String word2 = words.get(2);\n+                        @Nullable final Integer index = PlannerRepl.getIdFromIdentifier(word2, \"\");\n+                        if (index == null) {\n+                            plannerRepl.printlnError(\"invalid index for break point\");\n+                            return false;\n+                        }\n+                        if (plannerRepl.removeBreakPoint(index) != null) {\n+                            plannerRepl.printHighlighted(\"break point \" + index + \" removed.\");\n+                            plannerRepl.println();\n+                        } else {\n+                            plannerRepl.printlnError(\"unable to find break point \" + index + \".\");\n+                        }\n+                        return false;\n+                    }\n+                    plannerRepl.printlnError(\"usage: break remove <index>\");\n+                }\n+\n+                final Optional<Debugger.Shorthand> shorthandOptional =\n+                        Enums.getIfPresent(Debugger.Shorthand.class, word1).toJavaUtil();\n+                if (!shorthandOptional.isPresent()) {\n+                    plannerRepl.printlnError(\"unknown event class, should be one of [\" +\n+                                             Arrays.stream(Debugger.Shorthand.values()).map(e -> e.name()).collect(Collectors.joining(\", \")) +\n+                                             \"].\");\n+                    return false;\n+                }\n+                final Debugger.Shorthand shorthand = shorthandOptional.get();\n+\n+                if (words.size() == 2) {\n+                    plannerRepl.addBreakPoint(new PlannerRepl.OnEventTypeBreakPoint(shorthand, Debugger.Location.ANY));\n+                    return false;\n+                }\n+\n+                if (words.size() >= 3) {\n+                    final String word2 = words.get(2).toUpperCase();\n+                    final Debugger.Location location = Enums.getIfPresent(Debugger.Location.class, word2.toUpperCase()).toJavaUtil().orElse(Debugger.Location.ANY);\n+                    plannerRepl.addBreakPoint(new PlannerRepl.OnEventTypeBreakPoint(shorthand, location));\n+                }\n+                return false;\n+            }\n+\n+            plannerRepl.printlnError(\"usage: break event_type [location]\");\n+            return false;\n+        }\n+\n+        private void listBreakPoints(final PlannerRepl plannerRepl) {\n+            for (PlannerRepl.BreakPoint breakPoint : plannerRepl.getBreakPoints()) {\n+                final int index = Objects.requireNonNull(plannerRepl.lookupBreakPoint(breakPoint));\n+                plannerRepl.printKeyValue(\"id\", index + \"; \");\n+                breakPoint.onList(plannerRepl);\n+                plannerRepl.println();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"BREAK\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"break [list | yield <id> | remove <index> | <event> [ <location>]]\", \"manage breakpoints\");\n+        }\n+    }\n+\n+    /**\n+     * Continue execution.\n+     */\n+    @AutoService(Command.class)\n+    public static class ContinueCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            return true;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"CONT\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"cont\", \"continue execution\");\n+        }\n+    }\n+\n+    /**\n+     * Dump the current event.\n+     */\n+    @AutoService(Command.class)\n+    public static class CurrentCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Event e = state.getEvents().get(state.getCurrentTick());\n+            plannerRepl.withProcessors(e, processor -> processor.onDetail(plannerRepl, e));\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"CURRENT\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"current\", \"dump current event\");\n+        }\n+    }\n+\n+    /**\n+     * List out all events already seen.\n+     */\n+    @AutoService(Command.class)\n+    public static class EventsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final List<Event> eventList = state.getEvents();\n+            for (int tick = 0; tick < eventList.size(); tick++) {\n+                final Event e = eventList.get(tick);\n+                if (state.getCurrentTick() == tick) {\n+                    plannerRepl.printHighlighted(\"==> \");\n+                } else {\n+                    plannerRepl.print(\"    \");\n+                }\n+                plannerRepl.printKeyValue(\"tick\", tick + \"; \");\n+                plannerRepl.withProcessors(e, processor -> processor.onList(plannerRepl, e));\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"EVENTS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"events\", \"list history of events\");\n+        }\n+    }\n+\n+    /**\n+     * List out all expressions.\n+     */\n+    @AutoService(Command.class)\n+    public static class ExpsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Cache<Integer, RelationalExpression> expressionCache = state.getExpressionCache();\n+            final List<Integer> ids = Lists.newArrayList(expressionCache.asMap().keySet());\n+            Collections.sort(ids);\n+            for (Integer id : ids) {\n+                plannerRepl.printKeyValue(\"id\", \"exp\" + id + \"; \");\n+                @Nullable final RelationalExpression expression = expressionCache.getIfPresent(id);\n+                if (expression != null) {\n+                    final String quantifiersString = expression.getQuantifiers()\n+                            .stream()\n+                            .map(plannerRepl::nameForObjectOrNotInCache)\n+                            .collect(Collectors.joining(\", \"));\n+                    plannerRepl.printKeyValue(\"structure\", expression.getClass().getSimpleName() + \"(\" + quantifiersString + \")\");\n+                }\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"EXPS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"exps\", \"list all expressions\");\n+        }\n+    }\n+\n+    /**\n+     * List out all references.\n+     */\n+    @AutoService(Command.class)\n+    public static class HelpCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            plannerRepl.printlnHighlighted(\"Basic Usage\");\n+            plannerRepl.println();\n+            for (final Command<Event> command : PlannerRepl.getCommands()) {\n+                command.printUsage(plannerRepl);\n+            }\n+            plannerRepl.println();\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"HELP\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"help\", \"print this help\");\n+        }\n+    }\n+\n+    /**\n+     * List out all references.\n+     */\n+    @AutoService(Command.class)\n+    public static class RefsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Cache<Integer, ExpressionRef<? extends RelationalExpression>> referenceCache = state.getReferenceCache();\n+            final List<Integer> ids = Lists.newArrayList(referenceCache.asMap().keySet());\n+            Collections.sort(ids);\n+            for (Integer id : ids) {\n+                plannerRepl.printKeyValue(\"id\", \"ref\" + id + \"; \");\n+                @Nullable final ExpressionRef<? extends RelationalExpression> reference = referenceCache.getIfPresent(id);\n+                plannerRepl.printKeyValue(\"kind\", reference == null ? \"not in cache; \" : reference.getClass().getSimpleName() + \"; \");\n+                if (reference instanceof GroupExpressionRef) {\n+                    final GroupExpressionRef<? extends RelationalExpression> groupReference = (GroupExpressionRef<? extends RelationalExpression>)reference;\n+                    final String membersString = groupReference.getMembers()\n+                            .stream()\n+                            .map(expression -> Optional.ofNullable(plannerRepl.nameForObject(expression)))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.joining(\", \"));\n+                    plannerRepl.printKeyValue(\"members: \", \"{\" + membersString + \"}\");\n+                }\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"REFS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"refs\", \"list all references\");\n+        }\n+    }\n+\n+    /**\n+     * Restart execution. All entity names remain stable.\n+     */\n+    @AutoService(Command.class)\n+    public static class RestartCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            plannerRepl.restartState();\n+            plannerRepl.addInternalBreakPoint(new PlannerRepl.CountingTautologyBreakPoint(1));\n+            plannerRepl.printHighlighted(\"restarting planning...\");\n+            plannerRepl.println();\n+            throw new RestartException();\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"RESTART\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"restart\", \"restart the planner and return to tick 0\");\n+        }\n+    }\n+\n+    /**\n+     * Show an entity using its name:\n+     * {@code show <entityname>} where entity name is {@code exp<id>, ref<id>, or qun<id>}.\n+     */\n+    @AutoService(Command.class)\n+    public static class ShowCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final List<String> words = parsedLine.words();\n+            if (words.size() < 2) {\n+                plannerRepl.printlnError(\"usage show [exp|ref|qun]id\");\n+                return false;\n+            }\n+\n+            plannerRepl.processIdentifiers(words.get(1),\n+                    expression -> expression.show(true),\n+                    reference -> {\n+                        if (reference instanceof GroupExpressionRef) {\n+                            ((GroupExpressionRef<? extends RelationalExpression>)reference).show(true);\n+                        } else {\n+                            plannerRepl.println(\"show is not supported for non-group references.\");\n+                        }\n+                    },\n+                    quantifier -> plannerRepl.println(\"show is not supported for quantifiers.\"));\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"SHOW\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"show (<expId> | <refId> | <qunId>)\", \"render the entity graphically\");\n+        }\n+    }\n+\n+    /**\n+     * Print the current state of the task stack.\n+     */\n+    @AutoService(Command.class)\n+    public static class TasksCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            if (event instanceof Debugger.AbstractEventWithState) {\n+                final Deque<CascadesPlanner.Task> taskStack = ((Debugger.AbstractEventWithState)event).getTaskStack();\n+                final int size = taskStack.size();\n+\n+                int i = 0;\n+                for (final Iterator<CascadesPlanner.Task> iterator = taskStack.descendingIterator(); iterator.hasNext(); i ++) {\n+                    final CascadesPlanner.Task task = iterator.next();\n+                    final Event e = task.toTaskEvent(Debugger.Location.ANY);\n+\n+                    if (i + 1 == size) {\n+                        plannerRepl.printHighlighted(\" ==> \");\n+                    } else {\n+                        plannerRepl.print(\"     \");\n+                    }\n+\n+                    plannerRepl.withProcessors(e, p -> p.onList(plannerRepl, e));\n+                    plannerRepl.println();\n+                }\n+\n+            } else {\n+                plannerRepl.printlnError(\"event does not contain information about current state of task stack.\");\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"TASKS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"tasks\", \"show the current state of the task stack\");\n+        }\n+    }\n+\n+    /**\n+     * Continue the specified (or one) number of steps.\n+     * {@code step [<number>]} continue execution for the next number of steps.\n+     */\n+    @AutoService(Command.class)\n+    public static class StepCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final List<String> words = parsedLine.words();\n+            final int steps;\n+            if (words.size() == 2) {\n+                steps = NumberUtils.toInt(words.get(1));\n+            } else {\n+                steps = 1;\n+            }\n+\n+            if (steps == 0) {\n+                plannerRepl.printlnError(\"usage step [number]\");\n+                return false;\n+            }\n+\n+            plannerRepl.addInternalBreakPoint(new PlannerRepl.CountingTautologyBreakPoint(steps));\n+            return true;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"STEP\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"step [<number>]\", \"continue execution by the number of specified steps (default: 1)\");\n+        }\n+    }\n+\n+    /**\n+     * List out all quantifiers.\n+     */\n+    @AutoService(Command.class)\n+    public static class QunsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final List<Integer> ids = Lists.newArrayList(state.getQuantifierCache().asMap().keySet());\n+            Collections.sort(ids);\n+            for (Integer id : ids) {\n+                plannerRepl.printKeyValue(\"id\", \"qun\" + id + \"; \");\n+                @Nullable final Quantifier quantifier = state.getQuantifierCache().getIfPresent(id);\n+                if (quantifier != null) {\n+                    plannerRepl.printKeyValue(\"kind\", quantifier.getShorthand() + \"; \");\n+                    plannerRepl.printKeyValue(\"alias\", quantifier.getAlias().toString() + \"; \");\n+                    final ExpressionRef<? extends RelationalExpression> rangesOver = quantifier.getRangesOver();\n+                    plannerRepl.printKeyValue(\"ranges over\", plannerRepl.nameForObjectOrNotInCache(rangesOver));\n+                }\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"QUNS\";", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc2MDYwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506760601", "bodyText": "this is the command you have to type in on the REPL to show all quantifier objects. I'd rather have it very short as I am using this quite often. The other similar commands comparable to this are REFS and EXPS", "author": "normen662", "createdAt": "2020-10-16T23:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Mzc1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r492273751", "bodyText": "Does this mean that restart stops after the first thing the new plan does or before it?", "author": "MMcM", "createdAt": "2020-09-21T18:48:16Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/query/plan/debug/Commands.java", "diffHunk": "@@ -0,0 +1,623 @@\n+/*\n+ * Commands.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.debug;\n+\n+import com.apple.foundationdb.record.query.plan.temp.CascadesPlanner;\n+import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.GroupExpressionRef;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;\n+import com.apple.foundationdb.record.query.plan.temp.debug.Debugger;\n+import com.apple.foundationdb.record.query.plan.temp.debug.Debugger.Event;\n+import com.apple.foundationdb.record.query.plan.temp.debug.RestartException;\n+import com.google.auto.service.AutoService;\n+import com.google.common.base.Enums;\n+import com.google.common.cache.Cache;\n+import com.google.common.collect.Lists;\n+import org.apache.commons.lang3.math.NumberUtils;\n+import org.jline.reader.ParsedLine;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class containing all implementations of {@link Command}\n+ * in a <em>sealed trait</em> style (except it's not sealed).\n+ */\n+public class Commands {\n+    /**\n+     * Interface for all kinds of commands. Commands are typed by event. When we receive a callback from the\n+     * planner we also receive that callback using some sort of event. The kind of event defines the context for\n+     * all actions taken place while the REPL has control. So for instance it may be useful for a command\n+     * \"current\" to know the current event so it can properly print out information depending on the specifics\n+     * of the event.\n+     *\n+     * All commands are <em>discovered</em> through a {@link java.util.ServiceLoader}. In order to create the\n+     * correct information in the meta-info of the jar, we use the {@link AutoService} annotation for all\n+     * discoverable commands.\n+     *\n+     * @param <E> the type of the event\n+     */\n+    public interface Command<E extends Event> {\n+        /**\n+         * Method that is called from the REPL when a command is interpreted that starts with the string that\n+         * {@link #getCommandToken()} returns.\n+         * @param plannerRepl the REPL\n+         * @param event the current event\n+         * @param parsedLine the tokenized input string\n+         * @return {@code true} if planning should continue afterwards, {@code false} if the REPL should prompt\n+         *         for the next command after the execution of this command has finished.\n+         */\n+        boolean executeCommand(@Nonnull PlannerRepl plannerRepl, @Nonnull E event, @Nonnull ParsedLine parsedLine);\n+\n+        /**\n+         * The command in as a string.\n+         * @return the comman token\n+         */\n+        @Nonnull\n+        String getCommandToken();\n+\n+        void printUsage(@Nonnull final PlannerRepl plannerRepl);\n+    }\n+\n+    /**\n+     * Break point command.\n+     *\n+     * Supports:\n+     * <ul>\n+     * <li>{@code break [list]} -- show all currently defined break points</li>\n+     * <li>{@code break yield <identifier>} -- set a break point when the specified expression is yielded</li>\n+     * <li>{@code break remove <index>} -- remove the break point at the specified index</li>\n+     * <li>{@code break <rule> [<location>]} -- set a break point when the specified event happens</li>\n+     * </ul>\n+     *\n+     */\n+    @AutoService(Command.class)\n+    public static class BreakCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final List<String> words = parsedLine.words();\n+\n+            if (words.size() == 1) {\n+                listBreakPoints(plannerRepl);\n+                return false;\n+            }\n+\n+            if (words.size() >= 2) {\n+                final String word1 = words.get(1).toUpperCase();\n+                if (words.size() == 2) {\n+                    if (\"LIST\".equals(word1.toUpperCase())) {\n+                        listBreakPoints(plannerRepl);\n+                        return false;\n+                    }\n+                }\n+\n+                if (\"YIELD\".equals(word1.toUpperCase())) {\n+                    if (words.size() == 3) {\n+                        final String word2 = words.get(2);\n+                        if (!plannerRepl.isValidEntityName(word2)) {\n+                            plannerRepl.printlnError(\"invalid identifier\");\n+                            return false;\n+                        }\n+                        plannerRepl.addBreakPoint(new PlannerRepl.OnYieldBreakPoint(word2.toLowerCase()));\n+                        return false;\n+                    }\n+                    plannerRepl.printlnError(\"usage: break yield identifier\");\n+                    return false;\n+                }\n+\n+                if (\"REMOVE\".equals(word1.toUpperCase())) {\n+                    if (words.size() == 3) {\n+                        final String word2 = words.get(2);\n+                        @Nullable final Integer index = PlannerRepl.getIdFromIdentifier(word2, \"\");\n+                        if (index == null) {\n+                            plannerRepl.printlnError(\"invalid index for break point\");\n+                            return false;\n+                        }\n+                        if (plannerRepl.removeBreakPoint(index) != null) {\n+                            plannerRepl.printHighlighted(\"break point \" + index + \" removed.\");\n+                            plannerRepl.println();\n+                        } else {\n+                            plannerRepl.printlnError(\"unable to find break point \" + index + \".\");\n+                        }\n+                        return false;\n+                    }\n+                    plannerRepl.printlnError(\"usage: break remove <index>\");\n+                }\n+\n+                final Optional<Debugger.Shorthand> shorthandOptional =\n+                        Enums.getIfPresent(Debugger.Shorthand.class, word1).toJavaUtil();\n+                if (!shorthandOptional.isPresent()) {\n+                    plannerRepl.printlnError(\"unknown event class, should be one of [\" +\n+                                             Arrays.stream(Debugger.Shorthand.values()).map(e -> e.name()).collect(Collectors.joining(\", \")) +\n+                                             \"].\");\n+                    return false;\n+                }\n+                final Debugger.Shorthand shorthand = shorthandOptional.get();\n+\n+                if (words.size() == 2) {\n+                    plannerRepl.addBreakPoint(new PlannerRepl.OnEventTypeBreakPoint(shorthand, Debugger.Location.ANY));\n+                    return false;\n+                }\n+\n+                if (words.size() >= 3) {\n+                    final String word2 = words.get(2).toUpperCase();\n+                    final Debugger.Location location = Enums.getIfPresent(Debugger.Location.class, word2.toUpperCase()).toJavaUtil().orElse(Debugger.Location.ANY);\n+                    plannerRepl.addBreakPoint(new PlannerRepl.OnEventTypeBreakPoint(shorthand, location));\n+                }\n+                return false;\n+            }\n+\n+            plannerRepl.printlnError(\"usage: break event_type [location]\");\n+            return false;\n+        }\n+\n+        private void listBreakPoints(final PlannerRepl plannerRepl) {\n+            for (PlannerRepl.BreakPoint breakPoint : plannerRepl.getBreakPoints()) {\n+                final int index = Objects.requireNonNull(plannerRepl.lookupBreakPoint(breakPoint));\n+                plannerRepl.printKeyValue(\"id\", index + \"; \");\n+                breakPoint.onList(plannerRepl);\n+                plannerRepl.println();\n+            }\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"BREAK\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"break [list | yield <id> | remove <index> | <event> [ <location>]]\", \"manage breakpoints\");\n+        }\n+    }\n+\n+    /**\n+     * Continue execution.\n+     */\n+    @AutoService(Command.class)\n+    public static class ContinueCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            return true;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"CONT\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"cont\", \"continue execution\");\n+        }\n+    }\n+\n+    /**\n+     * Dump the current event.\n+     */\n+    @AutoService(Command.class)\n+    public static class CurrentCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Event e = state.getEvents().get(state.getCurrentTick());\n+            plannerRepl.withProcessors(e, processor -> processor.onDetail(plannerRepl, e));\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"CURRENT\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"current\", \"dump current event\");\n+        }\n+    }\n+\n+    /**\n+     * List out all events already seen.\n+     */\n+    @AutoService(Command.class)\n+    public static class EventsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final List<Event> eventList = state.getEvents();\n+            for (int tick = 0; tick < eventList.size(); tick++) {\n+                final Event e = eventList.get(tick);\n+                if (state.getCurrentTick() == tick) {\n+                    plannerRepl.printHighlighted(\"==> \");\n+                } else {\n+                    plannerRepl.print(\"    \");\n+                }\n+                plannerRepl.printKeyValue(\"tick\", tick + \"; \");\n+                plannerRepl.withProcessors(e, processor -> processor.onList(plannerRepl, e));\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"EVENTS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"events\", \"list history of events\");\n+        }\n+    }\n+\n+    /**\n+     * List out all expressions.\n+     */\n+    @AutoService(Command.class)\n+    public static class ExpsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Cache<Integer, RelationalExpression> expressionCache = state.getExpressionCache();\n+            final List<Integer> ids = Lists.newArrayList(expressionCache.asMap().keySet());\n+            Collections.sort(ids);\n+            for (Integer id : ids) {\n+                plannerRepl.printKeyValue(\"id\", \"exp\" + id + \"; \");\n+                @Nullable final RelationalExpression expression = expressionCache.getIfPresent(id);\n+                if (expression != null) {\n+                    final String quantifiersString = expression.getQuantifiers()\n+                            .stream()\n+                            .map(plannerRepl::nameForObjectOrNotInCache)\n+                            .collect(Collectors.joining(\", \"));\n+                    plannerRepl.printKeyValue(\"structure\", expression.getClass().getSimpleName() + \"(\" + quantifiersString + \")\");\n+                }\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"EXPS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"exps\", \"list all expressions\");\n+        }\n+    }\n+\n+    /**\n+     * List out all references.\n+     */\n+    @AutoService(Command.class)\n+    public static class HelpCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            plannerRepl.printlnHighlighted(\"Basic Usage\");\n+            plannerRepl.println();\n+            for (final Command<Event> command : PlannerRepl.getCommands()) {\n+                command.printUsage(plannerRepl);\n+            }\n+            plannerRepl.println();\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"HELP\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"help\", \"print this help\");\n+        }\n+    }\n+\n+    /**\n+     * List out all references.\n+     */\n+    @AutoService(Command.class)\n+    public static class RefsCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            final State state = plannerRepl.getCurrentState();\n+            final Cache<Integer, ExpressionRef<? extends RelationalExpression>> referenceCache = state.getReferenceCache();\n+            final List<Integer> ids = Lists.newArrayList(referenceCache.asMap().keySet());\n+            Collections.sort(ids);\n+            for (Integer id : ids) {\n+                plannerRepl.printKeyValue(\"id\", \"ref\" + id + \"; \");\n+                @Nullable final ExpressionRef<? extends RelationalExpression> reference = referenceCache.getIfPresent(id);\n+                plannerRepl.printKeyValue(\"kind\", reference == null ? \"not in cache; \" : reference.getClass().getSimpleName() + \"; \");\n+                if (reference instanceof GroupExpressionRef) {\n+                    final GroupExpressionRef<? extends RelationalExpression> groupReference = (GroupExpressionRef<? extends RelationalExpression>)reference;\n+                    final String membersString = groupReference.getMembers()\n+                            .stream()\n+                            .map(expression -> Optional.ofNullable(plannerRepl.nameForObject(expression)))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.joining(\", \"));\n+                    plannerRepl.printKeyValue(\"members: \", \"{\" + membersString + \"}\");\n+                }\n+                plannerRepl.println();\n+            }\n+            return false;\n+        }\n+\n+        @Nonnull\n+        @Override\n+        public String getCommandToken() {\n+            return \"REFS\";\n+        }\n+\n+        @Override\n+        public void printUsage(@Nonnull final PlannerRepl plannerRepl) {\n+            plannerRepl.printlnKeyValue(\"refs\", \"list all references\");\n+        }\n+    }\n+\n+    /**\n+     * Restart execution. All entity names remain stable.\n+     */\n+    @AutoService(Command.class)\n+    public static class RestartCommand implements Command<Event> {\n+        @Override\n+        public boolean executeCommand(@Nonnull final PlannerRepl plannerRepl,\n+                                      @Nonnull final Event event,\n+                                      @Nonnull final ParsedLine parsedLine) {\n+            plannerRepl.restartState();\n+            plannerRepl.addInternalBreakPoint(new PlannerRepl.CountingTautologyBreakPoint(1));", "originalCommit": "a53f90baded58b14a92142133c10370e0baeb056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc2MTE4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1027#discussion_r506761181", "bodyText": "The first thing the compilation process does it to pop the first task from the task stack and call the debugger with an instance of ExecutingTaskEvent. That's when the break point stops execution again and self-removes itself from the list of break points. So to answer your question it will be before the first actual thing happens and identical to what happens when you first run it prior to the restart()", "author": "normen662", "createdAt": "2020-10-16T23:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Mzc1MQ=="}], "type": "inlineReview"}, {"oid": "fdee984a3bd2eb83c1fe2b828ed70ff7f4ff3634", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/fdee984a3bd2eb83c1fe2b828ed70ff7f4ff3634", "message": "address review comments", "committedDate": "2020-10-16T23:31:02Z", "type": "forcePushed"}, {"oid": "67fd3583edd878a3aacfbd074982342dcef4be96", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/67fd3583edd878a3aacfbd074982342dcef4be96", "message": "Resolves #987: introduce concept of correlations (using quantifiers)", "committedDate": "2020-11-16T16:18:42Z", "type": "commit"}, {"oid": "70c9cda2ea88555dab2d5556baabcbad739990c4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/70c9cda2ea88555dab2d5556baabcbad739990c4", "message": "matching infrastructure", "committedDate": "2020-11-16T16:18:42Z", "type": "commit"}, {"oid": "5266a7b800868f209354151db936d845de909683", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5266a7b800868f209354151db936d845de909683", "message": "address review comments", "committedDate": "2020-11-16T16:44:00Z", "type": "forcePushed"}, {"oid": "927c00d44a27ef2465336e98179bba2efaec5b96", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/927c00d44a27ef2465336e98179bba2efaec5b96", "message": "address review comments", "committedDate": "2020-11-16T18:26:56Z", "type": "commit"}, {"oid": "927c00d44a27ef2465336e98179bba2efaec5b96", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/927c00d44a27ef2465336e98179bba2efaec5b96", "message": "address review comments", "committedDate": "2020-11-16T18:26:56Z", "type": "forcePushed"}]}