{"pr_number": 999, "pr_title": "Resolve #703, OnlineIndexer should limit amount of work by transactio\u2026", "pr_createdAt": "2020-07-17T15:18:39Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/999", "timeline": [{"oid": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/46ad4dbf74eb5bc9039eec4201085a9b18723355", "message": "Resolve #703, OnlineIndexer should limit amount of work by transaction size\n\n    While interating, limit range to the one record beyond a predefined max write size.\n    Add FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE/COUNT to count the number of cases\n    of terminating a range by size vs. by count limit.", "committedDate": "2020-07-17T15:13:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDQyNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458534424", "bodyText": "Maybe DEFAULT_WRITE_BYTES_LIMIT? It would be nice to tell from the name that this is a \"limit\" and the unit is bytes.", "author": "nblintao", "createdAt": "2020-07-22T04:58:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -126,6 +127,10 @@\n      * Default number of records to attempt to run in a single transaction.\n      */\n     public static final int DEFAULT_LIMIT = 100;\n+    /**\n+     * Default transaction write size limit. Note that the actual write might be \"a little\" bigger.\n+     */\n+    public static final int DEFAULT_WRITE_SIZE = 900 * 1024;", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjE1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458946156", "bodyText": "Sure! (and don't worry about the nitpicking - I'm here to learn).\nI've changed that to DEFAULT_WRITE_LIMIT_BYTES (keeping the unit at the end). Would that be acceptable?", "author": "jjezra", "createdAt": "2020-07-22T17:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0ODI1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458948258", "bodyText": "Sure. A GitHub tip: If you want to send out tons of replies in a batch, you can do it in the reviewer's view https://github.com/FoundationDB/fdb-record-layer/pull/999/files", "author": "nblintao", "createdAt": "2020-07-22T17:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMDg5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459010896", "bodyText": "I've tried - it became messy, so I'll keep going here (for now) to avoid losing momentum. Sorry for the frequent emails.", "author": "jjezra", "createdAt": "2020-07-22T18:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNDQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536165", "bodyText": "This is correct. Nothing need to be changed here.\nJust wonder if you had the same confusion when you first see this. Things like cursor.onNext().thenCompose(result -> {if (!result.hasNext()) { always make me feel it iterated two steps at the first glance. The trick here is that RecordCursorResult is not a \"record\", but an info about the next record. See details at the RecordCursorResult.java.\nIt probably won't happen because it's STABLE but I'd love to see it's renamed to something like NextRecordInfo some day.", "author": "nblintao", "createdAt": "2020-07-22T05:04:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMTkxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458801911", "bodyText": "Yes, it had confused me too!\nI asked Scott G. about it - he think that hasNext() should have been something like isValid().", "author": "jjezra", "createdAt": "2020-07-22T13:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTEyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458911126", "bodyText": "I don't think isValid is quite right... The idea is that you want to distinguish getting a result with an item and getting a result that just indicates that it's at the end of iteration. Perhaps hasElement?", "author": "alecgrieser", "createdAt": "2020-07-22T16:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MDUwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458950505", "bodyText": "Modern C++ usually uses the reverse logic, as in if(result.isEnd()). Would that be clearer or even more confusing?\n__\nC++ iterator example:\nfor (auto ptr = ar.begin(); ptr != ar.end(); ptr++)", "author": "jjezra", "createdAt": "2020-07-22T17:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2NjUwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459066500", "bodyText": "I'm not sure. I would worry .isEnd() being a little confusing, as we also use \"end\" in the context of \"end continuation\" to indicate \"there is no more data left to read\" (as distinct from \"we have reached a limit, and that's why this cursor is done\"), but I'm not sure I have too many opinions, really", "author": "alecgrieser", "createdAt": "2020-07-22T20:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjIxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536213", "bodyText": "Is this comment going to be removed?", "author": "nblintao", "createdAt": "2020-07-22T05:04:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MTU3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458951570", "bodyText": "Removed.", "author": "jjezra", "createdAt": "2020-07-22T17:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjgzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458536830", "bodyText": "I think it's good to have a comment here. Just remove \"here\".\nConsidering this method is getting larger, maybe you can extract this part as a separate method.", "author": "nblintao", "createdAt": "2020-07-22T05:07:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1NDk4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458954984", "bodyText": "Removed \"here\"", "author": "jjezra", "createdAt": "2020-07-22T17:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNzIzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458537230", "bodyText": "lol", "author": "nblintao", "createdAt": "2020-07-22T05:08:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzODAxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458538014", "bodyText": "thenCompose will worth a new line", "author": "nblintao", "createdAt": "2020-07-22T05:11:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzOTAyNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458539027", "bodyText": "Is this comment removed intentionally?", "author": "nblintao", "createdAt": "2020-07-22T05:15:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2OTM5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458969393", "bodyText": "Nope. I've added it to the systheticPlan line", "author": "jjezra", "createdAt": "2020-07-22T17:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzOTAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MDMyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458540326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return (syntheticPlan == null ?\n          \n          \n            \n                                maintainer.update(null, rec) :\n          \n          \n            \n                                syntheticPlan.execute(store, rec)\n          \n          \n            \n                                        .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n          \n          \n            \n                                ).thenCompose(vignore ->\n          \n          \n            \n                        final CompletableFuture<Void> updateMaintainer;\n          \n          \n            \n                        if (syntheticPlan == null) {\n          \n          \n            \n                            updateMaintainer = maintainer.update(null, rec);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            // Pipeline size is 1, since not all maintainers are thread-safe.\n          \n          \n            \n                            updateMaintainer = syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n          \n          \n            \n                        }\n          \n          \n            \n                        return updateMaintainer. thenCompose(vignore ->\n          \n      \n    \n    \n  \n\nI would probably do something like this to make it faster to read. But it's up to you.", "author": "nblintao", "createdAt": "2020-07-22T05:19:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MzY3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458973672", "bodyText": "I've tried to ease the reading with comments...", "author": "jjezra", "createdAt": "2020-07-22T17:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MjE4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458542183", "bodyText": "A name like lastResult will be more intuitive.", "author": "nblintao", "createdAt": "2020-07-22T05:26:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3NTY4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458975680", "bodyText": "I like the dual meaning of \"last\" - as both most recent and lasting...", "author": "jjezra", "createdAt": "2020-07-22T17:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MjE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0MzM4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458543381", "bodyText": "I don't know reason but the codebase uses vignore", "author": "nblintao", "createdAt": "2020-07-22T05:30:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NDQzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458544436", "bodyText": "This value is not \"no next\" anymore in RecordCursorResult's definition. Maybe you can just inline it.", "author": "nblintao", "createdAt": "2020-07-22T05:33:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {\n+                        if (size >= config.getMaxWriteSize()) {\n+                            // the transaction becomes too big - stop iterating\n+                            if (timer != null) {\n+                                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE);\n+                            }\n+                            holder.set(result);\n+                            return AsyncUtil.READY_FALSE;\n+                        }\n+                        return AsyncUtil.READY_TRUE;\n+                    }));\n+\n+        }), cursor.getExecutor()).thenCompose(vIgnore -> {\n+            RecordCursorResult<FDBStoredRecord<Message>> noNextResult = holder.get();", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NjY4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458546680", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than\n          \n          \n            \n                     * @return the write size. Typically a transaction will be submitted when it becomes bigger than", "author": "nblintao", "createdAt": "2020-07-22T05:40:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1474,6 +1509,16 @@ public int getIncreaseLimitAfter() {\n             return increaseLimitAfter;\n         }\n \n+        /**\n+         * Get the approximate size limit, represents a desired max transaction message size. Note that the actual write\n+         * might be \"a little\" larger than this limit.\n+         * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMTI5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459001296", "bodyText": "Oops.", "author": "jjezra", "createdAt": "2020-07-22T18:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NjY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NzE4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458547181", "bodyText": "Same here. I would like to indicate \"bytes\" in the name and/or the comment.", "author": "nblintao", "createdAt": "2020-07-22T05:41:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * he default limit is {@link #DEFAULT_WRITE_SIZE} = {@value #DEFAULT_WRITE_SIZE}.\n+         * @param max the desired max write size\n+         * @return this builder\n+         */\n+\n+        @Nonnull\n+        public Builder setMaxWriteSize(int max) {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0NzM5OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458547398", "bodyText": "f there is going to be a place explaining what \"a little\" means, it's here.", "author": "nblintao", "createdAt": "2020-07-22T05:42:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU0OTE1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458549154", "bodyText": "There are two sets of get/set here. I wish the comments can be exactly same so you don't have to fix 4 places separately. For the same reason, I would not leave important information in the lines above rather than @return and @params", "author": "nblintao", "createdAt": "2020-07-22T05:48:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1474,6 +1509,16 @@ public int getIncreaseLimitAfter() {\n             return increaseLimitAfter;\n         }\n \n+        /**\n+         * Get the approximate size limit, represents a desired max transaction message size. Note that the actual write\n+         * might be \"a little\" larger than this limit.\n+         * @return a the efficient write size. Typically a transaction will be submitted when it becomes bigger than", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458551085", "bodyText": "It should better to be in OnlineIndexerSimpleTest.java (if it is easy to move there)", "author": "nblintao", "createdAt": "2020-07-22T05:54:37Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMTgzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458931836", "bodyText": "I could also believe that a separate OnlineIndexerWithRecordTypeKeysTest.java (or something like that) could be a good idea, and that the other tests of the online indexer in this file could be moved there.\nOr, actually, perhaps more holistically, I think we don't (necessarily) want to test this with a test of RecordTypeKeys, but instead probably just want a test with some of the more traditional OnlineIndexer tests in OnlineIndexerSimpleTest.", "author": "alecgrieser", "createdAt": "2020-07-22T16:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNTc1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459035757", "bodyText": "I agree. However, since my attempt to port it became a little messy, would it be ok to do it in a separate, standalone fix?", "author": "jjezra", "createdAt": "2020-07-22T19:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2NzAzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459067039", "bodyText": "I think if a full refactoring is done, then, yeah, that would be a separate PR. If it's adding a new test not using RecordTypeKeys, then that feels like it should be in this PR (imo)", "author": "alecgrieser", "createdAt": "2020-07-22T20:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTg0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459139841", "bodyText": "Ok. I'll try again.", "author": "jjezra", "createdAt": "2020-07-22T23:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTY2Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458551663", "bodyText": "Are these checks relevant?", "author": "nblintao", "createdAt": "2020-07-22T05:56:19Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();\n+            context.commit();\n+        }\n+\n+        saveManyRecords(BASIC_HOOK, 250, 250);\n \n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MySimpleRecord\").join().intValue());\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MyOtherRecord\").join().intValue());", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzNzAwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459037001", "bodyText": "It is my way to verify the behavior with high write limit, before making sure the \"flattened\" 1 byte write limit behaves the same. Is that an issue?", "author": "jjezra", "createdAt": "2020-07-22T19:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1MTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1Mjk1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458552958", "bodyText": "I think some old code still calls is indexBuilder (OnlineIndexer used to be called OnlineIndexBuilder) but it'd better to be called indexer because it's weird to have a \"Builder\" for a \"XXXBuilder\".", "author": "nblintao", "createdAt": "2020-07-22T06:00:10Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();\n+            context.commit();\n+        }\n+\n+        saveManyRecords(BASIC_HOOK, 250, 250);\n \n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MySimpleRecord\").join().intValue());\n+            assertEquals(250, recordStore.getSnapshotRecordCountForRecordType(\"MyOtherRecord\").join().intValue());\n+        }\n+\n+        RecordMetaDataHook hook = metaData -> {\n+            BASIC_HOOK.apply(metaData);\n+            metaData.addIndex(\"MySimpleRecord\", \"newIndex\", \"num_value_2\");\n+        };\n+\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, hook);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            assertTrue(recordStore.isIndexWriteOnly(\"newIndex\"));\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexBuilder =", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458556272", "bodyText": "Is this comment still true?", "author": "nblintao", "createdAt": "2020-07-22T06:10:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyODMxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458928310", "bodyText": "This appears to still be true, at least the way I'm reading the code", "author": "alecgrieser", "createdAt": "2020-07-22T16:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1NzUxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458957515", "bodyText": "I mean \"If everything were thread safe, a larger pipeline size would be possible\" part. Will there be problem to have a non-1 pipeline size at the write part?", "author": "nblintao", "createdAt": "2020-07-22T17:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MDQwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459040401", "bodyText": "I removed the hypothetical part of the comment.", "author": "jjezra", "createdAt": "2020-07-22T19:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNzI3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459117272", "bodyText": "I think we still want to have that hypothetical comment. At the moment, we can't do anything in parallel, but at some point we will... It probably doesn't matter too much, and I think the main upshot from this change is that we'd need to think about how to pipeline the .whileTrue, etc.", "author": "alecgrieser", "createdAt": "2020-07-22T22:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MjMwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459142305", "bodyText": "NP. I'll put it back.", "author": "jjezra", "createdAt": "2020-07-22T23:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU1NjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTkxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458571919", "bodyText": "Maybe you can explain more about \"range termination\" here.", "author": "nblintao", "createdAt": "2020-07-22T06:50:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2NTM4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458965386", "bodyText": "Yes, this is very unclear. How about:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */\n          \n          \n            \n                    /** The indexer's single transaction range limit - by number of records scanned {@link OnlineIndexer}. */\n          \n          \n            \n                    ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n          \n          \n            \n                    /** The indexer's single transaction range limit - by transaction's write size  {@link OnlineIndexer}. */\n          \n          \n            \n                    ONLINE_INDEX_BUILDER_RANGE_BY_SIZE(\"number of indexer iterations terminated by write limit\", false),", "author": "jjezra", "createdAt": "2020-07-22T17:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2Mzc5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459063792", "bodyText": "I think that the current comment seems to suggest that the timer's will contain, like, the values of the limits themselves rather than the number of times a transaction is committed because it hits each limit (which I think is what it's actually recording, right?).", "author": "alecgrieser", "createdAt": "2020-07-22T20:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MjExMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459142110", "bodyText": "I've changed that according to your suggestion below. Please review the change.", "author": "jjezra", "createdAt": "2020-07-22T23:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTkyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458911925", "bodyText": "Perhaps something more like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */\n          \n          \n            \n                    /** The number of {@link OnlineIndexer} range scans terminated after hitting the scan limit. */", "author": "alecgrieser", "createdAt": "2020-07-22T16:13:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0NTkzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459045935", "bodyText": "Oh (already visited this item..). How about combining your/my suggesting to:\n        /** The number of {@link OnlineIndexer} records scanned in a single iteration/transaction. */\n        /** The number of {@link OnlineIndexer} bytes to write in a single iteration/transaction. */", "author": "jjezra", "createdAt": "2020-07-22T19:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0OTE5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459049192", "bodyText": "How about\n        /** The number of {@link OnlineIndexer} records scanned in a single iteration/transaction. */\n        /** The number of {@link OnlineIndexer} bytes to write in a single iteration/transaction. */", "author": "jjezra", "createdAt": "2020-07-22T20:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2MzI4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459063288", "bodyText": "It's probably worth consolidating the discussion here to a single thread. I'll respond in: #999 (comment)", "author": "alecgrieser", "createdAt": "2020-07-22T20:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxMTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNDUxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458914510", "bodyText": "Suggested change", "author": "alecgrieser", "createdAt": "2020-07-22T16:17:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.\n+         */\n+        @Nonnull\n+        public int getMaxWriteSize() {\n+            return maxWriteSize;\n+        }\n+\n+        /**\n+         * Set the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * he default limit is {@link #DEFAULT_WRITE_SIZE} = {@value #DEFAULT_WRITE_SIZE}.\n+         * @param max the desired max write size\n+         * @return this builder\n+         */\n+", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNTM3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458915379", "bodyText": "In general, we try and keep @return statements as a single \"statement\" (without a period), so something like @return the requested write size, and then additional clarifying comments go in the body.\nAlso, looking at \"Index iteration stops when exceeding this size.\", the way I read that is that it stops, like, \"iterating over the index and the build stops\" or something when it hits the limit, which I don't think is what you're getting at. I think something like \"transactions started as part of the index build will be committed after they exceed this size, and a new transaction will be started\", or something like that.", "author": "alecgrieser", "createdAt": "2020-07-22T16:19:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1807,6 +1868,28 @@ public Builder setLimit(int limit) {\n             return this;\n         }\n \n+        /**\n+         * Get the approximate maximum transaction write size. Note that the actual size might be \"a little\" bigger.\n+         * @return the requested write size. Index iteration stops when exceeding this size.", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkxNzkxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458917912", "bodyText": "In a similar vein (presented mostly for parallelism, but this really should be whatever is decided for the first timer option, but adapted for this one).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** The number of indexer range termination by write limit {@link OnlineIndexer}. */\n          \n          \n            \n                    /** The number of {@OnlineIndexer} range scans terminated after hitting the by write limit. */", "author": "alecgrieser", "createdAt": "2020-07-22T16:22:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of indexer range termination by scan limit {@link OnlineIndexer}. */\n+        ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n+        /** The number of indexer range termination by write limit {@link OnlineIndexer}. */", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyMTEwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458921105", "bodyText": "I suppose 900 kiB is a fine enough default size as any, though I believe that the FDB limits use base-1000 rather than base-1024 units in general (that is to say, the absolute maximum transaction size is 10 MB = 10 * 106 B, not 10 MiB = 10 * 220 B).", "author": "alecgrieser", "createdAt": "2020-07-22T16:25:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -126,6 +127,10 @@\n      * Default number of records to attempt to run in a single transaction.\n      */\n     public static final int DEFAULT_LIMIT = 100;\n+    /**\n+     * Default transaction write size limit. Note that the actual write might be \"a little\" bigger.\n+     */\n+    public static final int DEFAULT_WRITE_SIZE = 900 * 1024;", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1Mzc0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459053741", "bodyText": "900_000 it is.", "author": "jjezra", "createdAt": "2020-07-22T20:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyMTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458925074", "bodyText": "I think this can be .thenApply instead of .thenCompose, and then it would return false and true instead of READY_FALSE and READY_TRUE.", "author": "alecgrieser", "createdAt": "2020-07-22T16:30:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -558,27 +563,55 @@ private void increaseLimit() {\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n         // in the rank code that was causing incorrect results. If everything were thread safe,\n         // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> holder = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                holder.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n+            // here: implement forEachResultAsync\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // here: add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    maintainer.update(null, rec) :\n+                    syntheticPlan.execute(store, rec)\n+                            .forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)\n+                    ).thenCompose(vignore ->\n+                    context.getApproximateTransactionSize().thenCompose(size -> {", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NTg4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459055883", "bodyText": "I've tried that and it didn't work. I assume that the expectations is for a boolean completable future is not happen with the thenApply.", "author": "jjezra", "createdAt": "2020-07-22T20:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2MjM0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459062349", "bodyText": "What exactly did you try? It should work if you use .thenApply and return vanilla booleans (not CompletableFutures)?", "author": "alecgrieser", "createdAt": "2020-07-22T20:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MjAzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459772030", "bodyText": "I'm still a little suprsed that the inner-most .thenCompose here can't be .thenApply.", "author": "alecgrieser", "createdAt": "2020-07-23T22:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkyNTA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMDE3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r458930170", "bodyText": "Hm, I'm not sure this separate transaction is necessary, though the other OnlineIndexer-related tests in this file are doing it, so \u00af\\_(\u30c4)_/\u00af", "author": "alecgrieser", "createdAt": "2020-07-22T16:36:35Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/RecordTypeKeyTest.java", "diffHunk": "@@ -697,5 +698,96 @@ private void saveManyRecords(@Nonnull RecordMetaDataHook hook, int count1, int c\n             context.commit();\n         }\n     }\n+    \n+    @Test\n+    public void testOnlineIndexBuilderMaxWrite() throws Exception {\n+        try (FDBRecordContext context = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context, BASIC_HOOK);\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_EXISTS).join();", "originalCommit": "46ad4dbf74eb5bc9039eec4201085a9b18723355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NzMwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459057301", "bodyText": "\u00af_(\u30c4)_/\u00af\n(maybe the second test was a copy&paste, then the rest followed)", "author": "jjezra", "createdAt": "2020-07-22T20:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzMDE3MA=="}], "type": "inlineReview"}, {"oid": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "message": "Apply changes requested by Tao & Alec.", "committedDate": "2020-07-22T20:38:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTc3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459119770", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.\n          \n          \n            \n                                // case 2: syntheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.", "author": "alecgrieser", "createdAt": "2020-07-22T22:29:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -556,29 +561,57 @@ private void increaseLimit() {\n \n         AtomicLong recordsScannedCounter = new AtomicLong();\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n-        // in the rank code that was causing incorrect results. If everything were thread safe,\n-        // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+        // in the rank code that was causing incorrect results.\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> lastResult = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                lastResult.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    // case 1: simple\n+                    maintainer.update(null, rec) :\n+                    // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.", "originalCommit": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTk5Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459119993", "bodyText": "I kind of liked @nblintao's suggestion to remove the ternary operator and make it a real if statement for readability, but I suppose it doesn't really matter", "author": "alecgrieser", "createdAt": "2020-07-22T22:30:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -556,29 +561,57 @@ private void increaseLimit() {\n \n         AtomicLong recordsScannedCounter = new AtomicLong();\n         // Note: This runs all of the updates in serial in order to not invoke a race condition\n-        // in the rank code that was causing incorrect results. If everything were thread safe,\n-        // a larger pipeline size would be possible.\n-        return cursor.forEachResultAsync(result -> {\n+        // in the rank code that was causing incorrect results.\n+\n+        final AtomicReference<RecordCursorResult<FDBStoredRecord<Message>>> lastResult = new AtomicReference<>(RecordCursorResult.exhausted());\n+        final FDBRecordContext context = store.getContext();\n+        return AsyncUtil.whileTrue(() -> cursor.onNext().thenCompose(result -> {\n+\n+            if (!result.hasNext()) {\n+                // end of the cursor list\n+                if (timer != null) {\n+                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT);\n+                }\n+                lastResult.set(result);\n+                return AsyncUtil.READY_FALSE;\n+            }\n+\n             final FDBStoredRecord<Message> rec = result.get();\n             empty.set(false);\n             if (timer != null) {\n                 timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED);\n             }\n             recordsScannedCounter.incrementAndGet();\n-            if (recordTypes.contains(rec.getRecordType())) {\n-                if (timer != null) {\n-                    timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n-                }\n-                if (syntheticPlan == null) {\n-                    return maintainer.update(null, rec);\n-                } else {\n-                    // Pipeline size is 1, since not all maintainers are thread-safe.\n-                    return syntheticPlan.execute(store, rec).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1);\n-                }\n-            } else {\n-                return AsyncUtil.DONE;\n+            if (!recordTypes.contains(rec.getRecordType())) {\n+                // This record is not our type, swipe left\n+                return AsyncUtil.READY_TRUE;\n             }\n-        }).thenCompose(noNextResult -> {\n+            // add this index to the transaction\n+            if (timer != null) {\n+                timer.increment(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED);\n+            }\n+            return (syntheticPlan == null ?\n+                    // case 1: simple\n+                    maintainer.update(null, rec) :\n+                    // case 2: synatheticPlan - note that Pipeline size is 1, since not all maintainers are thread-safe.\n+                    syntheticPlan.execute(store, rec\n+                    ).forEachAsync(syntheticRecord -> maintainer.update(null, syntheticRecord), 1)", "originalCommit": "4ed04378e5b165c38c7e38c0894cf17bc827d9ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NDg0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459144849", "bodyText": "If the majority claim that A is more readable than B, then more readable it is.", "author": "jjezra", "createdAt": "2020-07-22T23:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTk5Mw=="}], "type": "inlineReview"}, {"oid": "76b313f4067eb326350fca837c1d9ffcba7ba1c4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/76b313f4067eb326350fca837c1d9ffcba7ba1c4", "message": "Apply (more) change requests", "committedDate": "2020-07-23T00:49:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MTYyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459771626", "bodyText": "I still think these names seem to suggest that they are tracking the number of records scanned or bytes written, when they seem to actually be tracking the number of ranges scanned (by termination type)", "author": "alecgrieser", "createdAt": "2020-07-23T22:53:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -570,6 +570,10 @@ public String logKey() {\n         ONLINE_INDEX_BUILDER_RECORDS_SCANNED(\"number of records scanned by online index build\", false),\n         /** The number of records indexed by {@link OnlineIndexer}. */\n         ONLINE_INDEX_BUILDER_RECORDS_INDEXED(\"number of records indexed by online index build\", false),\n+        /** The number of {@link OnlineIndexer} records scanned in a single iteration/transaction. */\n+        ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n+        /** The number of {@link OnlineIndexer} bytes to write in a single iteration/transaction. */", "originalCommit": "76b313f4067eb326350fca837c1d9ffcba7ba1c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODg5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459778892", "bodyText": "Yep. That was my late working day confusion.\nHow about:\n      /** The number of {@link OnlineIndexer} ranges defined by scanned record count limit. */\n        ONLINE_INDEX_BUILDER_RANGE_BY_COUNT(\"number of indexer iterations terminated by scan limit\", false),\n        /** The number of {@link OnlineIndexer} ranges defined by transaction write size limit. */\n        ONLINE_INDEX_BUILDER_RANGE_BY_SIZE(\"number of indexer iterations terminated by write limit\", false),", "author": "jjezra", "createdAt": "2020-07-23T23:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MTYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MDMwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459780305", "bodyText": "Yeah, I like The number of {@link OnlineIndexer} range scans terminated after hitting the scan limit. (and similar for ONLINE_INDEX_BUILDER_RANGE_BY_COUNT.\nAlthough, actually, the names here should probably be RANGES_BY_COUNT and RANGES_BY_SIZE (plural instead of singular).", "author": "alecgrieser", "createdAt": "2020-07-23T23:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MTYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDg1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459774852", "bodyText": "I think this probably could use one more test where it calls OnlineIndexer.buildIndex (i.e., building the index across multiple transactions) and makes sure that we get a built index, at the end of it.", "author": "alecgrieser", "createdAt": "2020-07-23T23:03:33Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerSimpleTest.java", "diffHunk": "@@ -883,4 +883,88 @@ public void testConfigLoader() throws Exception {\n             assertThat(\"Should have done several transactions in a few seconds\", pass, lessThan(100));\n         }\n     }\n+\n+    @Test\n+    public void testOnlineIndexerBuilderWriteLimitBytes() {\n+        List<TestRecords1Proto.MySimpleRecord> records = LongStream.range(0, 200).mapToObj( val ->\n+                TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+        ).collect(Collectors.toList());\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n+        IndexAggregateFunction aggregateFunction = new IndexAggregateFunction(FunctionNames.SUM, index.getRootExpression(), index.getName());\n+        List<String> indexTypes = Collections.singletonList(\"MySimpleRecord\");\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            records.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+\n+        final Supplier<Tuple> getAggregate = () -> {\n+            Tuple ret;\n+            try (FDBRecordContext context = openContext()) {\n+                assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n+                FDBRecordStore recordStore2 = recordStore.asBuilder().setContext(context).uncheckedOpen();\n+                ret = recordStore2.evaluateAggregateFunction(indexTypes, aggregateFunction, TupleRange.ALL, IsolationLevel.SERIALIZABLE).join();\n+                // Do NOT commit changes\n+            }\n+            return ret;\n+        };\n+\n+        openSimpleMetaData(hook);\n+        final FDBStoreTimer timer = new FDBStoreTimer();\n+\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexer =\n+                         OnlineIndexer.newBuilder()\n+                                 .setRecordStore(recordStore)\n+                                 .setTimer(timer)\n+                                 .setIndex(\"newIndex\")\n+                                 .setLimit(100000)\n+                                 .setMaxWriteLimitBytes(1)\n+                                 .build()) {\n+                // this call will \"flatten\" the staccato iterations to a whole range. Testing compatibility.\n+                indexer.rebuildIndex(recordStore);\n+            }\n+            recordStore.markIndexReadable(\"newIndex\").join();\n+\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_SCANNED));\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RECORDS_INDEXED));\n+\n+            assertEquals(200, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE));\n+            assertEquals(0, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT));\n+\n+            recordStore.clearAndMarkIndexWriteOnly(\"newIndex\").join();\n+            context.commit();\n+        }\n+\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n+\n+            timer.reset();\n+\n+            // Build in this transaction.\n+            try (OnlineIndexer indexer =\n+                         OnlineIndexer.newBuilder()\n+                                 .setRecordStore(recordStore)\n+                                 .setTimer(timer)\n+                                 .setIndex(\"newIndex\")\n+                                 .setLimit(100000)\n+                                 .setMaxWriteLimitBytes(1)\n+                                 .build()) {\n+\n+                Key.Evaluated key = indexer.buildUnbuiltRange(Key.Evaluated.scalar(0L), Key.Evaluated.scalar(25L)).join();\n+                assertEquals(1, key.getLong(0));\n+                assertEquals(1, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_SIZE));\n+                assertEquals(0, timer.getCount(FDBStoreTimer.Counts.ONLINE_INDEX_BUILDER_RANGE_BY_COUNT));\n+            }\n+            recordStore.clearAndMarkIndexWriteOnly(\"newIndex\").join();\n+            context.commit();\n+        }", "originalCommit": "76b313f4067eb326350fca837c1d9ffcba7ba1c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5NTE3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/999#discussion_r459795170", "bodyText": "Just pushed the thenApply (sorry, forgot about it yesterday)\nI would need some guidance writing the additional test. Of all the existing indexer tests, Is there one I can use as an example?", "author": "jjezra", "createdAt": "2020-07-24T00:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDg1Mg=="}], "type": "inlineReview"}, {"oid": "e4520c538e0dbe6679dd075a7d2472d690bfb26f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/e4520c538e0dbe6679dd075a7d2472d690bfb26f", "message": "Apply two more changes:\n\n   1. better comments\n   2. thenCompose ==>", "committedDate": "2020-07-24T00:08:00Z", "type": "commit"}, {"oid": "168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "message": ".._RANGE_.. => .._RANGES_..", "committedDate": "2020-07-24T19:32:04Z", "type": "commit"}, {"oid": "168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/168cd17194d31a6b725a0c2863277ee8cd0ab3b3", "message": ".._RANGE_.. => .._RANGES_..", "committedDate": "2020-07-24T19:32:04Z", "type": "forcePushed"}, {"oid": "45095f16528cea8e6a4ed886e609fcc59284ce55", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/45095f16528cea8e6a4ed886e609fcc59284ce55", "message": "Add an indexer.buildIndex test", "committedDate": "2020-07-24T21:35:31Z", "type": "commit"}]}