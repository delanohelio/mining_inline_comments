{"pr_number": 1018, "pr_title": "Resolves #1016: Covering filters on legs of unions/intersections.", "pr_createdAt": "2020-08-18T20:30:39Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018", "timeline": [{"oid": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/86be71c95c98e46b8dee430ba206d8e96d75d7f8", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries.", "committedDate": "2020-08-19T02:36:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQ2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473373466", "bodyText": "Does this mean full (not-partial) records, where all fields are available by navigation of said record?\nI guess I am unclear whether this comment is speaking generally of scan streams or more specifically of how this class is used.", "author": "MMcM", "createdAt": "2020-08-19T22:09:36Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MzU1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477493554", "bodyText": "Yes, this should be full records, not partial ones.", "author": "nschiefer", "createdAt": "2020-08-26T18:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3ODE2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473378167", "bodyText": "Map.keySet is backed by the map itself, so I think retainAll should work here.", "author": "MMcM", "createdAt": "2020-08-19T22:15:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    Set<KeyExpression> keysToRemove = new HashSet<>(Sets.difference(intersection.keySet(),", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NDMxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477494318", "bodyText": "Ah, great, that makes this much tidier.", "author": "nschiefer", "createdAt": "2020-08-26T18:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3ODE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5MDM0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r473390341", "bodyText": "Maybe a helper here in this fixture for that?", "author": "MMcM", "createdAt": "2020-08-19T22:31:36Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "diffHunk": "@@ -1015,10 +1023,12 @@ public void twoRankPredicates() throws Exception {\n                         Query.rank(Key.Expressions.field(\"score\").groupBy(Key.Expressions.field(\"gender\"))).equalsValue(1L)))\n                 .build();\n         RecordQueryPlan plan = planner.plan(query);\n-        assertEquals(\"Index(rank_by_gender [[M, 1],[M, 1]] BY_RANK)\" +\n-                        \" | score LESS_THAN $__rank_0\" +\n-                        \" WHERE __rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\",\n-                plan.toString());\n+        assertThat(plan, scoreForRank(contains(\n+                hasToString(\"__rank_0 = BasicRankedRecord$score.score_for_rank_else_skip(3)\")),\n+                // need to explicitly construct QueryComponent because we're using an internal parameter", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODUzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477498531", "bodyText": "Yes, good idea. Fixed.", "author": "nschiefer", "createdAt": "2020-08-26T18:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5MDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NjEyOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474096128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n          \n          \n            \n             * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included", "author": "normen662", "createdAt": "2020-08-20T16:01:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474099335", "bodyText": "Not sure if that would be useful, but is this worth logging?", "author": "normen662", "createdAt": "2020-08-20T16:06:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5OTEyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477499122", "bodyText": "No, this can happen for fairly pedestrian reasons, such as having a repeated field. isValid() is a bit harsh sounding, but I didn't want to change the existing method name.", "author": "nschiefer", "createdAt": "2020-08-26T18:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMTEzMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474111133", "bodyText": "Hmm, let me just list out two thoughts I have here:\n\nIn a perfect world, we should always know the universe of fields that actually comprise all fields. Since we presumably don't know that in all cases, we use a special value to represent all fields. If that assumption on my side is true, then I guess we cannot do better, however, this may be error prone going forward or just straight out lose information. I mean ALL intersection set should not be set as ALL may be a superset or a subset of set in the most general case.\nThis intersection has a weird behavioral knack when it comes to an empty list of fields to intersect which would return all fields which feels counterintuitive. I am not sure if this can happen but if it cannot happen through callers, maybe this case should be verified and this should bail or return something else. I only see intersection and union base plans to call this, maybe I missed one.", "author": "normen662", "createdAt": "2020-08-20T16:24:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+import com.google.common.collect.Sets;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes partial records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field every be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMDgwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477500805", "bodyText": "With regard to the first thought, I agree in principle but think this should be handled in a more systematic way. Right now, it's remarkably difficult to say exactly what fields are present, because the way that \"present\" is defined varies by context. For example, is a repeated field \"present\"? For the purposes of covering optimizations, it is not, but in general it probably is. I believe that the logic we have here is circumstantially correct and also fairly simple. The join-based framework you're working on will clarify a lot of these issues.\nRegarding the second point, that's an oversight on my part. This is only ever called by union and intersection plans, w which are required to have a least two children. I've added a check that throws an exception if this gets called on an empty list.", "author": "nschiefer", "createdAt": "2020-08-26T18:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMTYwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474811603", "bodyText": "This cannot be empty, I don't think the other callers can be empty either -- maybe let's not allow intersections of zero number of operands.", "author": "normen662", "createdAt": "2020-08-21T16:47:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryIntersectionPlan.java", "diffHunk": "@@ -202,8 +203,16 @@ public boolean equalsWithoutChildren(@Nonnull RelationalExpression otherExpressi\n                comparisonKey.equals(other.comparisonKey);\n     }\n \n-    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n+    @Nonnull\n+    @Override\n+    public AvailableFields getAvailableFields() {\n+        return AvailableFields.intersection(quantifiers.stream()", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMTQwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477501407", "bodyText": "RecordQueryIntersectionPlan requires at least two children (see line 294). However, I've added a check to AvailableFields so that it can't be misused.", "author": "nschiefer", "createdAt": "2020-08-26T18:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjQyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r474812420", "bodyText": "property visitor?", "author": "normen662", "createdAt": "2020-08-21T16:49:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/visitor/FilterVisitor.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * FilterVisitor.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.visitor;\n+\n+import com.apple.foundationdb.record.RecordMetaData;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.FunctionKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.LiteralKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.QueryableKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.ThenKeyExpression;\n+import com.apple.foundationdb.record.query.expressions.AndOrComponent;\n+import com.apple.foundationdb.record.query.expressions.FieldWithComparison;\n+import com.apple.foundationdb.record.query.expressions.QueryComponent;\n+import com.apple.foundationdb.record.query.expressions.QueryKeyExpressionWithComparison;\n+import com.apple.foundationdb.record.query.plan.PlannableIndexTypes;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFetchFromPartialRecordPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan;\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * A substitution visitor that pushes a filter below a record fetch if all of the (non-repeated) field are available\n+ * in a covering scan.\n+ */\n+public class FilterVisitor extends RecordQueryPlannerSubstitutionVisitor {\n+    public FilterVisitor(@Nonnull final RecordMetaData recordMetadata, @Nonnull final PlannableIndexTypes indexTypes, @Nullable final KeyExpression commonPrimaryKey) {\n+        super(recordMetadata, indexTypes, commonPrimaryKey);\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public RecordQueryPlan postVisit(@Nonnull final RecordQueryPlan recordQueryPlan) {\n+        if (recordQueryPlan instanceof RecordQueryFilterPlan) {\n+            final RecordQueryFilterPlan filterPlan = (RecordQueryFilterPlan)recordQueryPlan;\n+            final QueryComponent filter = filterPlan.getFilter();\n+            final Set<KeyExpression> filterFields = new HashSet<>();\n+            boolean canCollectFilterFields = findFilterCoveredFields(filter, filterFields);\n+\n+            if (canCollectFilterFields) {\n+                @Nullable RecordQueryPlan newPlan = removeIndexFetch(filterPlan.getChild(), filterFields);\n+                if (newPlan != null) {\n+                    return new RecordQueryFetchFromPartialRecordPlan(new RecordQueryFilterPlan(newPlan, filter));\n+                }\n+            }\n+        }\n+        return recordQueryPlan;\n+    }\n+\n+    // Find equivalent key expressions for fields used by the given filter.\n+    // Does not attempt to deal with OneOfThemWithComponent, as the repeated nested field will be spread across multiple\n+    // index entries. Reconstituting that as a singleton in a partial record might work for the simplest case, but\n+    // could not for multiple such filter conditions.\n+    private static boolean findFilterCoveredFields(@Nonnull QueryComponent filter, @Nonnull Set<KeyExpression> filterFields) {\n+        if (filter instanceof FieldWithComparison) {\n+            filterFields.add(Key.Expressions.field(((FieldWithComparison)filter).getFieldName()));\n+            return true;\n+        }\n+        if (filter instanceof AndOrComponent) {\n+            for (QueryComponent child : ((AndOrComponent)filter).getChildren()) {\n+                if (!findFilterCoveredFields(child, filterFields)) {", "originalCommit": "86be71c95c98e46b8dee430ba206d8e96d75d7f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMTkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r477501922", "bodyText": "It can't quite be a property visitor because the property visitors no longer visit QueryComponents (and probably never will, because the new planner uses QueryPredicate instead). It's the same concept, but I think we should leave anything like this for a future refactor.", "author": "nschiefer", "createdAt": "2020-08-26T18:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjQyMA=="}], "type": "inlineReview"}, {"oid": "02fec496f356304442fca35decd053cd06202c08", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/02fec496f356304442fca35decd053cd06202c08", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries.", "committedDate": "2020-08-26T18:39:49Z", "type": "forcePushed"}, {"oid": "ba532f63a0773e2f5b700d516700af053f7854cd", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ba532f63a0773e2f5b700d516700af053f7854cd", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries.", "committedDate": "2020-08-26T18:58:14Z", "type": "forcePushed"}, {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7657afbfacc42ab452078e203749342b8a1f6ff0", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries.", "committedDate": "2020-08-27T19:13:41Z", "type": "commit"}, {"oid": "7657afbfacc42ab452078e203749342b8a1f6ff0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7657afbfacc42ab452078e203749342b8a1f6ff0", "message": "Resolves #1016: Covering filters on legs of unions/intersections.\n\nIn #1001, we added an optimization that allows filters to be executed\non partial records produced by covering index scans. In #992, we also\nadded the ability to perform union/intersection/primary key distinct\noperations before fetching the base records by primary key.\n\nThis refactors the work from #1001 into a substitution visitor that can\nwork in concert with the union/intersection/distinct visitors. It also\ncorrects some (untriggered) bugs in the existing visitors.\n\nThis also fixes #1017; full text fields now require looking at the\nprimary records and are not \"satisfied\" by the tokens in the full text\nindex entries.", "committedDate": "2020-08-27T19:13:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5NzA1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1018#discussion_r478697054", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * A pair of a representing a tuple source (key or value) and an index within that tuple source.\n          \n          \n            \n                 * A pair of a tuple source (key or value) and an index within that tuple source.", "author": "MMcM", "createdAt": "2020-08-27T21:09:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/AvailableFields.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * AvailableFields.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan;\n+\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.record.RecordCoreException;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.RecordType;\n+import com.apple.foundationdb.record.metadata.expressions.FieldKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.NestingKeyExpression;\n+import com.apple.foundationdb.record.query.plan.planning.TextScanPlanner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Represents a subset of the fields available in a stream of records, including partial records.\n+ *\n+ * If a stream includes full records, all fields are available; they are not represented individually.\n+ * For partial records, this class tracks a (non-strict) subset of the fields that are actually available.\n+ * For example, all repeated fields are currently dropped. It is extremely important that no field ever be included\n+ * when it is not actually available on a partial record.\n+ */\n+public class AvailableFields {\n+    @Nonnull\n+    public static final AvailableFields ALL_FIELDS = new AvailableFields(null);\n+    @Nonnull\n+    public static final AvailableFields NO_FIELDS = new AvailableFields(Collections.emptyMap());\n+\n+    @Nullable\n+    private final Map<KeyExpression, FieldData> fields;\n+\n+    private AvailableFields(@Nullable Map<KeyExpression, FieldData> fields) {\n+        this.fields = fields;\n+    }\n+\n+\n+    public boolean hasAllFields() {\n+        return fields == null;\n+    }\n+\n+    public boolean containsAll(@Nonnull Collection<KeyExpression> requiredFields) {\n+        if (fields == null) {\n+            return true;\n+        }\n+        return fields.keySet().containsAll(requiredFields);\n+    }\n+\n+    @Nullable\n+    public IndexKeyValueToPartialRecord.Builder buildIndexKeyValueToPartialRecord(@Nonnull RecordType recordType) {\n+        if (fields == null) {\n+            return null;\n+        }\n+\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (Map.Entry<KeyExpression, FieldData> entry : fields.entrySet()) {\n+            if (!addCoveringField(entry.getKey(), entry.getValue(), builder)) {\n+                return null;\n+            }\n+        }\n+        if (!builder.isValid()) {\n+            return null;\n+        }\n+\n+        return builder;\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields fromIndex(@Nonnull RecordType recordType,\n+                                            @Nonnull Index index,\n+                                            @Nonnull PlannableIndexTypes indexTypes,\n+                                            @Nullable KeyExpression commonPrimaryKey) {\n+        final KeyExpression rootExpression = index.getRootExpression();\n+\n+        final List<KeyExpression> keyFields = new ArrayList<>();\n+        final List<KeyExpression> valueFields = new ArrayList<>();\n+        if (indexTypes.getTextTypes().contains(index.getType())) {\n+            // Full text index entries have all of their fields except the tokenized one.\n+            keyFields.addAll(TextScanPlanner.getOtherFields(rootExpression));\n+        } else if (indexTypes.getValueTypes().contains(index.getType()) ||\n+                   indexTypes.getRankTypes().contains(index.getType())) {\n+            keyFields.addAll(KeyExpression.getKeyFields(rootExpression));\n+            valueFields.addAll(KeyExpression.getValueFields(rootExpression));\n+        } else {\n+            // Aggregate index\n+            if (rootExpression instanceof GroupingKeyExpression) {\n+                GroupingKeyExpression groupingKeyExpression = (GroupingKeyExpression) rootExpression;\n+                keyFields.addAll(groupingKeyExpression.getGroupingSubKey().normalizeKeyForPositions());\n+            }\n+        }\n+\n+        // Like FDBRecordStoreBase.indexEntryKey(), but with key expressions instead of actual values.\n+        final List<KeyExpression> primaryKeys = commonPrimaryKey == null\n+                                                ? Collections.emptyList()\n+                                                : commonPrimaryKey.normalizeKeyForPositions();\n+        index.trimPrimaryKey(primaryKeys);\n+        keyFields.addAll(primaryKeys);\n+\n+        Map<KeyExpression, FieldData> fields = new HashMap<>();\n+        final IndexKeyValueToPartialRecord.Builder builder = IndexKeyValueToPartialRecord.newBuilder(recordType);\n+        for (int i = 0; i < keyFields.size(); i++) {\n+            KeyExpression keyField = keyFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.KEY, i);\n+            if (!keyField.createsDuplicates() && addCoveringField(keyField, fieldData, builder)) {\n+                fields.put(keyField, fieldData);\n+            }\n+        }\n+        for (int i = 0; i < valueFields.size(); i++) {\n+            KeyExpression valueField = valueFields.get(i);\n+            FieldData fieldData = FieldData.of(IndexKeyValueToPartialRecord.TupleSource.VALUE, i);\n+            if (!valueField.createsDuplicates() && addCoveringField(valueField, fieldData, builder)) {\n+                fields.put(valueField, fieldData);\n+            }\n+        }\n+\n+        if (!builder.isValid()) {\n+            return NO_FIELDS;\n+        }\n+        return new AvailableFields(fields);\n+    }\n+\n+    public static boolean addCoveringField(@Nonnull KeyExpression requiredExpr,\n+                                           @Nonnull FieldData fieldData,\n+                                           @Nonnull IndexKeyValueToPartialRecord.Builder builder) {\n+        while (requiredExpr instanceof NestingKeyExpression) {\n+            NestingKeyExpression nesting = (NestingKeyExpression)requiredExpr;\n+            String fieldName = nesting.getParent().getFieldName();\n+            requiredExpr = nesting.getChild();\n+            builder = builder.getFieldBuilder(fieldName);\n+        }\n+        if (requiredExpr instanceof FieldKeyExpression) {\n+            FieldKeyExpression fieldKeyExpression = (FieldKeyExpression)requiredExpr;\n+            if (!fieldKeyExpression.getNullStandin().equals(Key.Evaluated.NullStandin.NULL) ||\n+                    fieldKeyExpression.getFanType().equals(KeyExpression.FanType.FanOut)) {\n+                return false;\n+            }\n+            builder.addField(fieldKeyExpression.getFieldName(), fieldData.source, fieldData.index);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Nonnull\n+    public static AvailableFields intersection(@Nonnull List<AvailableFields> toIntersect) {\n+        if (toIntersect.isEmpty()) {\n+            throw new RecordCoreException(\"tried to find intersection of an empty list of available fields\");\n+        }\n+\n+        Map<KeyExpression, FieldData> intersection = null;\n+        for (AvailableFields fields : toIntersect) {\n+            if (!fields.hasAllFields()) {\n+                if (intersection == null) {\n+                    intersection = new HashMap<>(fields.fields);\n+                } else {\n+                    // keySet() is backed by the map itself\n+                    intersection.keySet().retainAll(fields.fields.keySet());\n+                }\n+            }\n+        }\n+        if (intersection == null) {\n+            return ALL_FIELDS;\n+        } else {\n+            return new AvailableFields(intersection);\n+        }\n+    }\n+\n+    /**\n+     * A pair of a representing a tuple source (key or value) and an index within that tuple source.", "originalCommit": "7657afbfacc42ab452078e203749342b8a1f6ff0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "33541e2711e0c33c61892b67e4335bd636c99ce4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/33541e2711e0c33c61892b67e4335bd636c99ce4", "message": "Respond to review comments.\n\nCo-authored-by: Mike McMahon <mmcm@comcast.net>", "committedDate": "2020-08-27T22:29:41Z", "type": "commit"}]}