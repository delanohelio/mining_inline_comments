{"pr_number": 822, "pr_title": "Resolves #816: Parse client latency log samples in a key space aware way", "pr_createdAt": "2020-02-14T02:46:38Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/822", "timeline": [{"oid": "d834edd8be34ee59eed00c608e5283684b218e99", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d834edd8be34ee59eed00c608e5283684b218e99", "message": "Add a key space aware counter.", "committedDate": "2020-02-14T16:25:41Z", "type": "forcePushed"}, {"oid": "abff27792051041429044620f13215e3129ff64f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/abff27792051041429044620f13215e3129ff64f", "message": "Add a key space aware counter.", "committedDate": "2020-02-14T16:42:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0ODczMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r379448732", "bodyText": "Should this go into com.apple.foundationdb.annotation instead?\nThis change also, unfortunately, means that the items importing this class no longer are correctly sorting this class when they import. Not sure if there is a way to re-optimize imports when the name is changed, or something.", "author": "alecgrieser", "createdAt": "2020-02-14T14:09:57Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/SpotBugsSuppressWarnings.java", "diffHunk": "@@ -18,7 +18,7 @@\n  * limitations under the License.\n  */\n \n-package com.apple.foundationdb.record;\n+package com.apple.foundationdb;", "originalCommit": "5e425b34be99b7d2133812d1528ba968073a58f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTM1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341351", "bodyText": "Moved. I didn't do anything special about the sorting, though.", "author": "MMcM", "createdAt": "2020-02-17T19:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0ODczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2NTU0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r379665548", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Get start timestamp formatted for the local zone.\n          \n          \n            \n                     * Get start timestamp formatted for the local time zone.\n          \n      \n    \n    \n  \n\nMaybe?", "author": "alecgrieser", "createdAt": "2020-02-14T22:03:26Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/FDBClientLogEvents.java", "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * FDBClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.google.common.primitives.Longs;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+@SpotBugsSuppressWarnings(\"EI_EXPOSE_REP2\")\n+public class FDBClientLogEvents {\n+    public static final int GET_VERSION_LATENCY = 0;\n+    public static final int GET_LATENCY = 1;\n+    public static final int GET_RANGE_LATENCY = 2;\n+    public static final int COMMIT_LATENCY = 3;\n+    public static final int ERROR_GET = 4;\n+    public static final int ERROR_GET_RANGE = 5;\n+    public static final int ERROR_COMMIT = 6;\n+\n+    public static final long PROTOCOL_VERSION_5_2 = 0x0FDB00A552000001L;\n+    public static final long PROTOCOL_VERSION_6_0 = 0x0FDB00A570010001L;\n+    public static final long PROTOCOL_VERSION_6_1 = 0x0FDB00B061060001L;\n+    public static final long PROTOCOL_VERSION_6_2 = 0x0FDB00B062010001L;\n+    private static final long[] SUPPORTED_PROTOCOL_VERSIONS = {\n+            PROTOCOL_VERSION_5_2, PROTOCOL_VERSION_6_0, PROTOCOL_VERSION_6_1, PROTOCOL_VERSION_6_2\n+    };\n+\n+    //                                              0         1         2         3         4         5         6         7\n+    //                                              0123456789012345678901234567890123456789012345678901234567890123456789012345...\n+    public static final String EVENT_KEY_PATTERN = \"FF/fdbClientInfo/client_latency/SSSSSSSSSS/RRRRRRRRRRRRRRRR/NNNNTTTT/XXXX/\";\n+    @SpotBugsSuppressWarnings(\"MS_PKGPROTECT\")\n+    public static final byte[] EVENT_KEY_PREFIX;\n+    public static final int EVENT_KEY_VERSION_START_INDEX = 32;\n+    public static final int EVENT_KEY_VERSION_END_INDEX = 42;\n+    public static final int EVENT_KEY_ID_START_INDEX = 43;\n+    public static final int EVENT_KEY_ID_END_INDEX = 59;\n+    public static final int EVENT_KEY_CHUNK_INDEX = 60;\n+\n+    static {\n+        EVENT_KEY_PREFIX = EVENT_KEY_PATTERN.substring(0, EVENT_KEY_VERSION_START_INDEX).getBytes(StandardCharsets.US_ASCII);\n+        EVENT_KEY_PREFIX[0] = (byte)0xFF;\n+        EVENT_KEY_PREFIX[1] = (byte)0x02;\n+    }\n+\n+    private static final Map<Integer, MutationType> MUTATION_TYPE_BY_CODE = buildMutationTypeMap();\n+\n+    private static Map<Integer, MutationType> buildMutationTypeMap() {\n+        final Map<Integer, MutationType> result = new HashMap<>();\n+        for (MutationType mutationType : MutationType.values()) {\n+            // NOTE: There are duplicates, but the deprecated ones always come first, so we overwrite.\n+            result.put(mutationType.code(), mutationType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Asynchronous callback.\n+     * @param <T> type of the callback argument\n+     */\n+    @FunctionalInterface\n+    public interface AsyncConsumer<T> {\n+        CompletableFuture<Void> accept(T t);\n+    }\n+\n+    /**\n+     * Base class for parsed events.\n+     */\n+    public abstract static class Event {\n+        protected final double startTimestamp;\n+\n+        protected Event(double startTimestamp) {\n+            this.startTimestamp = startTimestamp;\n+        }\n+\n+        public abstract int getType();\n+\n+        public double getStartTimestampDouoble() {\n+            return startTimestamp;\n+        }\n+\n+        public Instant getStartTimestamp() {\n+            final long seconds = (long)startTimestamp;\n+            final long nanos = (long)((startTimestamp - seconds) * 1.0e9);\n+            return Instant.ofEpochSecond(seconds, nanos);\n+        }\n+\n+        /**\n+         * Get start timestamp formatted for the local zone.", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MDUzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r379670535", "bodyText": "This branch should never be reached, right? It's just there in case there's, like, some bug which results in a missing chunk (or something)?\nShould it log or error if this gets hit?", "author": "alecgrieser", "createdAt": "2020-02-14T22:19:23Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/FDBClientLogEvents.java", "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * FDBClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.google.common.primitives.Longs;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+@SpotBugsSuppressWarnings(\"EI_EXPOSE_REP2\")\n+public class FDBClientLogEvents {\n+    public static final int GET_VERSION_LATENCY = 0;\n+    public static final int GET_LATENCY = 1;\n+    public static final int GET_RANGE_LATENCY = 2;\n+    public static final int COMMIT_LATENCY = 3;\n+    public static final int ERROR_GET = 4;\n+    public static final int ERROR_GET_RANGE = 5;\n+    public static final int ERROR_COMMIT = 6;\n+\n+    public static final long PROTOCOL_VERSION_5_2 = 0x0FDB00A552000001L;\n+    public static final long PROTOCOL_VERSION_6_0 = 0x0FDB00A570010001L;\n+    public static final long PROTOCOL_VERSION_6_1 = 0x0FDB00B061060001L;\n+    public static final long PROTOCOL_VERSION_6_2 = 0x0FDB00B062010001L;\n+    private static final long[] SUPPORTED_PROTOCOL_VERSIONS = {\n+            PROTOCOL_VERSION_5_2, PROTOCOL_VERSION_6_0, PROTOCOL_VERSION_6_1, PROTOCOL_VERSION_6_2\n+    };\n+\n+    //                                              0         1         2         3         4         5         6         7\n+    //                                              0123456789012345678901234567890123456789012345678901234567890123456789012345...\n+    public static final String EVENT_KEY_PATTERN = \"FF/fdbClientInfo/client_latency/SSSSSSSSSS/RRRRRRRRRRRRRRRR/NNNNTTTT/XXXX/\";\n+    @SpotBugsSuppressWarnings(\"MS_PKGPROTECT\")\n+    public static final byte[] EVENT_KEY_PREFIX;\n+    public static final int EVENT_KEY_VERSION_START_INDEX = 32;\n+    public static final int EVENT_KEY_VERSION_END_INDEX = 42;\n+    public static final int EVENT_KEY_ID_START_INDEX = 43;\n+    public static final int EVENT_KEY_ID_END_INDEX = 59;\n+    public static final int EVENT_KEY_CHUNK_INDEX = 60;\n+\n+    static {\n+        EVENT_KEY_PREFIX = EVENT_KEY_PATTERN.substring(0, EVENT_KEY_VERSION_START_INDEX).getBytes(StandardCharsets.US_ASCII);\n+        EVENT_KEY_PREFIX[0] = (byte)0xFF;\n+        EVENT_KEY_PREFIX[1] = (byte)0x02;\n+    }\n+\n+    private static final Map<Integer, MutationType> MUTATION_TYPE_BY_CODE = buildMutationTypeMap();\n+\n+    private static Map<Integer, MutationType> buildMutationTypeMap() {\n+        final Map<Integer, MutationType> result = new HashMap<>();\n+        for (MutationType mutationType : MutationType.values()) {\n+            // NOTE: There are duplicates, but the deprecated ones always come first, so we overwrite.\n+            result.put(mutationType.code(), mutationType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Asynchronous callback.\n+     * @param <T> type of the callback argument\n+     */\n+    @FunctionalInterface\n+    public interface AsyncConsumer<T> {\n+        CompletableFuture<Void> accept(T t);\n+    }\n+\n+    /**\n+     * Base class for parsed events.\n+     */\n+    public abstract static class Event {\n+        protected final double startTimestamp;\n+\n+        protected Event(double startTimestamp) {\n+            this.startTimestamp = startTimestamp;\n+        }\n+\n+        public abstract int getType();\n+\n+        public double getStartTimestampDouoble() {\n+            return startTimestamp;\n+        }\n+\n+        public Instant getStartTimestamp() {\n+            final long seconds = (long)startTimestamp;\n+            final long nanos = (long)((startTimestamp - seconds) * 1.0e9);\n+            return Instant.ofEpochSecond(seconds, nanos);\n+        }\n+\n+        /**\n+         * Get start timestamp formatted for the local zone.\n+         * @return a printable timestamp\n+         */\n+        public String getStartTimestampString() {\n+            Instant startTimestamp = getStartTimestamp();\n+            return startTimestamp.atOffset(ZoneId.systemDefault().getRules().getOffset(startTimestamp)).toString();\n+        }\n+    }\n+\n+    /**\n+     * Event callback.\n+     */\n+    public interface EventConsumer extends AsyncConsumer<Event> {\n+        /**\n+         * Determine whether to continue processing events.\n+         * @return {@code true} if more events should be processed\n+         */\n+        default boolean more() {\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * A GRV latency event.\n+     */\n+    public static class EventGetVersion extends Event {\n+        private final double latency;\n+        private final int priority;\n+\n+        public EventGetVersion(double startTimestamp, double latency, int priority) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.priority = priority;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_VERSION_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getPriority() {\n+            return priority;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"priority=\" + priority)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A single key get latency event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class EventGet extends Event {\n+        private final double latency;\n+        private final int size;\n+        @Nonnull\n+        private final byte[] key;\n+\n+        public EventGet(double startTimestamp, double latency, int size, @Nonnull byte[] key) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.size = size;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getSize() {\n+            return size;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"size=\" + size)\n+                    .add(\"key=\" + ByteArrayUtil.printable(key))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A range get latency event.\n+     */\n+    public static class EventGetRange extends Event {\n+        private final double latency;\n+        private final int size;\n+        @Nonnull\n+        private final Range range;\n+\n+        public EventGetRange(double startTimestamp, double latency, int size, @Nonnull Range range) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.size = size;\n+            this.range = range;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_RANGE_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getSize() {\n+            return size;\n+        }\n+\n+        @Nonnull\n+        public Range getRange() {\n+            return range;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"size=\" + size)\n+                    .add(\"range=\" + range)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A commit latency event.\n+     */\n+    public static class EventCommit extends Event {\n+        private final double latency;\n+        private final int numMutations;\n+        private final int commitBytes;\n+        @Nonnull\n+        private final CommitRequest commitRequest;\n+\n+        public EventCommit(double startTimestamp, double latency, int numMutations, int commitBytes,\n+                           @Nonnull CommitRequest commitRequest) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.numMutations = numMutations;\n+            this.commitBytes = commitBytes;\n+            this.commitRequest = commitRequest;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return COMMIT_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getNumMutations() {\n+            return numMutations;\n+        }\n+\n+        public int getCommitBytes() {\n+            return commitBytes;\n+        }\n+\n+        @Nonnull\n+        public CommitRequest getCommitRequest() {\n+            return commitRequest;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"numMutations=\" + numMutations)\n+                    .add(\"commitBytes=\" + commitBytes)\n+                    .add(\"commitRequest=\" + commitRequest)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing single key get event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class EventGetError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final byte[] key;\n+\n+        public EventGetError(double startTimestamp, int errorCode, @Nonnull byte[] key) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_GET;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"key=\" + Arrays.toString(key))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing range get event.\n+     */\n+    public static class EventGetRangeError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final Range range;\n+\n+        public EventGetRangeError(double startTimestamp, int errorCode, @Nonnull Range range) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.range = range;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_GET_RANGE;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public Range getRange() {\n+            return range;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"range=\" + range)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing commit event.\n+     */\n+    public static class EventCommitError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final CommitRequest commitRequest;\n+\n+        public EventCommitError(double startTimestamp, int errorCode, @Nonnull CommitRequest commitRequest) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.commitRequest = commitRequest;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_COMMIT;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public CommitRequest getCommitRequest() {\n+            return commitRequest;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"commitRequest=\" + commitRequest)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A single mutation in a {@link CommitRequest}.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class Mutation {\n+        // These are not in the binding's MutationType enum.\n+        public static final int SET_VALUE = 0;\n+        public static final int CLEAR_RANGE = 1;\n+\n+        private final int type;\n+        @Nonnull\n+        private final byte[] key;\n+        @Nonnull\n+        private final byte[] param;\n+\n+        public Mutation(int type, @Nonnull byte[] key, @Nonnull byte[] param) {\n+            this.type = type;\n+            this.key = key;\n+            this.param = param;\n+        }\n+\n+        public int getType() {\n+            return type;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Nonnull\n+        public byte[] getParam() {\n+            return param;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String typeName;\n+            if (type == SET_VALUE) {\n+                typeName = \"SET_VALUE\";\n+            } else if (type == CLEAR_RANGE) {\n+                typeName = \"CLEAR_RANGE\";\n+            } else if (MUTATION_TYPE_BY_CODE.containsKey(type)) {\n+                typeName = MUTATION_TYPE_BY_CODE.get(type).name();\n+            } else {\n+                typeName = Integer.toString(type);\n+            }\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"type=\" + typeName)\n+                    .add(\"key=\" + ByteArrayUtil.printable(key))\n+                    .add(\"param=\" + ByteArrayUtil.printable(param))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * Information about a commit, successful or not, in an event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class CommitRequest {\n+        @Nonnull\n+        private final Range[] readConflictRanges;\n+        @Nonnull\n+        private final Range[] writeConflictRanges;\n+        @Nonnull\n+        private final Mutation[] mutations;\n+        private final long snapshotVersion;\n+\n+        public CommitRequest(@Nonnull Range[] readConflictRanges, @Nonnull Range[] writeConflictRanges,\n+                             @Nonnull Mutation[] mutations, long snapshotVersion) {\n+            this.readConflictRanges = readConflictRanges;\n+            this.writeConflictRanges = writeConflictRanges;\n+            this.mutations = mutations;\n+            this.snapshotVersion = snapshotVersion;\n+        }\n+\n+        @Nonnull\n+        public Range[] getReadConflictRanges() {\n+            return readConflictRanges;\n+        }\n+\n+        @Nonnull\n+        public Range[] getWriteConflictRanges() {\n+            return writeConflictRanges;\n+        }\n+\n+        @Nonnull\n+        public Mutation[] getMutations() {\n+            return mutations;\n+        }\n+\n+        public long getSnapshotVersion() {\n+            return snapshotVersion;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", CommitRequest.class.getSimpleName() + \"[\", \"]\")\n+                    .add(\"readConflictRanges=\" + Arrays.toString(readConflictRanges))\n+                    .add(\"writeConflictRanges=\" + Arrays.toString(writeConflictRanges))\n+                    .add(\"mutations=\" + Arrays.toString(mutations))\n+                    .add(\"snapshotVersion=\" + snapshotVersion)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * Apply a callback to parsed events.\n+     * @param buffer the transaction's client trace entry\n+     * @param callback an asynchronous function to apply to each entry\n+     * @return a future that completes when all items have been processed\n+     */\n+    public static CompletableFuture<Void> deserializeEvents(@Nonnull ByteBuffer buffer, @Nonnull AsyncConsumer<Event> callback) {\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        final long protocolVersion = buffer.getLong();\n+        if (Longs.indexOf(SUPPORTED_PROTOCOL_VERSIONS, protocolVersion) < 0) {\n+            throw new IllegalStateException(\"Unknown protocol version: 0x\" + Long.toString(protocolVersion, 16));\n+        }\n+        return AsyncUtil.whileTrue(() -> {\n+            final int type = buffer.getInt();\n+            final Event event;\n+            switch (type) {\n+                case GET_VERSION_LATENCY:\n+                    event = new EventGetVersion(buffer.getDouble(), buffer.getDouble(),\n+                            protocolVersion < PROTOCOL_VERSION_6_2 ? 0 : buffer.getInt());\n+                    break;\n+                case GET_LATENCY:\n+                    event = new EventGet(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), deserializeByteArray(buffer));\n+                    break;\n+                case GET_RANGE_LATENCY:\n+                    event = new EventGetRange(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), deserializeRange(buffer));\n+                    break;\n+                case COMMIT_LATENCY:\n+                    event = new EventCommit(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), buffer.getInt(), deserializeCommit(buffer));\n+                    break;\n+                case ERROR_GET:\n+                    event = new EventGetError(buffer.getDouble(), buffer.getInt(), deserializeByteArray(buffer));\n+                    break;\n+                case ERROR_GET_RANGE:\n+                    event = new EventGetRangeError(buffer.getDouble(), buffer.getInt(), deserializeRange(buffer));\n+                    break;\n+                case ERROR_COMMIT:\n+                    event = new EventCommitError(buffer.getDouble(), buffer.getInt(), deserializeCommit(buffer));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown event type: \" + type);\n+            }\n+            return callback.accept(event).thenApply(vignore -> buffer.hasRemaining());\n+        });\n+    }\n+\n+    @Nonnull\n+    protected static byte[] deserializeByteArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final byte[] result = new byte[length];\n+        buffer.get(result);\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static Range deserializeRange(@Nonnull ByteBuffer buffer) {\n+        return new Range(deserializeByteArray(buffer), deserializeByteArray(buffer));\n+    }\n+\n+    @Nonnull\n+    protected static Range[] deserializeRangeArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final Range[] result = new Range[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = deserializeRange(buffer);\n+        }\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static Mutation deserializeMutation(@Nonnull ByteBuffer buffer) {\n+        return new Mutation(buffer.get(), deserializeByteArray(buffer), deserializeByteArray(buffer));\n+    }\n+\n+    @Nonnull\n+    protected static Mutation[] deserializeMutationArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final Mutation[] result = new Mutation[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = deserializeMutation(buffer);\n+        }\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static CommitRequest deserializeCommit(@Nonnull ByteBuffer buffer) {\n+        return new CommitRequest(deserializeRangeArray(buffer), deserializeRangeArray(buffer),\n+                deserializeMutationArray(buffer), buffer.getLong());\n+    }\n+\n+    protected static class EventDeserializer implements AsyncConsumer<KeyValue> {\n+        @Nonnull\n+        private final AsyncConsumer<Event> callback;\n+        @Nullable\n+        private ByteBuffer splitBuffer;\n+        private byte[] splitId;\n+        private int splitPosition;\n+        private byte[] lastProcessedKey;\n+\n+        public EventDeserializer(@Nonnull AsyncConsumer<Event> callback) {\n+            this.callback = callback;\n+        }\n+\n+        /**\n+         * Process next key-value pair by calling callback or appending to pending buffer.\n+         * @param keyValue a key-value pair with client trace events\n+         * @return a future which completes when the key-value pair has been processed\n+         */\n+        @Override\n+        public CompletableFuture<Void> accept(KeyValue keyValue) {\n+            final byte[] transactionId = Arrays.copyOfRange(keyValue.getKey(), EVENT_KEY_ID_START_INDEX, EVENT_KEY_ID_END_INDEX);\n+            final ByteBuffer keyBuffer = ByteBuffer.wrap(keyValue.getKey());\n+            keyBuffer.position(EVENT_KEY_CHUNK_INDEX);\n+            final int chunkNumber = keyBuffer.getInt();\n+            final int numChunks = keyBuffer.getInt();\n+            if (numChunks == 1) {\n+                splitBuffer = null;\n+                lastProcessedKey = keyValue.getKey();\n+                return deserializeEvents(ByteBuffer.wrap(keyValue.getValue()), callback);\n+            } else {\n+                if (chunkNumber == 1) {\n+                    splitBuffer = ByteBuffer.allocate(numChunks * keyValue.getValue().length);\n+                    splitId = transactionId;\n+                    splitPosition = 1;\n+                } else if (chunkNumber == splitPosition && Arrays.equals(transactionId, splitId)) {\n+                    if (splitBuffer.remaining() < keyValue.getValue().length) {\n+                        final ByteBuffer newBuffer = ByteBuffer.allocate(splitBuffer.remaining() + keyValue.getValue().length);\n+                        splitBuffer.flip();\n+                        newBuffer.put(splitBuffer);\n+                        splitBuffer = newBuffer;\n+                    }\n+                    splitBuffer.put(keyValue.getValue());\n+                    splitPosition++;\n+                    if (splitPosition == numChunks) {\n+                        splitBuffer.flip();\n+                        ByteBuffer buffer = splitBuffer;\n+                        splitBuffer = null;\n+                        lastProcessedKey = keyValue.getKey();\n+                        return deserializeEvents(buffer, callback);\n+                    }\n+                } else {\n+                    splitBuffer = null;\n+                    splitPosition = -1;\n+                    lastProcessedKey = keyValue.getKey();", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMTU1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380301550", "bodyText": "I understood that there were real cases where chunks went missing.", "author": "MMcM", "createdAt": "2020-02-17T17:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MDUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTQ1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380321454", "bodyText": "Oof. Well, good to know.", "author": "alecgrieser", "createdAt": "2020-02-17T18:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MDUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjM3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r379672376", "bodyText": "Should this be splitBuffer.capacity() instead of .remaining? If I'm understanding this correctly, this is supposed to handle the case where a single value would otherwise extend over the end of the current buffer, so it allocates a larger buffer and copies over the existing data to the new buffer (so that it can then put the final value at the end of the new buffer). I don't think the buffer would be large enough, though (necessarily) if it's .remaining.", "author": "alecgrieser", "createdAt": "2020-02-14T22:25:11Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/FDBClientLogEvents.java", "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * FDBClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.google.common.primitives.Longs;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+@SpotBugsSuppressWarnings(\"EI_EXPOSE_REP2\")\n+public class FDBClientLogEvents {\n+    public static final int GET_VERSION_LATENCY = 0;\n+    public static final int GET_LATENCY = 1;\n+    public static final int GET_RANGE_LATENCY = 2;\n+    public static final int COMMIT_LATENCY = 3;\n+    public static final int ERROR_GET = 4;\n+    public static final int ERROR_GET_RANGE = 5;\n+    public static final int ERROR_COMMIT = 6;\n+\n+    public static final long PROTOCOL_VERSION_5_2 = 0x0FDB00A552000001L;\n+    public static final long PROTOCOL_VERSION_6_0 = 0x0FDB00A570010001L;\n+    public static final long PROTOCOL_VERSION_6_1 = 0x0FDB00B061060001L;\n+    public static final long PROTOCOL_VERSION_6_2 = 0x0FDB00B062010001L;\n+    private static final long[] SUPPORTED_PROTOCOL_VERSIONS = {\n+            PROTOCOL_VERSION_5_2, PROTOCOL_VERSION_6_0, PROTOCOL_VERSION_6_1, PROTOCOL_VERSION_6_2\n+    };\n+\n+    //                                              0         1         2         3         4         5         6         7\n+    //                                              0123456789012345678901234567890123456789012345678901234567890123456789012345...\n+    public static final String EVENT_KEY_PATTERN = \"FF/fdbClientInfo/client_latency/SSSSSSSSSS/RRRRRRRRRRRRRRRR/NNNNTTTT/XXXX/\";\n+    @SpotBugsSuppressWarnings(\"MS_PKGPROTECT\")\n+    public static final byte[] EVENT_KEY_PREFIX;\n+    public static final int EVENT_KEY_VERSION_START_INDEX = 32;\n+    public static final int EVENT_KEY_VERSION_END_INDEX = 42;\n+    public static final int EVENT_KEY_ID_START_INDEX = 43;\n+    public static final int EVENT_KEY_ID_END_INDEX = 59;\n+    public static final int EVENT_KEY_CHUNK_INDEX = 60;\n+\n+    static {\n+        EVENT_KEY_PREFIX = EVENT_KEY_PATTERN.substring(0, EVENT_KEY_VERSION_START_INDEX).getBytes(StandardCharsets.US_ASCII);\n+        EVENT_KEY_PREFIX[0] = (byte)0xFF;\n+        EVENT_KEY_PREFIX[1] = (byte)0x02;\n+    }\n+\n+    private static final Map<Integer, MutationType> MUTATION_TYPE_BY_CODE = buildMutationTypeMap();\n+\n+    private static Map<Integer, MutationType> buildMutationTypeMap() {\n+        final Map<Integer, MutationType> result = new HashMap<>();\n+        for (MutationType mutationType : MutationType.values()) {\n+            // NOTE: There are duplicates, but the deprecated ones always come first, so we overwrite.\n+            result.put(mutationType.code(), mutationType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Asynchronous callback.\n+     * @param <T> type of the callback argument\n+     */\n+    @FunctionalInterface\n+    public interface AsyncConsumer<T> {\n+        CompletableFuture<Void> accept(T t);\n+    }\n+\n+    /**\n+     * Base class for parsed events.\n+     */\n+    public abstract static class Event {\n+        protected final double startTimestamp;\n+\n+        protected Event(double startTimestamp) {\n+            this.startTimestamp = startTimestamp;\n+        }\n+\n+        public abstract int getType();\n+\n+        public double getStartTimestampDouoble() {\n+            return startTimestamp;\n+        }\n+\n+        public Instant getStartTimestamp() {\n+            final long seconds = (long)startTimestamp;\n+            final long nanos = (long)((startTimestamp - seconds) * 1.0e9);\n+            return Instant.ofEpochSecond(seconds, nanos);\n+        }\n+\n+        /**\n+         * Get start timestamp formatted for the local zone.\n+         * @return a printable timestamp\n+         */\n+        public String getStartTimestampString() {\n+            Instant startTimestamp = getStartTimestamp();\n+            return startTimestamp.atOffset(ZoneId.systemDefault().getRules().getOffset(startTimestamp)).toString();\n+        }\n+    }\n+\n+    /**\n+     * Event callback.\n+     */\n+    public interface EventConsumer extends AsyncConsumer<Event> {\n+        /**\n+         * Determine whether to continue processing events.\n+         * @return {@code true} if more events should be processed\n+         */\n+        default boolean more() {\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * A GRV latency event.\n+     */\n+    public static class EventGetVersion extends Event {\n+        private final double latency;\n+        private final int priority;\n+\n+        public EventGetVersion(double startTimestamp, double latency, int priority) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.priority = priority;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_VERSION_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getPriority() {\n+            return priority;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"priority=\" + priority)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A single key get latency event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class EventGet extends Event {\n+        private final double latency;\n+        private final int size;\n+        @Nonnull\n+        private final byte[] key;\n+\n+        public EventGet(double startTimestamp, double latency, int size, @Nonnull byte[] key) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.size = size;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getSize() {\n+            return size;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"size=\" + size)\n+                    .add(\"key=\" + ByteArrayUtil.printable(key))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A range get latency event.\n+     */\n+    public static class EventGetRange extends Event {\n+        private final double latency;\n+        private final int size;\n+        @Nonnull\n+        private final Range range;\n+\n+        public EventGetRange(double startTimestamp, double latency, int size, @Nonnull Range range) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.size = size;\n+            this.range = range;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return GET_RANGE_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getSize() {\n+            return size;\n+        }\n+\n+        @Nonnull\n+        public Range getRange() {\n+            return range;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"size=\" + size)\n+                    .add(\"range=\" + range)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A commit latency event.\n+     */\n+    public static class EventCommit extends Event {\n+        private final double latency;\n+        private final int numMutations;\n+        private final int commitBytes;\n+        @Nonnull\n+        private final CommitRequest commitRequest;\n+\n+        public EventCommit(double startTimestamp, double latency, int numMutations, int commitBytes,\n+                           @Nonnull CommitRequest commitRequest) {\n+            super(startTimestamp);\n+            this.latency = latency;\n+            this.numMutations = numMutations;\n+            this.commitBytes = commitBytes;\n+            this.commitRequest = commitRequest;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return COMMIT_LATENCY;\n+        }\n+\n+        public double getLatency() {\n+            return latency;\n+        }\n+\n+        public int getNumMutations() {\n+            return numMutations;\n+        }\n+\n+        public int getCommitBytes() {\n+            return commitBytes;\n+        }\n+\n+        @Nonnull\n+        public CommitRequest getCommitRequest() {\n+            return commitRequest;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"latency=\" + latency)\n+                    .add(\"numMutations=\" + numMutations)\n+                    .add(\"commitBytes=\" + commitBytes)\n+                    .add(\"commitRequest=\" + commitRequest)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing single key get event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class EventGetError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final byte[] key;\n+\n+        public EventGetError(double startTimestamp, int errorCode, @Nonnull byte[] key) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_GET;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"key=\" + Arrays.toString(key))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing range get event.\n+     */\n+    public static class EventGetRangeError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final Range range;\n+\n+        public EventGetRangeError(double startTimestamp, int errorCode, @Nonnull Range range) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.range = range;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_GET_RANGE;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public Range getRange() {\n+            return range;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"range=\" + range)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A failing commit event.\n+     */\n+    public static class EventCommitError extends Event {\n+        private final int errorCode;\n+        @Nonnull\n+        private final CommitRequest commitRequest;\n+\n+        public EventCommitError(double startTimestamp, int errorCode, @Nonnull CommitRequest commitRequest) {\n+            super(startTimestamp);\n+            this.errorCode = errorCode;\n+            this.commitRequest = commitRequest;\n+        }\n+\n+        @Override\n+        public int getType() {\n+            return ERROR_COMMIT;\n+        }\n+\n+        public int getErrorCode() {\n+            return errorCode;\n+        }\n+\n+        @Nonnull\n+        public CommitRequest getCommitRequest() {\n+            return commitRequest;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"startTimestamp=\" + getStartTimestampString())\n+                    .add(\"errorCode=\" + errorCode)\n+                    .add(\"commitRequest=\" + commitRequest)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * A single mutation in a {@link CommitRequest}.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class Mutation {\n+        // These are not in the binding's MutationType enum.\n+        public static final int SET_VALUE = 0;\n+        public static final int CLEAR_RANGE = 1;\n+\n+        private final int type;\n+        @Nonnull\n+        private final byte[] key;\n+        @Nonnull\n+        private final byte[] param;\n+\n+        public Mutation(int type, @Nonnull byte[] key, @Nonnull byte[] param) {\n+            this.type = type;\n+            this.key = key;\n+            this.param = param;\n+        }\n+\n+        public int getType() {\n+            return type;\n+        }\n+\n+        @Nonnull\n+        public byte[] getKey() {\n+            return key;\n+        }\n+\n+        @Nonnull\n+        public byte[] getParam() {\n+            return param;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String typeName;\n+            if (type == SET_VALUE) {\n+                typeName = \"SET_VALUE\";\n+            } else if (type == CLEAR_RANGE) {\n+                typeName = \"CLEAR_RANGE\";\n+            } else if (MUTATION_TYPE_BY_CODE.containsKey(type)) {\n+                typeName = MUTATION_TYPE_BY_CODE.get(type).name();\n+            } else {\n+                typeName = Integer.toString(type);\n+            }\n+            return new StringJoiner(\", \", getClass().getSimpleName() + \"[\", \"]\")\n+                    .add(\"type=\" + typeName)\n+                    .add(\"key=\" + ByteArrayUtil.printable(key))\n+                    .add(\"param=\" + ByteArrayUtil.printable(param))\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * Information about a commit, successful or not, in an event.\n+     */\n+    @SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+    public static class CommitRequest {\n+        @Nonnull\n+        private final Range[] readConflictRanges;\n+        @Nonnull\n+        private final Range[] writeConflictRanges;\n+        @Nonnull\n+        private final Mutation[] mutations;\n+        private final long snapshotVersion;\n+\n+        public CommitRequest(@Nonnull Range[] readConflictRanges, @Nonnull Range[] writeConflictRanges,\n+                             @Nonnull Mutation[] mutations, long snapshotVersion) {\n+            this.readConflictRanges = readConflictRanges;\n+            this.writeConflictRanges = writeConflictRanges;\n+            this.mutations = mutations;\n+            this.snapshotVersion = snapshotVersion;\n+        }\n+\n+        @Nonnull\n+        public Range[] getReadConflictRanges() {\n+            return readConflictRanges;\n+        }\n+\n+        @Nonnull\n+        public Range[] getWriteConflictRanges() {\n+            return writeConflictRanges;\n+        }\n+\n+        @Nonnull\n+        public Mutation[] getMutations() {\n+            return mutations;\n+        }\n+\n+        public long getSnapshotVersion() {\n+            return snapshotVersion;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringJoiner(\", \", CommitRequest.class.getSimpleName() + \"[\", \"]\")\n+                    .add(\"readConflictRanges=\" + Arrays.toString(readConflictRanges))\n+                    .add(\"writeConflictRanges=\" + Arrays.toString(writeConflictRanges))\n+                    .add(\"mutations=\" + Arrays.toString(mutations))\n+                    .add(\"snapshotVersion=\" + snapshotVersion)\n+                    .toString();\n+        }\n+    }\n+\n+    /**\n+     * Apply a callback to parsed events.\n+     * @param buffer the transaction's client trace entry\n+     * @param callback an asynchronous function to apply to each entry\n+     * @return a future that completes when all items have been processed\n+     */\n+    public static CompletableFuture<Void> deserializeEvents(@Nonnull ByteBuffer buffer, @Nonnull AsyncConsumer<Event> callback) {\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        final long protocolVersion = buffer.getLong();\n+        if (Longs.indexOf(SUPPORTED_PROTOCOL_VERSIONS, protocolVersion) < 0) {\n+            throw new IllegalStateException(\"Unknown protocol version: 0x\" + Long.toString(protocolVersion, 16));\n+        }\n+        return AsyncUtil.whileTrue(() -> {\n+            final int type = buffer.getInt();\n+            final Event event;\n+            switch (type) {\n+                case GET_VERSION_LATENCY:\n+                    event = new EventGetVersion(buffer.getDouble(), buffer.getDouble(),\n+                            protocolVersion < PROTOCOL_VERSION_6_2 ? 0 : buffer.getInt());\n+                    break;\n+                case GET_LATENCY:\n+                    event = new EventGet(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), deserializeByteArray(buffer));\n+                    break;\n+                case GET_RANGE_LATENCY:\n+                    event = new EventGetRange(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), deserializeRange(buffer));\n+                    break;\n+                case COMMIT_LATENCY:\n+                    event = new EventCommit(buffer.getDouble(), buffer.getDouble(), buffer.getInt(), buffer.getInt(), deserializeCommit(buffer));\n+                    break;\n+                case ERROR_GET:\n+                    event = new EventGetError(buffer.getDouble(), buffer.getInt(), deserializeByteArray(buffer));\n+                    break;\n+                case ERROR_GET_RANGE:\n+                    event = new EventGetRangeError(buffer.getDouble(), buffer.getInt(), deserializeRange(buffer));\n+                    break;\n+                case ERROR_COMMIT:\n+                    event = new EventCommitError(buffer.getDouble(), buffer.getInt(), deserializeCommit(buffer));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown event type: \" + type);\n+            }\n+            return callback.accept(event).thenApply(vignore -> buffer.hasRemaining());\n+        });\n+    }\n+\n+    @Nonnull\n+    protected static byte[] deserializeByteArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final byte[] result = new byte[length];\n+        buffer.get(result);\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static Range deserializeRange(@Nonnull ByteBuffer buffer) {\n+        return new Range(deserializeByteArray(buffer), deserializeByteArray(buffer));\n+    }\n+\n+    @Nonnull\n+    protected static Range[] deserializeRangeArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final Range[] result = new Range[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = deserializeRange(buffer);\n+        }\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static Mutation deserializeMutation(@Nonnull ByteBuffer buffer) {\n+        return new Mutation(buffer.get(), deserializeByteArray(buffer), deserializeByteArray(buffer));\n+    }\n+\n+    @Nonnull\n+    protected static Mutation[] deserializeMutationArray(@Nonnull ByteBuffer buffer) {\n+        final int length = buffer.getInt();\n+        final Mutation[] result = new Mutation[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = deserializeMutation(buffer);\n+        }\n+        return result;\n+    }\n+\n+    @Nonnull\n+    protected static CommitRequest deserializeCommit(@Nonnull ByteBuffer buffer) {\n+        return new CommitRequest(deserializeRangeArray(buffer), deserializeRangeArray(buffer),\n+                deserializeMutationArray(buffer), buffer.getLong());\n+    }\n+\n+    protected static class EventDeserializer implements AsyncConsumer<KeyValue> {\n+        @Nonnull\n+        private final AsyncConsumer<Event> callback;\n+        @Nullable\n+        private ByteBuffer splitBuffer;\n+        private byte[] splitId;\n+        private int splitPosition;\n+        private byte[] lastProcessedKey;\n+\n+        public EventDeserializer(@Nonnull AsyncConsumer<Event> callback) {\n+            this.callback = callback;\n+        }\n+\n+        /**\n+         * Process next key-value pair by calling callback or appending to pending buffer.\n+         * @param keyValue a key-value pair with client trace events\n+         * @return a future which completes when the key-value pair has been processed\n+         */\n+        @Override\n+        public CompletableFuture<Void> accept(KeyValue keyValue) {\n+            final byte[] transactionId = Arrays.copyOfRange(keyValue.getKey(), EVENT_KEY_ID_START_INDEX, EVENT_KEY_ID_END_INDEX);\n+            final ByteBuffer keyBuffer = ByteBuffer.wrap(keyValue.getKey());\n+            keyBuffer.position(EVENT_KEY_CHUNK_INDEX);\n+            final int chunkNumber = keyBuffer.getInt();\n+            final int numChunks = keyBuffer.getInt();\n+            if (numChunks == 1) {\n+                splitBuffer = null;\n+                lastProcessedKey = keyValue.getKey();\n+                return deserializeEvents(ByteBuffer.wrap(keyValue.getValue()), callback);\n+            } else {\n+                if (chunkNumber == 1) {\n+                    splitBuffer = ByteBuffer.allocate(numChunks * keyValue.getValue().length);\n+                    splitId = transactionId;\n+                    splitPosition = 1;\n+                } else if (chunkNumber == splitPosition && Arrays.equals(transactionId, splitId)) {\n+                    if (splitBuffer.remaining() < keyValue.getValue().length) {\n+                        final ByteBuffer newBuffer = ByteBuffer.allocate(splitBuffer.remaining() + keyValue.getValue().length);", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzAyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380303023", "bodyText": "Isn't limit the same as capacity, in which case remaining is the amount left that is writable? Just checking capacity would require subtracting position ourselves.", "author": "MMcM", "createdAt": "2020-02-17T17:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMjkzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380322935", "bodyText": "I think .remaining() is right for the if condition, but when allocating newBuffer, I don't see how splitBuffer.remaining() + keyValue.getValue().length is guaranteed to be big enough to hold both all of the contents of the old buffer and the new key value.", "author": "alecgrieser", "createdAt": "2020-02-17T18:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTUzNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341537", "bodyText": "Oh, sorry, I misunderstood. Yes, it should be position + new length, I think.", "author": "MMcM", "createdAt": "2020-02-17T19:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3MjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NDA1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380264051", "bodyText": "If I'm reasoning about the endpoints here correctly, then I believe that if there is a timekeeper entry that exactly matches the Instant provided, then this will include that data point (so the methods here are really lastVersionBeforeOrAr and nextVersionAfterOrAt or something). Which, is probably fine for the use case, but it feels like it should be documented.", "author": "alecgrieser", "createdAt": "2020-02-17T16:03:51Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/VersionFromTimestamp.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * VersionstampFromDate.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Map from wall-clock time to transaction time.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+@SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+public class VersionFromTimestamp {\n+\n+    public static final String TIME_KEEPER_KEY_PATTERN = \"FF/timeKeeper/map/\";\n+    @SpotBugsSuppressWarnings(\"MS_PKGPROTECT\")\n+    public static final byte[] TIME_KEEPER_KEY_PREFIX;\n+\n+    static {\n+        TIME_KEEPER_KEY_PREFIX = TIME_KEEPER_KEY_PATTERN.getBytes(StandardCharsets.US_ASCII);\n+        TIME_KEEPER_KEY_PREFIX[0] = (byte)0xFF;\n+        TIME_KEEPER_KEY_PREFIX[1] = (byte)0x02;\n+    }\n+\n+    /**\n+     * Get the last version from the timekeeper before the given timestamp.\n+     * @param tr an open transaction\n+     * @param timestamp the wall-clock time\n+     * @return a future that completes with the recorded version that comes immediately before the target time\n+     */\n+    @Nonnull\n+    public static CompletableFuture<Long> lastVersionBefore(@Nonnull ReadTransaction tr, @Nonnull Instant timestamp) {\n+        return versionFromTimestamp(tr, timestamp, true);\n+    }\n+\n+    /**\n+     * Get the last version from the timekeeper after the given timestamp.\n+     * @param tr an open transaction\n+     * @param timestamp the wall-clock time\n+     * @return a future that completes with the recorded version that comes immediately after the target time\n+     */\n+    @Nonnull\n+    public static CompletableFuture<Long> nextVersionAfter(@Nonnull ReadTransaction tr, @Nonnull Instant timestamp) {\n+        return versionFromTimestamp(tr, timestamp, false);\n+    }\n+\n+    private static CompletableFuture<Long> versionFromTimestamp(@Nonnull ReadTransaction tr, @Nonnull Instant timestamp, boolean start) {\n+        final byte[] dateKey = ByteArrayUtil.join(TIME_KEEPER_KEY_PREFIX, Tuple.from(timestamp.getEpochSecond()).pack());\n+        final KeySelector startKey;\n+        final KeySelector endKey;\n+        if (start) {\n+            startKey = KeySelector.firstGreaterThan(TIME_KEEPER_KEY_PREFIX);\n+            endKey = KeySelector.firstGreaterThan(dateKey);\n+        } else {\n+            startKey = KeySelector.firstGreaterOrEqual(dateKey);\n+            endKey = KeySelector.firstGreaterOrEqual(ByteArrayUtil.strinc(TIME_KEEPER_KEY_PREFIX));\n+        }", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTcxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341717", "bodyText": "I fixed the java doc. I didn't think the longer method names were needed, but I could change them if it seems confusing.", "author": "MMcM", "createdAt": "2020-02-17T19:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NDA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcwNjA1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380706059", "bodyText": "Yeah, I think just updating the java doc is sufficient, and that the longer names don't really help.", "author": "alecgrieser", "createdAt": "2020-02-18T14:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NDA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODU3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380268578", "bodyText": "It seems like this class could be moved to the fdb-extensions sub-project without any changes.", "author": "alecgrieser", "createdAt": "2020-02-17T16:12:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/TupleKeyCountTree.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * TupleEventCountTree.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+\n+/**\n+ * A tree of occurrence counts tuple-encoded keys.\n+ */\n+@SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+public class TupleKeyCountTree {", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzMzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380303338", "bodyText": "With the reasoning that non record layer clients might also encode keys as tuples?", "author": "MMcM", "createdAt": "2020-02-17T17:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMTIxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380321219", "bodyText": "Right, yeah. I think that's a reasonable-enough use case", "author": "alecgrieser", "createdAt": "2020-02-17T18:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTc4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341785", "bodyText": "Done.", "author": "MMcM", "createdAt": "2020-02-17T19:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MDA2MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380270060", "bodyText": "I'm somewhat torn on this, given that null is a valid object in a Tuple, so I could see some users being confused by the fact that getObject() returns null in either circumstance. It might at least be worth documenting that. I suppose the alternative would be to throw an error on UNPARSEABLE so that users are required to check hasObject (or something?).", "author": "alecgrieser", "createdAt": "2020-02-17T16:15:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/TupleKeyCountTree.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * TupleEventCountTree.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+\n+/**\n+ * A tree of occurrence counts tuple-encoded keys.\n+ */\n+@SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+public class TupleKeyCountTree {\n+    @Nonnull\n+    private final byte[] bytes;\n+    @Nullable\n+    private final Object object;\n+\n+    private int count;\n+    @Nullable\n+    private final TupleKeyCountTree parent;\n+    @Nonnull\n+    private final Map<byte[], TupleKeyCountTree> children;\n+\n+    private boolean visible = true;\n+\n+    // Internal standin object for entries that don't actually have an object, just bytes that don't parse as a tuple.\n+    private static final Object UNPARSEABLE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"*unparseable*\";\n+        }\n+    };\n+    private static final Comparator<byte[]> BYTES_COMPARATOR = ByteArrayUtil::compareUnsigned;\n+\n+    public TupleKeyCountTree() {\n+        this(null, new byte[0], null);\n+    }\n+\n+    public TupleKeyCountTree(@Nullable TupleKeyCountTree parent, @Nonnull byte[] bytes, @Nullable Object object) {\n+        this.bytes = bytes;\n+        this.object = object;\n+\n+        this.count = 0;\n+        this.parent = parent;\n+        this.children = new TreeMap<>(BYTES_COMPARATOR);\n+    }\n+    \n+    @Nonnull\n+    public byte[] getBytes() {\n+        return bytes;\n+    }\n+\n+    @SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\n+    public boolean hasObject() {\n+        return object != UNPARSEABLE;\n+    }\n+\n+    @Nullable\n+    @SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\n+    public Object getObject() {\n+        return object == UNPARSEABLE ? null : object;", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTg5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341892", "bodyText": "I made it an error, since that is simpler.", "author": "MMcM", "createdAt": "2020-02-17T19:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MTY3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380271670", "bodyText": "Why protected?", "author": "alecgrieser", "createdAt": "2020-02-17T16:19:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/TupleKeyCountTree.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * TupleEventCountTree.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.SpotBugsSuppressWarnings;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import com.apple.foundationdb.tuple.Tuple;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+\n+/**\n+ * A tree of occurrence counts tuple-encoded keys.\n+ */\n+@SpotBugsSuppressWarnings({\"EI_EXPOSE_REP\", \"EI_EXPOSE_REP2\"})\n+public class TupleKeyCountTree {\n+    @Nonnull\n+    private final byte[] bytes;\n+    @Nullable\n+    private final Object object;\n+\n+    private int count;\n+    @Nullable\n+    private final TupleKeyCountTree parent;\n+    @Nonnull\n+    private final Map<byte[], TupleKeyCountTree> children;\n+\n+    private boolean visible = true;\n+\n+    // Internal standin object for entries that don't actually have an object, just bytes that don't parse as a tuple.\n+    private static final Object UNPARSEABLE = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"*unparseable*\";\n+        }\n+    };\n+    private static final Comparator<byte[]> BYTES_COMPARATOR = ByteArrayUtil::compareUnsigned;\n+\n+    public TupleKeyCountTree() {\n+        this(null, new byte[0], null);\n+    }\n+\n+    public TupleKeyCountTree(@Nullable TupleKeyCountTree parent, @Nonnull byte[] bytes, @Nullable Object object) {\n+        this.bytes = bytes;\n+        this.object = object;\n+\n+        this.count = 0;\n+        this.parent = parent;\n+        this.children = new TreeMap<>(BYTES_COMPARATOR);\n+    }\n+    \n+    @Nonnull\n+    public byte[] getBytes() {\n+        return bytes;\n+    }\n+\n+    @SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\n+    public boolean hasObject() {\n+        return object != UNPARSEABLE;\n+    }\n+\n+    @Nullable\n+    @SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\n+    public Object getObject() {\n+        return object == UNPARSEABLE ? null : object;\n+    }\n+\n+    /**\n+     * Add the given tuple to the tree.\n+     *\n+     * Each element is added to the next deeper level in the tree, incrementing the count as it goes.\n+     * @param tuple the tuple to add\n+     */\n+    public void add(@Nonnull Tuple tuple) {\n+        addInternal(tuple.getItems(), 0, tuple.pack(), 0);\n+    }\n+\n+    /**\n+     * Add encoded tuple bytes to the tree.\n+     *\n+     * @param packed the packed form of a tuple to be parsed and added to the tree\n+     */\n+    public void add(@Nonnull byte[] packed) {\n+        List<Object> items = null;\n+        int endPosition = packed.length;\n+        while (endPosition > 0) {\n+            try {\n+                items = Tuple.fromBytes(packed, 0, endPosition).getItems();\n+                break;\n+            } catch (IllegalArgumentException ex) {\n+                endPosition--;\n+            }\n+        }\n+        if (items == null) {\n+            items = new ArrayList<>();\n+        }\n+        if (endPosition < packed.length) {\n+            items.add(UNPARSEABLE);\n+        }\n+        addInternal(items, 0, packed, 0);\n+    }\n+\n+    @SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\n+    protected synchronized void addInternal(@Nonnull List<Object> items, int itemPosition, @Nonnull byte[] bytes, int bytePosition) {", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MTk4Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380341986", "bodyText": "I made it private.", "author": "MMcM", "createdAt": "2020-02-17T19:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3MTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NTQ4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380275480", "bodyText": "The addRange and addKey methods might perform some asynchronous I/O, and it doesn't look like this method is waiting on those.", "author": "alecgrieser", "createdAt": "2020-02-17T16:26:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/ClientLogEventCounter.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * ClientLogEventCounter.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.LocalityUtil;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.CloseableAsyncIterator;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Count tuple-encoded keys into {@link TupleKeyCountTree}.\n+ */\n+public class ClientLogEventCounter implements FDBDatabaseClientLogEvents.RecordEventConsumer {\n+    @Nonnull\n+    private final TupleKeyCountTree root;\n+    private final boolean countReads;\n+    private final boolean countWrites;\n+    private final boolean byAddress;\n+\n+    public ClientLogEventCounter(@Nonnull TupleKeyCountTree root, boolean countReads, boolean countWrites, boolean byAddress) {\n+        this.root = root;\n+        this.countReads = countReads;\n+        this.countWrites = countWrites;\n+        this.byAddress = byAddress;\n+    }\n+\n+    /**\n+     * Update the count tree with keys &mdash; and optional storage server IP addresses &mdash; in an event.\n+     * @param context an open record context\n+     * @param event a parsed client latency event\n+     * @return a future that completes when the event has been processed\n+     */\n+    @Override\n+    public CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event) {\n+        switch (event.getType()) {\n+            case FDBClientLogEvents.GET_VERSION_LATENCY:\n+                break;\n+            case FDBClientLogEvents.GET_LATENCY:\n+                if (countReads) {\n+                    return addKey(context, ((FDBClientLogEvents.EventGet)event).getKey());\n+                }\n+                break;\n+            case FDBClientLogEvents.GET_RANGE_LATENCY:\n+                if (countReads) {\n+                    return addRange(context, ((FDBClientLogEvents.EventGetRange)event).getRange());\n+                }\n+                break;\n+            case FDBClientLogEvents.COMMIT_LATENCY:\n+                if (countWrites) {\n+                    return addCommit(context, ((FDBClientLogEvents.EventCommit)event).getCommitRequest());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_GET:\n+                if (countReads) {\n+                    return addKey(context, ((FDBClientLogEvents.EventGetError)event).getKey());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_GET_RANGE:\n+                if (countReads) {\n+                    return addRange(context, ((FDBClientLogEvents.EventGetRangeError)event).getRange());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_COMMIT:\n+                if (countWrites) {\n+                    return addCommit(context, ((FDBClientLogEvents.EventCommitError)event).getCommitRequest());\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        return AsyncUtil.DONE;\n+    }\n+\n+    protected CompletableFuture<Void> addKey(@Nonnull FDBRecordContext context, @Nonnull byte[] key) {\n+        if (byAddress) {\n+            return addKeyAddresses(context, key);\n+        } else {\n+            root.add(key);\n+            return AsyncUtil.DONE;\n+        }\n+    }\n+\n+    protected CompletableFuture<Void> addKeyAddresses(@Nonnull FDBRecordContext context, @Nonnull byte[] key) {\n+        return LocalityUtil.getAddressesForKey(context.ensureActive(), key).handle((addresses, ex) -> {\n+            if (ex == null) {\n+                for (String address : addresses) {\n+                    root.addPrefixChild(address).add(key);\n+                }\n+            }\n+            return null;\n+        });\n+    }\n+\n+    protected CompletableFuture<Void> addRange(@Nonnull FDBRecordContext context, @Nonnull Range range) {\n+        if (byAddress) {\n+            return addKeyAddresses(context, range.begin).thenCompose(vignore -> {\n+                final CloseableAsyncIterator<byte[]> boundaryKeys = LocalityUtil.getBoundaryKeys(context.ensureActive(), range.begin, range.end);\n+                return AsyncUtil.whileTrue(() -> boundaryKeys.onHasNext().thenCompose(hasNext -> {\n+                    if (hasNext) {\n+                        final byte[] boundaryKey = boundaryKeys.next();\n+                        if (Arrays.equals(boundaryKey, range.begin)) {\n+                            return AsyncUtil.READY_TRUE;\n+                        } else {\n+                            return addKeyAddresses(context, boundaryKey).thenApply(vignore2 -> true);\n+                        }\n+                    } else {\n+                        return AsyncUtil.READY_FALSE;\n+                    }\n+                })).whenComplete((v, t) -> boundaryKeys.close());\n+            });\n+        } else {\n+            root.add(range.begin);\n+            return AsyncUtil.DONE;\n+        }\n+    }\n+\n+    protected CompletableFuture<Void> addCommit(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.CommitRequest commitRequest) {\n+        for (FDBClientLogEvents.Mutation mutation : commitRequest.getMutations()) {\n+            if (mutation.getType() == FDBClientLogEvents.Mutation.CLEAR_RANGE) {\n+                addRange(context, new Range(mutation.getKey(), mutation.getParam()));\n+            } else {\n+                addKey(context, mutation.getKey());\n+            }", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjA0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342044", "bodyText": "Fixed.", "author": "MMcM", "createdAt": "2020-02-17T19:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NjI5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380276290", "bodyText": "It doesn't look like any of the methods are doing anything with the FDBRecordContext except asking it for its underlying Transaction. Should this be moved to fdb-extensions and changed to take a Transaction (just to be a little more general)?", "author": "alecgrieser", "createdAt": "2020-02-17T16:28:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/ClientLogEventCounter.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * ClientLogEventCounter.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.LocalityUtil;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.CloseableAsyncIterator;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Count tuple-encoded keys into {@link TupleKeyCountTree}.\n+ */\n+public class ClientLogEventCounter implements FDBDatabaseClientLogEvents.RecordEventConsumer {\n+    @Nonnull\n+    private final TupleKeyCountTree root;\n+    private final boolean countReads;\n+    private final boolean countWrites;\n+    private final boolean byAddress;\n+\n+    public ClientLogEventCounter(@Nonnull TupleKeyCountTree root, boolean countReads, boolean countWrites, boolean byAddress) {\n+        this.root = root;\n+        this.countReads = countReads;\n+        this.countWrites = countWrites;\n+        this.byAddress = byAddress;\n+    }\n+\n+    /**\n+     * Update the count tree with keys &mdash; and optional storage server IP addresses &mdash; in an event.\n+     * @param context an open record context\n+     * @param event a parsed client latency event\n+     * @return a future that completes when the event has been processed\n+     */\n+    @Override\n+    public CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event) {", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjExNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342115", "bodyText": "Yes, done.", "author": "MMcM", "createdAt": "2020-02-17T19:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NjcyOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380276729", "bodyText": "Is this main function just intended to test this class, or is it intended to be an interface into this? Should it be moved to a testing class (if the former)?", "author": "alecgrieser", "createdAt": "2020-02-17T16:28:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/ClientLogEventCounter.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * ClientLogEventCounter.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.LocalityUtil;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.async.CloseableAsyncIterator;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Count tuple-encoded keys into {@link TupleKeyCountTree}.\n+ */\n+public class ClientLogEventCounter implements FDBDatabaseClientLogEvents.RecordEventConsumer {\n+    @Nonnull\n+    private final TupleKeyCountTree root;\n+    private final boolean countReads;\n+    private final boolean countWrites;\n+    private final boolean byAddress;\n+\n+    public ClientLogEventCounter(@Nonnull TupleKeyCountTree root, boolean countReads, boolean countWrites, boolean byAddress) {\n+        this.root = root;\n+        this.countReads = countReads;\n+        this.countWrites = countWrites;\n+        this.byAddress = byAddress;\n+    }\n+\n+    /**\n+     * Update the count tree with keys &mdash; and optional storage server IP addresses &mdash; in an event.\n+     * @param context an open record context\n+     * @param event a parsed client latency event\n+     * @return a future that completes when the event has been processed\n+     */\n+    @Override\n+    public CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event) {\n+        switch (event.getType()) {\n+            case FDBClientLogEvents.GET_VERSION_LATENCY:\n+                break;\n+            case FDBClientLogEvents.GET_LATENCY:\n+                if (countReads) {\n+                    return addKey(context, ((FDBClientLogEvents.EventGet)event).getKey());\n+                }\n+                break;\n+            case FDBClientLogEvents.GET_RANGE_LATENCY:\n+                if (countReads) {\n+                    return addRange(context, ((FDBClientLogEvents.EventGetRange)event).getRange());\n+                }\n+                break;\n+            case FDBClientLogEvents.COMMIT_LATENCY:\n+                if (countWrites) {\n+                    return addCommit(context, ((FDBClientLogEvents.EventCommit)event).getCommitRequest());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_GET:\n+                if (countReads) {\n+                    return addKey(context, ((FDBClientLogEvents.EventGetError)event).getKey());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_GET_RANGE:\n+                if (countReads) {\n+                    return addRange(context, ((FDBClientLogEvents.EventGetRangeError)event).getRange());\n+                }\n+                break;\n+            case FDBClientLogEvents.ERROR_COMMIT:\n+                if (countWrites) {\n+                    return addCommit(context, ((FDBClientLogEvents.EventCommitError)event).getCommitRequest());\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        return AsyncUtil.DONE;\n+    }\n+\n+    protected CompletableFuture<Void> addKey(@Nonnull FDBRecordContext context, @Nonnull byte[] key) {\n+        if (byAddress) {\n+            return addKeyAddresses(context, key);\n+        } else {\n+            root.add(key);\n+            return AsyncUtil.DONE;\n+        }\n+    }\n+\n+    protected CompletableFuture<Void> addKeyAddresses(@Nonnull FDBRecordContext context, @Nonnull byte[] key) {\n+        return LocalityUtil.getAddressesForKey(context.ensureActive(), key).handle((addresses, ex) -> {\n+            if (ex == null) {\n+                for (String address : addresses) {\n+                    root.addPrefixChild(address).add(key);\n+                }\n+            }\n+            return null;\n+        });\n+    }\n+\n+    protected CompletableFuture<Void> addRange(@Nonnull FDBRecordContext context, @Nonnull Range range) {\n+        if (byAddress) {\n+            return addKeyAddresses(context, range.begin).thenCompose(vignore -> {\n+                final CloseableAsyncIterator<byte[]> boundaryKeys = LocalityUtil.getBoundaryKeys(context.ensureActive(), range.begin, range.end);\n+                return AsyncUtil.whileTrue(() -> boundaryKeys.onHasNext().thenCompose(hasNext -> {\n+                    if (hasNext) {\n+                        final byte[] boundaryKey = boundaryKeys.next();\n+                        if (Arrays.equals(boundaryKey, range.begin)) {\n+                            return AsyncUtil.READY_TRUE;\n+                        } else {\n+                            return addKeyAddresses(context, boundaryKey).thenApply(vignore2 -> true);\n+                        }\n+                    } else {\n+                        return AsyncUtil.READY_FALSE;\n+                    }\n+                })).whenComplete((v, t) -> boundaryKeys.close());\n+            });\n+        } else {\n+            root.add(range.begin);\n+            return AsyncUtil.DONE;\n+        }\n+    }\n+\n+    protected CompletableFuture<Void> addCommit(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.CommitRequest commitRequest) {\n+        for (FDBClientLogEvents.Mutation mutation : commitRequest.getMutations()) {\n+            if (mutation.getType() == FDBClientLogEvents.Mutation.CLEAR_RANGE) {\n+                addRange(context, new Range(mutation.getKey(), mutation.getParam()));\n+            } else {\n+                addKey(context, mutation.getKey());\n+            }\n+        }\n+        return AsyncUtil.DONE;\n+    }\n+\n+    @SuppressWarnings(\"PMD.SystemPrintln\")\n+    public static void main(String[] args) {", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjI1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342250", "bodyText": "I moved this into a new test class.", "author": "MMcM", "createdAt": "2020-02-17T19:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3NjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3OTI0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380279247", "bodyText": "Any reason not to retry on any retriable exception? I think the only other one might expect from a read-only operation would be...future_version?", "author": "alecgrieser", "createdAt": "2020-02-17T16:33:37Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/FDBDatabaseClientLogEvents.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * FDBDatabaseClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.clientlog.VersionFromTimestamp;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBExceptions;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class FDBDatabaseClientLogEvents {\n+    @Nonnull\n+    private byte[] startKey;\n+    @Nonnull\n+    private byte[] endKey;\n+    @Nullable\n+    private Instant earliestTimestamp;\n+    @Nullable\n+    private Instant latestTimestamp;\n+    private int eventCount;\n+    private boolean more;\n+\n+    /**\n+     * A callback with the current transaction.\n+     */\n+    @FunctionalInterface\n+    public interface RecordEventConsumer {\n+        CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event);\n+    }\n+    \n+    private FDBDatabaseClientLogEvents(@Nonnull byte[] startKey, @Nonnull byte[] endKey) {\n+        this.startKey = startKey;\n+        this.endKey = endKey;\n+    }\n+\n+    @Nullable\n+    public Instant getEarliestTimestamp() {\n+        return earliestTimestamp;\n+    }\n+\n+    @Nullable\n+    public Instant getLatestTimestamp() {\n+        return latestTimestamp;\n+    }\n+\n+    public int getEventCount() {\n+        return eventCount;\n+    }\n+\n+    public boolean hasMore() {\n+        return more;\n+    }\n+\n+    protected static class EventRunner implements FDBClientLogEvents.EventConsumer {\n+        @Nonnull\n+        private final FDBDatabase database;\n+        @Nullable\n+        private FDBRecordContext context;\n+        @Nonnull\n+        private final RecordEventConsumer callback;\n+        @Nullable\n+        private FDBDatabaseClientLogEvents events;\n+        @Nullable\n+        private final Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer;\n+        private int eventCount;\n+        private final int eventCountLimit;\n+        private long startTimeMillis = System.currentTimeMillis();\n+        private final long timeLimitMillis;\n+        private boolean limitReached;\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.versionRangeProducer = versionRangeProducer;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull FDBDatabaseClientLogEvents events,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.events = events;\n+            this.versionRangeProducer = null;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public CompletableFuture<FDBDatabaseClientLogEvents> run() {\n+            return AsyncUtil.whileTrue(this::loop).thenApply(vignore -> {\n+                events.updateForRun(eventCount, limitReached);\n+                return events;\n+            });\n+        }\n+\n+        private CompletableFuture<Boolean> loop() {\n+            context = database.openContext();\n+            final TransactionOptions transactionOptions = context.ensureActive().options();\n+            transactionOptions.setAccessSystemKeys();\n+            transactionOptions.setReadLockAware();\n+            if (events == null) {\n+                return versionRangeProducer.apply(context).thenCompose(versions -> {\n+                    final Long startVersion = versions.getLeft();\n+                    final byte[] startKey = startVersion == null ? FDBClientLogEvents.EVENT_KEY_PREFIX : FDBClientLogEvents.eventKeyForVersion(startVersion);\n+                    final Long endVersion = versions.getRight();\n+                    final byte[] endKey = endVersion == null ? ByteArrayUtil.strinc(FDBClientLogEvents.EVENT_KEY_PREFIX) : FDBClientLogEvents.eventKeyForVersion(endVersion);\n+                    events = new FDBDatabaseClientLogEvents(startKey, endKey);\n+                    return loopBody();\n+                });\n+            } else {\n+                return loopBody();\n+            }\n+        }\n+\n+        private CompletableFuture<Boolean> loopBody() {\n+            final AsyncIterable<KeyValue> range = events.getRange(context);\n+            return FDBClientLogEvents.forEachEvent(range, this).thenApply(lastProcessedKey -> {\n+                events.updateForTransaction(lastProcessedKey);\n+                return false;   // Return to caller if range processed or limit reached.\n+            }).handle((b, t) -> {\n+                if (context != null) {\n+                    context.close();\n+                    context = null;\n+                }\n+                if (t != null) {\n+                    final RuntimeException ex = FDBExceptions.wrapException(t);\n+                    if (ex instanceof FDBExceptions.FDBStoreTransactionIsTooOldException) {\n+                        return true;    // Continue with new transaction when too old.", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwOTQxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380309414", "bodyText": "By retry you mean start a new transaction like it does for pst version? Really retrying (reprocessing data) introduces the possibility of double counting.", "author": "MMcM", "createdAt": "2020-02-17T17:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3OTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMyMDAwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380320007", "bodyText": "Right, yeah, start a new transaction like past version, not reprocess data", "author": "alecgrieser", "createdAt": "2020-02-17T18:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3OTI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjMxMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342313", "bodyText": "Done.", "author": "MMcM", "createdAt": "2020-02-17T19:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI3OTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI4MDE1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380280152", "bodyText": "I think setReadSystemKeys would be sufficient and probably safer", "author": "alecgrieser", "createdAt": "2020-02-17T16:35:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/FDBDatabaseClientLogEvents.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * FDBDatabaseClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.clientlog.VersionFromTimestamp;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBExceptions;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class FDBDatabaseClientLogEvents {\n+    @Nonnull\n+    private byte[] startKey;\n+    @Nonnull\n+    private byte[] endKey;\n+    @Nullable\n+    private Instant earliestTimestamp;\n+    @Nullable\n+    private Instant latestTimestamp;\n+    private int eventCount;\n+    private boolean more;\n+\n+    /**\n+     * A callback with the current transaction.\n+     */\n+    @FunctionalInterface\n+    public interface RecordEventConsumer {\n+        CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event);\n+    }\n+    \n+    private FDBDatabaseClientLogEvents(@Nonnull byte[] startKey, @Nonnull byte[] endKey) {\n+        this.startKey = startKey;\n+        this.endKey = endKey;\n+    }\n+\n+    @Nullable\n+    public Instant getEarliestTimestamp() {\n+        return earliestTimestamp;\n+    }\n+\n+    @Nullable\n+    public Instant getLatestTimestamp() {\n+        return latestTimestamp;\n+    }\n+\n+    public int getEventCount() {\n+        return eventCount;\n+    }\n+\n+    public boolean hasMore() {\n+        return more;\n+    }\n+\n+    protected static class EventRunner implements FDBClientLogEvents.EventConsumer {\n+        @Nonnull\n+        private final FDBDatabase database;\n+        @Nullable\n+        private FDBRecordContext context;\n+        @Nonnull\n+        private final RecordEventConsumer callback;\n+        @Nullable\n+        private FDBDatabaseClientLogEvents events;\n+        @Nullable\n+        private final Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer;\n+        private int eventCount;\n+        private final int eventCountLimit;\n+        private long startTimeMillis = System.currentTimeMillis();\n+        private final long timeLimitMillis;\n+        private boolean limitReached;\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.versionRangeProducer = versionRangeProducer;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull FDBDatabaseClientLogEvents events,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.events = events;\n+            this.versionRangeProducer = null;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public CompletableFuture<FDBDatabaseClientLogEvents> run() {\n+            return AsyncUtil.whileTrue(this::loop).thenApply(vignore -> {\n+                events.updateForRun(eventCount, limitReached);\n+                return events;\n+            });\n+        }\n+\n+        private CompletableFuture<Boolean> loop() {\n+            context = database.openContext();\n+            final TransactionOptions transactionOptions = context.ensureActive().options();\n+            transactionOptions.setAccessSystemKeys();", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjM0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342342", "bodyText": "Fixed.", "author": "MMcM", "createdAt": "2020-02-17T19:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI4MDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI4MjQ5Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380282497", "bodyText": "Similar question about the purpose of the main function here", "author": "alecgrieser", "createdAt": "2020-02-17T16:40:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/clientlog/FDBDatabaseClientLogEvents.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * FDBDatabaseClientLogEvents.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb.clientlog;\n+\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.annotation.API;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.clientlog.FDBClientLogEvents;\n+import com.apple.foundationdb.clientlog.VersionFromTimestamp;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabase;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBDatabaseFactory;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBExceptions;\n+import com.apple.foundationdb.record.provider.foundationdb.FDBRecordContext;\n+import com.apple.foundationdb.tuple.ByteArrayUtil;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+\n+/**\n+ * Parse client latency events from system keyspace.\n+ */\n+@API(API.Status.EXPERIMENTAL)\n+public class FDBDatabaseClientLogEvents {\n+    @Nonnull\n+    private byte[] startKey;\n+    @Nonnull\n+    private byte[] endKey;\n+    @Nullable\n+    private Instant earliestTimestamp;\n+    @Nullable\n+    private Instant latestTimestamp;\n+    private int eventCount;\n+    private boolean more;\n+\n+    /**\n+     * A callback with the current transaction.\n+     */\n+    @FunctionalInterface\n+    public interface RecordEventConsumer {\n+        CompletableFuture<Void> accept(@Nonnull FDBRecordContext context, @Nonnull FDBClientLogEvents.Event event);\n+    }\n+    \n+    private FDBDatabaseClientLogEvents(@Nonnull byte[] startKey, @Nonnull byte[] endKey) {\n+        this.startKey = startKey;\n+        this.endKey = endKey;\n+    }\n+\n+    @Nullable\n+    public Instant getEarliestTimestamp() {\n+        return earliestTimestamp;\n+    }\n+\n+    @Nullable\n+    public Instant getLatestTimestamp() {\n+        return latestTimestamp;\n+    }\n+\n+    public int getEventCount() {\n+        return eventCount;\n+    }\n+\n+    public boolean hasMore() {\n+        return more;\n+    }\n+\n+    protected static class EventRunner implements FDBClientLogEvents.EventConsumer {\n+        @Nonnull\n+        private final FDBDatabase database;\n+        @Nullable\n+        private FDBRecordContext context;\n+        @Nonnull\n+        private final RecordEventConsumer callback;\n+        @Nullable\n+        private FDBDatabaseClientLogEvents events;\n+        @Nullable\n+        private final Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer;\n+        private int eventCount;\n+        private final int eventCountLimit;\n+        private long startTimeMillis = System.currentTimeMillis();\n+        private final long timeLimitMillis;\n+        private boolean limitReached;\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.versionRangeProducer = versionRangeProducer;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public EventRunner(@Nonnull FDBDatabase database, @Nonnull RecordEventConsumer callback,\n+                           @Nonnull FDBDatabaseClientLogEvents events,\n+                           int eventCountLimit, long timeLimitMillis) {\n+            this.database = database;\n+            this.callback = callback;\n+            this.events = events;\n+            this.versionRangeProducer = null;\n+            this.eventCountLimit = eventCountLimit;\n+            this.timeLimitMillis = timeLimitMillis;\n+        }\n+\n+        public CompletableFuture<FDBDatabaseClientLogEvents> run() {\n+            return AsyncUtil.whileTrue(this::loop).thenApply(vignore -> {\n+                events.updateForRun(eventCount, limitReached);\n+                return events;\n+            });\n+        }\n+\n+        private CompletableFuture<Boolean> loop() {\n+            context = database.openContext();\n+            final TransactionOptions transactionOptions = context.ensureActive().options();\n+            transactionOptions.setAccessSystemKeys();\n+            transactionOptions.setReadLockAware();\n+            if (events == null) {\n+                return versionRangeProducer.apply(context).thenCompose(versions -> {\n+                    final Long startVersion = versions.getLeft();\n+                    final byte[] startKey = startVersion == null ? FDBClientLogEvents.EVENT_KEY_PREFIX : FDBClientLogEvents.eventKeyForVersion(startVersion);\n+                    final Long endVersion = versions.getRight();\n+                    final byte[] endKey = endVersion == null ? ByteArrayUtil.strinc(FDBClientLogEvents.EVENT_KEY_PREFIX) : FDBClientLogEvents.eventKeyForVersion(endVersion);\n+                    events = new FDBDatabaseClientLogEvents(startKey, endKey);\n+                    return loopBody();\n+                });\n+            } else {\n+                return loopBody();\n+            }\n+        }\n+\n+        private CompletableFuture<Boolean> loopBody() {\n+            final AsyncIterable<KeyValue> range = events.getRange(context);\n+            return FDBClientLogEvents.forEachEvent(range, this).thenApply(lastProcessedKey -> {\n+                events.updateForTransaction(lastProcessedKey);\n+                return false;   // Return to caller if range processed or limit reached.\n+            }).handle((b, t) -> {\n+                if (context != null) {\n+                    context.close();\n+                    context = null;\n+                }\n+                if (t != null) {\n+                    final RuntimeException ex = FDBExceptions.wrapException(t);\n+                    if (ex instanceof FDBExceptions.FDBStoreTransactionIsTooOldException) {\n+                        return true;    // Continue with new transaction when too old.\n+                    } else {\n+                        throw ex;\n+                    }\n+                } else {\n+                    return b;\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public CompletableFuture<Void> accept(FDBClientLogEvents.Event event) {\n+            eventCount++;\n+            events.updateForEvent(event.getStartTimestamp());\n+            return callback.accept(context, event);\n+        }\n+\n+        @Override\n+        public boolean more() {\n+            if (eventCount >= eventCountLimit || System.currentTimeMillis() - startTimeMillis >= timeLimitMillis) {\n+                limitReached = true;\n+            }\n+            return !limitReached;\n+        }\n+    }\n+\n+    private AsyncIterable<KeyValue> getRange(@Nonnull FDBRecordContext context) {\n+        return context.ensureActive().getRange(startKey, endKey);\n+    }\n+\n+    private void updateForEvent(@Nonnull Instant eventTimestamp) {\n+        if (earliestTimestamp == null) {\n+            earliestTimestamp = eventTimestamp;\n+        }\n+        latestTimestamp = eventTimestamp;\n+    }\n+\n+    private void updateForTransaction(@Nullable byte[] lastProcessedKey) {\n+        if (lastProcessedKey != null) {\n+            startKey = ByteArrayUtil.join(lastProcessedKey, new byte[1]);   // The immediately following key.\n+        } else {\n+            startKey = endKey;  // Empty range.\n+        }\n+    }\n+\n+    private void updateForRun(int rangeEventCount, boolean limitReached) {\n+        eventCount += rangeEventCount;\n+        more = limitReached;    // Otherwise range was processed, possibly in multiple transactions.\n+    }\n+\n+    @Nonnull\n+    public static CompletableFuture<FDBDatabaseClientLogEvents> forEachEvent(@Nonnull FDBDatabase database,\n+                                                                             @Nonnull RecordEventConsumer callback,\n+                                                                             @Nonnull Function<FDBRecordContext, CompletableFuture<Pair<Long, Long>>> versionRangeProducer,\n+                                                                             int eventCountLimit, long timeLimitMillis) {\n+        final EventRunner runner = new EventRunner(database, callback, versionRangeProducer,\n+                                                   eventCountLimit, timeLimitMillis);\n+        return runner.run();\n+    }\n+\n+    /**\n+     * Apply a callback to client latency events recorded in the given database between two commit versions.\n+     * @param database the database to open and read events from\n+     * @param callback the callback to apply\n+     * @param startVersion the starting commit version\n+     * @param endVersion the exclusive end version\n+     * @param eventCountLimit the maximum number of events to process before returning\n+     * @param timeLimitMillis the maximum time to process before returning\n+     * @return a future which completes when the version range has been processed by the callback with an object that can be used to resume the scan\n+     */\n+    @Nonnull\n+    public static CompletableFuture<FDBDatabaseClientLogEvents> forEachEventBetweenVersions(@Nonnull FDBDatabase database,\n+                                                                                            @Nonnull RecordEventConsumer callback,\n+                                                                                            @Nullable Long startVersion, @Nullable Long endVersion,\n+                                                                                            int eventCountLimit, long timeLimitMillis) {\n+        return forEachEvent(database, callback, cignore -> CompletableFuture.completedFuture(Pair.of(startVersion, endVersion)), eventCountLimit, timeLimitMillis);\n+    }\n+\n+    /**\n+     * Apply a callback to client latency events recorded in the given database between two commit versions.\n+     * @param database the database to open and read events from\n+     * @param callback the callback to apply\n+     * @param startTimestamp the starting wall-clock time\n+     * @param endTimestamp the exclusive end time\n+     * @param eventCountLimit the maximum number of events to process before returning\n+     * @param timeLimitMillis the maximum time to process before returning\n+     * @return a future which completes when the version range has been processed by the callback with an object that can be used to resume the scan\n+     */\n+    @Nonnull\n+    public static CompletableFuture<FDBDatabaseClientLogEvents> forEachEventBetweenTimestamps(@Nonnull FDBDatabase database,\n+                                                                                              @Nonnull RecordEventConsumer callback,\n+                                                                                              @Nullable Instant startTimestamp, @Nullable Instant endTimestamp,\n+                                                                                              int eventCountLimit, long timeLimitMillis) {\n+        return forEachEvent(database, callback, context -> {\n+            final CompletableFuture<Long> startVersion = startTimestamp == null ? CompletableFuture.completedFuture(null) :\n+                                                         VersionFromTimestamp.lastVersionBefore(context.readTransaction(false), startTimestamp);\n+            final CompletableFuture<Long> endVersion = endTimestamp == null ? CompletableFuture.completedFuture(null) :\n+                                                       VersionFromTimestamp.nextVersionAfter(context.readTransaction(false), endTimestamp);\n+            return startVersion.thenCombine(endVersion, Pair::of);\n+        },\n+                eventCountLimit, timeLimitMillis);\n+    }\n+\n+    /**\n+     * Apply a callback to client latency events following an early return due to reaching a limit.\n+     * @param database the database to open and read events from\n+     * @param callback the callback to apply\n+     * @param eventCountLimit the maximum number of events to process before returning\n+     * @param timeLimitMillis the maximum time to process before returning\n+     * @return a future which completes when the version range has been processed by the callback with an object that can be used to resume the scan again\n+     */\n+    public CompletableFuture<FDBDatabaseClientLogEvents> forEachEventContinued(@Nonnull FDBDatabase database,\n+                                                                               @Nonnull RecordEventConsumer callback,\n+                                                                               int eventCountLimit, long timeLimitMillis) {\n+        final EventRunner runner = new EventRunner(database, callback, this,\n+                                                   eventCountLimit, timeLimitMillis);\n+        return runner.run();\n+    }\n+\n+    @SuppressWarnings(\"PMD.SystemPrintln\")\n+    public static void main(String[] args) {", "originalCommit": "e5267a3849b75fcdffe49e328a27ca20842ab343", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0MjQ1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380342454", "bodyText": "I added another test for this, too.", "author": "MMcM", "createdAt": "2020-02-17T19:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI4MjQ5Nw=="}], "type": "inlineReview"}, {"oid": "537ec05dad57cb4d47e4f111ca3773628d8ac4ae", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/537ec05dad57cb4d47e4f111ca3773628d8ac4ae", "message": "Move more files into fdb-extensions, with appropriate adjustments to signatures.", "committedDate": "2020-02-17T19:32:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcwMTk0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380701947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * ClientLogEventCounter.java\n          \n          \n            \n             * DatabaseClientLogEventCounter.java", "author": "alecgrieser", "createdAt": "2020-02-18T14:23:17Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/DatabaseClientLogEventCounter.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * ClientLogEventCounter.java", "originalCommit": "537ec05dad57cb4d47e4f111ca3773628d8ac4ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcwNTIzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380705238", "bodyText": "I'm not sure RecordEventConsumer (instead of just EventConsumer) makes sense now that it's in fdb-extensions.", "author": "alecgrieser", "createdAt": "2020-02-18T14:28:19Z", "path": "fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/DatabaseClientLogEvents.java", "diffHunk": "@@ -62,10 +59,10 @@\n      */\n     @FunctionalInterface\n     public interface RecordEventConsumer {", "originalCommit": "537ec05dad57cb4d47e4f111ca3773628d8ac4ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0ODA1NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/822#discussion_r380848055", "bodyText": "Changed.", "author": "MMcM", "createdAt": "2020-02-18T18:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcwNTIzOA=="}], "type": "inlineReview"}, {"oid": "6c1cb2e31940a08a9a9df18fb1d1b056adc9803c", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6c1cb2e31940a08a9a9df18fb1d1b056adc9803c", "message": "Need to have @SpotBufSuppressWarnings in fdb-extensions", "committedDate": "2020-02-18T18:09:25Z", "type": "commit"}, {"oid": "63304535e50b1c5da54740f86bdafb99e7b071c0", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/63304535e50b1c5da54740f86bdafb99e7b071c0", "message": "Resolves #816: Parse client latency log samples in a key space aware way", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "518bc5db280fb08ce70686cd34df8a8b78a05e12", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/518bc5db280fb08ce70686cd34df8a8b78a05e12", "message": "Resolves #821: Remove the reverse directory cache scan fallback.", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "4e219109094d7314a434614cc7f0ae4de6d01ba7", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4e219109094d7314a434614cc7f0ae4de6d01ba7", "message": "Add a key space aware counter.", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "a18a0678f7c131fab22040398138cce29ae668a8", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/a18a0678f7c131fab22040398138cce29ae668a8", "message": "Update fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/FDBClientLogEvents.java\n\nCo-Authored-By: Alec Grieser <alloc@apple.com>", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "207a386d4ae84a2498301d5ebae141c4c7c1a6bc", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/207a386d4ae84a2498301d5ebae141c4c7c1a6bc", "message": "Move more files into fdb-extensions, with appropriate adjustments to signatures.", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "4d8bd10950783dc6b45b59fc6fa176e9e9765c5d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/4d8bd10950783dc6b45b59fc6fa176e9e9765c5d", "message": "Update fdb-extensions/src/main/java/com/apple/foundationdb/clientlog/DatabaseClientLogEventCounter.java\n\nCo-Authored-By: Alec Grieser <alloc@apple.com>", "committedDate": "2020-02-18T18:10:13Z", "type": "commit"}, {"oid": "7e748e8fd18c82e9e4910561b74cf8a0ad12570e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7e748e8fd18c82e9e4910561b74cf8a0ad12570e", "message": "Rename EventConsumer", "committedDate": "2020-02-18T18:14:24Z", "type": "commit"}, {"oid": "7e748e8fd18c82e9e4910561b74cf8a0ad12570e", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7e748e8fd18c82e9e4910561b74cf8a0ad12570e", "message": "Rename EventConsumer", "committedDate": "2020-02-18T18:14:24Z", "type": "forcePushed"}]}