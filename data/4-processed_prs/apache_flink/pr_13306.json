{"pr_number": 13306, "pr_title": "[FLINK-17779][Connectors/ORC]Orc file format support filter push down", "pr_createdAt": "2020-09-02T12:39:29Z", "pr_url": "https://github.com/apache/flink/pull/13306", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODAwOQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483358009", "bodyText": "Can you move these codes to a class: OrcFilters", "author": "JingsongLi", "createdAt": "2020-09-04T02:58:40Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFileSystemFormatFactory.java", "diffHunk": "@@ -83,14 +96,227 @@ private static Properties getOrcProperties(ReadableConfig options) {\n \t\treturn orcProperties;\n \t}\n \n+\tprivate boolean isUnaryValid(CallExpression callExpression) {", "originalCommit": "8048b8f9ded32203cb0ca0761414ef7186a68e5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQzOTI0OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483439249", "bodyText": "@JingsongLi  thanks for your review, do you mean that all the codes related to filter pushdown conversion below are put in the class OrcFilters ?", "author": "meetjunsu", "createdAt": "2020-09-04T07:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ0MjI3Nw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483442277", "bodyText": "Yes, we can have a helper class OrcFilters, provides static helper methods.", "author": "JingsongLi", "createdAt": "2020-09-04T07:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODk4Nw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483358987", "bodyText": "Maybe we can have a static final ImmutableMap<FunctionDefinition, Function<CallExpression, Expression>> FILTERS. The function style can make codes better.", "author": "JingsongLi", "createdAt": "2020-09-04T03:02:43Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFileSystemFormatFactory.java", "diffHunk": "@@ -83,14 +96,227 @@ private static Properties getOrcProperties(ReadableConfig options) {\n \t\treturn orcProperties;\n \t}\n \n+\tprivate boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tpublic OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tFunctionDefinition funcDef = callExp.getFunctionDefinition();\n+\n+\t\t\tif (funcDef == BuiltInFunctionDefinitions.IS_NULL || funcDef == BuiltInFunctionDefinitions.IS_NOT_NULL || funcDef == BuiltInFunctionDefinitions.NOT) {", "originalCommit": "8048b8f9ded32203cb0ca0761414ef7186a68e5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQzOTU5Nw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483439597", "bodyText": "do you means: static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS ?", "author": "meetjunsu", "createdAt": "2020-09-04T07:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ0MTkxNw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483441917", "bodyText": "Yes", "author": "JingsongLi", "createdAt": "2020-09-04T07:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1ODk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1OTY4OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483359689", "bodyText": "Looks like bug here? We should add more cases.", "author": "JingsongLi", "createdAt": "2020-09-04T03:05:51Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFileSystemFormatFactory.java", "diffHunk": "@@ -83,14 +96,227 @@ private static Properties getOrcProperties(ReadableConfig options) {\n \t\treturn orcProperties;\n \t}\n \n+\tprivate boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tpublic OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tFunctionDefinition funcDef = callExp.getFunctionDefinition();\n+\n+\t\t\tif (funcDef == BuiltInFunctionDefinitions.IS_NULL || funcDef == BuiltInFunctionDefinitions.IS_NOT_NULL || funcDef == BuiltInFunctionDefinitions.NOT) {\n+\t\t\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t\t\t// not a valid predicate\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\t\t\tif (colType == null) {\n+\t\t\t\t\t// unsupported type\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcTableSource.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tString colName = getColumnName(callExp);\n+\n+\t\t\t\tif (funcDef == BuiltInFunctionDefinitions.IS_NULL) {\n+\t\t\t\t\treturn new OrcSplitReader.IsNull(colName, colType);\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.IS_NOT_NULL) {\n+\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\tnew OrcSplitReader.IsNull(colName, colType));\n+\t\t\t\t} else {\n+\t\t\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\t\t\tif (c == null) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.OR) {\n+\t\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t\t\t// not a valid predicate\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\t\t\tif (litType == null) {\n+\t\t\t\t\t// unsupported literal type\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\t\t\t\tString colName = getColumnName(callExp);\n+\n+\t\t\t\t// fetch literal and ensure it is serializable\n+\t\t\t\tObject literalObj = getLiteral(callExp).get();\n+\t\t\t\tSerializable literal;\n+\t\t\t\t// validate that literal is serializable\n+\t\t\t\tif (literalObj instanceof Serializable) {\n+\t\t\t\t\tliteral = (Serializable) literalObj;\n+\t\t\t\t} else {\n+\t\t\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\t\t\tliteralObj.getClass().getCanonicalName(), expression);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tif (funcDef == BuiltInFunctionDefinitions.EQUALS) {\n+\t\t\t\t\treturn new OrcSplitReader.Equals(colName, litType, literal);\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.NOT_EQUALS) {\n+\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\tnew OrcSplitReader.Equals(colName, litType, literal));\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.GREATER_THAN) {\n+\t\t\t\t\tif (literalOnRight) {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(colName, litType, literal));", "originalCommit": "8048b8f9ded32203cb0ca0761414ef7186a68e5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQzOTg1NA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483439854", "bodyText": "My idea is to only support = <> > >= < <= expressions like OrcTableSource. What expressions do you think need to be supported?", "author": "meetjunsu", "createdAt": "2020-09-04T07:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1OTY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ0MTcxMQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483441711", "bodyText": "I see, you are right.", "author": "JingsongLi", "createdAt": "2020-09-04T07:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM1OTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM2MDExNQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r483360115", "bodyText": "You can use switch... case...", "author": "JingsongLi", "createdAt": "2020-09-04T03:07:53Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFileSystemFormatFactory.java", "diffHunk": "@@ -83,14 +96,227 @@ private static Properties getOrcProperties(ReadableConfig options) {\n \t\treturn orcProperties;\n \t}\n \n+\tprivate boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tpublic OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tFunctionDefinition funcDef = callExp.getFunctionDefinition();\n+\n+\t\t\tif (funcDef == BuiltInFunctionDefinitions.IS_NULL || funcDef == BuiltInFunctionDefinitions.IS_NOT_NULL || funcDef == BuiltInFunctionDefinitions.NOT) {\n+\t\t\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t\t\t// not a valid predicate\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\t\t\tif (colType == null) {\n+\t\t\t\t\t// unsupported type\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcTableSource.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tString colName = getColumnName(callExp);\n+\n+\t\t\t\tif (funcDef == BuiltInFunctionDefinitions.IS_NULL) {\n+\t\t\t\t\treturn new OrcSplitReader.IsNull(colName, colType);\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.IS_NOT_NULL) {\n+\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\tnew OrcSplitReader.IsNull(colName, colType));\n+\t\t\t\t} else {\n+\t\t\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\t\t\tif (c == null) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.OR) {\n+\t\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t\t\t// not a valid predicate\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\t\t\tif (litType == null) {\n+\t\t\t\t\t// unsupported literal type\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\t\t\t\tString colName = getColumnName(callExp);\n+\n+\t\t\t\t// fetch literal and ensure it is serializable\n+\t\t\t\tObject literalObj = getLiteral(callExp).get();\n+\t\t\t\tSerializable literal;\n+\t\t\t\t// validate that literal is serializable\n+\t\t\t\tif (literalObj instanceof Serializable) {\n+\t\t\t\t\tliteral = (Serializable) literalObj;\n+\t\t\t\t} else {\n+\t\t\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\t\t\tliteralObj.getClass().getCanonicalName(), expression);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tif (funcDef == BuiltInFunctionDefinitions.EQUALS) {\n+\t\t\t\t\treturn new OrcSplitReader.Equals(colName, litType, literal);\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.NOT_EQUALS) {\n+\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\tnew OrcSplitReader.Equals(colName, litType, literal));\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.GREATER_THAN) {\n+\t\t\t\t\tif (literalOnRight) {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(colName, litType, literal));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.LessThan(colName, litType, literal);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL) {\n+\t\t\t\t\tif (literalOnRight) {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\t\tnew OrcSplitReader.LessThan(colName, litType, literal));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.LessThanEquals(colName, litType, literal);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.LESS_THAN) {\n+\t\t\t\t\tif (literalOnRight) {\n+\t\t\t\t\t\treturn new OrcSplitReader.LessThan(colName, litType, literal);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(colName, litType, literal));\n+\t\t\t\t\t}\n+\t\t\t\t} else if (funcDef == BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL) {\n+\t\t\t\t\tif (literalOnRight) {\n+\t\t\t\t\t\treturn new OrcSplitReader.LessThanEquals(colName, litType, literal);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\t\t\tnew OrcSplitReader.LessThan(colName, litType, literal));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// unsupported predicate\n+\t\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (comp.getChildren().get(0) instanceof ValueLiteralExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof FieldReferenceExpression) {\n+\t\t\treturn false;\n+\t\t} else if (comp.getChildren().get(0) instanceof FieldReferenceExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof ValueLiteralExpression) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate Optional<?> getLiteral(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t} else {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t}\n+\t}\n+\n+\tpublic PredicateLeaf.Type toOrcType(DataType type) {\n+\t\tLogicalTypeRoot ltype = type.getLogicalType().getTypeRoot();\n+\n+\t\tif (ltype == LogicalTypeRoot.TINYINT ||", "originalCommit": "8048b8f9ded32203cb0ca0761414ef7186a68e5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE2OTQwMg==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484169402", "bodyText": "NIT: List<OrcSplitReader.Predicate> is OK", "author": "JingsongLi", "createdAt": "2020-09-07T03:50:17Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFileSystemFormatFactory.java", "diffHunk": "@@ -85,12 +86,22 @@ private static Properties getOrcProperties(ReadableConfig options) {\n \n \t@Override\n \tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tArrayList<OrcSplitReader.Predicate> orcPredicates = new ArrayList<>();", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MDExMQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484170111", "bodyText": "The two lines are too long... Line breaks can be appropriate.", "author": "JingsongLi", "createdAt": "2020-09-07T03:54:11Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MDQyNQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484170425", "bodyText": "Can have a isRef(Expression) and isLit(Expr)", "author": "JingsongLi", "createdAt": "2020-09-07T03:55:43Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MDkyMA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484170920", "bodyText": "Inline this method to createIsNullPredicateConverter.", "author": "JingsongLi", "createdAt": "2020-09-07T03:58:13Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MTMzNQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484171335", "bodyText": "You can create a method: convertIsNull, and:\n.put(BuiltInFunctionDefinitions.IS_NULL, OrcFilters::convertIsNull.\nOthers can be the same.", "author": "JingsongLi", "createdAt": "2020-09-07T04:00:23Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MTQ0OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484171449", "bodyText": "Can be convertNot(convertIsNull(call))", "author": "JingsongLi", "createdAt": "2020-09-07T04:00:58Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MTU1NQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484171555", "bodyText": "Can be c == null ? null : new OrcSplitReader.Not(c)", "author": "JingsongLi", "createdAt": "2020-09-07T04:01:35Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3MjEyNw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484172127", "bodyText": "You can remove all **Predicate** in methods of this class.", "author": "JingsongLi", "createdAt": "2020-09-07T04:04:22Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createOrPredicateConverter(){", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3Mjg3OA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484172878", "bodyText": "You can pass a TriFunction to a convertBinary:\npublic OrcSplitReader.Predicate convertBinary(CallExpression call,\n   TriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> func,\n   TriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> reverseFunc) {\n   // move codes from getTuple3Args to here\n   // For example, func is LessThan, reverseFunc is greaterThanOrEqual\n   return literalOnRight ? func.apply(name, type, literal) : reverseFunc.apply(name, type, literal);\n}", "author": "JingsongLi", "createdAt": "2020-09-07T04:08:23Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createOrPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotEqualsPredicateConverter(){", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIyOTk0Mw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484229943", "bodyText": "hi @JingsongLi  , This is a good idea , but i think TriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> is conflict with Function<CallExpression, OrcSplitReader.Predicate> in FILTERS, We need another static variable, such as BINARY_FILTERS ?\nprivate static final ImmutableMap<FunctionDefinition, TriFunction<CallExpression, TriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate>, TriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate>, OrcSplitReader.Predicate>> BINARY_FILTERS", "author": "meetjunsu", "createdAt": "2020-09-07T07:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3Mjg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzMzkwMQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484233901", "bodyText": "We don't need to change FILTERS, for example:\nFILTERS.put(BuiltInFunctionDefinitions.GREATER_THAN, call -> convertBinary(call, OrcSplitReader.GreaterThan::new, OrcSplitReader.LessThanOrEqual::new))", "author": "JingsongLi", "createdAt": "2020-09-07T07:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3Mjg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNTI3Nw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484235277", "bodyText": "I got it, Thanks a lot", "author": "meetjunsu", "createdAt": "2020-09-07T07:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3Mjg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3NDAyNQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484174025", "bodyText": "Can be OrcFileSystemFilterTest", "author": "JingsongLi", "createdAt": "2020-09-07T04:14:26Z", "path": "flink-formats/flink-orc/src/test/java/org/apache/flink/orc/OrcFileSystemFormatFactoryTest.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit Tests for {@link OrcFileSystemFormatFactory}.\n+ */\n+public class OrcFileSystemFormatFactoryTest {", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3NDM2MQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484174361", "bodyText": "Add case CHAR: to STRING too.", "author": "JingsongLi", "createdAt": "2020-09-07T04:16:01Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createOrPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tif (FILTERS.get(callExp.getFunctionDefinition()) == null) {\n+\t\t\t\t// unsupported predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn FILTERS.get(callExp.getFunctionDefinition()).apply(callExp);\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate static String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (comp.getChildren().get(0) instanceof ValueLiteralExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof FieldReferenceExpression) {\n+\t\t\treturn false;\n+\t\t} else if (comp.getChildren().get(0) instanceof FieldReferenceExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof ValueLiteralExpression) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<?> getLiteral(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t} else {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type toOrcType(DataType type) {\n+\t\tLogicalTypeRoot ltype = type.getLogicalType().getTypeRoot();\n+\t\tswitch (ltype){\n+\t\t\tcase TINYINT:\n+\t\t\tcase SMALLINT:\n+\t\t\tcase INTEGER:\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn PredicateLeaf.Type.LONG;\n+\t\t\tcase FLOAT:\n+\t\t\tcase DOUBLE:\n+\t\t\t\treturn PredicateLeaf.Type.FLOAT;\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn PredicateLeaf.Type.BOOLEAN;\n+\t\t\tcase VARCHAR:", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3NDQ1MQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484174451", "bodyText": "Remove this one TIMESTAMP_WITH_TIME_ZONE", "author": "JingsongLi", "createdAt": "2020-09-07T04:16:29Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createOrPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tif (FILTERS.get(callExp.getFunctionDefinition()) == null) {\n+\t\t\t\t// unsupported predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn FILTERS.get(callExp.getFunctionDefinition()).apply(callExp);\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate static String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (comp.getChildren().get(0) instanceof ValueLiteralExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof FieldReferenceExpression) {\n+\t\t\treturn false;\n+\t\t} else if (comp.getChildren().get(0) instanceof FieldReferenceExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof ValueLiteralExpression) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<?> getLiteral(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t} else {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type toOrcType(DataType type) {\n+\t\tLogicalTypeRoot ltype = type.getLogicalType().getTypeRoot();\n+\t\tswitch (ltype){\n+\t\t\tcase TINYINT:\n+\t\t\tcase SMALLINT:\n+\t\t\tcase INTEGER:\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn PredicateLeaf.Type.LONG;\n+\t\t\tcase FLOAT:\n+\t\t\tcase DOUBLE:\n+\t\t\t\treturn PredicateLeaf.Type.FLOAT;\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn PredicateLeaf.Type.BOOLEAN;\n+\t\t\tcase VARCHAR:\n+\t\t\t\treturn PredicateLeaf.Type.STRING;\n+\t\t\tcase TIMESTAMP_WITHOUT_TIME_ZONE:\n+\t\t\tcase TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+\t\t\tcase TIMESTAMP_WITH_TIME_ZONE:", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3NDU0Mw==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484174543", "bodyText": "It is not BINARY", "author": "JingsongLi", "createdAt": "2020-09-07T04:17:02Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple3;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, createIsNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, createIsNotNullPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, createNotPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, createOrPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, createEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, createNotEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, createGreaterThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, createGreaterThanEqualsPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, createLessThanPredicateConverter())\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, createLessThanEqualsPredicateConverter())\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && callExpression.getChildren().get(0) instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && ((callExpression.getChildren().get(0) instanceof FieldReferenceExpression && callExpression.getChildren().get(1) instanceof ValueLiteralExpression) ||\n+\t\t\t\t(callExpression.getChildren().get(0) instanceof ValueLiteralExpression && callExpression.getChildren().get(1) instanceof FieldReferenceExpression));\n+\t}\n+\n+\tprivate static Tuple2<String, PredicateLeaf.Type> getTuple2Args(CallExpression callExp){\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn Tuple2.of(colName, colType);\n+\t}\n+\n+\tprivate static Tuple3<String, PredicateLeaf.Type, Serializable> getTuple3Args(CallExpression callExp){\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn Tuple3.of(colName, litType, literal);\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\t\tif (tuple2 == null){\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\treturn new OrcSplitReader.IsNull(tuple2.f0, tuple2.f1);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createIsNotNullPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple2<String, PredicateLeaf.Type> tuple2 = getTuple2Args(callExp);\n+\n+\t\t\tif (tuple2 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.IsNull(tuple2.f0, tuple2.f1));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t\t// not a valid predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\t\tif (c == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(c);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createOrPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tExpression left = callExp.getChildren().get(0);\n+\t\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\t\tif (c1 == null || c2 == null) {\n+\t\t\t\treturn null;\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createNotEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\tnew OrcSplitReader.Equals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createGreaterThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static Function<CallExpression, OrcSplitReader.Predicate> createLessThanEqualsPredicateConverter(){\n+\t\treturn callExp -> {\n+\n+\t\t\tTuple3<String, PredicateLeaf.Type, Serializable> tuple3 = getTuple3Args(callExp);\n+\n+\t\t\tif (tuple3 == null){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tboolean literalOnRight = literalOnRight(callExp);\n+\n+\t\t\tif (literalOnRight) {\n+\t\t\t\treturn new OrcSplitReader.LessThanEquals(tuple3.f0, tuple3.f1, tuple3.f2);\n+\t\t\t} else {\n+\t\t\t\treturn new OrcSplitReader.Not(\n+\t\t\t\t\t\tnew OrcSplitReader.LessThan(tuple3.f0, tuple3.f1, tuple3.f2));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tif (FILTERS.get(callExp.getFunctionDefinition()) == null) {\n+\t\t\t\t// unsupported predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn FILTERS.get(callExp.getFunctionDefinition()).apply(callExp);\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate static String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (comp.getChildren().get(0) instanceof ValueLiteralExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof FieldReferenceExpression) {\n+\t\t\treturn false;\n+\t\t} else if (comp.getChildren().get(0) instanceof FieldReferenceExpression\n+\t\t\t\t&& comp.getChildren().get(1) instanceof ValueLiteralExpression) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<?> getLiteral(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t} else {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type toOrcType(DataType type) {\n+\t\tLogicalTypeRoot ltype = type.getLogicalType().getTypeRoot();\n+\t\tswitch (ltype){\n+\t\t\tcase TINYINT:\n+\t\t\tcase SMALLINT:\n+\t\t\tcase INTEGER:\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn PredicateLeaf.Type.LONG;\n+\t\t\tcase FLOAT:\n+\t\t\tcase DOUBLE:\n+\t\t\t\treturn PredicateLeaf.Type.FLOAT;\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn PredicateLeaf.Type.BOOLEAN;\n+\t\t\tcase VARCHAR:\n+\t\t\t\treturn PredicateLeaf.Type.STRING;\n+\t\t\tcase TIMESTAMP_WITHOUT_TIME_ZONE:\n+\t\t\tcase TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n+\t\t\tcase TIMESTAMP_WITH_TIME_ZONE:\n+\t\t\t\treturn PredicateLeaf.Type.TIMESTAMP;\n+\t\t\tcase DATE:\n+\t\t\t\treturn PredicateLeaf.Type.DATE;\n+\t\t\tcase BINARY:", "originalCommit": "c7628fc4b97f68c44d7f5e9cf316814c9f73db18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzMTEzMA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484231130", "bodyText": "Sorry, this is my carelessness", "author": "meetjunsu", "createdAt": "2020-09-07T07:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3NDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNTI0Ng==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484615246", "bodyText": "I have some concern about literal structure..\nEspecially timestamp and date, Flink is LocalTimestamp, and LocalDate, I don't know what is ORC. You verify this in ITCase.", "author": "JingsongLi", "createdAt": "2020-09-08T02:21:48Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+import org.apache.flink.util.function.TriFunction;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, OrcFilters::convertIsNull)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, OrcFilters::convertIsNotNull)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, OrcFilters::convertNot)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, OrcFilters::convertOr)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, call -> convertBinary(call, OrcFilters::convertEquals, OrcFilters::convertEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, call -> convertBinary(call, OrcFilters::convertNotEquals, OrcFilters::convertNotEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, call -> convertBinary(call, OrcFilters::convertGreaterThan, OrcFilters::convertLessThanEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, call -> convertBinary(call, OrcFilters::convertGreaterThanEquals, OrcFilters::convertLessThan))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, call -> convertBinary(call, OrcFilters::convertLessThan, OrcFilters::convertGreaterThanEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, call -> convertBinary(call, OrcFilters::convertLessThanEquals, OrcFilters::convertGreaterThan))\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isRef(Expression expression) {\n+\t\treturn expression instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isLit(Expression expression) {\n+\t\treturn expression instanceof ValueLiteralExpression;\n+\t}\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && isRef(callExpression.getChildren().get(0));\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && (\n+\t\t\t\tisRef(callExpression.getChildren().get(0)) && isLit(callExpression.getChildren().get(1)) ||\n+\t\t\t\t\t\tisLit(callExpression.getChildren().get(0)) && isRef(callExpression.getChildren().get(1))\n+\t\t);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertIsNull(CallExpression callExp) {\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn new OrcSplitReader.IsNull(colName, colType);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertIsNotNull(CallExpression callExp) {\n+\t\treturn new OrcSplitReader.Not(convertIsNull(callExp));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertNot(CallExpression callExp) {\n+\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\treturn c == null ? null : new OrcSplitReader.Not(c);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertOr(CallExpression callExp) {\n+\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tExpression left = callExp.getChildren().get(0);\n+\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\tif (c1 == null || c2 == null) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t}\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate convertBinary(CallExpression callExp,\n+\t\t\tTriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> func,\n+\t\t\tTriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> reverseFunc) {\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn literalOnRight(callExp) ? func.apply(colName, litType, literal) : reverseFunc.apply(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Equals(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertNotEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(convertEquals(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertGreaterThan(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(\n+\t\t\t\tnew OrcSplitReader.LessThanEquals(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertGreaterThanEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(\n+\t\t\t\tnew OrcSplitReader.LessThan(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertLessThan(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.LessThan(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertLessThanEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.LessThanEquals(colName, litType, literal);\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tif (FILTERS.get(callExp.getFunctionDefinition()) == null) {\n+\t\t\t\t// unsupported predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn FILTERS.get(callExp.getFunctionDefinition()).apply(callExp);\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate static String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (isLit(comp.getChildren().get(0)) && isRef(comp.getChildren().get(1))) {\n+\t\t\treturn false;\n+\t\t} else if (isRef(comp.getChildren().get(0)) && isLit(comp.getChildren().get(1))) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<?> getLiteral(CallExpression comp) {", "originalCommit": "174d9d69aa825ce53661c38b2bf9c7e71440c687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYzOTQ3NQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484639475", "bodyText": "By looking at the orc source code, orc is java.sql.Date and java.sql.Timestamp\nThe relevant code is in RecordReaderImpl.getBaseObjectForComparison()", "author": "meetjunsu", "createdAt": "2020-09-08T04:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNTI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY1ODE1OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484658159", "bodyText": "Maybe we can change the getLiteral() function like this:\nprivate static Object getLiteral(CallExpression comp) {\n        Object literalObj;\n        if (literalOnRight(comp)) {\n                ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n                literalObj = valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass()).get();\n        } else {\n                ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n                literalObj = valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass()).get();\n        }\n\n        if(literalObj instanceof LocalDate){\n                LocalDate localDate = (LocalDate) literalObj;\n                return Date.valueOf(localDate);\n        }else if(literalObj instanceof LocalDateTime){\n                LocalDateTime localDateTime = (LocalDateTime) literalObj;\n                return Timestamp.valueOf(localDateTime);\n        }else{\n                return literalObj;\n        }\n}\n\nTest sql in ITCase:\ncreate table orcFilterTable (\n        x string,\n        y int,\n        a int,\n        b bigint,\n        c boolean,\n        d string,\n        e decimal(8,4),\n        f date,\n        g timestamp\n) with (\n        'connector' = 'filesystem',\n        'path' = '/path/to/data',\n        'format' = 'orc'\n)\n\n// test date type\n select x, y from orcFilterTable where f = date '2020-01-01'\n\n// test timestamp type\n select x, y from orcFilterTable where g = timestamp '2020-01-01 00:00:00'", "author": "meetjunsu", "createdAt": "2020-09-08T05:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNTI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc0MjA0OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484742049", "bodyText": "@JingsongLi  Do you have a better solution ?", "author": "meetjunsu", "createdAt": "2020-09-08T08:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNTI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc0NDU4OA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484744588", "bodyText": "I think it is good, minor is we take a look to type first: public Serialiable toOrcObject() {switch(typeRoot) case TIMESTAMP}....", "author": "JingsongLi", "createdAt": "2020-09-08T08:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNTI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNjA1NA==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484616054", "bodyText": "You can remove TIMESTAMP_WITH_LOCAL_TIME_ZONE, it is hard to test it.", "author": "JingsongLi", "createdAt": "2020-09-08T02:25:19Z", "path": "flink-formats/flink-orc/src/main/java/org/apache/flink/orc/OrcFilters.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.orc;\n+\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalTypeRoot;\n+import org.apache.flink.util.function.TriFunction;\n+\n+import org.apache.flink.shaded.curator4.com.google.common.collect.ImmutableMap;\n+\n+import org.apache.hadoop.hive.ql.io.sarg.PredicateLeaf;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Utility class that provides helper methods to work with Orc Filter PushDown.\n+ */\n+public class OrcFilters {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OrcFileSystemFormatFactory.class);\n+\n+\tprivate static final ImmutableMap<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>> FILTERS =\n+\t\t\tnew ImmutableMap.Builder<FunctionDefinition, Function<CallExpression, OrcSplitReader.Predicate>>()\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NULL, OrcFilters::convertIsNull)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.IS_NOT_NULL, OrcFilters::convertIsNotNull)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT, OrcFilters::convertNot)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.OR, OrcFilters::convertOr)\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.EQUALS, call -> convertBinary(call, OrcFilters::convertEquals, OrcFilters::convertEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.NOT_EQUALS, call -> convertBinary(call, OrcFilters::convertNotEquals, OrcFilters::convertNotEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN, call -> convertBinary(call, OrcFilters::convertGreaterThan, OrcFilters::convertLessThanEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, call -> convertBinary(call, OrcFilters::convertGreaterThanEquals, OrcFilters::convertLessThan))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN, call -> convertBinary(call, OrcFilters::convertLessThan, OrcFilters::convertGreaterThanEquals))\n+\t\t\t\t\t.put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, call -> convertBinary(call, OrcFilters::convertLessThanEquals, OrcFilters::convertGreaterThan))\n+\t\t\t\t\t.build();\n+\n+\tprivate static boolean isRef(Expression expression) {\n+\t\treturn expression instanceof FieldReferenceExpression;\n+\t}\n+\n+\tprivate static boolean isLit(Expression expression) {\n+\t\treturn expression instanceof ValueLiteralExpression;\n+\t}\n+\n+\tprivate static boolean isUnaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 1 && isRef(callExpression.getChildren().get(0));\n+\t}\n+\n+\tprivate static boolean isBinaryValid(CallExpression callExpression) {\n+\t\treturn callExpression.getChildren().size() == 2 && (\n+\t\t\t\tisRef(callExpression.getChildren().get(0)) && isLit(callExpression.getChildren().get(1)) ||\n+\t\t\t\t\t\tisLit(callExpression.getChildren().get(0)) && isRef(callExpression.getChildren().get(1))\n+\t\t);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertIsNull(CallExpression callExp) {\n+\t\tif (!isUnaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type colType = toOrcType(((FieldReferenceExpression) callExp.getChildren().get(0)).getOutputDataType());\n+\t\tif (colType == null) {\n+\t\t\t// unsupported type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\treturn new OrcSplitReader.IsNull(colName, colType);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertIsNotNull(CallExpression callExp) {\n+\t\treturn new OrcSplitReader.Not(convertIsNull(callExp));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertNot(CallExpression callExp) {\n+\t\tif (callExp.getChildren().size() != 1) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tOrcSplitReader.Predicate c = toOrcPredicate(callExp.getChildren().get(0));\n+\t\treturn c == null ? null : new OrcSplitReader.Not(c);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertOr(CallExpression callExp) {\n+\t\tif (callExp.getChildren().size() < 2) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tExpression left = callExp.getChildren().get(0);\n+\t\tExpression right = callExp.getChildren().get(1);\n+\n+\t\tOrcSplitReader.Predicate c1 = toOrcPredicate(left);\n+\t\tOrcSplitReader.Predicate c2 = toOrcPredicate(right);\n+\t\tif (c1 == null || c2 == null) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\treturn new OrcSplitReader.Or(c1, c2);\n+\t\t}\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate convertBinary(CallExpression callExp,\n+\t\t\tTriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> func,\n+\t\t\tTriFunction<String, PredicateLeaf.Type, Serializable, OrcSplitReader.Predicate> reverseFunc) {\n+\t\tif (!isBinaryValid(callExp)) {\n+\t\t\t// not a valid predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tPredicateLeaf.Type litType = getLiteralType(callExp);\n+\t\tif (litType == null) {\n+\t\t\t// unsupported literal type\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tString colName = getColumnName(callExp);\n+\n+\t\t// fetch literal and ensure it is serializable\n+\t\tObject literalObj = getLiteral(callExp).get();\n+\t\tSerializable literal;\n+\t\t// validate that literal is serializable\n+\t\tif (literalObj instanceof Serializable) {\n+\t\t\tliteral = (Serializable) literalObj;\n+\t\t} else {\n+\t\t\tLOG.warn(\"Encountered a non-serializable literal of type {}. \" +\n+\t\t\t\t\t\t\t\"Cannot push predicate [{}] into OrcFileSystemFormatFactory. \" +\n+\t\t\t\t\t\t\t\"This is a bug and should be reported.\",\n+\t\t\t\t\tliteralObj.getClass().getCanonicalName(), callExp);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn literalOnRight(callExp) ? func.apply(colName, litType, literal) : reverseFunc.apply(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Equals(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertNotEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(convertEquals(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertGreaterThan(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(\n+\t\t\t\tnew OrcSplitReader.LessThanEquals(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertGreaterThanEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.Not(\n+\t\t\t\tnew OrcSplitReader.LessThan(colName, litType, literal));\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertLessThan(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.LessThan(colName, litType, literal);\n+\t}\n+\n+\tprivate static OrcSplitReader.Predicate convertLessThanEquals(String colName, PredicateLeaf.Type litType, Serializable literal) {\n+\t\treturn new OrcSplitReader.LessThanEquals(colName, litType, literal);\n+\t}\n+\n+\tpublic static OrcSplitReader.Predicate toOrcPredicate(Expression expression) {\n+\t\tif (expression instanceof CallExpression) {\n+\t\t\tCallExpression callExp = (CallExpression) expression;\n+\t\t\tif (FILTERS.get(callExp.getFunctionDefinition()) == null) {\n+\t\t\t\t// unsupported predicate\n+\t\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn FILTERS.get(callExp.getFunctionDefinition()).apply(callExp);\n+\t\t} else {\n+\t\t\t// unsupported predicate\n+\t\t\tLOG.debug(\"Unsupported predicate [{}] cannot be pushed into OrcFileSystemFormatFactory.\", expression);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate static String getColumnName(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(0)).getName();\n+\t\t} else {\n+\t\t\treturn ((FieldReferenceExpression) comp.getChildren().get(1)).getName();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean literalOnRight(CallExpression comp) {\n+\t\tif (comp.getChildren().size() == 1 && comp.getChildren().get(0) instanceof FieldReferenceExpression) {\n+\t\t\treturn true;\n+\t\t} else if (isLit(comp.getChildren().get(0)) && isRef(comp.getChildren().get(1))) {\n+\t\t\treturn false;\n+\t\t} else if (isRef(comp.getChildren().get(0)) && isLit(comp.getChildren().get(1))) {\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tthrow new RuntimeException(\"Invalid binary comparison.\");\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type getLiteralType(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(1)).getOutputDataType());\n+\t\t} else {\n+\t\t\treturn toOrcType(((ValueLiteralExpression) comp.getChildren().get(0)).getOutputDataType());\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<?> getLiteral(CallExpression comp) {\n+\t\tif (literalOnRight(comp)) {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(1);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t} else {\n+\t\t\tValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) comp.getChildren().get(0);\n+\t\t\treturn valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass());\n+\t\t}\n+\t}\n+\n+\tprivate static PredicateLeaf.Type toOrcType(DataType type) {\n+\t\tLogicalTypeRoot ltype = type.getLogicalType().getTypeRoot();\n+\t\tswitch (ltype) {\n+\t\t\tcase TINYINT:\n+\t\t\tcase SMALLINT:\n+\t\t\tcase INTEGER:\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn PredicateLeaf.Type.LONG;\n+\t\t\tcase FLOAT:\n+\t\t\tcase DOUBLE:\n+\t\t\t\treturn PredicateLeaf.Type.FLOAT;\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn PredicateLeaf.Type.BOOLEAN;\n+\t\t\tcase CHAR:\n+\t\t\tcase VARCHAR:\n+\t\t\t\treturn PredicateLeaf.Type.STRING;\n+\t\t\tcase TIMESTAMP_WITHOUT_TIME_ZONE:\n+\t\t\tcase TIMESTAMP_WITH_LOCAL_TIME_ZONE:", "originalCommit": "174d9d69aa825ce53661c38b2bf9c7e71440c687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDYxNjE1OQ==", "url": "https://github.com/apache/flink/pull/13306#discussion_r484616159", "bodyText": "It is better to add timestamp, date, decimal too.", "author": "JingsongLi", "createdAt": "2020-09-08T02:25:48Z", "path": "flink-formats/flink-orc/src/test/java/org/apache/flink/orc/OrcFileSystemITCase.java", "diffHunk": "@@ -85,4 +88,59 @@ public void testNonPartition() {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n \t}\n+\n+\t@Override\n+\tpublic void before() {\n+\t\tsuper.before();\n+\t\tsuper.tableEnv().executeSql(String.format(\n+\t\t\t\t\"create table orcFilterTable (\" +\n+\t\t\t\t\t\t\"x string,\" +\n+\t\t\t\t\t\t\"y int,\" +\n+\t\t\t\t\t\t\"a int,\" +\n+\t\t\t\t\t\t\"b bigint,\" +\n+\t\t\t\t\t\t\"c boolean,\" +\n+\t\t\t\t\t\t\"d string\" +", "originalCommit": "174d9d69aa825ce53661c38b2bf9c7e71440c687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0fc75a3e8c45cb9ada6571c56b978af7ed99b6b", "url": "https://github.com/apache/flink/commit/f0fc75a3e8c45cb9ada6571c56b978af7ed99b6b", "message": "[FLINK-17779][Connectors/ORC]Orc file format support filter push down", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "ea9e1f404d62be4926a29ac9c64b72a388db4a4a", "url": "https://github.com/apache/flink/commit/ea9e1f404d62be4926a29ac9c64b72a388db4a4a", "message": "[FLINK-17779][Connectors/ORC] Add test cases for OrcFileSystemFormatFactory", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "d48cfb01b6cbb5a170e82f4caf58dbe529c6258e", "url": "https://github.com/apache/flink/commit/d48cfb01b6cbb5a170e82f4caf58dbe529c6258e", "message": "[FLINK-17779][Connectors/ORC] normalize description of class", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "cdaf01cb0072f6afa6176915f67a2cddd9780c0a", "url": "https://github.com/apache/flink/commit/cdaf01cb0072f6afa6176915f67a2cddd9780c0a", "message": "[FLINK-17779][Connectors/ORC]Orc file format support filter push down", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "13eff0ef80c62deb18948ffe965efe8c55e350d0", "url": "https://github.com/apache/flink/commit/13eff0ef80c62deb18948ffe965efe8c55e350d0", "message": "[hotfix][Connectors/ORC] refactor code to function style", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "cb433f17845f7dd326c21bd10072ce3971100145", "url": "https://github.com/apache/flink/commit/cb433f17845f7dd326c21bd10072ce3971100145", "message": "[hotfix][Connectors/ORC] Adapt date and timestamp data types between Flink and Orc", "committedDate": "2020-09-08T10:17:22Z", "type": "commit"}, {"oid": "507fa0a64dc561fca0e16161d4a325d97785fe2b", "url": "https://github.com/apache/flink/commit/507fa0a64dc561fca0e16161d4a325d97785fe2b", "message": "[hotfix][Connectors/ORC] Adapt date and timestamp data types between Flink and Orc", "committedDate": "2020-09-08T10:24:40Z", "type": "commit"}]}