{"pr_number": 11486, "pr_title": "[FLINK-16712][task] Refactor StreamTask to construct final fields", "pr_createdAt": "2020-03-23T03:43:29Z", "pr_url": "https://github.com/apache/flink/pull/11486", "timeline": [{"oid": "9535112ff0782fd584600cc3fdbefe0457b1bcfb", "url": "https://github.com/apache/flink/commit/9535112ff0782fd584600cc3fdbefe0457b1bcfb", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.", "committedDate": "2020-03-23T08:14:20Z", "type": "forcePushed"}, {"oid": "4c7dde85991c2181362648abbce207778f84ac07", "url": "https://github.com/apache/flink/commit/4c7dde85991c2181362648abbce207778f84ac07", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.", "committedDate": "2020-03-23T11:04:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM4NTEyNA==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396385124", "bodyText": "How long running are those calls? If they are touching some IO files, they might take quite some time and with your change, they would happen before the following lines in Task class:\n\t\t\t// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime\n\t\t\tif (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// notify everyone that we switched to running\n\t\t\ttaskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));\n\n\t\t\t// make sure the user code classloader is accessible thread-locally\n\t\t\texecutingThread.setContextClassLoader(userCodeClassLoader);\n\nas oppose to running after them, as it is now. I'm not sure what could be the side effects?", "author": "pnowojski", "createdAt": "2020-03-23T11:33:07Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -260,17 +258,28 @@ protected StreamTask(\n \t\t\t@Nullable TimerService timerService,\n \t\t\tThread.UncaughtExceptionHandler uncaughtExceptionHandler,\n \t\t\tStreamTaskActionExecutor actionExecutor,\n-\t\t\tTaskMailbox mailbox) {\n+\t\t\tTaskMailbox mailbox) throws Exception {\n \n \t\tsuper(environment);\n \n-\t\tthis.timerService = timerService;\n-\t\tthis.uncaughtExceptionHandler = Preconditions.checkNotNull(uncaughtExceptionHandler);\n \t\tthis.configuration = new StreamConfig(getTaskConfiguration());\n \t\tthis.recordWriter = createRecordWriterDelegate(configuration, environment);\n \t\tthis.actionExecutor = Preconditions.checkNotNull(actionExecutor);\n \t\tthis.mailboxProcessor = new MailboxProcessor(this::processInput, mailbox, actionExecutor);\n \t\tthis.asyncExceptionHandler = new StreamTaskAsyncExceptionHandler(environment);\n+\t\tthis.asyncOperationsThreadPool = Executors.newCachedThreadPool(\n+\t\t\tnew ExecutorThreadFactory(\"AsyncOperations\", uncaughtExceptionHandler));\n+\n+\t\tthis.stateBackend = createStateBackend();\n+\t\tthis.checkpointStorage = stateBackend.createCheckpointStorage(getEnvironment().getJobID());", "originalCommit": "4c7dde85991c2181362648abbce207778f84ac07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQwODcxNg==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396408716", "bodyText": "TBH I did not think of this issue before making the changes. And you really pointed out a critical and reasonable concern here.\nAfter double checking the related codes of creating backend and storage, I do not find any IO operators or any time-consuming operations, only deserialization from config and some paths generation. So IMO it should not bring obvious side effects.", "author": "zhijiangW", "createdAt": "2020-03-23T12:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM4NTEyNA=="}], "type": "inlineReview"}, {"oid": "0a1a1264434909e99062ffe146c0222d4ed9d558", "url": "https://github.com/apache/flink/commit/0a1a1264434909e99062ffe146c0222d4ed9d558", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.", "committedDate": "2020-03-23T14:39:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjE4MQ==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396592181", "bodyText": "I'm a bit concerned about concurrency here: we publish a reference to this object before it's being fully constructed.\nSo the other thread can read null as asyncExceptionHandler value.\nBut now this field is final, so the preceding write to it should be already visible.\nIf this is correct, I think we need to put a warning here and near final modifier that changing them can cause concurrency problems.", "author": "rkhachatryan", "createdAt": "2020-03-23T16:39:16Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -260,17 +258,28 @@ protected StreamTask(\n \t\t\t@Nullable TimerService timerService,\n \t\t\tThread.UncaughtExceptionHandler uncaughtExceptionHandler,\n \t\t\tStreamTaskActionExecutor actionExecutor,\n-\t\t\tTaskMailbox mailbox) {\n+\t\t\tTaskMailbox mailbox) throws Exception {\n \n \t\tsuper(environment);\n \n-\t\tthis.timerService = timerService;\n-\t\tthis.uncaughtExceptionHandler = Preconditions.checkNotNull(uncaughtExceptionHandler);\n \t\tthis.configuration = new StreamConfig(getTaskConfiguration());\n \t\tthis.recordWriter = createRecordWriterDelegate(configuration, environment);\n \t\tthis.actionExecutor = Preconditions.checkNotNull(actionExecutor);\n \t\tthis.mailboxProcessor = new MailboxProcessor(this::processInput, mailbox, actionExecutor);\n \t\tthis.asyncExceptionHandler = new StreamTaskAsyncExceptionHandler(environment);\n+\t\tthis.asyncOperationsThreadPool = Executors.newCachedThreadPool(\n+\t\t\tnew ExecutorThreadFactory(\"AsyncOperations\", uncaughtExceptionHandler));\n+\n+\t\tthis.stateBackend = createStateBackend();\n+\t\tthis.checkpointStorage = stateBackend.createCheckpointStorage(getEnvironment().getJobID());\n+\n+\t\t// if the clock is not already set, then assign a default TimeServiceProvider\n+\t\tif (timerService == null) {\n+\t\t\tThreadFactory timerThreadFactory = new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName());\n+\t\t\tthis.timerService = new SystemProcessingTimeService(this::handleTimerException, timerThreadFactory);\n+\t\t} else {", "originalCommit": "0a1a1264434909e99062ffe146c0222d4ed9d558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3MzQxNg==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396873416", "bodyText": "I did not get your point here. You referred to the concurrent issue for timeService or asyncExceptionHandler? And which kind of thread might touch this object before the StreamTask is fully constructed?", "author": "zhijiangW", "createdAt": "2020-03-24T02:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAyMzg5Ng==", "url": "https://github.com/apache/flink/pull/11486#discussion_r397023896", "bodyText": "I meant that the timer thread could access asyncExceptionHandler variable.\nSo, if someone later reorders it like this:\nStreamTask(){\n  this.timerService = new SystemProcessingTimeService(this::handleTimerException, timerThreadFactory);\n  this.asyncExceptionHandler = new StreamTaskAsyncExceptionHandler(environment);\n}\n...\n/// schedule task\n\nand removes final from asyncExceptionHandler then timerService thread can see null even after it's assigned.", "author": "rkhachatryan", "createdAt": "2020-03-24T09:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2NDM3MA==", "url": "https://github.com/apache/flink/pull/11486#discussion_r397064370", "bodyText": "Hmm, thanks for the explanations and I got your point now.\nI also found that there exists another variable to prevent this case happen.  StreamTask#isRunning is set true after beforeInvoke done, and the asyncExceptionHandler would be only used by timeService after isRunning true. So it can eliminate our concern. :)", "author": "zhijiangW", "createdAt": "2020-03-24T10:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMTc5Ng==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396601796", "bodyText": "If I'm not mistaken, these exceptions were previously thrown from StreamTask.invoke(); and then they weren't wrapped into anything neither by StreamTask nor by Task.\nNow they are thrown from Task.loadAndInstantiateInvokable which can wrap them into FlinkException.\nThis wrapping can break exception-matching logic in Task (e.g. if (t instanceof CancelTaskException) ...).", "author": "rkhachatryan", "createdAt": "2020-03-23T16:52:28Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -260,17 +258,28 @@ protected StreamTask(\n \t\t\t@Nullable TimerService timerService,\n \t\t\tThread.UncaughtExceptionHandler uncaughtExceptionHandler,\n \t\t\tStreamTaskActionExecutor actionExecutor,\n-\t\t\tTaskMailbox mailbox) {\n+\t\t\tTaskMailbox mailbox) throws Exception {\n ", "originalCommit": "0a1a1264434909e99062ffe146c0222d4ed9d558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5MDk4NQ==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396890985", "bodyText": "Good catch. I double checked the codes and it seems not break any existing behaviors, because we would not explicitly match the FlinkException in Task or JobMaster ATM.\nThis wrapped exception for statelessCtor.newInstance(environment) is redundant before this PR, because any instance of AbstractInvokable would not throw exceptions during construction.\nI am a bit torn whether it should be wrapped into FlinkException now because it would hide the essential exception to confuse users sometimes. But this is a common issue also existing in other wrapped exceptions.  E.g. some users were always confused when seeing the message \"Could not forward element to next operator\" from wrapped ExceptionInChainedOperatorException which causes task failure, but the real exception might come from specific UDF. And I also plan to improve this issue a bit by appending the real exception message with the custom message, but it should be a separate ticket.\nDo you have some further concerns for this case?", "author": "zhijiangW", "createdAt": "2020-03-24T04:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk5MzA3Mw==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396993073", "bodyText": "Hmm..I meant that we could match something other than FlinkException, but it is wrapped into FlinkException.\nI checked it again and found only one such case: c on line 776 (Task).\nSo if it is thrown somewhere in constructor of StreamTask or its descendants then Task will be failed, not cancelled. Currently, it is not thrown in any of constructors though.\nI think we can ignore this issue for now. And if CancelTaskException will be added to constructor, IMO we should rather revisit this cancelation mechanism.", "author": "rkhachatryan", "createdAt": "2020-03-24T09:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzAwMQ==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396613001", "bodyText": "Should we move the appropriate line in Task higher:\nexecutingThread.setContextClassLoader(userCodeClassLoader);\n?\nNow (in master) it's before invoke(); and it looks like it should be moved before\ninvokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);", "author": "rkhachatryan", "createdAt": "2020-03-23T17:08:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -260,17 +258,28 @@ protected StreamTask(\n \t\t\t@Nullable TimerService timerService,\n \t\t\tThread.UncaughtExceptionHandler uncaughtExceptionHandler,\n \t\t\tStreamTaskActionExecutor actionExecutor,\n-\t\t\tTaskMailbox mailbox) {\n+\t\t\tTaskMailbox mailbox) throws Exception {\n \n \t\tsuper(environment);\n \n-\t\tthis.timerService = timerService;\n-\t\tthis.uncaughtExceptionHandler = Preconditions.checkNotNull(uncaughtExceptionHandler);\n \t\tthis.configuration = new StreamConfig(getTaskConfiguration());\n \t\tthis.recordWriter = createRecordWriterDelegate(configuration, environment);\n \t\tthis.actionExecutor = Preconditions.checkNotNull(actionExecutor);\n \t\tthis.mailboxProcessor = new MailboxProcessor(this::processInput, mailbox, actionExecutor);\n \t\tthis.asyncExceptionHandler = new StreamTaskAsyncExceptionHandler(environment);\n+\t\tthis.asyncOperationsThreadPool = Executors.newCachedThreadPool(\n+\t\t\tnew ExecutorThreadFactory(\"AsyncOperations\", uncaughtExceptionHandler));\n+\n+\t\tthis.stateBackend = createStateBackend();", "originalCommit": "0a1a1264434909e99062ffe146c0222d4ed9d558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5MzAwNw==", "url": "https://github.com/apache/flink/pull/11486#discussion_r396893007", "bodyText": "executingThread.setContextClassLoader(userCodeClassLoader) was actually done twice both before loadAndInstantiateInvokable and invoke(). I am not quite sure why we need to set twice before.\nAnyway it is not related to my PR change, so I do not try to figure it out ATM. WDYT?", "author": "zhijiangW", "createdAt": "2020-03-24T04:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAyNTQyMg==", "url": "https://github.com/apache/flink/pull/11486#discussion_r397025422", "bodyText": "Yes, you are right, it's set twice :)", "author": "rkhachatryan", "createdAt": "2020-03-24T09:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzAwMQ=="}], "type": "inlineReview"}, {"oid": "96c328765887f416fce5c49c74094ca6fe0640e2", "url": "https://github.com/apache/flink/commit/96c328765887f416fce5c49c74094ca6fe0640e2", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486.", "committedDate": "2020-03-24T04:46:32Z", "type": "forcePushed"}, {"oid": "8fa00239cb575a67dde4f0fa500eab470efe2581", "url": "https://github.com/apache/flink/commit/8fa00239cb575a67dde4f0fa500eab470efe2581", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486.", "committedDate": "2020-03-24T05:58:33Z", "type": "forcePushed"}, {"oid": "3e6dc74c58a913e0242e127da0e9504e9e0c44d4", "url": "https://github.com/apache/flink/commit/3e6dc74c58a913e0242e127da0e9504e9e0c44d4", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486.", "committedDate": "2020-03-24T07:11:55Z", "type": "forcePushed"}, {"oid": "502f33e71092027ca04a464a213378af173f5fa5", "url": "https://github.com/apache/flink/commit/502f33e71092027ca04a464a213378af173f5fa5", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486.", "committedDate": "2020-03-24T07:53:45Z", "type": "forcePushed"}, {"oid": "9d88662d7b4ba04fde20491e72d18a522d17d8ee", "url": "https://github.com/apache/flink/commit/9d88662d7b4ba04fde20491e72d18a522d17d8ee", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486", "committedDate": "2020-03-25T02:23:08Z", "type": "commit"}, {"oid": "9d88662d7b4ba04fde20491e72d18a522d17d8ee", "url": "https://github.com/apache/flink/commit/9d88662d7b4ba04fde20491e72d18a522d17d8ee", "message": "[FLINK-16712][task] Refactor StreamTask to construct final fields\n\nAt the moment there are four fields initialized in the method of StreamTask#beforeInvoke, such as `stateBackend`, `checkpointStorage`, `timerService`, `asyncOperationsThreadPool`.\n\nIn general it is suggested to use final fields to get known benefits. So we can refactor the StreamTask to initialize these fields in the constructor instead.\n\nThis closes #11486", "committedDate": "2020-03-25T02:23:08Z", "type": "forcePushed"}]}