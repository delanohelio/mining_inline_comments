{"pr_number": 13650, "pr_title": "[FLINK-19605][table-runtime-blink] Implement cumulative windowing for window aggregate operator", "pr_createdAt": "2020-10-15T12:02:02Z", "pr_url": "https://github.com/apache/flink/pull/13650", "timeline": [{"oid": "6f7b817c8d78530f0c9e674cde25bb311fe03d57", "url": "https://github.com/apache/flink/commit/6f7b817c8d78530f0c9e674cde25bb311fe03d57", "message": "[FLINK-19605][table-runtime-blink] Implement cumulative windowing for window aggregate operator", "committedDate": "2020-10-15T11:57:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUzOTM1OQ==", "url": "https://github.com/apache/flink/pull/13650#discussion_r507539359", "bodyText": "If paneSize  always equals step, keep only step is enough, because we always have limitation size must be an integral multiple of step.", "author": "danny0405", "createdAt": "2020-10-19T07:48:13Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long size;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final long paneSize;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long size, long step, long offset, boolean isEventTime) {\n+\t\tif (size <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (size % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.size = size;\n+\t\tthis.step = step;\n+\t\tthis.offset = offset;\n+\t\tthis.isEventTime = isEventTime;\n+\t\tthis.paneSize = step;\n+\t}", "originalCommit": "6f7b817c8d78530f0c9e674cde25bb311fe03d57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MDM0Mw==", "url": "https://github.com/apache/flink/pull/13650#discussion_r507540343", "bodyText": "Do we support size argument that is not 1 day ? Say 2 days or 3 days ?", "author": "danny0405", "createdAt": "2020-10-19T07:49:53Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long size;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final long paneSize;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long size, long step, long offset, boolean isEventTime) {\n+\t\tif (size <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (size % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.size = size;\n+\t\tthis.step = step;", "originalCommit": "6f7b817c8d78530f0c9e674cde25bb311fe03d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MTYzMw==", "url": "https://github.com/apache/flink/pull/13650#discussion_r507541633", "bodyText": "We should name it the maxSize because the window size is actually increasing.", "author": "danny0405", "createdAt": "2020-10-19T07:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MDM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4NTU0Ng==", "url": "https://github.com/apache/flink/pull/13650#discussion_r507885546", "bodyText": "Yes. We can support 2 days max size.", "author": "wuchong", "createdAt": "2020-10-19T16:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MDM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NDMyNA==", "url": "https://github.com/apache/flink/pull/13650#discussion_r507544324", "bodyText": "We may also need to add a test case for the late arrive data.", "author": "danny0405", "createdAt": "2020-10-19T07:56:32Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/window/WindowOperatorTest.java", "diffHunk": "@@ -289,6 +289,155 @@ public void testProcessingTimeSlidingWindows() throws Throwable {\n \t\ttestHarness.close();\n \t}\n \n+\t@Test\n+\tpublic void testEventTimeCumulativeWindows() throws Exception {\n+\t\tcloseCalled.set(0);\n+\n+\t\tWindowOperator operator = WindowOperatorBuilder\n+\t\t\t.builder()\n+\t\t\t.withInputFields(inputFieldTypes)\n+\t\t\t.cumulative(Duration.ofSeconds(3), Duration.ofSeconds(1))\n+\t\t\t.withEventTime(2)\n+\t\t\t.aggregateAndBuild(getTimeWindowAggFunction(), equaliser, accTypes, aggResultTypes, windowTypes);\n+\n+\t\tOneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(operator);\n+\n+\t\ttestHarness.open();\n+\n+\t\t// process elements\n+\t\tConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();\n+\n+\t\t// add elements out-of-order\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 2999L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 3000L));\n+\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 20L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 0L));\n+\t\ttestHarness.processElement(insertRecord(\"key1\", 1, 999L));\n+\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1998L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1999L));\n+\t\ttestHarness.processElement(insertRecord(\"key2\", 1, 1000L));\n+\n+\t\ttestHarness.processWatermark(new Watermark(999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 1000L, 999L)));\n+\t\texpectedOutput.add(new Watermark(999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(1999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 2000L, 1999L)));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 3L, 3L, 0L, 2000L, 1999L)));\n+\t\texpectedOutput.add(new Watermark(1999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(2999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key1\", 3L, 3L, 0L, 3000L, 2999L)));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 4L, 4L, 0L, 3000L, 2999L)));\n+\t\texpectedOutput.add(new Watermark(2999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\t// do a snapshot, close and restore again\n+\t\tOperatorSubtaskState snapshot = testHarness.snapshot(0L, 0);\n+\t\ttestHarness.close();\n+\t\texpectedOutput.clear();\n+\n+\t\ttestHarness = createTestHarness(operator);\n+\t\ttestHarness.setup();\n+\t\ttestHarness.initializeState(snapshot);\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processWatermark(new Watermark(3999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 4000L, 3999L)));\n+\t\texpectedOutput.add(new Watermark(3999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(4999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 5000L, 4999L)));\n+\t\texpectedOutput.add(new Watermark(4999));\n+\t\tassertor.assertOutputEqualsSorted(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n+\n+\t\ttestHarness.processWatermark(new Watermark(5999));\n+\t\texpectedOutput.addAll(doubleRecord(isTableAggregate, insertRecord(\"key2\", 1L, 1L, 3000L, 6000L, 5999L)));", "originalCommit": "6f7b817c8d78530f0c9e674cde25bb311fe03d57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "26d7b65b3e795a9aa597269fc04a00d38ef1a1ad", "url": "https://github.com/apache/flink/commit/26d7b65b3e795a9aa597269fc04a00d38ef1a1ad", "message": "address review comment", "committedDate": "2020-10-20T04:15:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMzIwMw==", "url": "https://github.com/apache/flink/pull/13650#discussion_r508203203", "bodyText": "size -> maxSize", "author": "danny0405", "createdAt": "2020-10-20T04:33:31Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/window/assigners/CumulativeWindowAssigner.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.window.assigners;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.operators.window.TimeWindow;\n+import org.apache.flink.util.IterableIterator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A {@link WindowAssigner} that windows elements into cumulative windows based on the timestamp of the\n+ * elements. Windows are overlap.\n+ */\n+public class CumulativeWindowAssigner extends PanedWindowAssigner<TimeWindow> implements InternalTimeWindowAssigner {\n+\n+\tprivate static final long serialVersionUID = 4895551155814656518L;\n+\n+\tprivate final long maxSize;\n+\n+\tprivate final long step;\n+\n+\tprivate final long offset;\n+\n+\tprivate final boolean isEventTime;\n+\n+\tprotected CumulativeWindowAssigner(long maxSize, long step, long offset, boolean isEventTime) {\n+\t\tif (maxSize <= 0 || step <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner parameters must satisfy step > 0 and size > 0\");\n+\t\t}\n+\t\tif (maxSize % step != 0) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"CumulativeWindowAssigner requires size must be an integral multiple of step.\");\n+\t\t}\n+\n+\t\tthis.maxSize = maxSize;\n+\t\tthis.step = step;\n+\t\tthis.offset = offset;\n+\t\tthis.isEventTime = isEventTime;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TimeWindow> assignWindows(RowData element, long timestamp) {\n+\t\tList<TimeWindow> windows = new ArrayList<>();\n+\t\tlong start = TimeWindow.getWindowStartWithOffset(timestamp, offset, maxSize);\n+\t\tlong lastEnd = start + maxSize;\n+\t\tlong firstEnd = TimeWindow.getWindowStartWithOffset(timestamp, offset, step) + step;\n+\t\tfor (long end = firstEnd; end <= lastEnd; end += step) {\n+\t\t\twindows.add(new TimeWindow(start, end));\n+\t\t}\n+\t\treturn windows;\n+\t}\n+\n+\t@Override\n+\tpublic TimeWindow assignPane(Object element, long timestamp) {\n+\t\tlong start = TimeWindow.getWindowStartWithOffset(timestamp, offset, step);\n+\t\treturn new TimeWindow(start, start + step);\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<TimeWindow> splitIntoPanes(TimeWindow window) {\n+\t\treturn new PanesIterable(window.getStart(), window.getEnd(), step);\n+\t}\n+\n+\t@Override\n+\tpublic TimeWindow getLastWindow(TimeWindow pane) {\n+\t\tlong windowStart = TimeWindow.getWindowStartWithOffset(pane.getStart(), offset, maxSize);\n+\t\t// the last window is the max size window\n+\t\treturn new TimeWindow(windowStart, windowStart + maxSize);\n+\t}\n+\n+\t@Override\n+\tpublic TypeSerializer<TimeWindow> getWindowSerializer(ExecutionConfig executionConfig) {\n+\t\treturn new TimeWindow.Serializer();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEventTime() {\n+\t\treturn isEventTime;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"CumulativeWindow(\" + maxSize + \", \" + step + \")\";\n+\t}\n+\n+\tprivate static class PanesIterable implements IterableIterator<TimeWindow> {\n+\n+\t\tprivate final long paneSize;\n+\t\tprivate final long windowEnd;\n+\t\tprivate long paneStart;\n+\t\tprivate long paneEnd;\n+\n+\t\tPanesIterable(long windowStart, long windowEnd, long paneSize) {\n+\t\t\tthis.windowEnd = windowEnd;\n+\t\t\tthis.paneSize = paneSize;\n+\t\t\tthis.paneStart = windowStart;\n+\t\t\tthis.paneEnd = windowStart + paneSize;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn paneEnd <= windowEnd;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic TimeWindow next() {\n+\t\t\tTimeWindow window = new TimeWindow(paneStart, paneEnd);\n+\t\t\tpaneStart += paneSize;\n+\t\t\tpaneEnd += paneSize;\n+\t\t\treturn window;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Iterator<TimeWindow> iterator() {\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t//  Utilities\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Creates a new {@link CumulativeWindowAssigner} that assigns\n+\t * elements to cumulative time windows based on the element timestamp.\n+\t *\n+\t * @param size  The max size of the generated windows.\n+\t * @param step The step interval for window size to increase of the generated windows.\n+\t * @return The time policy.\n+\t */\n+\tpublic static CumulativeWindowAssigner of(Duration size, Duration step) {\n+\t\treturn new CumulativeWindowAssigner(size.toMillis(), step.toMillis(), 0, true);", "originalCommit": "26d7b65b3e795a9aa597269fc04a00d38ef1a1ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2cd041a86351096a1cea72f0ef2b8a20c021c339", "url": "https://github.com/apache/flink/commit/2cd041a86351096a1cea72f0ef2b8a20c021c339", "message": "size -> maxSize", "committedDate": "2020-10-20T15:50:18Z", "type": "commit"}]}