{"pr_number": 10763, "pr_title": "[FLINK-14200][table] Fix NPE for Temporal Table Function Join when left side is a query instead of a source", "pr_createdAt": "2020-01-03T16:18:09Z", "pr_url": "https://github.com/apache/flink/pull/10763", "timeline": [{"oid": "99a0f74453ddeedb32a32b92daa19b2243621e7f", "url": "https://github.com/apache/flink/commit/99a0f74453ddeedb32a32b92daa19b2243621e7f", "message": "[FLINK-14200][table-planner] Fix NPE for Temporal Table Function Join when left side is a query instead of a source", "committedDate": "2020-01-03T16:15:01Z", "type": "commit"}, {"oid": "19e2bf9244667af4490f1463bdf48ba40d02e5ed", "url": "https://github.com/apache/flink/commit/19e2bf9244667af4490f1463bdf48ba40d02e5ed", "message": "[FLINK-14200][table-planner-blink] Fix NPE for Temporal Table Function Join when left side is a query instead of a source", "committedDate": "2020-01-03T16:15:11Z", "type": "commit"}, {"oid": "da8137a5c135ee86f12bd4cbd33f6aea77c06a14", "url": "https://github.com/apache/flink/commit/da8137a5c135ee86f12bd4cbd33f6aea77c06a14", "message": "fix checkstyle", "committedDate": "2020-01-04T02:59:04Z", "type": "commit"}, {"oid": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "url": "https://github.com/apache/flink/commit/0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "message": "fix  test", "committedDate": "2020-01-04T14:58:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwMjIzNQ==", "url": "https://github.com/apache/flink/pull/10763#discussion_r363202235", "bodyText": "nit: this comment is a bit misleading don't you think? It depends on the subsequent query what will be the view used for.\nAnyway it does not provide any extra info therefore personally I'm always against adding redundant comments as they easily go out of sync.", "author": "dawidwys", "createdAt": "2020-01-06T08:47:00Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -73,6 +73,21 @@ class TemporalJoinTest extends TableTestBase {\n     util.verifyPlan(sqlQuery)\n   }\n \n+  @Test\n+  def testJoinOnQueryLeft(): Unit = {\n+    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n+    // register a query as left side", "originalCommit": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIwOTY1MQ==", "url": "https://github.com/apache/flink/pull/10763#discussion_r363209651", "bodyText": "How about fixing the generic type of TimestampExtractor instead?\n      .fromCollection(ordersData)\n      .assignTimestampsAndWatermarks(new TimestampExtractor[(Long, String, String, Timestamp)]())\n\n\nclass TimestampExtractor[T <: Product]\n  extends BoundedOutOfOrdernessTimestampExtractor[T]", "author": "dawidwys", "createdAt": "2020-01-06T09:12:13Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price\n+        |FROM\n+        |  Orders AS o,\n+        |  LATERAL TABLE (Rates(o.rowtime)) AS r,\n+        |  LATERAL TABLE (Prices(o.rowtime)) AS p\n+        |WHERE r.currency = o.currency AND p.productId = o.productId\n+        |\"\"\".stripMargin\n+\n+    val ordersData = new mutable.MutableList[(Long, String, String, Timestamp)]\n+    ordersData.+=((2L, \"A1\", \"Euro\", new Timestamp(2L)))\n+    ordersData.+=((1L, \"A2\", \"US Dollar\", new Timestamp(3L)))\n+    ordersData.+=((50L, \"A4\", \"Yen\", new Timestamp(4L)))\n+    ordersData.+=((3L, \"A2\", \"Euro\", new Timestamp(5L)))\n+\n+    val ratesHistoryData = new mutable.MutableList[(String, Long, Timestamp)]\n+    ratesHistoryData.+=((\"US Dollar\", 102L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 114L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Yen\", 1L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 116L, new Timestamp(5L)))\n+    ratesHistoryData.+=((\"Euro\", 119L, new Timestamp(7L)))\n+\n+    val pricesHistoryData = new mutable.MutableList[(String, Double, Timestamp)]\n+    pricesHistoryData.+=((\"A2\", 10.2D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.4D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A4\", 1D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.6D, new Timestamp(5L)))\n+    pricesHistoryData.+=((\"A1\", 11.9D, new Timestamp(7L)))\n+\n+    val orders = env\n+      .fromCollection(ordersData)\n+      .asInstanceOf[DataStream[Product]]", "originalCommit": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIxNDkyOA==", "url": "https://github.com/apache/flink/pull/10763#discussion_r363214928", "bodyText": "If we are using a real world example, could we make it more useful?\nHow about:\nOrders\n  |- orderId: String\n  |- productId: String\n  |- amount: Long\n  |- timestamp: Timestamp\n\nRates\n  |- currency: String\n  |- rate: Double\n  |- timestamp: Timestamp\n\nPrices\n  |- productId: String\n  |- currency: String\n  |- price: Double\n  |- timestamp: Timestamp\n\nQuery:\nSELECT\n  o.orderId,\n  (o.amount * p.price * r.rate) as total_price\nFROM\n  Orders AS o,\n  LATERAL TABLE (Rates(o.rowtime)) AS r,\n  LATERAL TABLE (Prices(o.rowtime)) AS p\nWHERE\n  o.productId = p.productId AND \n  r.currency = p.currency", "author": "dawidwys", "createdAt": "2020-01-06T09:27:25Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price", "originalCommit": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIxNTk4NQ==", "url": "https://github.com/apache/flink/pull/10763#discussion_r363215985", "bodyText": "add a default branch:\ncase _ => throw new IllegalArgumentException(\"Expected the last element in a tuple to be of a Timestamp type.\")\n\nThis will make it easier to use this extractor in future tests.", "author": "dawidwys", "createdAt": "2020-01-06T09:30:24Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -158,11 +160,87 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     assertEquals(expectedOutput, sink.getAppendResults.toSet)\n   }\n+\n+  @Test\n+  def testNestedTemporalJoin(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val tEnv = StreamTableEnvironment.create(env, TableTestUtil.STREAM_SETTING)\n+    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n+\n+    val sqlQuery =\n+      \"\"\"\n+        |SELECT\n+        |  o.amount, r.rate, p.price\n+        |FROM\n+        |  Orders AS o,\n+        |  LATERAL TABLE (Rates(o.rowtime)) AS r,\n+        |  LATERAL TABLE (Prices(o.rowtime)) AS p\n+        |WHERE r.currency = o.currency AND p.productId = o.productId\n+        |\"\"\".stripMargin\n+\n+    val ordersData = new mutable.MutableList[(Long, String, String, Timestamp)]\n+    ordersData.+=((2L, \"A1\", \"Euro\", new Timestamp(2L)))\n+    ordersData.+=((1L, \"A2\", \"US Dollar\", new Timestamp(3L)))\n+    ordersData.+=((50L, \"A4\", \"Yen\", new Timestamp(4L)))\n+    ordersData.+=((3L, \"A2\", \"Euro\", new Timestamp(5L)))\n+\n+    val ratesHistoryData = new mutable.MutableList[(String, Long, Timestamp)]\n+    ratesHistoryData.+=((\"US Dollar\", 102L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 114L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Yen\", 1L, new Timestamp(1L)))\n+    ratesHistoryData.+=((\"Euro\", 116L, new Timestamp(5L)))\n+    ratesHistoryData.+=((\"Euro\", 119L, new Timestamp(7L)))\n+\n+    val pricesHistoryData = new mutable.MutableList[(String, Double, Timestamp)]\n+    pricesHistoryData.+=((\"A2\", 10.2D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.4D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A4\", 1D, new Timestamp(1L)))\n+    pricesHistoryData.+=((\"A1\", 11.6D, new Timestamp(5L)))\n+    pricesHistoryData.+=((\"A1\", 11.9D, new Timestamp(7L)))\n+\n+    val orders = env\n+      .fromCollection(ordersData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'amount, 'productId, 'currency, 'rowtime.rowtime)\n+    val ratesHistory = env\n+      .fromCollection(ratesHistoryData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'currency, 'rate, 'rowtime.rowtime)\n+    val pricesHistory = env\n+      .fromCollection(pricesHistoryData)\n+      .asInstanceOf[DataStream[Product]]\n+      .assignTimestampsAndWatermarks(new TimestampExtractor())\n+      .toTable(tEnv, 'productId, 'price, 'rowtime.rowtime)\n+\n+    tEnv.createTemporaryView(\"Orders\", orders)\n+    tEnv.createTemporaryView(\"RatesHistory\", ratesHistory)\n+    tEnv.registerFunction(\n+      \"Rates\",\n+      ratesHistory.createTemporalTableFunction(\"rowtime\", \"currency\"))\n+    tEnv.registerFunction(\n+      \"Prices\",\n+      pricesHistory.createTemporalTableFunction(\"rowtime\", \"productId\"))\n+\n+    tEnv.createTemporaryView(\"TemporalJoinResult\", tEnv.sqlQuery(sqlQuery))\n+\n+    // Scan from registered table to test for interplay between\n+    // LogicalCorrelateToTemporalTableJoinRule and TableScanRule\n+    val result = tEnv.from(\"TemporalJoinResult\").toAppendStream[Row]\n+    val sink = new TestingAppendSink\n+    result.addSink(sink)\n+    env.execute()\n+\n+    val expected = List(\"1,102,10.2\", \"3,116,10.2\", \"2,114,11.4\", \"50,1,1.0\")\n+    assertEquals(expected.sorted, sink.getAppendResults.sorted)\n+  }\n }\n \n-class TimestampExtractor[T1, T2]\n-  extends BoundedOutOfOrdernessTimestampExtractor[(T1, T2, Timestamp)](Time.seconds(10))  {\n-  override def extractTimestamp(element: (T1, T2, Timestamp)): Long = {\n-    element._3.getTime\n+class TimestampExtractor\n+  extends BoundedOutOfOrdernessTimestampExtractor[Product](Time.seconds(10))  {\n+  override def extractTimestamp(element: Product): Long = element match {\n+    case (_, _, ts: Timestamp) => ts.getTime\n+    case (_, _, _, ts: Timestamp) => ts.getTime", "originalCommit": "0bcdc9a62338aefab77a8277e87f10f8afcfc48e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f65244f166d33141c1d722a8244e4de4e4c9f1c", "url": "https://github.com/apache/flink/commit/6f65244f166d33141c1d722a8244e4de4e4c9f1c", "message": "address comments (blink planner)", "committedDate": "2020-01-06T10:34:31Z", "type": "commit"}, {"oid": "4311bd9a01f16b10d03ce1744c7baebd3c2872e4", "url": "https://github.com/apache/flink/commit/4311bd9a01f16b10d03ce1744c7baebd3c2872e4", "message": "address comments (old planner)", "committedDate": "2020-01-06T10:34:43Z", "type": "commit"}]}