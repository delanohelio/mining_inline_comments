{"pr_number": 12188, "pr_title": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser", "pr_createdAt": "2020-05-16T05:58:18Z", "pr_url": "https://github.com/apache/flink/pull/12188", "timeline": [{"oid": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "url": "https://github.com/apache/flink/commit/7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "message": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser", "committedDate": "2020-05-16T05:58:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzU0NQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426133545", "bodyText": "Mark both operands as nullable.", "author": "danny0405", "createdAt": "2020-05-16T08:41:57Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -194,6 +283,11 @@ private SqlCommandParser() {\n \t\tpublic final Pattern pattern;\n \t\tpublic final Function<String[], Optional<String[]>> operandConverter;\n \n+\t\tSqlCommand() {\n+\t\t\tthis.pattern = null;\n+\t\t\tthis.operandConverter = null;\n+\t\t}\n+\n \t\tSqlCommand(String matchingRegex, Function<String[], Optional<String[]>> operandConverter) {\n \t\t\tthis.pattern = Pattern.compile(matchingRegex, DEFAULT_PATTERN_FLAGS);", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzY4MQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426133681", "bodyText": "We should use equals instead of != to compare the operands.", "author": "danny0405", "createdAt": "2020-05-16T08:43:32Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -207,6 +301,10 @@ public String toString() {\n \t\tpublic boolean hasOperands() {\n \t\t\treturn operandConverter != NO_OPERANDS;\n \t\t}", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MDQyNw==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426140427", "bodyText": "NO_OPERANDS  is internal variable and NO_OPERANDS is a static final instance. we can use !=  to do compare", "author": "godfreyhe", "createdAt": "2020-05-16T10:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDAzMQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134031", "bodyText": "Move the whole if else block to a single class named OperationToSqlCommandConverter ? We also need to add tests for the mapping.", "author": "danny0405", "createdAt": "2020-05-16T08:47:10Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParserFunction, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t}\n+\n+\t\t// parse statement via regex match\n \t\tfor (SqlCommand cmd : SqlCommand.values()) {\n-\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n-\t\t\tif (matcher.matches()) {\n-\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n-\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n-\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\tif (cmd.hasRegexPattern()) {\n+\t\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n+\t\t\t\tif (matcher.matches()) {\n+\t\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n+\t\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n+\t\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn cmd.operandConverter.apply(groups)\n+\t\t\t\t\t\t\t.map((operands) -> {\n+\t\t\t\t\t\t\t\tString[] newOperands = operands;\n+\t\t\t\t\t\t\t\tif (cmd == SqlCommand.EXPLAIN) {\n+\t\t\t\t\t\t\t\t\t// convert `explain xx` to `explain plan for xx`\n+\t\t\t\t\t\t\t\t\tnewOperands = new String[] { \"EXPLAIN PLAN FOR \" + operands[0] };\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\treturn new SqlCommandCall(cmd, newOperands);\n+\t\t\t\t\t\t\t});\n \t\t\t\t}\n-\t\t\t\treturn cmd.operandConverter.apply(groups)\n-\t\t\t\t\t.map((operands) -> new SqlCommandCall(cmd, operands));\n \t\t\t}\n \t\t}\n \t\treturn Optional.empty();\n \t}\n \n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(\n+\t\t\tFunction<String, List<Operation>> sqlParserFunction, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParserFunction.apply(stmt);\n+\t\t} catch (SqlExecutionException e) {\n+\t\t\tif (e.getCause() instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MDUwNg==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426140506", "bodyText": "The mapping logic is tested in SqlCommandParserTest", "author": "godfreyhe", "createdAt": "2020-05-16T10:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDAzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MDMzNQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426150335", "bodyText": "Let's see if we can make some refactoring here, the code now is a mess.", "author": "danny0405", "createdAt": "2020-05-16T12:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDE5OA==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134198", "bodyText": "It is hacky to support a non-common syntax and replace it silently, i think support EXPLAIN PLAN FOR is enough.", "author": "danny0405", "createdAt": "2020-05-16T08:49:11Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParserFunction, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t}\n+\n+\t\t// parse statement via regex match\n \t\tfor (SqlCommand cmd : SqlCommand.values()) {\n-\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n-\t\t\tif (matcher.matches()) {\n-\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n-\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n-\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\tif (cmd.hasRegexPattern()) {\n+\t\t\t\tfinal Matcher matcher = cmd.pattern.matcher(stmt);\n+\t\t\t\tif (matcher.matches()) {\n+\t\t\t\t\tfinal String[] groups = new String[matcher.groupCount()];\n+\t\t\t\t\tfor (int i = 0; i < groups.length; i++) {\n+\t\t\t\t\t\tgroups[i] = matcher.group(i + 1);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn cmd.operandConverter.apply(groups)\n+\t\t\t\t\t\t\t.map((operands) -> {\n+\t\t\t\t\t\t\t\tString[] newOperands = operands;\n+\t\t\t\t\t\t\t\tif (cmd == SqlCommand.EXPLAIN) {\n+\t\t\t\t\t\t\t\t\t// convert `explain xx` to `explain plan for xx`", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MDYwNw==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426140607", "bodyText": "I want do that, but we should treat EXPLAIN as public interface, we can't remove this directly", "author": "godfreyhe", "createdAt": "2020-05-16T10:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MDMxNw==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426150317", "bodyText": "After a offline discussion, we have a TODO to refactor the commands in SQL-CLI to keep them more in line with TableEnv, so it's not a big deal currently.", "author": "danny0405", "createdAt": "2020-05-16T12:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDc4OA==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134788", "bodyText": "How about we just split 2 methods parseByExecutor and parseByCli, parse a function here seems weird, because the first operand of the sqlParserFunction  is just the stmt.", "author": "danny0405", "createdAt": "2020-05-16T08:56:38Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,29 +58,131 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Function<String, List<Operation>> sqlParserFunction, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MTE2OQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426141169", "bodyText": "for the SqlCommandParser users, they do not need to know how to parse a statement, so I think we should only provide one entry point method. I can extract the regex matching part into a method. for sqlParserFunction, how about pass it into SqlCommandParser through constructor, that means we should make parse method as a non-static method ?", "author": "godfreyhe", "createdAt": "2020-05-16T10:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MDI1OQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426150259", "bodyText": "How about just add method #parse(Parser, String), and add a new interface Executor#getParser.", "author": "danny0405", "createdAt": "2020-05-16T12:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDkyNA==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426134924", "bodyText": "It's a ParserUtils but why we register table there ?", "author": "danny0405", "createdAt": "2020-05-16T08:58:44Z", "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/utils/ParserUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.client.cli.utils;\n+\n+import org.apache.flink.table.api.EnvironmentSettings;\n+import org.apache.flink.table.api.TableEnvironment;\n+import org.apache.flink.table.api.internal.TableEnvironmentInternal;\n+import org.apache.flink.table.client.gateway.SqlExecutionException;\n+import org.apache.flink.table.operations.Operation;\n+\n+import java.util.List;\n+\n+/**\n+ * An utility class that provides abilities to parse sql statements.\n+ */\n+public class ParserUtils {\n+\n+\tprivate static final TableEnvironment tableEnv = TableEnvironment.create(EnvironmentSettings.newInstance().build());\n+\n+\tstatic {\n+\t\ttableEnv.executeSql(\"create table MyTable (a int, b bigint, c varchar(32)) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");\n+\t\ttableEnv.executeSql(\"create table MyOtherTable (a int, b bigint) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");", "originalCommit": "7111bcfcc655d8d6b0ee5f9ff66e80e732f7272e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MDc2Mg==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426140762", "bodyText": "prepare some tables for testing. now Parser#parse contains validation logic, we should make sure the table in a statement exists. I can add some comments here", "author": "godfreyhe", "createdAt": "2020-05-16T10:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MDQyNQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426150425", "bodyText": "I think the tool class should be stateless, or we make a common data structure there with pre-registered tables there only for testing.", "author": "danny0405", "createdAt": "2020-05-16T12:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzNDkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTY1Ng==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426335656", "bodyText": "return Optional.empty(); directly.", "author": "danny0405", "createdAt": "2020-05-18T01:54:14Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,24 +61,130 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Parser sqlParser, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParser, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t} else {\n+\t\t\treturn parseByRegexMatching(stmt);\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(Parser sqlParser, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParser.parse(stmt);\n+\t\t} catch (Throwable e) {\n+\t\t\tif (e instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow new SqlExecutionException(\"Invalidate SQL statement.\", e);\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };\n+\t\t} else if (operation instanceof UseDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.USE;\n+\t\t\tUseDatabaseOperation op = ((UseDatabaseOperation) operation);\n+\t\t\toperands = new String[] { String.format(\"`%s`.`%s`\", op.getCatalogName(), op.getDatabaseName()) };\n+\t\t} else if (operation instanceof ShowCatalogsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_CATALOGS;\n+\t\t} else if (operation instanceof ShowDatabasesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_DATABASES;\n+\t\t} else if (operation instanceof ShowTablesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_TABLES;\n+\t\t} else if (operation instanceof ShowFunctionsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_FUNCTIONS;\n+\t\t} else if (operation instanceof ExplainOperation) {\n+\t\t\tcmd = SqlCommand.EXPLAIN;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DescribeTableOperation) {\n+\t\t\tcmd = SqlCommand.DESCRIBE;\n+\t\t\toperands = new String[] { ((DescribeTableOperation) operation).getSqlIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof QueryOperation) {\n+\t\t\tcmd = SqlCommand.SELECT;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else {\n+\t\t\tcmd = null;", "originalCommit": "48e61b51442e40d0de50c315a9850aae80c4396b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTc2Nw==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426335767", "bodyText": "Most of the operations has the same operands new String[] { stmt }; can we merge the handling of them ?", "author": "danny0405", "createdAt": "2020-05-18T01:54:55Z", "path": "flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/SqlCommandParser.java", "diffHunk": "@@ -34,24 +61,130 @@ private SqlCommandParser() {\n \t\t// private\n \t}\n \n-\tpublic static Optional<SqlCommandCall> parse(String stmt) {\n+\tpublic static Optional<SqlCommandCall> parse(Parser sqlParser, String stmt) {\n \t\t// normalize\n \t\tstmt = stmt.trim();\n \t\t// remove ';' at the end\n \t\tif (stmt.endsWith(\";\")) {\n \t\t\tstmt = stmt.substring(0, stmt.length() - 1).trim();\n \t\t}\n \n-\t\t// parse\n+\t\t// parse statement via sql parser first\n+\t\tOptional<SqlCommandCall> callOpt = parseBySqlParser(sqlParser, stmt);\n+\t\tif (callOpt.isPresent()) {\n+\t\t\treturn callOpt;\n+\t\t} else {\n+\t\t\treturn parseByRegexMatching(stmt);\n+\t\t}\n+\t}\n+\n+\tprivate static Optional<SqlCommandCall> parseBySqlParser(Parser sqlParser, String stmt) {\n+\t\tList<Operation> operations;\n+\t\ttry {\n+\t\t\toperations = sqlParser.parse(stmt);\n+\t\t} catch (Throwable e) {\n+\t\t\tif (e instanceof ValidationException) {\n+\t\t\t\t// can be parsed via sql parser, but is not validated.\n+\t\t\t\t// throw exception directly\n+\t\t\t\tthrow new SqlExecutionException(\"Invalidate SQL statement.\", e);\n+\t\t\t}\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tif (operations.size() != 1) {\n+\t\t\tthrow new SqlExecutionException(\"Only single statement is supported now.\");\n+\t\t}\n+\n+\t\tfinal SqlCommand cmd;\n+\t\tString[] operands = new String[0];\n+\t\tOperation operation = operations.get(0);\n+\t\tif (operation instanceof CatalogSinkModifyOperation) {\n+\t\t\tboolean overwrite = ((CatalogSinkModifyOperation) operation).isOverwrite();\n+\t\t\tcmd = overwrite ? SqlCommand.INSERT_OVERWRITE : SqlCommand.INSERT_INTO;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateTableOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropTableOperation) {\n+\t\t\tcmd = SqlCommand.DROP_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterTableOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_TABLE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateViewOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_VIEW;\n+\t\t\tCreateViewOperation op = (CreateViewOperation) operation;\n+\t\t\toperands = new String[] { op.getViewIdentifier().asSerializableString(),\n+\t\t\t\t\top.getCatalogView().getOriginalQuery() };\n+\t\t} else if (operation instanceof DropViewOperation) {\n+\t\t\tcmd = SqlCommand.DROP_VIEW;\n+\t\t\toperands = new String[] { ((DropViewOperation) operation).getViewIdentifier().asSerializableString() };\n+\t\t} else if (operation instanceof CreateDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DropDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.DROP_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof AlterDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.ALTER_DATABASE;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof CreateCatalogOperation) {\n+\t\t\tcmd = SqlCommand.CREATE_CATALOG;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof UseCatalogOperation) {\n+\t\t\tcmd = SqlCommand.USE_CATALOG;\n+\t\t\toperands = new String[] { String.format(\"`%s`\", ((UseCatalogOperation) operation).getCatalogName()) };\n+\t\t} else if (operation instanceof UseDatabaseOperation) {\n+\t\t\tcmd = SqlCommand.USE;\n+\t\t\tUseDatabaseOperation op = ((UseDatabaseOperation) operation);\n+\t\t\toperands = new String[] { String.format(\"`%s`.`%s`\", op.getCatalogName(), op.getDatabaseName()) };\n+\t\t} else if (operation instanceof ShowCatalogsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_CATALOGS;\n+\t\t} else if (operation instanceof ShowDatabasesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_DATABASES;\n+\t\t} else if (operation instanceof ShowTablesOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_TABLES;\n+\t\t} else if (operation instanceof ShowFunctionsOperation) {\n+\t\t\tcmd = SqlCommand.SHOW_FUNCTIONS;\n+\t\t} else if (operation instanceof ExplainOperation) {\n+\t\t\tcmd = SqlCommand.EXPLAIN;\n+\t\t\toperands = new String[] { stmt };\n+\t\t} else if (operation instanceof DescribeTableOperation) {", "originalCommit": "48e61b51442e40d0de50c315a9850aae80c4396b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODE2Mw==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426428163", "bodyText": "we can change the default value from new String[0] to new String[] { stmt }", "author": "godfreyhe", "createdAt": "2020-05-18T07:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODA5OQ==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426338099", "bodyText": "Can invoke registerTable(String createTableStmt) instead.", "author": "danny0405", "createdAt": "2020-05-18T02:09:02Z", "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/utils/SqlParserHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.client.cli.utils;\n+\n+import org.apache.flink.table.api.EnvironmentSettings;\n+import org.apache.flink.table.api.TableEnvironment;\n+import org.apache.flink.table.api.internal.TableEnvironmentInternal;\n+import org.apache.flink.table.delegation.Parser;\n+\n+/**\n+ * An utility class that provides pre-prepared tables and sql parser.\n+ */\n+public class SqlParserHelper {\n+\t// return the sql parser instance hold by this table evn.\n+\tprivate final TableEnvironment tableEnv;\n+\n+\tpublic SqlParserHelper() {\n+\t\ttableEnv = TableEnvironment.create(EnvironmentSettings.newInstance().build());\n+\t}\n+\n+\t/**\n+\t * prepare some tables for testing.\n+\t */\n+\tpublic void registerTables() {\n+\t\ttableEnv.executeSql(\"create table MyTable (a int, b bigint, c varchar(32)) \" +\n+\t\t\t\t\"with ('connector' = 'filesystem', 'path' = '/non')\");", "originalCommit": "48e61b51442e40d0de50c315a9850aae80c4396b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODIzOA==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426338238", "bodyText": "Why drop the SELEC completion test ?", "author": "danny0405", "createdAt": "2020-05-18T02:09:54Z", "path": "flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/CliClientTest.java", "diffHunk": "@@ -90,9 +92,9 @@ public void testFailedUpdateSubmission() throws Exception {\n \n \t@Test\n \tpublic void testSqlCompletion() throws IOException {\n-\t\tverifySqlCompletion(\"\", 0, Arrays.asList(\"SELECT\", \"QUIT;\", \"RESET;\"), Collections.emptyList());\n-\t\tverifySqlCompletion(\"SELEC\", 5, Collections.singletonList(\"SELECT\"), Collections.singletonList(\"QUIT;\"));\n-\t\tverifySqlCompletion(\"SELE\", 0, Collections.singletonList(\"SELECT\"), Collections.singletonList(\"QUIT;\"));\n+\t\tverifySqlCompletion(\"\", 0, Arrays.asList(\"SOURCE\", \"QUIT;\", \"RESET;\"), Collections.emptyList());", "originalCommit": "48e61b51442e40d0de50c315a9850aae80c4396b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNjMwNg==", "url": "https://github.com/apache/flink/pull/12188#discussion_r426426306", "bodyText": "before this pr, all commands are hint candidates. after this refactor,  only the commands who has regex pattern are hint candidates, or fallback to Table API hinting (will delegate to tableEnv.getCompletionHints in LocalExecutor). in MockExecutor, completeStatement method only returns HintA and Hint B", "author": "godfreyhe", "createdAt": "2020-05-18T07:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzODIzOA=="}], "type": "inlineReview"}, {"oid": "ec741956533afdfa34f6876b0a0d7c346c3f5db5", "url": "https://github.com/apache/flink/commit/ec741956533afdfa34f6876b0a0d7c346c3f5db5", "message": "[FLINK-17728] [sql-client] sql client supports parser statements via sql parser", "committedDate": "2020-05-18T13:19:27Z", "type": "commit"}, {"oid": "daa6a5f09c11116a555969b31e9e594eaf91ae30", "url": "https://github.com/apache/flink/commit/daa6a5f09c11116a555969b31e9e594eaf91ae30", "message": "address danny's comments", "committedDate": "2020-05-18T13:23:30Z", "type": "commit"}, {"oid": "5426fe3fa668e07dfe99c7b12aac678a2549bb3d", "url": "https://github.com/apache/flink/commit/5426fe3fa668e07dfe99c7b12aac678a2549bb3d", "message": "fix checkstyle error", "committedDate": "2020-05-18T13:23:34Z", "type": "commit"}, {"oid": "aae4f45fd18320222d790dffcda117e02cb64e5e", "url": "https://github.com/apache/flink/commit/aae4f45fd18320222d790dffcda117e02cb64e5e", "message": "address comments", "committedDate": "2020-05-18T13:58:42Z", "type": "commit"}, {"oid": "aae4f45fd18320222d790dffcda117e02cb64e5e", "url": "https://github.com/apache/flink/commit/aae4f45fd18320222d790dffcda117e02cb64e5e", "message": "address comments", "committedDate": "2020-05-18T13:58:42Z", "type": "forcePushed"}]}