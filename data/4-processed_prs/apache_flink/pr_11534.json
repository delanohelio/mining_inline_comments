{"pr_number": 11534, "pr_title": "[FLINK-16537][network] Implement ResultPartition state recovery for unaligned checkpoint", "pr_createdAt": "2020-03-26T14:57:30Z", "pr_url": "https://github.com/apache/flink/pull/11534", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MzQ5Nw==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400453497", "bodyText": "nit: we can get rid of this variable using for loop\nnit: import constant could improve readability", "author": "rkhachatryan", "createdAt": "2020-03-30T19:52:13Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -89,6 +91,25 @@\n \t\tsuper(index, parent);\n \t}\n \n+\t@Override\n+\tpublic void initializeState() throws IOException, InterruptedException {\n+\t\tReadResult readResult = ReadResult.HAS_MORE_DATA;", "originalCommit": "d0d0b6fef21a118932e878255aa40f10f17fe753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxNDk5Mg==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400614992", "bodyText": "we can get rid of this variable using for loop\n\nI guess you mean the way via while(true) and break the loop inside while. I also tried that way in first version, but it seems not very suggested by intelliJ.", "author": "zhijiangW", "createdAt": "2020-03-31T03:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MzQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0ODk1OA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400748958", "bodyText": "I mean something like this:\nfor (ReadResult readResult = HAS_MORE_DATA; readResult == HAS_MORE_DATA; ) {\n    readResult = read ...\n}", "author": "rkhachatryan", "createdAt": "2020-03-31T08:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MzQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1NjY4MA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400756680", "bodyText": "It is interesting and actually I have not tried out this way before. Actually we still have the variable definition in for way and they are same in essence. Only reduce one line in practice. I can try out it for your favor. :)", "author": "zhijiangW", "createdAt": "2020-03-31T09:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MzQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1NTg2NA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400455864", "bodyText": "I see initializeState is called by parent.\nWhy not to pass ChannelStateReader as a parameter to initializeState then?\n(this would decrease coupling and increase testability)", "author": "rkhachatryan", "createdAt": "2020-03-30T19:56:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -89,6 +91,25 @@\n \t\tsuper(index, parent);\n \t}\n \n+\t@Override\n+\tpublic void initializeState() throws IOException, InterruptedException {\n+\t\tReadResult readResult = ReadResult.HAS_MORE_DATA;\n+\t\twhile (readResult == ReadResult.HAS_MORE_DATA) {\n+\t\t\tBufferBuilder bufferBuilder = parent.getBufferPool().requestBufferBuilderBlocking();\n+\t\t\tBufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();\n+\t\t\treadResult = parent.getChannelStateReader().readOutputData(subpartitionInfo, bufferBuilder);", "originalCommit": "d0d0b6fef21a118932e878255aa40f10f17fe753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTc1OQ==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400619759", "bodyText": "I think it is not so necessary to decouple ResultPartition with ResultSubpartition, because the ResultSubpartition is derived from ResultPartition and it can get everything from parent by design. In the constructor of ResultSubpartition, ResultPartition is already passed as argument and defined as protected variable to be referenced directly by any kind of subpartitions. So we do not destroy the existing rules or add any new rules. Also for tests, the separate PipelinedSubpartitionTest still needs to construct parent ResultPartition in practice.\nBut your comment makes me think of another possible option, to pass ChannelStateReader into ResultPartitionWriter#initializeState, then we do not need to pass it into constructor to touch many components.", "author": "zhijiangW", "createdAt": "2020-03-31T03:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1NTg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1Mzg4Mw==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400753883", "bodyText": "But your comment makes me think of another possible option, to pass ChannelStateReader into ResultPartitionWriter#initializeState, then we do not need to pass it into constructor to touch many components.\n\nThis is exactly what I meant by\n\nWhy not to pass ChannelStateReader as a parameter to initializeState then?\n\nSo, instead of having channelStateReader field anywhere I'd pass it from StreamTask\nto ResultPartitionWriter.initializeState()\nto ResultPartition.initializeState()\nto ResultSubpartition.initializeState()\nSorry for the confusion", "author": "rkhachatryan", "createdAt": "2020-03-31T09:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1NTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Nzk3Mw==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400457973", "bodyText": "I guess update() was added to read the value that was written in ChannelStateReader?\nWouldn't creation of bufferConsumer after readOutputData() have the same effect?", "author": "rkhachatryan", "createdAt": "2020-03-30T20:00:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -89,6 +91,25 @@\n \t\tsuper(index, parent);\n \t}\n \n+\t@Override\n+\tpublic void initializeState() throws IOException, InterruptedException {\n+\t\tReadResult readResult = ReadResult.HAS_MORE_DATA;\n+\t\twhile (readResult == ReadResult.HAS_MORE_DATA) {\n+\t\t\tBufferBuilder bufferBuilder = parent.getBufferPool().requestBufferBuilderBlocking();\n+\t\t\tBufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();\n+\t\t\treadResult = parent.getChannelStateReader().readOutputData(subpartitionInfo, bufferBuilder);\n+\n+\t\t\t// check whether there are some states data filled in this time\n+\t\t\tbufferConsumer.update();", "originalCommit": "d0d0b6fef21a118932e878255aa40f10f17fe753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyMzExNA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400623114", "bodyText": "I guess update() was added to read the value that was written in ChannelStateReader?\n\nNot really. The update() is used for checking whether there are any data written in above readOutputData call. And it is actually used together with below bufferConsumer.getWrittenBytes(). There are actually two implicit limitations here:\n\n\nThe ReadResult from ChannelStateReader only indicates the future situation, not indicates whether the current call actually reads data or not, especially for the first call. So we have to judge whether the passed BufferBuilder has written any data or not.\n\n\nThe cached position is only updated after calling BufferConsumer#build() atm. In order to check the written position before constructing the slice buffer, we have to call update() explicitly before calling bufferConsumer.getWrittenBytes(). I ever tried to break this rule to also add the update() inside BufferConsumer#getWrittenBytes() and BufferConsumer#isFinished(). But it would bring many unit tests failure and break previous design of BufferConsumer which might bring additional discussions. So I introduce another separate update() from BufferConsumer which can be used by demand.\n\n\n\nWouldn't creation of bufferConsumer after readOutputData() have the same effect?\n\nActually not. The property usage is to to create BufferConsumer firstly, and then written data into BufferBuilder. Otherwise the delay creation of BufferConsumer can not see the data written before creation.", "author": "zhijiangW", "createdAt": "2020-03-31T03:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Nzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc4MjU3Ng==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400782576", "bodyText": "I actually meant the committed writer position by value. Bad wording, sorry.\nI see, we shouldn't change the creation order.\nBut can we use BufferConsumer.isDataAvailable instead of update() + getWrittenBytes()?\npublic boolean isDataAvailable() {\n\treturn currentReaderPosition < writerPosition.getLatest();\n}", "author": "rkhachatryan", "createdAt": "2020-03-31T09:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Nzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4NjY5MA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400886690", "bodyText": "I am also fine with the way of isDataAvailable.", "author": "zhijiangW", "createdAt": "2020-03-31T12:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Nzk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2MzM3MA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400463370", "bodyText": "The same as for PipelinedSubpartition: I think it's better to pass channelStateReader as a parameter to initializeState (to reduce coupling and other benefits).", "author": "rkhachatryan", "createdAt": "2020-03-30T20:10:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartition.java", "diffHunk": "@@ -107,6 +108,8 @@\n \t@Nullable\n \tprotected final BufferCompressor bufferCompressor;\n \n+\tprivate final ChannelStateReader channelStateReader;\n+", "originalCommit": "d0d0b6fef21a118932e878255aa40f10f17fe753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyMzMwMA==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400623300", "bodyText": "Replied above.", "author": "zhijiangW", "createdAt": "2020-03-31T03:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2MzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTA3Mg==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400485072", "bodyText": "Should we close the reader here? Or it will be used for InputChannels later?", "author": "rkhachatryan", "createdAt": "2020-03-30T20:49:51Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -434,6 +434,13 @@ protected void beforeInvoke() throws Exception {\n \t\t\t// so that we avoid race conditions in the case that initializeState()\n \t\t\t// registers a timer, that fires before the open() is called.\n \t\t\toperatorChain.initializeStateAndOpenOperators(createStreamTaskStateInitializer());\n+\n+\t\t\tResultPartitionWriter[] writers = getEnvironment().getAllWriters();\n+\t\t\tif (writers != null) {\n+\t\t\t\tfor (ResultPartitionWriter writer : writers) {\n+\t\t\t\t\twriter.initializeState();\n+\t\t\t\t}\n+\t\t\t}", "originalCommit": "d0d0b6fef21a118932e878255aa40f10f17fe753", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyNTg3Nw==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400625877", "bodyText": "The reader would also be used for input side for recovery in another PR. Have you considered when to close it in your PR? The ChannelStateReader is a task-level component and passed into Environment to be used anywhere in theory. Input and output sides are the users for reader ATM, but they should not be aware whether there are other users. So they should not close it after using . The proper way might consider its lifecycle together with task's lifecycle. WDYT?", "author": "zhijiangW", "createdAt": "2020-03-31T03:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2MTY0MQ==", "url": "https://github.com/apache/flink/pull/11534#discussion_r400761641", "bodyText": "Yes, I fully agree with what you point. In my PR, I'm closing it in Task.releaseResources. Just wanted to make sure that we can't close it sooner.\nIn ChannelStreamReaderImpl, the underlying streams are closed as soon as all the data is read from them, so it shouldn't be an issue.", "author": "rkhachatryan", "createdAt": "2020-03-31T09:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTA3Mg=="}], "type": "inlineReview"}, {"oid": "9e82da175780aa6a6ef19272a41c9a4796621e1a", "url": "https://github.com/apache/flink/commit/9e82da175780aa6a6ef19272a41c9a4796621e1a", "message": "[FLINK-16537][network] Implement ResultPartition state recovery for unaligned checkpoint\n\nDuring state recovery for unaligned checkpoint, the partition state should also be recovered besides with existing operator states.\n\nThe ResultPartition would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.\nThe filled buffer would be inserted into respective ResultSubpartition queue in normal way.\n\nIt should guarantee that op can not process any inputs before finishing all the output recovery to avoid mis-order issue.", "committedDate": "2020-04-03T03:08:56Z", "type": "forcePushed"}, {"oid": "2670a045bd9c9c4c75e7a22bf188fc673c85a062", "url": "https://github.com/apache/flink/commit/2670a045bd9c9c4c75e7a22bf188fc673c85a062", "message": "[FLINK-16537][network] Implement ResultPartition state recovery for unaligned checkpoint\n\nDuring state recovery for unaligned checkpoint, the partition state should also be recovered besides with existing operator states.\n\nThe ResultPartition would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.\nThe filled buffer would be inserted into respective ResultSubpartition queue in normal way.\n\nIt should guarantee that op can not process any inputs before finishing all the output recovery to avoid mis-order issue.", "committedDate": "2020-04-03T05:00:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwNjMwMQ==", "url": "https://github.com/apache/flink/pull/11534#discussion_r402906301", "bodyText": "nit: space", "author": "AHeise", "createdAt": "2020-04-03T10:20:31Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java", "diffHunk": "@@ -464,6 +456,59 @@ public void testIsAvailableOrNot() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testEmitRecordWithPartitionStateRecovery() throws Exception {\n+\t\tfinal int totalBuffers = 10; // enough for both states and normal records\n+\t\tfinal int totalStates = 2;\n+\t\tfinal int[] states = {1, 2, 3, 4};\n+\t\tfinal int[] records = {5, 6, 7, 8};\n+\t\tfinal int bufferSize = states.length * Integer.BYTES;\n+\n+\t\tfinal NetworkBufferPool globalPool = new NetworkBufferPool(totalBuffers, bufferSize , 1);", "originalCommit": "2670a045bd9c9c4c75e7a22bf188fc673c85a062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c34e52b4461b08091ce2d019537d2ceda1ca068b", "url": "https://github.com/apache/flink/commit/c34e52b4461b08091ce2d019537d2ceda1ca068b", "message": "[FLINK-16537][network] Implement ResultPartition state recovery for unaligned checkpoint\n\nDuring state recovery for unaligned checkpoint, the partition state should also be recovered besides with existing operator states.\n\nThe ResultPartition would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.\nThe filled buffer would be inserted into respective ResultSubpartition queue in normal way.\n\nIt should guarantee that op can not process any inputs before finishing all the output recovery to avoid mis-order issue.", "committedDate": "2020-04-07T09:57:18Z", "type": "commit"}, {"oid": "c34e52b4461b08091ce2d019537d2ceda1ca068b", "url": "https://github.com/apache/flink/commit/c34e52b4461b08091ce2d019537d2ceda1ca068b", "message": "[FLINK-16537][network] Implement ResultPartition state recovery for unaligned checkpoint\n\nDuring state recovery for unaligned checkpoint, the partition state should also be recovered besides with existing operator states.\n\nThe ResultPartition would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.\nThe filled buffer would be inserted into respective ResultSubpartition queue in normal way.\n\nIt should guarantee that op can not process any inputs before finishing all the output recovery to avoid mis-order issue.", "committedDate": "2020-04-07T09:57:18Z", "type": "forcePushed"}]}