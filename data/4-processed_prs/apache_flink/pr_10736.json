{"pr_number": 10736, "pr_title": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "pr_createdAt": "2020-01-01T15:45:14Z", "pr_url": "https://github.com/apache/flink/pull/10736", "timeline": [{"oid": "72711436341661fa90f495a529b3cc616b8df7ec", "url": "https://github.com/apache/flink/commit/72711436341661fa90f495a529b3cc616b8df7ec", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "committedDate": "2020-01-01T15:47:01Z", "type": "forcePushed"}, {"oid": "4b605068e32d3eb15a51f838ed29918d1224959a", "url": "https://github.com/apache/flink/commit/4b605068e32d3eb15a51f838ed29918d1224959a", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "committedDate": "2020-01-01T15:50:29Z", "type": "forcePushed"}, {"oid": "9430066683a67318f9685de8a58904972c5dbaca", "url": "https://github.com/apache/flink/commit/9430066683a67318f9685de8a58904972c5dbaca", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "committedDate": "2020-01-02T02:19:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxMTk4NQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r363711985", "bodyText": "Can we always add the shutdown hook to remove the argument deleteOnShutdown?", "author": "zhijiangW", "createdAt": "2020-01-07T11:46:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -51,12 +52,30 @@\n \t/** The number of the next path to use. */\n \tprivate volatile int nextPath;\n \n+\tprivate final String prefix;\n+\n+\tprivate final Thread shutdownHook;\n+\n \tpublic FileChannelManagerImpl(String[] tempDirs, String prefix) {\n+\t\tthis(tempDirs, prefix, false);\n+\t}\n+\n+\tpublic FileChannelManagerImpl(String[] tempDirs, String prefix, boolean deleteOnShutdown) {\n \t\tcheckNotNull(tempDirs, \"The temporary directories must not be null.\");\n \t\tcheckArgument(tempDirs.length > 0, \"The temporary directories must not be empty.\");\n \n \t\tthis.random = new Random();\n \t\tthis.nextPath = 0;\n+\t\tthis.prefix = prefix;\n+\n+\t\tif (deleteOnShutdown) {\n+\t\t\tshutdownHook = ShutdownHookUtil.addShutdownHook(this, String.format(\"%s-%s\", getClass().getSimpleName(), prefix), LOG);", "originalCommit": "9430066683a67318f9685de8a58904972c5dbaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0NDEzMw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r364544133", "bodyText": "This is due to in this PR I think it should be better to not affect the current behaviors of IOManager.  Although IOManager also have the problem that register shutdown hook after the directories are created, I think it might be better to fix it in separate PR if we agree with how to deal with it. Since IOManager already has a shutdown hook, for IOManager we also need to allow the FileChannelManagerImpl#close be closed for multiple times (i.e., using closed flag to skip cleanup in repeat close calls).", "author": "gaoyunhaii", "createdAt": "2020-01-09T03:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxMTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0MjQ5OQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r365642499", "bodyText": "I got the point now.\nI think it is better to make FileChannelManagerImpl always have the shutdownHook, and then it does not need judge whether it is null in other usages. Also it does not need to care about this argument deleteOnShutdown to true or false for upper component.\nIn order to avoid repeated close calling by IOManager usage, we can add the atomic boolean var in FileChannelManagerImpl and check this state in other usages as well.", "author": "zhijiangW", "createdAt": "2020-01-13T04:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxMTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MjQ0NA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r365662444", "bodyText": "If the shutdown hook only supports the following systems, maybe it is better to not fail for other systems, i mean this test can be ignored directly instead of failing.", "author": "zhijiangW", "createdAt": "2020-01-13T06:52:26Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()", "originalCommit": "9430066683a67318f9685de8a58904972c5dbaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzMzQ0Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r366133442", "bodyText": "I think assumeTrue would skip the tests if conditions not satisfied, it will not cause the test fails.", "author": "gaoyunhaii", "createdAt": "2020-01-14T03:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MjQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNjU0Ng==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368406546", "bodyText": "Sorry I read it wrong as assertTrue. Ignore my previous comment.", "author": "zhijiangW", "createdAt": "2020-01-20T07:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzIzNA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r365663234", "bodyText": "It is too heavy-height to start the cluster besides the preparation of above configuration and writer. We can construct the FileChannelManagerImpl via TestJvmProcess directly for simple. Actually we only want to verify that the new added shutdown hook to FileChannelManagerImpl work correctly, no matter which component covers it.", "author": "zhijiangW", "createdAt": "2020-01-13T06:56:46Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile confDir = temporaryFolder.newFolder();\n+\t\tFile confFile = new File(confDir + \"/flink-conf.yaml\");\n+\n+\t\tFile taskManagerTmpDir = temporaryFolder.newFolder();\n+\n+\t\tConfiguration config = new Configuration();\n+\t\tconfig.setString(JobManagerOptions.ADDRESS, \"localhost\");\n+\t\tconfig.setString(RestOptions.BIND_PORT, \"0\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_MODE, \"zookeeper\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());\n+\t\tconfig.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getAbsolutePath());\n+\t\tconfig.setString(CoreOptions.TMP_DIRS, taskManagerTmpDir.getAbsolutePath());\n+\t\tconfig.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, \"4m\");\n+\t\tconfig.setInteger(NettyShuffleEnvironmentOptions.NETWORK_NUM_BUFFERS, 100);\n+\t\tconfig.setString(TaskManagerOptions.TOTAL_FLINK_MEMORY, \"512m\");\n+\n+\t\ttry (FileOutputStream fos = new FileOutputStream(confFile);\n+\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos))) {\n+\t\t\tfor (Map.Entry<String, String> e : config.toMap().entrySet()) {\n+\t\t\t\twriter.write(e.getKey());\n+\t\t\t\twriter.write(\": \");\n+\t\t\t\twriter.write(e.getValue());\n+\t\t\t\twriter.newLine();\n+\t\t\t}\n+\n+\t\t\twriter.flush();\n+\t\t}\n+\n+\t\tTaskManagerProcess taskManagerProcess = null;\n+\n+\t\ttry (final StandaloneSessionClusterEntrypoint clusterEntrypoint = new StandaloneSessionClusterEntrypoint(config)) {", "originalCommit": "9430066683a67318f9685de8a58904972c5dbaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzcxNg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r365663716", "bodyText": "In addition, we should rename NettyShuffleEnvironmentCleanupTest to FileChannelManagerImplTest instead.", "author": "zhijiangW", "createdAt": "2020-01-13T06:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzMzUyMg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r366133522", "bodyText": "Agree with that and I have modified the test accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-14T03:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzUwMw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r365663503", "bodyText": "we should add a finally part to cleanup the FileChannelManagerImpl as the bottom line. In case this test fails unexpected, we still do not leak any files.", "author": "zhijiangW", "createdAt": "2020-01-13T06:58:14Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentCleanupTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network;\n+\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.CoreOptions;\n+import org.apache.flink.configuration.HighAvailabilityOptions;\n+import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;\n+import org.apache.flink.configuration.RestOptions;\n+import org.apache.flink.configuration.TaskManagerOptions;\n+import org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint;\n+import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;\n+import org.apache.flink.util.OperatingSystem;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.createTemporaryLog4JProperties;\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Verifies whether netty shuffle releases all the resources on shutdown, like the temporary directories.\n+ */\n+public class NettyShuffleEnvironmentCleanupTest {\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Rule\n+\tpublic final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();\n+\n+\t@Test\n+\tpublic void testRemovingTmpDirectoriesOnSignals() throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile confDir = temporaryFolder.newFolder();\n+\t\tFile confFile = new File(confDir + \"/flink-conf.yaml\");\n+\n+\t\tFile taskManagerTmpDir = temporaryFolder.newFolder();\n+\n+\t\tConfiguration config = new Configuration();\n+\t\tconfig.setString(JobManagerOptions.ADDRESS, \"localhost\");\n+\t\tconfig.setString(RestOptions.BIND_PORT, \"0\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_MODE, \"zookeeper\");\n+\t\tconfig.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());\n+\t\tconfig.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getAbsolutePath());\n+\t\tconfig.setString(CoreOptions.TMP_DIRS, taskManagerTmpDir.getAbsolutePath());\n+\t\tconfig.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, \"4m\");\n+\t\tconfig.setInteger(NettyShuffleEnvironmentOptions.NETWORK_NUM_BUFFERS, 100);\n+\t\tconfig.setString(TaskManagerOptions.TOTAL_FLINK_MEMORY, \"512m\");\n+\n+\t\ttry (FileOutputStream fos = new FileOutputStream(confFile);\n+\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos))) {\n+\t\t\tfor (Map.Entry<String, String> e : config.toMap().entrySet()) {\n+\t\t\t\twriter.write(e.getKey());\n+\t\t\t\twriter.write(\": \");\n+\t\t\t\twriter.write(e.getValue());\n+\t\t\t\twriter.newLine();\n+\t\t\t}\n+\n+\t\t\twriter.flush();\n+\t\t}\n+\n+\t\tTaskManagerProcess taskManagerProcess = null;\n+\n+\t\ttry (final StandaloneSessionClusterEntrypoint clusterEntrypoint = new StandaloneSessionClusterEntrypoint(config)) {\n+\t\t\tString javaCommand = getJavaCommandPath();\n+\t\t\tif (javaCommand == null) {\n+\t\t\t\tfail(\"Could not find java executable.\");\n+\t\t\t}\n+\n+\t\t\tclusterEntrypoint.startCluster();\n+\n+\t\t\ttaskManagerProcess = new TaskManagerProcess(javaCommand, confDir.getAbsolutePath());\n+\t\t\ttaskManagerProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\tFile[] nettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\n+\t\t\twhile (nettyShuffleTmpFiles.length == 0 && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t\tnettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\t\t\t}\n+\n+\t\t\tif (nettyShuffleTmpFiles.length == 0) {\n+\t\t\t\tfail(\"The TaskManager process does not create shuffle directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + taskManagerProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + taskManagerProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (taskManagerProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (taskManagerProcess.isAlive()) {\n+\t\t\t\tfail(\"The TaskManager process does not terminate in time, its output is: \\n\" + taskManagerProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tnettyShuffleTmpFiles = findNettyShuffleDirectories(taskManagerTmpDir);\n+\t\t\tassertEquals(\"The TaskManager does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + taskManagerProcess.getProcessOutput(),\n+\t\t\t\t\t0, nettyShuffleTmpFiles.length);\n+\t\t}", "originalCommit": "9430066683a67318f9685de8a58904972c5dbaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzNDU2NQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r366134565", "bodyText": "Agree with that we should add the finally block, and destroy the process in the finally block. Besides, I think we should not need to delete files explicitly since we are using the TemporaryFolder and it should be able to ensure files get cleared after the test.", "author": "gaoyunhaii", "createdAt": "2020-01-14T03:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MzUwMw=="}], "type": "inlineReview"}, {"oid": "2185007c824d21817356c9dfb9c9e09846e27f7e", "url": "https://github.com/apache/flink/commit/2185007c824d21817356c9dfb9c9e09846e27f7e", "message": "Addressing comments", "committedDate": "2020-01-14T02:50:29Z", "type": "forcePushed"}, {"oid": "d7ab35b18c5964b837be1d52611623d7c271dc99", "url": "https://github.com/apache/flink/commit/d7ab35b18c5964b837be1d52611623d7c271dc99", "message": "Addressing comments", "committedDate": "2020-01-14T03:07:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NDU0Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368464542", "bodyText": "nit: it already was -> it was already", "author": "zhijiangW", "createdAt": "2020-01-20T10:11:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -99,10 +123,17 @@ public Enumerator createChannelEnumerator() {\n \t */\n \t@Override\n \tpublic void close() throws Exception {\n+\t\t// Marks shut down and exit if it already was shut down.", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNjQwMQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368616401", "bodyText": "I have modified the comments.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NDU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NzM5Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368467392", "bodyText": "Extend TestLogger for better tracking.", "author": "zhijiangW", "createdAt": "2020-01-20T10:16:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNzQzMA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368617430", "bodyText": "Added the extension accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2Nzk1MA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368467950", "bodyText": "better to add an empty line before this import.", "author": "zhijiangW", "createdAt": "2020-01-20T10:18:01Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNzU4MA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368617580", "bodyText": "Added the empty line.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2Nzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MTY0Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368471642", "bodyText": "I guess this part is reductant because the javaCommand is actually not used below?", "author": "zhijiangW", "createdAt": "2020-01-20T10:25:28Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxODM2NQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368618365", "bodyText": "The javaCommand is truly redundant and I have removed the related code.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3NDEyMw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368474123", "bodyText": "Make this creation out of try clause, then we do not need to check whether it is null in finally clause.", "author": "zhijiangW", "createdAt": "2020-01-20T10:30:33Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxOTI4NA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368619284", "bodyText": "Agree with that, and the code is modified accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3NDEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4Nzk4Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368487987", "bodyText": "It is better to give some comment explanations here why we need callerHasHook for testing. E.g. we want to verify the case that both the upper component and its internal FileChannelManagerImpl have the shutdown hook in practice like IOManager.", "author": "zhijiangW", "createdAt": "2020-01-20T11:00:30Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzMjgzMg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368632832", "bodyText": "Agree with that and have modified the code accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-20T16:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4Nzk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTM5Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489397", "bodyText": "Can we still refer to the TEST_TIMEOUT for waiting before failure? Actually 50s is too long for this test I guess.", "author": "zhijiangW", "createdAt": "2020-01-20T11:03:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Single main process what we can be killed.\n+\t\t\tnew File(couldKillSignalFilePath).createNewFile();\n+\n+\t\t\t// Waits till get killed. If we have not killed in time, make sure we exit finally.\n+\t\t\t// Meanwhile, the test will fail due to process not terminated in time.\n+\t\t\tThread.sleep(5 * TEST_TIMEOUT.toMillis());", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNjU5Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368636592", "bodyText": "I think the waiting test process would wait enough time before the kill process takes effect, otherwise we may have unstable scenarios. If the killing process cannot kill the process in TEST_TIMEOUT, then the test would fail directly with the timeout logic in the test function, and it will not waiting for 5 * TEST_TIMEOUT.", "author": "gaoyunhaii", "createdAt": "2020-01-20T16:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5ODEzNg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368798136", "bodyText": "The normal case should take less than several seconds, so 30s should be enough for bearing the exception.", "author": "zhijiangW", "createdAt": "2020-01-21T03:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTY4MA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489680", "bodyText": "We should make this test fail if entering the exit(1)?", "author": "zhijiangW", "createdAt": "2020-01-20T11:04:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Single main process what we can be killed.\n+\t\t\tnew File(couldKillSignalFilePath).createNewFile();\n+\n+\t\t\t// Waits till get killed. If we have not killed in time, make sure we exit finally.\n+\t\t\t// Meanwhile, the test will fail due to process not terminated in time.\n+\t\t\tThread.sleep(5 * TEST_TIMEOUT.toMillis());\n+\t\t\tSystem.exit(1);", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNzE2OA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368637168", "bodyText": "I think Similar to the last issue, I think the test would be able to fail directly after TEST_TIMEOUT due to the test process does not get killed in time, as specified in the test function.", "author": "gaoyunhaii", "createdAt": "2020-01-20T16:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTkxMQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368489911", "bodyText": "can be package private and remove the throws Exception", "author": "zhijiangW", "createdAt": "2020-01-20T11:04:55Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.apache.flink.runtime.testutils.CommonTestUtils.getJavaCommandPath;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = null;\n+\n+\t\tString javaCommand = getJavaCommandPath();\n+\t\tif (javaCommand == null) {\n+\t\t\tfail(\"Could not find java executable.\");\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\t\t\tcallerHasHook,\n+\t\t\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tif (fileChannelManagerTestProcess != null) {\n+\t\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tpublic FileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {", "originalCommit": "d7ab35b18c5964b837be1d52611623d7c271dc99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxOTU0Mw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368619543", "bodyText": "Agree with that we could change to package private, and the code has been modified accordingly.\nThe exception should not be able to be removed, since the super constructor throws Exception.", "author": "gaoyunhaii", "createdAt": "2020-01-20T15:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ4OTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NzExNA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368787114", "bodyText": "I think we should give some comments for the reason of atomic here, which is for the case of multiple shutdown hooks.", "author": "zhijiangW", "createdAt": "2020-01-21T02:32:05Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -51,12 +54,27 @@\n \t/** The number of the next path to use. */\n \tprivate volatile int nextPath;\n \n+\t/** Prefix of the temporary directories to create */\n+\tprivate final String prefix;\n+\n+\t/** Flag to signify that the file channel manager has been shut down already. */\n+\tprivate final AtomicBoolean isShutdown = new AtomicBoolean();", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3MjQ5OQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368872499", "bodyText": "I have added the comments.", "author": "gaoyunhaii", "createdAt": "2020-01-21T08:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NzExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMjc1NQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368902755", "bodyText": "typo signify", "author": "zhijiangW", "createdAt": "2020-01-21T09:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxOA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368788718", "bodyText": "Can we check via fileChannelDir.list().length == 0 to avoid relying on COULD_KILL_SIGNAL_FILE? If so we can get ride of it completely and only rely on the original FileChannelManagerImpl.", "author": "zhijiangW", "createdAt": "2020-01-21T02:40:27Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTYyNA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368791624", "bodyText": "Also we could make use of  existing TestJvmProcess.waitForMarkerFile() instead if we pass the signal file in FileChannelManagerTestProcess", "author": "zhijiangW", "createdAt": "2020-01-21T02:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3ODYwNg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368878606", "bodyText": "Agree with that, and I have modified the code accordingly", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTk1Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368791957", "bodyText": "we can also remove this part if making use of TestJvmProcess.waitForMarkerFile() as mentioned above.", "author": "zhijiangW", "createdAt": "2020-01-21T02:57:24Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3ODc4MQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368878781", "bodyText": "I have modified the code accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MjY2NQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368792665", "bodyText": "Use assertFalse(\"\", fileChannelManagerTestProcess.isAlive()) for simple.", "author": "zhijiangW", "createdAt": "2020-01-21T03:01:01Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3ODg0Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368878847", "bodyText": "I have modified the code accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MjY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MzY5Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368793697", "bodyText": "also use assertFalse for simple", "author": "zhijiangW", "createdAt": "2020-01-21T03:07:05Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3ODg4Mg==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368878882", "bodyText": "I have modified the code accordingly.", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MzY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDM3Nw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368794377", "bodyText": "COULD_KILL_SIGNAL_FILE -> SIGNAL_FILE_FOR_KILLING, and give some comments for what it is used for.", "author": "zhijiangW", "createdAt": "2020-01-21T03:10:54Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3ODk1OQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368878959", "bodyText": "The name has been changed and the comments are added.", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDc4NA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368794784", "bodyText": "Singles -> Signals\nSignals the main process to execute the kill action.", "author": "zhijiangW", "createdAt": "2020-01-21T03:13:20Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tFileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {\n+\n+\t\tpublic static void main(String[] args) throws Exception{\n+\t\t\tboolean callerHasHook = Boolean.parseBoolean(args[0]);\n+\t\t\tString tmpDirectory = args[1];\n+\t\t\tString couldKillSignalFilePath = args[2];\n+\n+\t\t\tFileChannelManager manager = new FileChannelManagerImpl(new String[]{tmpDirectory}, DIR_NAME_PREFIX);\n+\n+\t\t\tif (callerHasHook) {\n+\t\t\t\t// Verifies the case that both FileChannelManager and its upper component\n+\t\t\t\t// have registered shutdown hooks, like in IOManager.\n+\t\t\t\tShutdownHookUtil.addShutdownHook(() -> manager.close(), \"Caller\", LOG);\n+\t\t\t}\n+\n+\t\t\t// Singles main process what we can be killed.", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4MDM4MA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368880380", "bodyText": "The comments are modified", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NTMzMw==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368795333", "bodyText": "public -> private", "author": "zhijiangW", "createdAt": "2020-01-21T03:16:18Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\tprivate static final String COULD_KILL_SIGNAL_FILE = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tFilenameUtils.concat(signalDir.getAbsolutePath(), COULD_KILL_SIGNAL_FILE));\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till netty shuffle environment has created the tmp directories.\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\n+\t\t\twhile (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (!fileOrDirExists(signalDir, COULD_KILL_SIGNAL_FILE) ||\n+\t\t\t\t\t!fileOrDirExists(fileChannelDir, DIR_NAME_PREFIX)) {\n+\t\t\t\tfail(\"The file channel manager test process does not create target directories in time, \" +\n+\t\t\t\t\t\t\"its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tdeadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tif (fileChannelManagerTestProcess.isAlive()) {\n+\t\t\t\tfail(\"The file channel manager test process does not terminate in time, its output is: \\n\" + fileChannelManagerTestProcess.getProcessOutput());\n+\t\t\t}\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertThat(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX),\n+\t\t\t\t\tis(false));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;\n+\n+\t\tFileChannelManagerTestProcess(boolean callerHasHook, String tmpDirectories, String couldKillSignalFilePath) throws Exception {\n+\t\t\tthis.callerHasHook = callerHasHook;\n+\t\t\tthis.tmpDirectories = tmpDirectories;\n+\t\t\tthis.couldKillSignalFilePath = couldKillSignalFilePath;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"File Channel Manager Test\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String[] getJvmArgs() {\n+\t\t\treturn new String[]{\n+\t\t\t\t\tBoolean.toString(callerHasHook),\n+\t\t\t\t\ttmpDirectories,\n+\t\t\t\t\tcouldKillSignalFilePath\n+\t\t\t};\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getEntryPointClassName() {\n+\t\t\treturn FileChannelManagerCleanupRunner.class.getName();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * The entry point class to test the file channel manager cleanup with shutdown hook.\n+\t */\n+\tpublic static class FileChannelManagerCleanupRunner {", "originalCommit": "2000e3bfb01cdb7e9c2fe7c882baad291e098de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTk3OA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368889978", "bodyText": "I am a little worry since that the class is used as an entry point class of one process. Although it seems  not cause error with the current JDK, I am afraid it may cause unstableness in the future.", "author": "gaoyunhaii", "createdAt": "2020-01-21T09:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5NTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjQwMA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368906400", "bodyText": "exit -> exits", "author": "zhijiangW", "createdAt": "2020-01-21T10:00:38Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/FileChannelManagerImpl.java", "diffHunk": "@@ -99,10 +126,17 @@ public Enumerator createChannelEnumerator() {\n \t */\n \t@Override\n \tpublic void close() throws Exception {\n+\t\t// Marks shut down and exit if it has already shut down.", "originalCommit": "3104fe46714388247df22b5372e5c3c134834646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk2MDQwOQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r373960409", "bodyText": "Have modified accordingly.", "author": "gaoyunhaii", "createdAt": "2020-02-03T07:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxNTcxNQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368915715", "bodyText": "<tt> callerHasHook </tt>", "author": "zhijiangW", "createdAt": "2020-01-21T10:19:09Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\t/**\n+\t * Marker file indicating the test process is ready to be killed. We could not simply kill the process\n+\t * after FileChannelManager has created temporary files since we also need to ensure the caller has\n+\t * also registered the shutdown hook if callerHasHook is true.", "originalCommit": "3104fe46714388247df22b5372e5c3c134834646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk2MDM5OA==", "url": "https://github.com/apache/flink/pull/10736#discussion_r373960398", "bodyText": "Have modified accordingly.", "author": "gaoyunhaii", "createdAt": "2020-02-03T07:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxNTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxODE3MQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r368918171", "bodyText": "couldKillSignalFilePath -> signalFilePath", "author": "zhijiangW", "createdAt": "2020-01-21T10:24:14Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/FileChannelManagerImplTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.disk;\n+\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.flink.api.common.time.Deadline;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.ShutdownHookUtil;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.time.Duration;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assume.assumeTrue;\n+\n+/**\n+ * Tests the logic of {@link FileChannelManagerImpl}.\n+ */\n+public class FileChannelManagerImplTest extends TestLogger {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FileChannelManagerImplTest.class);\n+\n+\tprivate static final String DIR_NAME_PREFIX = \"manager-test\";\n+\n+\t/**\n+\t * Marker file indicating the test process is ready to be killed. We could not simply kill the process\n+\t * after FileChannelManager has created temporary files since we also need to ensure the caller has\n+\t * also registered the shutdown hook if callerHasHook is true.\n+\t */\n+\tprivate static final String SIGNAL_FILE_FOR_KILLING = \"could-kill\";\n+\n+\tprivate static final Duration TEST_TIMEOUT = Duration.ofSeconds(10);\n+\n+\t@Rule\n+\tpublic final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithoutCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(false);\n+\t}\n+\n+\t@Test\n+\tpublic void testDirectoriesCleanupOnKillWithCallerHook() throws Exception {\n+\t\ttestDirectoriesCleanupOnKill(true);\n+\t}\n+\n+\tprivate void testDirectoriesCleanupOnKill(boolean callerHasHook) throws Exception {\n+\t\tassumeTrue(OperatingSystem.isLinux()\n+\t\t\t\t|| OperatingSystem.isFreeBSD()\n+\t\t\t\t|| OperatingSystem.isSolaris()\n+\t\t\t\t|| OperatingSystem.isMac());\n+\n+\t\tFile fileChannelDir = temporaryFolder.newFolder();\n+\n+\t\tFile signalDir = temporaryFolder.newFolder();\n+\t\tFile signalFile = new File(FilenameUtils.concat(signalDir.getAbsolutePath(), SIGNAL_FILE_FOR_KILLING));\n+\n+\t\tFileChannelManagerTestProcess fileChannelManagerTestProcess = new FileChannelManagerTestProcess(\n+\t\t\tcallerHasHook,\n+\t\t\tfileChannelDir.getAbsolutePath(),\n+\t\t\tsignalFile.getAbsolutePath());\n+\n+\t\ttry {\n+\t\t\tfileChannelManagerTestProcess.startProcess();\n+\n+\t\t\t// Waits till the process has created temporary files and registered the corresponding shutdown hooks.\n+\t\t\tTestJvmProcess.waitForMarkerFile(signalFile, TEST_TIMEOUT.toMillis());\n+\n+\t\t\tProcess kill = Runtime.getRuntime().exec(\"kill \" + fileChannelManagerTestProcess.getProcessId());\n+\t\t\tkill.waitFor();\n+\t\t\tassertEquals(\"Failed to send SIG_TERM to process\", 0, kill.exitValue());\n+\n+\t\t\tDeadline deadline = Deadline.now().plus(TEST_TIMEOUT);\n+\t\t\twhile (fileChannelManagerTestProcess.isAlive() && deadline.hasTimeLeft()) {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t}\n+\n+\t\t\tassertFalse(\"The file channel manager test process does not terminate in time, its output is: \\n\"\n+\t\t\t\t\t\t+ fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileChannelManagerTestProcess.isAlive());\n+\n+\t\t\t// Checks if the directories are cleared.\n+\t\t\tassertFalse(\"The file channel manager test process does not remove the tmp shuffle directories after termination, \" +\n+\t\t\t\t\t\t\t\"its output is \\n\" + fileChannelManagerTestProcess.getProcessOutput(),\n+\t\t\t\t\tfileOrDirExists(fileChannelDir, DIR_NAME_PREFIX));\n+\t\t} finally {\n+\t\t\tfileChannelManagerTestProcess.destroy();\n+\t\t}\n+\t}\n+\n+\tprivate boolean fileOrDirExists(File rootTmpDir, String namePattern) {\n+\t\tFile[] candidates = rootTmpDir.listFiles((dir, name) -> name.contains(namePattern));\n+\t\treturn candidates != null && candidates.length > 0;\n+\t}\n+\n+\t/**\n+\t * The {@link FileChannelManagerCleanupRunner} instance running in a separate JVM process.\n+\t */\n+\tprivate static class FileChannelManagerTestProcess extends TestJvmProcess {\n+\t\tprivate final boolean callerHasHook;\n+\t\tprivate final String tmpDirectories;\n+\t\tprivate final String couldKillSignalFilePath;", "originalCommit": "3104fe46714388247df22b5372e5c3c134834646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk2MDM4MQ==", "url": "https://github.com/apache/flink/pull/10736#discussion_r373960381", "bodyText": "Have modified accordingly.", "author": "gaoyunhaii", "createdAt": "2020-02-03T07:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxODE3MQ=="}], "type": "inlineReview"}, {"oid": "6aae9d5a92c2ad581af35152876996020eb368f7", "url": "https://github.com/apache/flink/commit/6aae9d5a92c2ad581af35152876996020eb368f7", "message": "[FLINK-15010][Network] Add shutdown hook to ensure cleanup netty shuffle directories", "committedDate": "2020-02-03T10:38:03Z", "type": "commit"}, {"oid": "31899d557907c3ae2dd78d079517cc91153c5201", "url": "https://github.com/apache/flink/commit/31899d557907c3ae2dd78d079517cc91153c5201", "message": "Addressing comments", "committedDate": "2020-02-03T10:38:03Z", "type": "commit"}, {"oid": "075c84fe6c165ecec90c0b4abb12460b8e717281", "url": "https://github.com/apache/flink/commit/075c84fe6c165ecec90c0b4abb12460b8e717281", "message": "Address the comments", "committedDate": "2020-02-03T10:38:03Z", "type": "commit"}, {"oid": "3008621f341037ed1cf1d5fd67ccedac2359a54f", "url": "https://github.com/apache/flink/commit/3008621f341037ed1cf1d5fd67ccedac2359a54f", "message": "Address the comments", "committedDate": "2020-02-03T10:38:03Z", "type": "commit"}, {"oid": "6c5e0c9d33f8cd3f44c06168890ec1313ebd6007", "url": "https://github.com/apache/flink/commit/6c5e0c9d33f8cd3f44c06168890ec1313ebd6007", "message": "Address more comments", "committedDate": "2020-02-03T10:38:03Z", "type": "commit"}, {"oid": "158dd43ee9cd107d7def34fef064946b00b4570d", "url": "https://github.com/apache/flink/commit/158dd43ee9cd107d7def34fef064946b00b4570d", "message": "Fix the import orders", "committedDate": "2020-02-03T10:50:33Z", "type": "commit"}, {"oid": "158dd43ee9cd107d7def34fef064946b00b4570d", "url": "https://github.com/apache/flink/commit/158dd43ee9cd107d7def34fef064946b00b4570d", "message": "Fix the import orders", "committedDate": "2020-02-03T10:50:33Z", "type": "forcePushed"}, {"oid": "a20895d3ac0e5fd3eb1f4fd3c665519bc15ae803", "url": "https://github.com/apache/flink/commit/a20895d3ac0e5fd3eb1f4fd3c665519bc15ae803", "message": "Remove dependency of FileNameUtils", "committedDate": "2020-02-03T14:24:17Z", "type": "commit"}]}