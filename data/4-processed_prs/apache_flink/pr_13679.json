{"pr_number": 13679, "pr_title": "[FLINK-19695][table-runtime-blink] Fix ClassCastException when writing table with rowtime attribute", "pr_createdAt": "2020-10-19T04:08:35Z", "pr_url": "https://github.com/apache/flink/pull/13679", "timeline": [{"oid": "94103469ab37ce717e0a3629f28055035124a12c", "url": "https://github.com/apache/flink/commit/94103469ab37ce717e0a3629f28055035124a12c", "message": "[FLINK-19695][table-runtime-blink] Fix ClassCastException when writing table with rowtime attribute", "committedDate": "2020-10-19T04:04:58Z", "type": "commit"}, {"oid": "43189cea09d80f8e3c6bc5d9c8a54c51b2c87915", "url": "https://github.com/apache/flink/commit/43189cea09d80f8e3c6bc5d9c8a54c51b2c87915", "message": "add an additional test for TUMBLE_ROWTIME", "committedDate": "2020-10-19T08:43:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzMjMyNQ==", "url": "https://github.com/apache/flink/pull/13679#discussion_r507632325", "bodyText": "Also use TableException ?", "author": "leonardBang", "createdAt": "2020-10-19T10:15:58Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -315,15 +320,28 @@ public DynamicTableSource createDynamicTableSource(Context context) {\n \tpublic DynamicTableSink createDynamicTableSink(Context context) {\n \t\tFactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context);\n \t\thelper.validate();\n+\t\tString sinkClass = helper.getOptions().get(TABLE_SINK_CLASS);\n+\n \t\tboolean isInsertOnly = helper.getOptions().get(SINK_INSERT_ONLY);\n \t\tString runtimeSink = helper.getOptions().get(RUNTIME_SINK);\n \t\tint expectedNum = helper.getOptions().get(SINK_EXPECTED_MESSAGES_NUM);\n \t\tTableSchema schema = context.getCatalogTable().getSchema();\n-\t\treturn new TestValuesTableSink(\n-\t\t\tschema,\n-\t\t\tcontext.getObjectIdentifier().getObjectName(),\n-\t\t\tisInsertOnly,\n-\t\t\truntimeSink, expectedNum);\n+\t\tif (sinkClass.equals(\"DEFAULT\")) {\n+\t\t\treturn new TestValuesTableSink(\n+\t\t\t\tschema,\n+\t\t\t\tcontext.getObjectIdentifier().getObjectName(),\n+\t\t\t\tisInsertOnly,\n+\t\t\t\truntimeSink, expectedNum);\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\treturn InstantiationUtil.instantiate(\n+\t\t\t\t\tsinkClass,\n+\t\t\t\t\tDynamicTableSink.class,\n+\t\t\t\t\tThread.currentThread().getContextClassLoader());\n+\t\t\t} catch (FlinkException e) {", "originalCommit": "43189cea09d80f8e3c6bc5d9c8a54c51b2c87915", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg3NTQzNQ==", "url": "https://github.com/apache/flink/pull/13679#discussion_r507875435", "bodyText": "I think we can't use TableException here, because InstantiationUtil.instantiate throws FlinkException which is defined in flink-core.", "author": "wuchong", "createdAt": "2020-10-19T16:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzMjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NzgyNw==", "url": "https://github.com/apache/flink/pull/13679#discussion_r508267827", "bodyText": "got it", "author": "leonardBang", "createdAt": "2020-10-20T07:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzMjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzODY4MQ==", "url": "https://github.com/apache/flink/pull/13679#discussion_r507638681", "bodyText": "Could we use LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, ZoneOffset.UTC) which is more readable ?", "author": "leonardBang", "createdAt": "2020-10-19T10:26:53Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/table/TableSinkITCase.scala", "diffHunk": "@@ -620,4 +622,93 @@ class TableSinkITCase extends StreamingTestBase {\n     val expected = List(\"book,1,12\", \"book,4,11\", \"fruit,3,44\")\n     assertEquals(expected.sorted, result.sorted)\n   }\n+\n+  @Test\n+  def testSinkContext(): Unit = {\n+    val data = List(\n+      rowOf(\"1970-01-01 00:00:00.001\", localDateTime(1L), 1, 1d),\n+      rowOf(\"1970-01-01 00:00:00.002\", localDateTime(2L), 1, 2d),\n+      rowOf(\"1970-01-01 00:00:00.003\", localDateTime(3L), 1, 2d),\n+      rowOf(\"1970-01-01 00:00:00.004\", localDateTime(4L), 1, 5d),\n+      rowOf(\"1970-01-01 00:00:00.007\", localDateTime(7L), 1, 3d),\n+      rowOf(\"1970-01-01 00:00:00.008\", localDateTime(8L), 1, 3d),\n+      rowOf(\"1970-01-01 00:00:00.016\", localDateTime(16L), 1, 4d))\n+\n+    val dataId: String = TestValuesTableFactory.registerData(data)\n+\n+    val sourceDDL =\n+      s\"\"\"\n+         |CREATE TABLE src (\n+         |  log_ts STRING,\n+         |  ts TIMESTAMP(3),\n+         |  a INT,\n+         |  b DOUBLE,\n+         |  WATERMARK FOR ts AS ts - INTERVAL '0.001' SECOND\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$dataId'\n+         |)\n+      \"\"\".stripMargin\n+\n+    val sinkDDL =\n+      s\"\"\"\n+         |CREATE TABLE sink (\n+         |  log_ts STRING,\n+         |  ts TIMESTAMP(3),\n+         |  a INT,\n+         |  b DOUBLE\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'table-sink-class' = '${classOf[TestSinkContextTableSink].getName}'\n+         |)\n+      \"\"\".stripMargin\n+\n+    tEnv.executeSql(sourceDDL)\n+    tEnv.executeSql(sinkDDL)\n+\n+    //---------------------------------------------------------------------------------------\n+    // Verify writing out a source directly with the rowtime attribute\n+    //---------------------------------------------------------------------------------------\n+\n+    tEnv.executeSql(\"INSERT INTO sink SELECT * FROM src\").await()\n+\n+    val expected = List(1, 2, 3, 4, 7, 8, 16)\n+    assertEquals(expected.sorted, TestSinkContextTableSink.ROWTIMES.sorted)\n+\n+    val sinkDDL2 =\n+      s\"\"\"\n+         |CREATE TABLE sink2 (\n+         |  window_rowtime TIMESTAMP(3),\n+         |  b DOUBLE\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'table-sink-class' = '${classOf[TestSinkContextTableSink].getName}'\n+         |)\n+      \"\"\".stripMargin\n+    tEnv.executeSql(sinkDDL2)\n+\n+    //---------------------------------------------------------------------------------------\n+    // Verify writing out with additional operator to generate a new rowtime attribute\n+    //---------------------------------------------------------------------------------------\n+\n+    tEnv.executeSql(\n+      \"\"\"\n+        |INSERT INTO sink2\n+        |SELECT\n+        |  TUMBLE_ROWTIME(ts, INTERVAL '0.005' SECOND),\n+        |  SUM(b)\n+        |FROM src\n+        |GROUP BY TUMBLE(ts, INTERVAL '0.005' SECOND)\n+        |\"\"\".stripMargin\n+    ).await()\n+\n+    val expected2 = List(4, 9, 19)\n+    assertEquals(expected2.sorted, TestSinkContextTableSink.ROWTIMES.sorted)\n+  }\n+\n+  // ------------------------------------------------------------------------------------------\n+\n+  private def localDateTime(ts: Long): LocalDateTime = {\n+    new Timestamp(ts - TimeZone.getDefault.getOffset(ts)).toLocalDateTime", "originalCommit": "43189cea09d80f8e3c6bc5d9c8a54c51b2c87915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1c677a00d1a729df385ab3b9663fdbba37ea0aa", "url": "https://github.com/apache/flink/commit/f1c677a00d1a729df385ab3b9663fdbba37ea0aa", "message": "address review comment", "committedDate": "2020-10-19T16:20:44Z", "type": "commit"}]}