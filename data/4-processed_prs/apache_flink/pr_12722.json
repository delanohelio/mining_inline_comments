{"pr_number": 12722, "pr_title": "[FLINK-18064][docs] Added unaligned checkpointing to docs.", "pr_createdAt": "2020-06-19T12:45:03Z", "pr_url": "https://github.com/apache/flink/pull/12722", "timeline": [{"oid": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "url": "https://github.com/apache/flink/commit/a1b55138a68d11ee5987199b1a4440429be0e9b0", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-19T19:25:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MjI1Mw==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443372253", "bodyText": "Hum, not sure I'd change this title, it might be more confusing than helpful. The sentence you have below is clarifying enough (\"Since Flink 1.11, checkpoints can be taken with or without alignment. In the\nfollowing, we describe aligned checkpoints first.\").", "author": "morsapaes", "createdAt": "2020-06-22T07:42:54Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzE3Nw==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373177", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The figure depicts how an operator handle unaligned checkpoint barriers:\n          \n          \n            \n            The figure depicts how an operator handles unaligned checkpoint barriers:", "author": "morsapaes", "createdAt": "2020-06-22T07:44:46Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MzU3Ng==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443373576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            as possible. It's especially suited for application with at least one slow \n          \n          \n            \n            as possible. It's especially suited for applications with at least one slow", "author": "morsapaes", "createdAt": "2020-06-22T07:45:36Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow ", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            high due to back-pressure. Then, checkpointing time becomes mostly\n          \n          \n            \n            high due to backpressure. Then, checkpointing time becomes mostly", "author": "morsapaes", "createdAt": "2020-06-22T07:48:59Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTQ2OA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443375468", "bodyText": "Just for the sake of coherence.", "author": "morsapaes", "createdAt": "2020-06-22T07:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NjA0NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443376044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons.\n          \n          \n            \n            - Unaligned checkpoints may produce incorrect results for the following reasons:", "author": "morsapaes", "createdAt": "2020-06-22T07:50:14Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3NzA3Mg==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443377072", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            checkpoints**, while window operators are safe to use. The work-around is to\n          \n          \n            \n            checkpoints**, while window operators are safe to use. The workaround is to", "author": "morsapaes", "createdAt": "2020-06-22T07:52:16Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons.\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The work-around is to", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443385164", "bodyText": "To my understanding, there are were papers: one by Lamport and one by DataArtisans.\nOne of the differences is that the former proposed to persist channel state, while the latter proposed alignment (I might be wrong).\nSo it's probably better to move reference to the paper by Lamport to Unaligned section and mention \"Flink\" paper in this Aligned section.", "author": "rkhachatryan", "createdAt": "2020-06-22T08:07:52Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -123,7 +123,7 @@ provided by Flink's connectors.\n snapshots, we use the words *snapshot* and *checkpoint* interchangeably. Often\n we also use the term *snapshot* to mean either *checkpoint* or *savepoint*.\n \n-### Checkpointing\n+### Aligned Checkpointing\n \n The central part of Flink's fault tolerance mechanism is drawing consistent", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5OTgwMA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443499800", "bodyText": "Good question. I briefly looked at it and it seems as if you are right. I pinged @StephanEwen for clarification and he responded that it is indeed closer, but there are still some difference:\n\nFlink checkpoints start at sources, propagate through a DAG and persist in-flight as needed\nChandy-Lamport assumes no DAG, starts everywhere at the same time (think: RPC goes to every operators) and all operators log until they saw all markers.\n\nI'd probably leave the reference as is and add a clarifying line to unaligned section.", "author": "AHeise", "createdAt": "2020-06-22T11:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM4NzgzNg==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443387836", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator reacts on the first barrier that is stored in input buffers.\n          \n          \n            \n            - The operator reacts on the first barrier that is stored in its input buffers.", "author": "rkhachatryan", "createdAt": "2020-06-22T08:13:06Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5MDg4NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443390884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The operator marks all overtaken buffers, which are asynchronously stored in\n          \n          \n            \n              the state backend together with the other operator state.\n          \n          \n            \n            - The operator marks all overtaken records to be stored asynchronously and creates a snapshot of its own state.", "author": "rkhachatryan", "createdAt": "2020-06-22T08:18:48Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443392894", "bodyText": "It reads like a separate step (it's not, right?)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - It only briefly stops the processing of input to mark the buffers, forward \n          \n          \n            \n              the barrier and create the snapshot of the other state.\n          \n          \n            \n            Compared to aligned checkpoints, the operator doesn't need to suspend any of its inputs.", "author": "rkhachatryan", "createdAt": "2020-06-22T08:22:29Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDA2MA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504060", "bodyText": "Yes, I have removed the bullet and made it a summarizing sentence.", "author": "AHeise", "createdAt": "2020-06-22T11:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mjg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5Mzg4NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443393884", "bodyText": "\ud83d\udc4d", "author": "rkhachatryan", "createdAt": "2020-06-22T08:24:13Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handle unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken buffers, which are asynchronously stored in\n+  the state backend together with the other operator state.\n+- It only briefly stops the processing of input to mark the buffers, forward \n+  the barrier and create the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for application with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O\n+to the state backends is the bottleneck. See the more in-depth discussion in \n+[ops]({% link ops/state/checkpoints.md %}#unaligned-checkpoints)\n+for other limitations.\n+\n+Note that savepoints will always be aligned.", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443395644", "bodyText": "Should we mention that this is an experimental feature?\nI think it should be a separate statement in the end of the section.", "author": "rkhachatryan", "createdAt": "2020-06-22T08:27:04Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,42 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwMjQ3OQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443502479", "bodyText": "My understanding was that this document is rather an expanded glossary and talks about the concept and not the implementation. Thus, I'd leave the implementation state out of this place. The ops link will directly say that it's experimental in 1.11.", "author": "AHeise", "createdAt": "2020-06-22T11:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTU3Mw==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443835573", "bodyText": "The page already goes quite deep into the details so I don't see why it shouldn't be mentioned here. Some users could benefit by ruling out the feature earlier if they are considering Flink or its configuration.", "author": "rkhachatryan", "createdAt": "2020-06-22T21:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNzY2MQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r444727661", "bodyText": "Since we decided at a different point to drop the experimental label, I'd leave this section as is.", "author": "AHeise", "createdAt": "2020-06-24T08:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM5NTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - You cannot rescale from unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment\n          \n          \n            \n            - You cannot rescale or change job graph with unaligned checkpoints. You have to take a savepoint \n          \n          \n            \n            before rescaling. Savepoints are always aligned independent of the alignment", "author": "rkhachatryan", "createdAt": "2020-06-22T08:50:49Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNDUwMg==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443504502", "bodyText": "Can you change the job graph with current checkpoints? I was always assuming that you need savepoints.", "author": "AHeise", "createdAt": "2020-06-22T11:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYzMzM1MA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443633350", "bodyText": "Hmm...the current Flink docs says that retained checkpoints:\n\ndo not support Flink specific features like rescaling.\n\n...and nothing about the job graph.\nBesides that, UC doesn't currently support Local recovery.\nEdit:\nLocal recovery limitation should probably be described in\nTuning Checkpoints section.", "author": "rkhachatryan", "createdAt": "2020-06-22T15:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2Nzg1NQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r444467855", "bodyText": "Yes technically but its incidental. The community hasn't made any backward compat guaruntees around that behavior.", "author": "sjwiesman", "createdAt": "2020-06-23T19:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyOTU2Nw==", "url": "https://github.com/apache/flink/pull/12722#discussion_r444729567", "bodyText": "I see, thanks.\nI think we can leave it as is then.", "author": "rkhachatryan", "createdAt": "2020-06-24T08:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwOTk1MA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443409950", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following shortcomings:\n          \n          \n            \n            We flagged unaligned checkpoints as experimental as it currently has the\n          \n          \n            \n            following limitations:", "author": "rkhachatryan", "createdAt": "2020-06-22T08:51:51Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to back-pressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following shortcomings:", "originalCommit": "a1b55138a68d11ee5987199b1a4440429be0e9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "91dfe90937ec1c2680022a12a1c4984fd59e61cf", "url": "https://github.com/apache/flink/commit/91dfe90937ec1c2680022a12a1c4984fd59e61cf", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-22T11:39:28Z", "type": "forcePushed"}, {"oid": "e80e905a5d66919427300af45b088e33b01d46d2", "url": "https://github.com/apache/flink/commit/e80e905a5d66919427300af45b088e33b01d46d2", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-22T11:53:53Z", "type": "forcePushed"}, {"oid": "8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "url": "https://github.com/apache/flink/commit/8718566c0b74fd6c3c6327980c1ee1d2abc8eda8", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-22T12:08:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Nzc1MQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443667751", "bodyText": "As it's stable on our builds, maybe we could label it more production ready?", "author": "pnowojski", "createdAt": "2020-06-22T16:04:03Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/CheckpointConfig.java", "diffHunk": "@@ -382,7 +382,7 @@ public void setPreferCheckpointForRecovery(boolean preferCheckpointForRecovery)\n \t}\n \n \t/**\n-\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure.\n+\t * Enables unaligned checkpoints, which greatly reduce checkpointing times under backpressure (experimental).", "originalCommit": "bfd067ea54c9c6662329cea2c8715a173961d9fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxMzc0MQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443813741", "bodyText": "Then just leave out experimental and just link to limitations?", "author": "AHeise", "createdAt": "2020-06-22T20:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2Nzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2ODU1Mw==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443668553", "bodyText": "following section?", "author": "pnowojski", "createdAt": "2020-06-22T16:05:15Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -140,6 +140,8 @@ Keep in mind that everything to do with checkpointing can be done\n asynchronously. The checkpoint barriers don't travel in lock step and\n operations can asynchronously snapshot their state.\n \n+Since Flink 1.11, checkpoints can be taken with or without alignment. In the \n+following, we describe aligned checkpoints first.", "originalCommit": "fb3bb709aa5ba9e83d1729958bab256a60eb41da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2OTczMA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443669730", "bodyText": "I/O pressure to state backends ->  I/O pressure, as it's not using state backends per se.", "author": "pnowojski", "createdAt": "2020-06-22T16:07:06Z", "path": "docs/concepts/stateful-stream-processing.md", "diffHunk": "@@ -242,6 +246,48 @@ updates to that state.\n See [Restart Strategies]({% link dev/task_failure_recovery.md\n %}#restart-strategies) for more information.\n \n+### Unaligned Checkpointing\n+\n+Starting with Flink 1.11, checkpointing can also be performed unaligned.\n+The basic idea is that checkpoints can overtake all in-flight data as long as \n+the in-flight data becomes part of the operator state.\n+\n+Note that this approach is actually closer to the [Chandy-Lamport algorithm\n+](http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf), but\n+Flink still inserts the barrier in the sources to avoid overloading the\n+checkpoint coordinator.\n+\n+<div style=\"text-align: center\">\n+  <img src=\"{% link fig/stream_unaligning.svg %}\" alt=\"Unaligned checkpointing\" style=\"width:100%; padding-top:10px; padding-bottom:10px;\" />\n+</div>\n+\n+The figure depicts how an operator handles unaligned checkpoint barriers:\n+\n+- The operator reacts on the first barrier that is stored in its input buffers.\n+- It immediately forwards the barrier to the downstream operator by adding it \n+  to the end of the output buffers.\n+- The operator marks all overtaken records to be stored asynchronously and \n+  creates a snapshot of its own state.\n+ \n+Consequently, the operator only briefly stops the processing of input to mark\n+the buffers, forwards the barrier, and creates the snapshot of the other state.\n+  \n+Unaligned checkpointing ensures that barriers are arriving at the sink as fast \n+as possible. It's especially suited for applications with at least one slow \n+moving data path, where alignment times can reach hours. However, since it's\n+adding additional I/O pressure to state backends, it doesn't help when the I/O", "originalCommit": "fb3bb709aa5ba9e83d1729958bab256a60eb41da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MDk5MA==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443670990", "bodyText": "We should mention here that aligned savepoints also can not happen concurrently to unaligned checkpoint", "author": "pnowojski", "createdAt": "2020-06-22T16:09:05Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.", "originalCommit": "fb3bb709aa5ba9e83d1729958bab256a60eb41da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MjEyOQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672129", "bodyText": "I think this paragraph is a bit too strong. As far as I understand, it's not that the UC will produce incorrect result, just that some records during the reprocessing might not be accounted as late data, right?", "author": "pnowojski", "createdAt": "2020-06-22T16:10:55Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:\n+\n+- You cannot rescale from unaligned checkpoints. You have to take a savepoint \n+before rescaling. Savepoints are always aligned independent of the alignment\n+setting of checkpoints.\n+- Flink currently does not support concurrent unaligned checkpoints. However, \n+due to the more predictable and shorter checkpointing times, concurrent \n+checkpoints might not be needed at all.\n+- Unaligned checkpoints may produce incorrect results for the following reasons:\n+\n+Currently, Flink generates the watermark as a first step of recovery instead of \n+storing the latest watermark in the operators to ease rescaling. In unaligned \n+checkpoints, that means on recovery, **Flink generates watermarks after it \n+restores in-flight data**. If your pipeline uses an **operator that applies the\n+latest watermark on each record**, it will produce **incorrect results** during \n+recovery if the watermark is not directly or indirectly part of the operator \n+state. Thus, **SQL OVER operator should not be used with unaligned\n+checkpoints**, while window operators are safe to use. The workaround is to\n+store the watermark in the operator state. If rescaling may occur, watermarks\n+should be stored per key-group in a union-state. We mostly likely will\n+implement this approach as a general solution (didn't make it into Flink \n+1.11.0).", "originalCommit": "fb3bb709aa5ba9e83d1729958bab256a60eb41da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgxNTEzMg==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443815132", "bodyText": "I can tone it done, but basically we are breaking with the old assumption that watermarks don't need to be stored at the operator because they are sent first.\nI'm especially referring to the OverITCases, which use a weird way to inject watermarks and logically should persist them. But now that I'm thinking about it, it's more a matter of the test setup itself.", "author": "AHeise", "createdAt": "2020-06-22T20:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MjEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Mjk0NQ==", "url": "https://github.com/apache/flink/pull/12722#discussion_r443672945", "bodyText": "I would also mention that flatMap operators can lead to unbounded spilled data.", "author": "pnowojski", "createdAt": "2020-06-22T16:12:17Z", "path": "docs/ops/state/checkpoints.md", "diffHunk": "@@ -113,4 +113,50 @@ above).\n $ bin/flink run -s :checkpointMetaDataPath [:runArgs]\n {% endhighlight %}\n \n+### Unaligned checkpoints\n+\n+Starting with Flink 1.11, checkpoints can be unaligned (experimental). \n+[Unaligned checkpoints]({% link concepts/stateful-stream-processing.md\n+%}#unaligned-checkpointing) contain in-flight data (i.e., data stored in\n+buffers) as part of the checkpoint state, which allows checkpoint barriers to\n+overtake these buffers. Thus, the checkpoint duration becomes independent of the\n+current throughput as checkpoint barriers are effectively not embedded into \n+the stream of data anymore.\n+\n+You should use unaligned checkpoints if your checkpointing durations are very\n+high due to backpressure. Then, checkpointing time becomes mostly\n+independent of the end-to-end latency. Be aware unaligned checkpointing\n+adds to I/O to the state backends, so you shouldn't use it when the I/O to\n+the state backend is actually the bottleneck during checkpointing.\n+\n+We flagged unaligned checkpoints as experimental as it currently has the\n+following limitations:", "originalCommit": "fb3bb709aa5ba9e83d1729958bab256a60eb41da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b9e224c9d8f40c3973974904a9ec477057761e9", "url": "https://github.com/apache/flink/commit/1b9e224c9d8f40c3973974904a9ec477057761e9", "message": "[FLINK-18064][python] Adding unaligned checkpoint config options.", "committedDate": "2020-06-24T18:49:16Z", "type": "commit"}, {"oid": "351a5f9e8ef61ea3aead0a493256930e6cb0eea1", "url": "https://github.com/apache/flink/commit/351a5f9e8ef61ea3aead0a493256930e6cb0eea1", "message": "[hotfix][conf] Fix javadoc of CheckpointConfig#isUnalignedCheckpointsEnabled.", "committedDate": "2020-06-24T18:50:24Z", "type": "commit"}, {"oid": "f0799d058a7ecc4ccead03029e0175336a4c928f", "url": "https://github.com/apache/flink/commit/f0799d058a7ecc4ccead03029e0175336a4c928f", "message": "[hotfix][docs] Fix broken link in metrics.md.", "committedDate": "2020-06-24T18:50:26Z", "type": "commit"}, {"oid": "d62757ad0b515c48c31cb1c4cde8878055b5ecfc", "url": "https://github.com/apache/flink/commit/d62757ad0b515c48c31cb1c4cde8878055b5ecfc", "message": "[FLINK-18064][docs] Added unaligned checkpointing to docs.\n\nIt's split into 3 parts to simulate the description of aligned checkpointing:\n- It's added on conceptual level in stateful-stream-processing.md with new/revised pics. It's written in a way that it could survive 1.12 without change.\n- A small change to dev/stream/state/checkpointing.md to show how it is enabled programmatically in Java/Scala/Python. Might need to be extended for 1.12 when new options become available (depending whether they can be programmatically changed or not).\n- A larger discussion in ops/state/checkpoints.md which includes the current limitations and a small glimpse into the next steps (will be in much more detail in blog post). This part needs to be largely rewritten for 1.12+ to reflect the new options.", "committedDate": "2020-06-24T18:50:26Z", "type": "commit"}, {"oid": "f818134b647f6e34bade6189640bd81575f0162c", "url": "https://github.com/apache/flink/commit/f818134b647f6e34bade6189640bd81575f0162c", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-24T18:50:26Z", "type": "commit"}, {"oid": "f818134b647f6e34bade6189640bd81575f0162c", "url": "https://github.com/apache/flink/commit/f818134b647f6e34bade6189640bd81575f0162c", "message": "[hotfix][docs] Replace/fix links in checkpointing documents.", "committedDate": "2020-06-24T18:50:26Z", "type": "forcePushed"}]}