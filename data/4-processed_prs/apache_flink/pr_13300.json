{"pr_number": 13300, "pr_title": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "pr_createdAt": "2020-09-01T15:45:45Z", "pr_url": "https://github.com/apache/flink/pull/13300", "timeline": [{"oid": "4f62c8cfc30654a7236e45b48a5846267897ba3a", "url": "https://github.com/apache/flink/commit/4f62c8cfc30654a7236e45b48a5846267897ba3a", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "committedDate": "2020-09-02T04:20:52Z", "type": "forcePushed"}, {"oid": "67048f0564671bfb89f9f1d88a3a717502a9cda8", "url": "https://github.com/apache/flink/commit/67048f0564671bfb89f9f1d88a3a717502a9cda8", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "committedDate": "2020-09-02T07:10:30Z", "type": "forcePushed"}, {"oid": "2ffa66b25a23f76cd7f930b0ca4ddc7ff904f748", "url": "https://github.com/apache/flink/commit/2ffa66b25a23f76cd7f930b0ca4ddc7ff904f748", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "committedDate": "2020-09-02T13:32:11Z", "type": "forcePushed"}, {"oid": "47e4cd9eca1c2772d67e484cfe3f732b4008b188", "url": "https://github.com/apache/flink/commit/47e4cd9eca1c2772d67e484cfe3f732b4008b188", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "committedDate": "2020-09-02T13:33:10Z", "type": "forcePushed"}, {"oid": "b32accb0c729ab361a8becf74808427f103bdeb0", "url": "https://github.com/apache/flink/commit/b32accb0c729ab361a8becf74808427f103bdeb0", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator.", "committedDate": "2020-10-18T04:07:49Z", "type": "forcePushed"}, {"oid": "ef62f94dc62ef90adbba35e3fc13119c2c0464b6", "url": "https://github.com/apache/flink/commit/ef62f94dc62ef90adbba35e3fc13119c2c0464b6", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator", "committedDate": "2020-10-18T07:13:43Z", "type": "forcePushed"}, {"oid": "831c8b47f5ac23fabf85fc6e1e868a39e057e540", "url": "https://github.com/apache/flink/commit/831c8b47f5ac23fabf85fc6e1e868a39e057e540", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator", "committedDate": "2020-10-18T14:25:44Z", "type": "forcePushed"}, {"oid": "26d7664c3772665425813a493ae546208dfae2bb", "url": "https://github.com/apache/flink/commit/26d7664c3772665425813a493ae546208dfae2bb", "message": "[FLINK-19077][table-runtime] Import process time temporal join operator", "committedDate": "2020-10-22T08:36:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1MTA1Mg==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511751052", "bodyText": "Do not in a separate line.", "author": "wuchong", "createdAt": "2020-10-26T07:03:39Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -36,29 +37,42 @@\n \n /**\n  * The operator to temporal join a stream on processing time.\n+ *\n+ * <p>For temporal TableFunction join (LATERAL TemporalTableFunction(o.proctime)) and\n+ * temporal table join (FOR SYSTEM_TIME AS OF), they can reuse same processing-time operator\n+ * implementation, the differences between them are:\n+ * (1) The temporal TableFunction join only supports single column in primary key but\n+ * temporal table join supports arbitrary columns in primary key.\n+ * (2) The temporal TableFunction join only supports inner join, temporal table join\n+ * supports both inner join and left outer join.\n  */\n-public class LegacyTemporalProcessTimeJoinOperator\n+public class TemporalProcessTimeJoinOperator\n \textends BaseTwoInputStreamOperatorWithStateRetention {\n \n \tprivate static final long serialVersionUID = -5182289624027523612L;\n \n+\tprivate final boolean isLeftOuterJoin;\n \tprivate final InternalTypeInfo<RowData> rightType;\n \tprivate final GeneratedJoinCondition generatedJoinCondition;\n \n \tprivate transient ValueState<RowData> rightState;\n \tprivate transient JoinCondition joinCondition;\n \n \tprivate transient JoinedRowData outRow;\n+\tprivate transient GenericRowData rightNullRow;\n \tprivate transient TimestampedCollector<RowData> collector;\n \n-\tpublic LegacyTemporalProcessTimeJoinOperator(\n+\tpublic TemporalProcessTimeJoinOperator(\n \t\t\tInternalTypeInfo<RowData> rightType,\n \t\t\tGeneratedJoinCondition generatedJoinCondition,\n \t\t\tlong minRetentionTime,\n-\t\t\tlong maxRetentionTime) {\n+\t\t\tlong maxRetentionTime,\n+\t\t\tboolean isLeftOuterJoin\n+\t\t\t) {", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1MjQ0NQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511752445", "bodyText": "Would it be better to refactor this into collectJoinedRow(RowData leftRow, RowData rightRow)? Then we can reuse this method for non-left-join result. E.g.\ncollectJoinedRow(leftSideRow, rightNullRow); // left x null\ncollectJoinedRow(leftSideRow, rightSideRow); // left x right", "author": "wuchong", "createdAt": "2020-10-26T07:08:05Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -72,24 +86,40 @@ public void open() throws Exception {\n \t\tthis.rightState = getRuntimeContext().getState(rightStateDesc);\n \t\tthis.collector = new TimestampedCollector<>(output);\n \t\tthis.outRow = new JoinedRowData();\n+\t\tthis.rightNullRow = new GenericRowData(rightType.toRowSize());\n \t\t// consider watermark from left stream only.\n \t\tsuper.processWatermark2(Watermark.MAX_WATERMARK);\n \t}\n \n \t@Override\n \tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData leftSideRow = element.getValue();\n \t\tRowData rightSideRow = rightState.value();\n+\n \t\tif (rightSideRow == null) {\n-\t\t\treturn;\n+\t\t\tif (isLeftOuterJoin) {\n+\t\t\t\tpadNullForLeftOuterJoin(leftSideRow);\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (joinCondition.apply(leftSideRow, rightSideRow)) {\n+\t\t\t\toutRow.setRowKind(leftSideRow.getRowKind());\n+\t\t\t\toutRow.replace(leftSideRow, rightSideRow);\n+\t\t\t\tcollector.collect(outRow);\n+\t\t\t} else {\n+\t\t\t\tif (isLeftOuterJoin) {\n+\t\t\t\t\tpadNullForLeftOuterJoin(leftSideRow);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tregisterProcessingCleanupTimer();\n \t\t}\n+\t}\n \n-\t\tRowData leftSideRow = element.getValue();\n-\t\tif (joinCondition.apply(leftSideRow, rightSideRow)) {\n-\t\t\toutRow.setRowKind(leftSideRow.getRowKind());\n-\t\t\toutRow.replace(leftSideRow, rightSideRow);\n-\t\t\tcollector.collect(outRow);\n-\t\t}\n-\t\tregisterProcessingCleanupTimer();\n+\tprivate void padNullForLeftOuterJoin(RowData leftSideRow) {", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1MzgxOQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511753819", "bodyText": "Add a comment why we don't need to register cleanup timer when rightSideRow == null", "author": "wuchong", "createdAt": "2020-10-26T07:12:15Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -72,24 +86,40 @@ public void open() throws Exception {\n \t\tthis.rightState = getRuntimeContext().getState(rightStateDesc);\n \t\tthis.collector = new TimestampedCollector<>(output);\n \t\tthis.outRow = new JoinedRowData();\n+\t\tthis.rightNullRow = new GenericRowData(rightType.toRowSize());\n \t\t// consider watermark from left stream only.\n \t\tsuper.processWatermark2(Watermark.MAX_WATERMARK);\n \t}\n \n \t@Override\n \tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData leftSideRow = element.getValue();\n \t\tRowData rightSideRow = rightState.value();\n+\n \t\tif (rightSideRow == null) {\n-\t\t\treturn;\n+\t\t\tif (isLeftOuterJoin) {\n+\t\t\t\tpadNullForLeftOuterJoin(leftSideRow);\n+\t\t\t} else {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (joinCondition.apply(leftSideRow, rightSideRow)) {\n+\t\t\t\toutRow.setRowKind(leftSideRow.getRowKind());\n+\t\t\t\toutRow.replace(leftSideRow, rightSideRow);\n+\t\t\t\tcollector.collect(outRow);\n+\t\t\t} else {\n+\t\t\t\tif (isLeftOuterJoin) {\n+\t\t\t\t\tpadNullForLeftOuterJoin(leftSideRow);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tregisterProcessingCleanupTimer();", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1NDU0OQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511754549", "bodyText": "LegacyTemporalProcessTimeJoinOperatorTest -> TemporalProcessTimeJoinOperatorTest?", "author": "wuchong", "createdAt": "2020-10-26T07:14:35Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperatorTest.java", "diffHunk": "@@ -26,46 +26,49 @@\n import org.apache.flink.table.runtime.util.RowDataHarnessAssertor;\n import org.apache.flink.table.types.logical.BigIntType;\n import org.apache.flink.table.types.logical.VarCharType;\n+import org.apache.flink.types.RowKind;\n \n import org.junit.Test;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.record;\n \n /**\n- * Harness tests for {@link LegacyTemporalProcessTimeJoinOperator}.\n+ * Harness tests for {@link TemporalProcessTimeJoinOperator}.\n  */\n public class LegacyTemporalProcessTimeJoinOperatorTest extends LegacyTemporalTimeJoinOperatorTestBase {", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1NzI3Mw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511757273", "bodyText": "It would be better to not mix using insertRecord and record, we can use updateBeforeRecord, deleteRecord instead.", "author": "wuchong", "createdAt": "2020-10-26T07:22:13Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperatorTest.java", "diffHunk": "@@ -123,13 +127,93 @@ public void testProcTimeTemporalJoinWithStateRetention() throws Exception {\n \t\ttestHarness.close();\n \t}\n \n+\t/**\n+\t * Test proctime left temporal join when set idle state retention.\n+\t */\n+\t@Test\n+\tpublic void testLeftProcTimeTemporalJoinWithStateRetention() throws Exception {\n+\t\tfinal int minRetentionTime = 10;\n+\t\tfinal int maxRetentionTime = minRetentionTime * 3 / 2;\n+\t\tTemporalProcessTimeJoinOperator joinOperator = new TemporalProcessTimeJoinOperator(\n+\t\t\t\trowType,\n+\t\t\t\tjoinCondition,\n+\t\t\t\tminRetentionTime,\n+\t\t\t\tmaxRetentionTime,\n+\t\t\t\ttrue);\n+\t\tKeyedTwoInputStreamOperatorTestHarness<RowData, RowData, RowData, RowData> testHarness = createTestHarness(\n+\t\t\t\tjoinOperator);\n+\t\ttestHarness.open();\n+\t\ttestHarness.setProcessingTime(1);\n+\t\ttestHarness.processElement1(insertRecord(1L, \"1a1\"));\n+\n+\t\ttestHarness.setProcessingTime(2);\n+\t\ttestHarness.processElement2(insertRecord(2L, \"2a2\"));\n+\n+\t\ttestHarness.setProcessingTime(3);\n+\t\ttestHarness.processElement1(insertRecord(2L, \"2a3\"));\n+\n+\t\ttestHarness.setProcessingTime(3 + maxRetentionTime);\n+\t\ttestHarness.processElement1(insertRecord(2L, \"1a5\"));\n+\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(insertRecord(1L, \"1a1\", null, null));\n+\t\texpectedOutput.add(insertRecord(2L, \"2a3\", 2L, \"2a2\"));\n+\t\texpectedOutput.add(insertRecord(2L, \"1a5\", null, null));\n+\n+\t\tassertor.assertOutputEquals(\"output wrong.\", expectedOutput, testHarness.getOutput());\n+\t\ttestHarness.close();\n+\t}\n+\n+\t/**\n+\t * Test proctime temporal join changelog stream.\n+\t */\n+\t@Test\n+\tpublic void testProcTimeTemporalJoinOnChangelog() throws Exception {\n+\t\tTemporalProcessTimeJoinOperator joinOperator = new TemporalProcessTimeJoinOperator(\n+\t\t\t\trowType,\n+\t\t\t\tjoinCondition,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\tfalse);\n+\t\tKeyedTwoInputStreamOperatorTestHarness<RowData, RowData, RowData, RowData> testHarness = createTestHarness(\n+\t\t\t\tjoinOperator);\n+\t\ttestHarness.open();\n+\t\ttestHarness.setProcessingTime(1);\n+\t\ttestHarness.processElement1(insertRecord(1L, \"1a1\"));\n+\n+\t\ttestHarness.setProcessingTime(2);\n+\t\ttestHarness.processElement2(record(RowKind.INSERT, 2L, \"2a2\"));\n+\n+\t\ttestHarness.setProcessingTime(3);\n+\t\ttestHarness.processElement1(insertRecord(2L, \"2a3\"));\n+\n+\t\ttestHarness.setProcessingTime(4);\n+\t\ttestHarness.processElement2(record(RowKind.INSERT, 1L, \"1a4\"));\n+\t\ttestHarness.processElement2(record(RowKind.UPDATE_BEFORE, 1L, \"1a4\"));\n+\t\ttestHarness.processElement2(record(RowKind.UPDATE_AFTER, 1L, \"1a7\"));\n+\n+\t\ttestHarness.setProcessingTime(5);\n+\t\ttestHarness.processElement1(insertRecord(1L, \"1a5\"));\n+\t\ttestHarness.processElement2(record(RowKind.DELETE, 1L, \"1a7\"));", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1NzY4Ng==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511757686", "bodyText": "Revert changes on this file? I think one indent is correct.", "author": "wuchong", "createdAt": "2020-10-26T07:23:21Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperatorTest.java", "diffHunk": "@@ -40,22 +40,22 @@\n  */\n public class LegacyTemporalRowTimeJoinOperatorTest extends LegacyTemporalTimeJoinOperatorTestBase {", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1Nzc3Mw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511757773", "bodyText": "Revert changes on this file? I think one indent is correct.", "author": "wuchong", "createdAt": "2020-10-26T07:23:31Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalTimeJoinOperatorTestBase.java", "diffHunk": "@@ -25,19 +25,19 @@\n  */\n public class LegacyTemporalTimeJoinOperatorTestBase {\n \tprotected String funcCode =\n-\t\t\"public class TimeTemporalJoinCondition extends org.apache.flink.api.common.functions.AbstractRichFunction \" +\n-\t\t\t\"implements org.apache.flink.table.runtime.generated.JoinCondition {\\n\"\n-\t\t\t+ \"\\n\"\n-\t\t\t+ \"    public TimeTemporalJoinCondition(Object[] reference) {\\n\"\n-\t\t\t+ \"    }\\n\"\n-\t\t\t+ \"\\n\"\n-\t\t\t+ \"    @Override\\n\"\n-\t\t\t+ \"    public boolean apply(org.apache.flink.table.data.RowData in1, org.apache.flink.table.data.RowData in2) {\\n\"\n-\t\t\t+ \"        return true;\\n\"\n-\t\t\t+ \"    }\\n\"\n-\t\t\t+ \"}\\n\";\n+\t\t\t\"public class TimeTemporalJoinCondition extends org.apache.flink.api.common.functions.AbstractRichFunction \" +", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzEzNw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511807137", "bodyText": "This is never used.", "author": "wuchong", "createdAt": "2020-10-26T09:04:48Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -49,6 +62,19 @@ class StreamExecTemporalJoin(\n   with StreamPhysicalRel\n   with StreamExecNode[RowData] {\n \n+  def rightInputUniqueKeyContainsJoinKey(): Boolean = {", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxNzg5OA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511817898", "bodyText": "It seems that we never check primary key on the right side when it is processing time temporal join.\nI think currently, we only support primary key == join key.\nAnd could you add such a unit test for this exception?", "author": "wuchong", "createdAt": "2020-10-26T09:22:54Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +110,261 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+      throw new TableException(\n+        \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+          \"but was \" + joinType.toString + \" JOIN\")\n+    }\n+\n+    val isLeftOuterJoin = joinType == JoinRelType.LEFT\n+    val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n+    val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n+    if (rightRowTimeAttributeInputReference.isDefined) {\n+      throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n+    } else {\n+      new TemporalProcessTimeJoinOperator(\n+        InternalTypeInfo.of(rightInputType),\n+        generatedJoinCondition,\n+        minRetentionTime,\n+        maxRetentionTime,\n+        isLeftOuterJoin)\n+    }\n+  }\n+}\n+\n+object StreamExecTemporalJoinToCoProcessTranslator {\n+  def create(\n+    textualRepresentation: String,\n+    config: TableConfig,\n+    returnType: RowType,\n+    leftInput: RelNode,\n+    rightInput: RelNode,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n+\n+\n+    val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n+    val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n+\n+    val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n+      textualRepresentation,\n+      leftType.getFieldCount,\n+      joinInfo,\n+      rexBuilder)\n+\n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+    val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n+\n+    val (leftTimeAttributeInputRef, rightRowTimeAttributeInputRef: Option[Int]) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+        checkState(temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKey.isDefined,\n+          \"Missing %s in Event-Time temporal join condition\", TEMPORAL_JOIN_CONDITION)\n+\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        val rightTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.rightTimeAttribute.get, textualRepresentation)\n+        val rightInputRef = rightTimeAttributeInputRef - leftType.getFieldCount\n+\n+        (leftTimeAttributeInputRef, Some(rightInputRef))\n+      } else {\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        // right time attribute defined in temporal join condition iff in Event time join\n+        (leftTimeAttributeInputRef, None)\n+      }\n+\n+    new StreamExecTemporalJoinToCoProcessTranslator(\n+      textualRepresentation,\n+      config,\n+      returnType,\n+      leftType,\n+      rightType,\n+      joinInfo,\n+      rexBuilder,\n+      leftTimeAttributeInputRef,\n+      rightRowTimeAttributeInputRef,\n+      remainingNonEquiJoinPredicates)\n+  }\n+\n+  private def extractInputRef(rexNode: RexNode, textualRepresentation: String): Int = {\n+    val inputReferenceVisitor = new InputRefVisitor\n+    rexNode.accept(inputReferenceVisitor)\n+    checkState(\n+      inputReferenceVisitor.getFields.length == 1,\n+      \"Failed to find input reference in [%s]\",\n+      textualRepresentation)\n+    inputReferenceVisitor.getFields.head\n+  }\n+\n+  private class TemporalJoinConditionExtractor(\n+    textualRepresentation: String,\n+    rightKeysStartingOffset: Int,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder)\n+\n+    extends RexShuttle {\n+\n+    var leftTimeAttribute: Option[RexNode] = None\n+\n+    var rightTimeAttribute: Option[RexNode] = None\n+\n+    var rightPrimaryKey: Option[Array[RexNode]] = None\n+\n+    override def visitCall(call: RexCall): RexNode = {\n+      if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n+        return super.visitCall(call)\n+      }\n+\n+      if (TemporalJoinUtil.isRowTimeTemporalJoinConditionCall(call)) {\n+        leftTimeAttribute = Some(call.getOperands.get(0))\n+        rightTimeAttribute = Some(call.getOperands.get(1))\n+        rightPrimaryKey = Some(extractPrimaryKeyArray(call.getOperands.get(4)))\n+      } else {\n+        leftTimeAttribute = Some(call.getOperands.get(0))", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDQ3OA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512084478", "bodyText": "I think the  primary key contained in join key is more proper way, I'll add a test", "author": "leonardBang", "createdAt": "2020-10-26T16:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxNzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDczMA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511820730", "bodyText": "Why the 4 operands call (LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY) is not row time temporal join?", "author": "wuchong", "createdAt": "2020-10-26T09:27:27Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -198,7 +198,7 @@ object TemporalJoinUtil {\n   }\n \n   def isRowTimeTemporalJoinConditionCall(rexCall: RexCall): Boolean = {\n-    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length > 3\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length == 5", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3ODc1Ng==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512078756", "bodyText": "the PRIMARY_KEY is necessary for row time temporal join.", "author": "leonardBang", "createdAt": "2020-10-26T16:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzEzNA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511833134", "bodyText": "Please fills the missing UB, UA messages.", "author": "wuchong", "createdAt": "2020-10-26T09:47:19Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,250 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQzNw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r511833437", "bodyText": "Please update the row kinds.", "author": "wuchong", "createdAt": "2020-10-26T09:47:49Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,250 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))", "originalCommit": "93048dd26aef5150440f66db3c3a408564ab61fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0ODIyNg==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512548226", "bodyText": "Split parameters into separate lines.", "author": "wuchong", "createdAt": "2020-10-27T09:49:27Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -287,10 +287,10 @@ abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n             s\" but no row time attribute can be found.\")\n       }\n       // Deal primary key in TemporalJoinRewriteUniqueKeyRule\n-      TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+      TemporalJoinUtil.makeInitialRowTimeTemporalTableJoinCondCall(rexBuilder, snapshotTimeInputRef,", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0OTU3OA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512549578", "bodyText": "I think it would be better to use if else branch for conditions instead of match pattern.", "author": "wuchong", "createdAt": "2020-10-27T09:51:27Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -69,19 +68,33 @@ class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n \n     val newJoinCondition = joinCondition.accept(new RexShuttle {\n       override def visitCall(call: RexCall): RexNode = {\n-        if (call.getOperator == TemporalJoinUtil.TEMPORAL_JOIN_CONDITION &&\n-        isRowTimeTemporalTableJoin(snapshot)) {\n-          val snapshotTimeInputRef = call.operands(0)\n-          val rightTimeInputRef = call.operands(1)\n-          val leftJoinKey = call.operands(2).asInstanceOf[RexCall].operands\n-          val rightJoinKey = call.operands(3).asInstanceOf[RexCall].operands\n+        if (call.getOperator == TemporalJoinUtil.INITIAL_TEMPORAL_JOIN_CONDITION) {\n+          val (snapshotTimeInputRef, leftJoinKey, rightJoinKey) =\n+            TemporalJoinUtil.isInitialRowTimeTemporalTableJoin(call) match {\n+              case true =>", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1Mjc2MQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512552761", "bodyText": "Would be better to print the plan tree which is helpful for debugging.", "author": "wuchong", "createdAt": "2020-10-27T09:56:08Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -98,9 +111,8 @@ class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n       rightPrimaryKeyInputRefs: Option[Seq[RexNode]]): Unit = {\n \n     if (rightPrimaryKeyInputRefs.isEmpty) {\n-      throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n-        s\" primary key and row time attribute in versioned table,\" +\n-        s\" but no primary key can be found.\")\n+      throw new ValidationException(\"Temporal Table Join requires\" +\n+        s\" primary key in versioned table, but no primary key can be found.\")", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1NDMxMg==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512554312", "bodyText": "Would be better to print what't the join key and primary key of temporal table. This would be useful for debugging.", "author": "wuchong", "createdAt": "2020-10-27T09:58:24Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -116,8 +128,8 @@ class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n \n     if (!primaryKeyContainedInJoinKey) {\n       throw new ValidationException(\n-        s\"Join key must be the same as temporal table's primary key \" +\n-          s\"in Event-time temporal table join.\")\n+        s\"Join key must contains temporal table's primary key \" +\n+          s\"in temporal table join.\")", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1OTI4NQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512559285", "bodyText": "Reorder imports.", "author": "wuchong", "createdAt": "2020-10-27T10:05:39Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,25 +18,42 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import java.util\n+\n import org.apache.flink.api.dag.Transformation\n-import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.api.java.typeutils.ResultTypeQueryable\n+import org.apache.flink.streaming.api.operators.TwoInputStreamOperator\n+import org.apache.flink.streaming.api.transformations.TwoInputTransformation\n+import org.apache.flink.table.api.{TableConfig, TableException, ValidationException}\n import org.apache.flink.table.data.RowData\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory\n+import org.apache.flink.table.planner.codegen.{CodeGeneratorContext, ExprCodeGenerator, FunctionCodeGenerator}\n import org.apache.flink.table.planner.delegation.StreamPlanner\n import org.apache.flink.table.planner.plan.nodes.common.CommonPhysicalJoin\n import org.apache.flink.table.planner.plan.nodes.exec.{ExecNode, StreamExecNode}\n-import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n-\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil.{TEMPORAL_JOIN_CONDITION, TEMPORAL_JOIN_CONDITION_PRIMARY_KEY}\n+import org.apache.flink.table.planner.plan.utils.{InputRefVisitor, KeySelectorUtil, RelExplainUtil, TemporalJoinUtil}\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition\n+import org.apache.flink.table.runtime.keyselector.RowDataKeySelector\n+import org.apache.flink.table.runtime.operators.join.temporal.{LegacyTemporalRowTimeJoinOperator, TemporalProcessTimeJoinOperator}\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo\n+import org.apache.flink.table.types.logical.RowType\n+import org.apache.flink.util.Preconditions.checkState\n import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.core.{Join, JoinRelType}\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n import org.apache.calcite.rex._\n-\n-import java.util\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.{isProctimeIndicatorType, isRowtimeIndicatorType}", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1OTcyNg==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512559726", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * the only difference is the validation, We reuse most same logic here;\n          \n          \n            \n             * the only difference is the validation, we reuse most same logic here.", "author": "wuchong", "createdAt": "2020-10-27T10:06:21Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,25 +18,42 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import java.util\n+\n import org.apache.flink.api.dag.Transformation\n-import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.api.java.typeutils.ResultTypeQueryable\n+import org.apache.flink.streaming.api.operators.TwoInputStreamOperator\n+import org.apache.flink.streaming.api.transformations.TwoInputTransformation\n+import org.apache.flink.table.api.{TableConfig, TableException, ValidationException}\n import org.apache.flink.table.data.RowData\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory\n+import org.apache.flink.table.planner.codegen.{CodeGeneratorContext, ExprCodeGenerator, FunctionCodeGenerator}\n import org.apache.flink.table.planner.delegation.StreamPlanner\n import org.apache.flink.table.planner.plan.nodes.common.CommonPhysicalJoin\n import org.apache.flink.table.planner.plan.nodes.exec.{ExecNode, StreamExecNode}\n-import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n-\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil.{TEMPORAL_JOIN_CONDITION, TEMPORAL_JOIN_CONDITION_PRIMARY_KEY}\n+import org.apache.flink.table.planner.plan.utils.{InputRefVisitor, KeySelectorUtil, RelExplainUtil, TemporalJoinUtil}\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition\n+import org.apache.flink.table.runtime.keyselector.RowDataKeySelector\n+import org.apache.flink.table.runtime.operators.join.temporal.{LegacyTemporalRowTimeJoinOperator, TemporalProcessTimeJoinOperator}\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo\n+import org.apache.flink.table.types.logical.RowType\n+import org.apache.flink.util.Preconditions.checkState\n import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.core.{Join, JoinRelType}\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n import org.apache.calcite.rex._\n-\n-import java.util\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.{isProctimeIndicatorType, isRowtimeIndicatorType}\n \n import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n- * Stream physical node for temporal table join (FOR SYSTEM_TIME AS OF).\n+ * Stream physical node for temporal table join (FOR SYSTEM_TIME AS OF) and\n+ * temporal TableFunction join (LATERAL TemporalTableFunction(o.proctime).\n+ *\n+ * <p>The legacy temporal table function join is the subset of temporal table join,\n+ * the only difference is the validation, We reuse most same logic here;", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU1OTk1NQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512559955", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * temporal TableFunction join (LATERAL TemporalTableFunction(o.proctime).\n          \n          \n            \n             * temporal TableFunction join (LATERAL TemporalTableFunction(o.proctime)).", "author": "wuchong", "createdAt": "2020-10-27T10:06:40Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,25 +18,42 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import java.util\n+\n import org.apache.flink.api.dag.Transformation\n-import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.api.java.typeutils.ResultTypeQueryable\n+import org.apache.flink.streaming.api.operators.TwoInputStreamOperator\n+import org.apache.flink.streaming.api.transformations.TwoInputTransformation\n+import org.apache.flink.table.api.{TableConfig, TableException, ValidationException}\n import org.apache.flink.table.data.RowData\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory\n+import org.apache.flink.table.planner.codegen.{CodeGeneratorContext, ExprCodeGenerator, FunctionCodeGenerator}\n import org.apache.flink.table.planner.delegation.StreamPlanner\n import org.apache.flink.table.planner.plan.nodes.common.CommonPhysicalJoin\n import org.apache.flink.table.planner.plan.nodes.exec.{ExecNode, StreamExecNode}\n-import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n-\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil.{TEMPORAL_JOIN_CONDITION, TEMPORAL_JOIN_CONDITION_PRIMARY_KEY}\n+import org.apache.flink.table.planner.plan.utils.{InputRefVisitor, KeySelectorUtil, RelExplainUtil, TemporalJoinUtil}\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition\n+import org.apache.flink.table.runtime.keyselector.RowDataKeySelector\n+import org.apache.flink.table.runtime.operators.join.temporal.{LegacyTemporalRowTimeJoinOperator, TemporalProcessTimeJoinOperator}\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo\n+import org.apache.flink.table.types.logical.RowType\n+import org.apache.flink.util.Preconditions.checkState\n import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.core.{Join, JoinRelType}\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n import org.apache.calcite.rex._\n-\n-import java.util\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.{isProctimeIndicatorType, isRowtimeIndicatorType}\n \n import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n- * Stream physical node for temporal table join (FOR SYSTEM_TIME AS OF).\n+ * Stream physical node for temporal table join (FOR SYSTEM_TIME AS OF) and\n+ * temporal TableFunction join (LATERAL TemporalTableFunction(o.proctime).", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2MDMxNQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512560315", "bodyText": "Add one more indent for constructor parameters.", "author": "wuchong", "createdAt": "2020-10-27T10:07:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2MDk2MA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512560960", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n          \n          \n            \n                        \"but was \" + joinType.toString + \" JOIN\")\n          \n          \n            \n                      \"Temporal table function join currently only support INNER JOIN, \" +\n          \n          \n            \n                        \"but was \" + joinType.toString + \" JOIN.\")", "author": "wuchong", "createdAt": "2020-10-27T10:08:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2MTA0Nw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512561047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"but was \" + joinType.toString + \" JOIN\")\n          \n          \n            \n                        \"but was \" + joinType.toString + \" JOIN.\")", "author": "wuchong", "createdAt": "2020-10-27T10:08:19Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    } else {\n+      if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+        throw new TableException(\n+          \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2MTQ2Nw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512561467", "bodyText": "create the issue and fill up the issue id.", "author": "wuchong", "createdAt": "2020-10-27T10:09:00Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    } else {\n+      if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+        throw new TableException(\n+          \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    }\n+\n+    val isLeftOuterJoin = joinType == JoinRelType.LEFT\n+    val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n+    val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n+    if (rightRowTimeAttributeInputReference.isDefined) {\n+      if (isTemporalFunctionJoin) {\n+        new LegacyTemporalRowTimeJoinOperator(\n+          InternalTypeInfo.of(leftInputType),\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          leftTimeAttributeInputReference,\n+          rightRowTimeAttributeInputReference.get,\n+          minRetentionTime,\n+          maxRetentionTime)\n+      } else {\n+        throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n+      }\n+    } else {\n+      if (isTemporalFunctionJoin) {\n+        new TemporalProcessTimeJoinOperator(\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          minRetentionTime,\n+          maxRetentionTime,\n+          isLeftOuterJoin)\n+      } else {\n+        // current Processing-time temporal join implements has been finished, but the version from\n+        // versioned table may be uncompleted, it may mislead users in production environment.\n+        // So, we disable this feature here, see FLINK-xx for more details.", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NDgzMA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512564830", "bodyText": "The exsiting TemporalProcessTimeJoinOperator has already supported temporal table join.\nHowever, the semantic of this implementation is problematic, because the join processing for left stream doesn't wait for the complete snapshot of temporal table, this may mislead users in production environment.", "author": "wuchong", "createdAt": "2020-10-27T10:14:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    } else {\n+      if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+        throw new TableException(\n+          \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    }\n+\n+    val isLeftOuterJoin = joinType == JoinRelType.LEFT\n+    val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n+    val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n+    if (rightRowTimeAttributeInputReference.isDefined) {\n+      if (isTemporalFunctionJoin) {\n+        new LegacyTemporalRowTimeJoinOperator(\n+          InternalTypeInfo.of(leftInputType),\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          leftTimeAttributeInputReference,\n+          rightRowTimeAttributeInputReference.get,\n+          minRetentionTime,\n+          maxRetentionTime)\n+      } else {\n+        throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n+      }\n+    } else {\n+      if (isTemporalFunctionJoin) {\n+        new TemporalProcessTimeJoinOperator(\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          minRetentionTime,\n+          maxRetentionTime,\n+          isLeftOuterJoin)\n+      } else {\n+        // current Processing-time temporal join implements has been finished, but the version from", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNzAzNw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512617037", "bodyText": "I would suggest to move the special validation logic into TemporalJoinUtil and unify the time attribute & primary key extraction for both legacy and new temporal join.", "author": "wuchong", "createdAt": "2020-10-27T11:35:27Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    } else {\n+      if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+        throw new TableException(\n+          \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    }\n+\n+    val isLeftOuterJoin = joinType == JoinRelType.LEFT\n+    val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n+    val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n+    if (rightRowTimeAttributeInputReference.isDefined) {\n+      if (isTemporalFunctionJoin) {\n+        new LegacyTemporalRowTimeJoinOperator(\n+          InternalTypeInfo.of(leftInputType),\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          leftTimeAttributeInputReference,\n+          rightRowTimeAttributeInputReference.get,\n+          minRetentionTime,\n+          maxRetentionTime)\n+      } else {\n+        throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n+      }\n+    } else {\n+      if (isTemporalFunctionJoin) {\n+        new TemporalProcessTimeJoinOperator(\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          minRetentionTime,\n+          maxRetentionTime,\n+          isLeftOuterJoin)\n+      } else {\n+        // current Processing-time temporal join implements has been finished, but the version from\n+        // versioned table may be uncompleted, it may mislead users in production environment.\n+        // So, we disable this feature here, see FLINK-xx for more details.\n+        throw new TableException(\"Processing-time temporal join is not supported yet.\")\n+      }\n+    }\n+  }\n+}\n+\n+object StreamExecTemporalJoinToCoProcessTranslator {\n+  def create(\n+    textualRepresentation: String,\n+    config: TableConfig,\n+    returnType: RowType,\n+    leftInput: RelNode,\n+    rightInput: RelNode,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n+\n+    val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n+    val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n+    val isTemporalFunctionJoin = TemporalJoinUtil.isTemporalFunctionJoin(rexBuilder, joinInfo)\n+\n+    checkState(\n+      !joinInfo.isEqui,\n+      \"Missing %s in temporal join condition\",\n+      TEMPORAL_JOIN_CONDITION)\n+\n+    val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n+      textualRepresentation,\n+      leftType.getFieldCount,\n+      joinInfo,\n+      rexBuilder,\n+      isTemporalFunctionJoin)\n+\n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+    val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n+\n+    val (leftTimeAttributeInputRef, rightRowTimeAttributeInputRef: Option[Int]) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+        checkState(temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKey.isDefined,\n+          \"Missing %s in Event-Time temporal join condition\", TEMPORAL_JOIN_CONDITION)\n+\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        val rightTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.rightTimeAttribute.get, textualRepresentation)\n+        val rightInputRef = rightTimeAttributeInputRef - leftType.getFieldCount\n+\n+        (leftTimeAttributeInputRef, Some(rightInputRef))\n+      } else {\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        // right time attribute defined in temporal join condition iff in Event time join\n+        (leftTimeAttributeInputRef, None)\n+      }\n+\n+    new StreamExecTemporalJoinToCoProcessTranslator(\n+      textualRepresentation,\n+      config,\n+      returnType,\n+      leftType,\n+      rightType,\n+      joinInfo,\n+      rexBuilder,\n+      leftTimeAttributeInputRef,\n+      rightRowTimeAttributeInputRef,\n+      remainingNonEquiJoinPredicates,\n+      isTemporalFunctionJoin)\n+  }\n+\n+  private def extractInputRef(rexNode: RexNode, textualRepresentation: String): Int = {\n+    val inputReferenceVisitor = new InputRefVisitor\n+    rexNode.accept(inputReferenceVisitor)\n+    checkState(\n+      inputReferenceVisitor.getFields.length == 1,\n+      \"Failed to find input reference in [%s]\",\n+      textualRepresentation)\n+    inputReferenceVisitor.getFields.head\n+  }\n+\n+  private class TemporalJoinConditionExtractor(\n+    textualRepresentation: String,\n+    rightKeysStartingOffset: Int,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder,\n+    isTemporalFunctionJoin: Boolean) extends RexShuttle {\n+\n+    var leftTimeAttribute: Option[RexNode] = None\n+\n+    var rightTimeAttribute: Option[RexNode] = None\n+\n+    var rightPrimaryKey: Option[Array[RexNode]] = None\n+\n+    override def visitCall(call: RexCall): RexNode = {\n+      if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n+        return super.visitCall(call)\n+      }\n+      // the condition of temporal function comes from WHERE clause,\n+      // so it's not been validated in logical plan\n+      if (isTemporalFunctionJoin) {\n+        validateAndExtractTemporalFunctionCondition(call)", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNzIzOQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512617239", "bodyText": "We can put the primary key at the 2nd position, then the extraction logic should be the same with legacy temporal join.", "author": "wuchong", "createdAt": "2020-10-27T11:35:50Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -84,6 +101,361 @@ class StreamExecTemporalJoin(\n   override protected def translateToPlanInternal(\n     planner: StreamPlanner): Transformation[RowData] = {\n \n-    throw new ValidationException(\"Physical node of temporal join does not supported yet.\")\n+    validateKeyTypes()\n+\n+    val returnType = FlinkTypeFactory.toLogicalRowType(getRowType)\n+\n+    val joinTranslator = StreamExecTemporalJoinToCoProcessTranslator.create(\n+      this.toString,\n+      planner.getTableConfig,\n+      returnType,\n+      leftRel,\n+      rightRel,\n+      getJoinInfo,\n+      cluster.getRexBuilder)\n+\n+    val joinOperator = joinTranslator.getJoinOperator(joinType, returnType.getFieldNames)\n+    val leftKeySelector = joinTranslator.getLeftKeySelector\n+    val rightKeySelector = joinTranslator.getRightKeySelector\n+\n+    val leftTransform = getInputNodes.get(0).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+    val rightTransform = getInputNodes.get(1).translateToPlan(planner)\n+      .asInstanceOf[Transformation[RowData]]\n+\n+    val ret = new TwoInputTransformation[RowData, RowData, RowData](\n+      leftTransform,\n+      rightTransform,\n+      getRelDetailedDescription,\n+      joinOperator,\n+      InternalTypeInfo.of(returnType),\n+      leftTransform.getParallelism)\n+\n+    if (inputsContainSingleton()) {\n+      ret.setParallelism(1)\n+      ret.setMaxParallelism(1)\n+    }\n+\n+    // set KeyType and Selector for state\n+    ret.setStateKeySelectors(leftKeySelector, rightKeySelector)\n+    ret.setStateKeyType(leftKeySelector.asInstanceOf[ResultTypeQueryable[_]].getProducedType)\n+    ret\n+  }\n+\n+  private def validateKeyTypes(): Unit = {\n+    // at least one equality expression\n+    val leftFields = left.getRowType.getFieldList\n+    val rightFields = right.getRowType.getFieldList\n+\n+    getJoinInfo.pairs().toList.foreach(pair => {\n+      val leftKeyType = leftFields.get(pair.source).getType.getSqlTypeName\n+      val rightKeyType = rightFields.get(pair.target).getType.getSqlTypeName\n+      // check if keys are compatible\n+      if (leftKeyType != rightKeyType) {\n+        throw new TableException(\n+          \"Equality join predicate on incompatible types.\\n\" +\n+            s\"\\tLeft: $left,\\n\" +\n+            s\"\\tRight: $right,\\n\" +\n+            s\"\\tCondition: (${RelExplainUtil.expressionToString(\n+              getCondition, inputRowType, getExpressionString)})\"\n+        )\n+      }\n+    })\n+  }\n+}\n+\n+/**\n+  * @param rightRowTimeAttributeInputReference is defined only for event time joins.\n+  */\n+class StreamExecTemporalJoinToCoProcessTranslator private(\n+  textualRepresentation: String,\n+  config: TableConfig,\n+  returnType: RowType,\n+  leftInputType: RowType,\n+  rightInputType: RowType,\n+  joinInfo: JoinInfo,\n+  rexBuilder: RexBuilder,\n+  leftTimeAttributeInputReference: Int,\n+  rightRowTimeAttributeInputReference: Option[Int],\n+  remainingNonEquiJoinPredicates: RexNode,\n+  isTemporalFunctionJoin: Boolean) {\n+\n+  val nonEquiJoinPredicates: Option[RexNode] = Some(remainingNonEquiJoinPredicates)\n+\n+  def getLeftKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.leftKeys.toIntArray,\n+      InternalTypeInfo.of(leftInputType)\n+    )\n+  }\n+\n+  def getRightKeySelector: RowDataKeySelector = {\n+    KeySelectorUtil.getRowDataSelector(\n+      joinInfo.rightKeys.toIntArray,\n+      InternalTypeInfo.of(rightInputType)\n+    )\n+  }\n+\n+  def getJoinOperator(\n+    joinType: JoinRelType,\n+    returnFieldNames: Seq[String]): TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    // input must not be nullable, because the runtime join function will make sure\n+    // the code-generated function won't process null inputs\n+    val ctx = CodeGeneratorContext(config)\n+    val exprGenerator = new ExprCodeGenerator(ctx, nullableInput = false)\n+      .bindInput(leftInputType)\n+      .bindSecondInput(rightInputType)\n+\n+    val body = if (nonEquiJoinPredicates.isEmpty) {\n+      // only equality condition\n+      \"return true;\"\n+    } else {\n+      val condition = exprGenerator.generateExpression(nonEquiJoinPredicates.get)\n+      s\"\"\"\n+         |${condition.code}\n+         |return ${condition.resultTerm};\n+         |\"\"\".stripMargin\n+    }\n+\n+    val generatedJoinCondition = FunctionCodeGenerator.generateJoinCondition(\n+      ctx,\n+      \"ConditionFunction\",\n+      body)\n+\n+    createJoinOperator(config, joinType, generatedJoinCondition)\n+  }\n+\n+  protected def createJoinOperator(\n+    tableConfig: TableConfig,\n+    joinType: JoinRelType,\n+    generatedJoinCondition: GeneratedJoinCondition)\n+  : TwoInputStreamOperator[RowData, RowData, RowData] = {\n+\n+    if (isTemporalFunctionJoin) {\n+      if (joinType != JoinRelType.INNER) {\n+        throw new ValidationException(\n+          \"Temporal table function join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    } else {\n+      if (joinType != JoinRelType.LEFT && joinType != JoinRelType.INNER) {\n+        throw new TableException(\n+          \"Temporal table join currently only support INNER JOIN and LEFT JOIN, \" +\n+            \"but was \" + joinType.toString + \" JOIN\")\n+      }\n+    }\n+\n+    val isLeftOuterJoin = joinType == JoinRelType.LEFT\n+    val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n+    val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n+    if (rightRowTimeAttributeInputReference.isDefined) {\n+      if (isTemporalFunctionJoin) {\n+        new LegacyTemporalRowTimeJoinOperator(\n+          InternalTypeInfo.of(leftInputType),\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          leftTimeAttributeInputReference,\n+          rightRowTimeAttributeInputReference.get,\n+          minRetentionTime,\n+          maxRetentionTime)\n+      } else {\n+        throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n+      }\n+    } else {\n+      if (isTemporalFunctionJoin) {\n+        new TemporalProcessTimeJoinOperator(\n+          InternalTypeInfo.of(rightInputType),\n+          generatedJoinCondition,\n+          minRetentionTime,\n+          maxRetentionTime,\n+          isLeftOuterJoin)\n+      } else {\n+        // current Processing-time temporal join implements has been finished, but the version from\n+        // versioned table may be uncompleted, it may mislead users in production environment.\n+        // So, we disable this feature here, see FLINK-xx for more details.\n+        throw new TableException(\"Processing-time temporal join is not supported yet.\")\n+      }\n+    }\n+  }\n+}\n+\n+object StreamExecTemporalJoinToCoProcessTranslator {\n+  def create(\n+    textualRepresentation: String,\n+    config: TableConfig,\n+    returnType: RowType,\n+    leftInput: RelNode,\n+    rightInput: RelNode,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n+\n+    val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n+    val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n+    val isTemporalFunctionJoin = TemporalJoinUtil.isTemporalFunctionJoin(rexBuilder, joinInfo)\n+\n+    checkState(\n+      !joinInfo.isEqui,\n+      \"Missing %s in temporal join condition\",\n+      TEMPORAL_JOIN_CONDITION)\n+\n+    val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n+      textualRepresentation,\n+      leftType.getFieldCount,\n+      joinInfo,\n+      rexBuilder,\n+      isTemporalFunctionJoin)\n+\n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+    val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n+\n+    val (leftTimeAttributeInputRef, rightRowTimeAttributeInputRef: Option[Int]) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+        checkState(temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKey.isDefined,\n+          \"Missing %s in Event-Time temporal join condition\", TEMPORAL_JOIN_CONDITION)\n+\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        val rightTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.rightTimeAttribute.get, textualRepresentation)\n+        val rightInputRef = rightTimeAttributeInputRef - leftType.getFieldCount\n+\n+        (leftTimeAttributeInputRef, Some(rightInputRef))\n+      } else {\n+        val leftTimeAttributeInputRef = extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get, textualRepresentation)\n+        // right time attribute defined in temporal join condition iff in Event time join\n+        (leftTimeAttributeInputRef, None)\n+      }\n+\n+    new StreamExecTemporalJoinToCoProcessTranslator(\n+      textualRepresentation,\n+      config,\n+      returnType,\n+      leftType,\n+      rightType,\n+      joinInfo,\n+      rexBuilder,\n+      leftTimeAttributeInputRef,\n+      rightRowTimeAttributeInputRef,\n+      remainingNonEquiJoinPredicates,\n+      isTemporalFunctionJoin)\n+  }\n+\n+  private def extractInputRef(rexNode: RexNode, textualRepresentation: String): Int = {\n+    val inputReferenceVisitor = new InputRefVisitor\n+    rexNode.accept(inputReferenceVisitor)\n+    checkState(\n+      inputReferenceVisitor.getFields.length == 1,\n+      \"Failed to find input reference in [%s]\",\n+      textualRepresentation)\n+    inputReferenceVisitor.getFields.head\n+  }\n+\n+  private class TemporalJoinConditionExtractor(\n+    textualRepresentation: String,\n+    rightKeysStartingOffset: Int,\n+    joinInfo: JoinInfo,\n+    rexBuilder: RexBuilder,\n+    isTemporalFunctionJoin: Boolean) extends RexShuttle {\n+\n+    var leftTimeAttribute: Option[RexNode] = None\n+\n+    var rightTimeAttribute: Option[RexNode] = None\n+\n+    var rightPrimaryKey: Option[Array[RexNode]] = None\n+\n+    override def visitCall(call: RexCall): RexNode = {\n+      if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n+        return super.visitCall(call)\n+      }\n+      // the condition of temporal function comes from WHERE clause,\n+      // so it's not been validated in logical plan\n+      if (isTemporalFunctionJoin) {\n+        validateAndExtractTemporalFunctionCondition(call)\n+      }\n+      // temporal table join has been validated in logical plan, only do extract here\n+      else {\n+        if (TemporalJoinUtil.isRowTimeTemporalTableJoinCon(call)) {\n+          leftTimeAttribute = Some(call.getOperands.get(0))\n+          rightTimeAttribute = Some(call.getOperands.get(1))\n+          rightPrimaryKey = Some(extractPrimaryKeyArray(call.getOperands.get(4)))", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxOTI5Mg==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512619292", "bodyText": "Indent.", "author": "wuchong", "createdAt": "2020-10-27T11:39:32Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -186,7 +280,8 @@ object TemporalJoinUtil {\n     var rowtimeJoin: Boolean = false\n     val visitor = new RexVisitorImpl[Unit](true) {\n       override def visitCall(call: RexCall): Unit = {\n-        if (isRowTimeTemporalJoinConditionCall(call)) {\n+        if (isRowTimeTemporalTableJoinCon(call) ||\n+        isRowTimeTemporalFunctionJoinCon(call)) {", "originalCommit": "0bd1d207abdb0e53946b2aaf34a2e1bb012d48ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjczNjc3NQ==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512736775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              def validateAndExtractTemporalFunctionCondition(\n          \n          \n            \n              def validateTemporalFunctionCondition(", "author": "wuchong", "createdAt": "2020-10-27T14:24:58Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -197,8 +294,121 @@ object TemporalJoinUtil {\n     rowtimeJoin\n   }\n \n-  def isRowTimeTemporalJoinConditionCall(rexCall: RexCall): Boolean = {\n-    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length > 3\n+  def isRowTimeTemporalTableJoinCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length == 5\n+  }\n+\n+  def isRowTimeTemporalFunctionJoinCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length == 3\n   }\n \n+  def isTemporalFunctionJoin(rexBuilder: RexBuilder, joinInfo: JoinInfo): Boolean = {\n+    val nonEquiJoinRex = joinInfo.getRemaining(rexBuilder)\n+    var isTemporalFunctionJoin: Boolean = false\n+    val visitor = new RexVisitorImpl[Unit](true) {\n+      override def visitCall(call: RexCall): Unit = {\n+        if (isTemporalFunctionCon(call)) {\n+          isTemporalFunctionJoin = true\n+        } else {\n+          super.visitCall(call)\n+        }\n+      }\n+    }\n+    nonEquiJoinRex.accept(visitor)\n+    isTemporalFunctionJoin\n+  }\n+\n+  def isTemporalFunctionCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION &&\n+      (rexCall.operands.length == 2 || rexCall.operands.length == 3)\n+  }\n+\n+  def validateAndExtractTemporalFunctionCondition(", "originalCommit": "f5ab96acdc20550ee4333519d0517a3f54253758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjczNzk0Nw==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512737947", "bodyText": "Can be RexNode instead of Option?", "author": "wuchong", "createdAt": "2020-10-27T14:26:16Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -197,8 +294,121 @@ object TemporalJoinUtil {\n     rowtimeJoin\n   }\n \n-  def isRowTimeTemporalJoinConditionCall(rexCall: RexCall): Boolean = {\n-    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length > 3\n+  def isRowTimeTemporalTableJoinCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length == 5\n+  }\n+\n+  def isRowTimeTemporalFunctionJoinCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION && rexCall.operands.length == 3\n   }\n \n+  def isTemporalFunctionJoin(rexBuilder: RexBuilder, joinInfo: JoinInfo): Boolean = {\n+    val nonEquiJoinRex = joinInfo.getRemaining(rexBuilder)\n+    var isTemporalFunctionJoin: Boolean = false\n+    val visitor = new RexVisitorImpl[Unit](true) {\n+      override def visitCall(call: RexCall): Unit = {\n+        if (isTemporalFunctionCon(call)) {\n+          isTemporalFunctionJoin = true\n+        } else {\n+          super.visitCall(call)\n+        }\n+      }\n+    }\n+    nonEquiJoinRex.accept(visitor)\n+    isTemporalFunctionJoin\n+  }\n+\n+  def isTemporalFunctionCon(rexCall: RexCall): Boolean = {\n+    //(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    //(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)\n+    rexCall.getOperator == TEMPORAL_JOIN_CONDITION &&\n+      (rexCall.operands.length == 2 || rexCall.operands.length == 3)\n+  }\n+\n+  def validateAndExtractTemporalFunctionCondition(\n+      call: RexCall,\n+      leftTimeAttribute: Option[RexNode],\n+      rightTimeAttribute: Option[RexNode],", "originalCommit": "f5ab96acdc20550ee4333519d0517a3f54253758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc5MzQ1NA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512793454", "bodyText": "leftTimeAttribute can be RexNode, rightTimeAttribute can not because it may be None", "author": "leonardBang", "createdAt": "2020-10-27T15:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjczNzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTE2Ng==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512749166", "bodyText": "Put the plan tree in a new line.\n      throw new ValidationException(\n        \"Temporal Table Join requires primary key in versioned table, \" +\n          s\"but no primary key can be found. The physical plan is:\\n${RelOptUtil.toString(join)}\\n\")", "author": "wuchong", "createdAt": "2020-10-27T14:39:17Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -94,13 +115,13 @@ class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n   }\n \n   private def validateRightPrimaryKey(\n+      join: FlinkLogicalJoin,\n       rightJoinKeyExpression: Seq[RexNode],\n       rightPrimaryKeyInputRefs: Option[Seq[RexNode]]): Unit = {\n \n     if (rightPrimaryKeyInputRefs.isEmpty) {\n-      throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n-        s\" primary key and row time attribute in versioned table,\" +\n-        s\" but no primary key can be found.\")\n+      throw new ValidationException(s\"Temporal Table Join requires primary key in versioned\" +\n+        s\" table, but no primary key can be found in ${RelOptUtil.toString(join)}.\")", "originalCommit": "f5ab96acdc20550ee4333519d0517a3f54253758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1MTAyOA==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512751028", "bodyText": "The join value is never used.", "author": "wuchong", "createdAt": "2020-10-27T14:41:29Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableFunctionRule.scala", "diffHunk": "@@ -84,7 +84,7 @@ class LogicalCorrelateToJoinFromTemporalTableFunctionRule\n \n     val cluster = logicalCorrelate.getCluster\n \n-    new GetTemporalTableFunctionCall(cluster.getRexBuilder, leftNode)\n+    val join = new GetTemporalTableFunctionCall(cluster.getRexBuilder, leftNode)", "originalCommit": "f5ab96acdc20550ee4333519d0517a3f54253758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NDc5Ng==", "url": "https://github.com/apache/flink/pull/13300#discussion_r512754796", "bodyText": "Rename the class name to the file name TemporalTableFunctionJoinITCase?", "author": "wuchong", "createdAt": "2020-10-27T14:45:48Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalTableFunctionJoinITCase.scala", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.runtime.stream.sql\n+\n+import org.apache.flink.api.scala._\n+import org.apache.flink.streaming.api.TimeCharacteristic\n+import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n+import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n+import org.apache.flink.streaming.api.windowing.time.Time\n+import org.apache.flink.table.api._\n+import org.apache.flink.table.api.bridge.scala._\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n+import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n+import org.apache.flink.table.planner.utils.TableTestUtil\n+import org.apache.flink.types.Row\n+\n+import org.junit.Assert.assertEquals\n+import org.junit._\n+import org.junit.runner.RunWith\n+import org.junit.runners.Parameterized\n+\n+import java.sql.Timestamp\n+\n+import scala.collection.mutable\n+\n+@RunWith(classOf[Parameterized])\n+class LegacyTemporalJoinITCase(state: StateBackendMode)", "originalCommit": "f5ab96acdc20550ee4333519d0517a3f54253758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5237811699733a394ef805fb1e2ab3f769f7500", "url": "https://github.com/apache/flink/commit/a5237811699733a394ef805fb1e2ab3f769f7500", "message": "address comments", "committedDate": "2020-10-27T15:42:21Z", "type": "forcePushed"}, {"oid": "6bf5dc2e71b14086d5f908cc300060595adc46ea", "url": "https://github.com/apache/flink/commit/6bf5dc2e71b14086d5f908cc300060595adc46ea", "message": "[FLINK-19077][table-runtime] Introduce process time temporal join operator", "committedDate": "2020-10-28T03:29:24Z", "type": "commit"}, {"oid": "6bf5dc2e71b14086d5f908cc300060595adc46ea", "url": "https://github.com/apache/flink/commit/6bf5dc2e71b14086d5f908cc300060595adc46ea", "message": "[FLINK-19077][table-runtime] Introduce process time temporal join operator", "committedDate": "2020-10-28T03:29:24Z", "type": "forcePushed"}]}