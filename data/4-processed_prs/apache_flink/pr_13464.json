{"pr_number": 13464, "pr_title": "[FLINK-19307][coordination] Add ResourceTracker", "pr_createdAt": "2020-09-23T14:12:29Z", "pr_url": "https://github.com/apache/flink/pull/13464", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2Nzg0MQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494067841", "bodyText": "Not sure about returning ResourceCounter for these two methods.\n\nThis exposes the internal states of BiDirectionalResourceToRequirementMapping in a writable way. Increasing/Decreasing to the returned counters may lead to inconsistent internal states.\nIt is implicit that the returned counters are sometimes immutable (EMPTY).", "author": "xintongsong", "createdAt": "2020-09-24T06:29:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/BiDirectionalResourceToRequirementMapping.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A bi-directional mapping between required and acquired resources.\n+ */\n+class BiDirectionalResourceToRequirementMapping {\n+\tprivate final Map<ResourceProfile, ResourceCounter> requirementToFulfillingResources = new HashMap<>();\n+\tprivate final Map<ResourceProfile, ResourceCounter> resourceToFulfilledRequirement = new HashMap<>();\n+\n+\tpublic void incrementCount(ResourceProfile requirement, ResourceProfile resource, int increment) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tinternalIncrementCount(requirementToFulfillingResources, requirement, resource, increment);\n+\t\tinternalIncrementCount(resourceToFulfilledRequirement, resource, requirement, increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile requirement, ResourceProfile resource, int decrement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tinternalDecrementCount(requirementToFulfillingResources, requirement, resource, decrement);\n+\t\tinternalDecrementCount(resourceToFulfilledRequirement, resource, requirement, decrement);\n+\t}\n+\n+\tprivate static void internalIncrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int increment) {\n+\t\tprimaryMap\n+\t\t\t.computeIfAbsent(primaryKey, ignored -> new ResourceCounter())\n+\t\t\t.incrementCount(secondaryKey, increment);\n+\t}\n+\n+\tprivate static void internalDecrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int decrement) {\n+\t\tprimaryMap.computeIfPresent(\n+\t\t\tprimaryKey,\n+\t\t\t(resourceProfile, resourceCounter) -> {\n+\t\t\t\tresourceCounter.decrementCount(secondaryKey, decrement);\n+\t\t\t\treturn resourceCounter.isEmpty() ? null : resourceCounter;\n+\t\t\t});\n+\t}\n+\n+\tpublic ResourceCounter getFulfillingResourcesFor(ResourceProfile requirement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\treturn requirementToFulfillingResources.getOrDefault(requirement, ResourceCounter.EMPTY);\n+\t}\n+\n+\tpublic ResourceCounter getFulfilledRequirementsBy(ResourceProfile resource) {\n+\t\tPreconditions.checkNotNull(resource);\n+\t\treturn resourceToFulfilledRequirement.getOrDefault(resource, ResourceCounter.EMPTY);\n+\t}", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMTk0NQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494201945", "bodyText": "yes, the ResourceCounter should not be returned since it is mutable.", "author": "zentol", "createdAt": "2020-09-24T10:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2Nzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3MDY1OQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494070659", "bodyText": "Attempts for decreasing on non-exist profiles will be ignored silently. Is this intended? Would it be better to fail explicitly on such attempts?\nIt's a bit counterintuitive that we fail on currentCount - decrement being negative, but not on non-exist profiles (equivalent to currentCount being zero).", "author": "xintongsong", "createdAt": "2020-09-24T06:36:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/slots/ResourceCounter.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.slots;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A counter for resources.\n+ *\n+ * <p>ResourceCounter contains a set of {@link ResourceProfile ResourceProfiles} and their\n+ * associated counts. The counts are always positive (> 0).\n+ */\n+public class ResourceCounter {\n+\tpublic static final ResourceCounter EMPTY = new ResourceCounter(Collections.emptyMap());\n+\n+\tprivate final Map<ResourceProfile, Integer> resources;\n+\n+\tpublic ResourceCounter() {\n+\t\tthis(new HashMap<>());\n+\t}\n+\n+\tprivate ResourceCounter(Map<ResourceProfile, Integer> resources) {\n+\t\tthis.resources = resources;\n+\t}\n+\n+\tpublic void incrementCount(ResourceProfile profile, int increment) {\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tresources.compute(profile, (ignored, currentCount) -> currentCount == null ? increment : currentCount + increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile profile, int decrement) {\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tresources.computeIfPresent(profile, (ignored, currentCount) -> currentCount == decrement ? null : guardAgainstNegativeCount(currentCount - decrement));", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjE3OA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494202178", "bodyText": "true, will adjust it.", "author": "zentol", "createdAt": "2020-09-24T10:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3MDY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3NjEzMw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494076133", "bodyText": "By using computeIfPresent, we are ignoring attempts for decreasing on non-exist  primary keys silently.\nWould it be better to fail explicitly on such attempts?", "author": "xintongsong", "createdAt": "2020-09-24T06:48:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/BiDirectionalResourceToRequirementMapping.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A bi-directional mapping between required and acquired resources.\n+ */\n+class BiDirectionalResourceToRequirementMapping {\n+\tprivate final Map<ResourceProfile, ResourceCounter> requirementToFulfillingResources = new HashMap<>();\n+\tprivate final Map<ResourceProfile, ResourceCounter> resourceToFulfilledRequirement = new HashMap<>();\n+\n+\tpublic void incrementCount(ResourceProfile requirement, ResourceProfile resource, int increment) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(increment > 0);\n+\t\tinternalIncrementCount(requirementToFulfillingResources, requirement, resource, increment);\n+\t\tinternalIncrementCount(resourceToFulfilledRequirement, resource, requirement, increment);\n+\t}\n+\n+\tpublic void decrementCount(ResourceProfile requirement, ResourceProfile resource, int decrement) {\n+\t\tPreconditions.checkNotNull(requirement);\n+\t\tPreconditions.checkNotNull(resource);\n+\t\tPreconditions.checkArgument(decrement > 0);\n+\t\tinternalDecrementCount(requirementToFulfillingResources, requirement, resource, decrement);\n+\t\tinternalDecrementCount(resourceToFulfilledRequirement, resource, requirement, decrement);\n+\t}\n+\n+\tprivate static void internalIncrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int increment) {\n+\t\tprimaryMap\n+\t\t\t.computeIfAbsent(primaryKey, ignored -> new ResourceCounter())\n+\t\t\t.incrementCount(secondaryKey, increment);\n+\t}\n+\n+\tprivate static void internalDecrementCount(Map<ResourceProfile, ResourceCounter> primaryMap, ResourceProfile primaryKey, ResourceProfile secondaryKey, int decrement) {\n+\t\tprimaryMap.computeIfPresent(\n+\t\t\tprimaryKey,\n+\t\t\t(resourceProfile, resourceCounter) -> {\n+\t\t\t\tresourceCounter.decrementCount(secondaryKey, decrement);\n+\t\t\t\treturn resourceCounter.isEmpty() ? null : resourceCounter;\n+\t\t\t});", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjI0OQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494202249", "bodyText": "yes we should fail.", "author": "zentol", "createdAt": "2020-09-24T10:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3NjEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3ODg0NQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494078845", "bodyText": "IIUC, the tracker is not for only A job?", "author": "xintongsong", "createdAt": "2020-09-24T06:54:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * A tracker for required/acquired resources of a job.", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMTY1Mg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494201652", "bodyText": "The phrasing isn't necessarily incorrect but I can see how it can be misleading.", "author": "zentol", "createdAt": "2020-09-24T10:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA3ODg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDExNDcyNw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494114727", "bodyText": "Actually, this could be way more expensive than copying the map twice. For each map entry, we could write the map as many times as the value of the entry.\nAnd the logs in notifyAcquiredResource could be misleading. It would look like the job acquired some new resources when calling on the already acquired resources.", "author": "xintongsong", "createdAt": "2020-09-24T07:59:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getFulfilledRequirementsBy(resourceProfile).getResourceProfiles();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources, otherwise use any\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getRequiredResources() {\n+\t\tfinal Collection<ResourceRequirement> requiredResources = new ArrayList<>();\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirement : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirement.getKey();\n+\n+\t\t\tint numRequiredResources = requirement.getValue();\n+\t\t\tint numAcquiredResources = resourceToRequirementMapping.getNumFulfillingResources(requirementProfile);\n+\n+\t\t\tif (numAcquiredResources < numRequiredResources) {\n+\t\t\t\trequiredResources.add(ResourceRequirement.create(requirementProfile, numRequiredResources - numAcquiredResources));\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn requiredResources;\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getAcquiredResources() {\n+\t\tfinal Set<ResourceProfile> knownResourceProfiles = new HashSet<>();\n+\t\tknownResourceProfiles.addAll(resourceToRequirementMapping.getAllResourceProfiles());\n+\t\tknownResourceProfiles.addAll(excessResources.getResourceProfiles());\n+\n+\t\tfinal List<ResourceRequirement> acquiredResources = new ArrayList<>();\n+\t\tfor (ResourceProfile knownResourceProfile : knownResourceProfiles) {\n+\t\t\tint numTotalAcquiredResources = resourceToRequirementMapping.getNumFulfilledRequirements(knownResourceProfile) + excessResources.getResourceCount(knownResourceProfile);\n+\t\t\tResourceRequirement resourceRequirement = ResourceRequirement.create(knownResourceProfile, numTotalAcquiredResources);\n+\t\t\tacquiredResources.add(resourceRequirement);\n+\t\t}\n+\n+\t\treturn acquiredResources;\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn resourceRequirements.isEmpty() && excessResources.isEmpty();\n+\t}\n+\n+\tprivate void findExcessSlots() {\n+\t\tfinal Collection<ExcessResource> excessResources = new ArrayList<>();\n+\n+\t\tfor (ResourceProfile requirementProfile : resourceToRequirementMapping.getAllRequirementProfiles()) {\n+\t\t\tint numTotalRequiredResources = resourceRequirements.getResourceCount(requirementProfile);\n+\t\t\tint numTotalAcquiredResources = resourceToRequirementMapping.getNumFulfillingResources(requirementProfile);\n+\n+\t\t\tif (numTotalAcquiredResources > numTotalRequiredResources) {\n+\t\t\t\tint numExcessResources = numTotalAcquiredResources - numTotalRequiredResources;\n+\n+\t\t\t\tfor (Map.Entry<ResourceProfile, Integer> acquiredResource : resourceToRequirementMapping.getFulfillingResourcesFor(requirementProfile).getResourceProfilesWithCount()) {\n+\t\t\t\t\tResourceProfile acquiredResourceProfile = acquiredResource.getKey();\n+\t\t\t\t\tint numAcquiredResources = acquiredResource.getValue();\n+\n+\t\t\t\t\tif (numAcquiredResources <= numExcessResources) {\n+\t\t\t\t\t\texcessResources.add(new ExcessResource(requirementProfile, acquiredResourceProfile, numAcquiredResources));\n+\n+\t\t\t\t\t\tnumExcessResources -= numAcquiredResources;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\texcessResources.add(new ExcessResource(requirementProfile, acquiredResourceProfile, numExcessResources));\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tLOG.debug(\"Detected excess resources for job {}: {}\", jobId, excessResources);\n+\t\tfor (ExcessResource excessResource : excessResources) {\n+\t\t\tresourceToRequirementMapping.decrementCount(excessResource.requirementProfile, excessResource.resourceProfile, excessResource.numExcessResources);\n+\t\t\tthis.excessResources.incrementCount(excessResource.resourceProfile, excessResource.numExcessResources);\n+\t\t}\n+\t}\n+\n+\tprivate void tryAssigningExcessSlots() {\n+\t\tif (LOG.isTraceEnabled()) {\n+\t\t\tLOG.trace(\"There are {} excess resources for job {} before re-assignment.\", jobId, excessResources.getResourceCount());\n+\t\t}\n+\t\t// this is a quick-and-dirty solution; in the worse case we copy the excessResources map twice", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMDg2Mg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494200862", "bodyText": "yes, this is only temporary ;)", "author": "zentol", "createdAt": "2020-09-24T10:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDExNDcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzk2MA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494127960", "bodyText": "I'm a bit confused with this comment.\nIIUC, we are actually using any requirement (the first encountered) that has too many resources. There's no \"otherwise\".", "author": "xintongsong", "createdAt": "2020-09-24T08:21:13Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getFulfilledRequirementsBy(resourceProfile).getResourceProfiles();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources, otherwise use any", "originalCommit": "f412e6cd8fbf17d063d9b33973a80ed49c7a7434", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMTE0Nw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494201147", "bodyText": "If no requirement has too many resources, we deduct one resource from the last encountered requirement.", "author": "zentol", "createdAt": "2020-09-24T10:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0MDE3MQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r494240171", "bodyText": "Ah, I see, thanks for the clarification.", "author": "xintongsong", "createdAt": "2020-09-24T11:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMTM0Mg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498221342", "bodyText": "Should we give this method a clearer name: getMissingResources, getOutstandingResources, or so?", "author": "tillrohrmann", "createdAt": "2020-10-01T12:55:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\tpublic Collection<ResourceRequirement> getRequiredResources() {", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNjU5Mg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498236592", "bodyText": "Why are these calls necessary?", "author": "tillrohrmann", "createdAt": "2020-10-01T13:18:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DefaultResourceTracker}.\n+ *\n+ * <p>Note: The majority is of the tracking logic is covered by the {@link JobScopedResourceTrackerTest}.\n+ */\n+public class DefaultResourceTrackerTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\ttracker.notifyLostResource(JobID.generate(), ResourceProfile.ANY);\n+\t\ttracker.clear();", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NzQxOA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499377418", "bodyText": "clear() is used during the suspension of the slot manager (which is kinda annoying in general).", "author": "zentol", "createdAt": "2020-10-05T06:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNjU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NDY1Ng==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499544656", "bodyText": "I am a bit confused because we don't assert anything after these lines.\nIf it tests that no exceptions are thrown, should we add a separate test case with a name along the lines of clearDoesNotThrowException?", "author": "tillrohrmann", "createdAt": "2020-10-05T11:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNjU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIzNzQwNQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498237405", "bodyText": "Does it make sense to make this a fields of DefaultResourceTrackerTest? That way we would not have to create these values multiple times.", "author": "tillrohrmann", "createdAt": "2020-10-01T13:19:27Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DefaultResourceTracker}.\n+ *\n+ * <p>Note: The majority is of the tracking logic is covered by the {@link JobScopedResourceTrackerTest}.\n+ */\n+public class DefaultResourceTrackerTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\ttracker.notifyLostResource(JobID.generate(), ResourceProfile.ANY);\n+\t\ttracker.clear();\n+\t}\n+\n+\t@Test\n+\tpublic void testGetRequiredResources() {\n+\t\tDefaultResourceTracker tracker = new DefaultResourceTracker();\n+\t\tJobID jobId1 = JobID.generate();\n+\t\tJobID jobId2 = JobID.generate();", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MjQ5Ng==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498242496", "bodyText": "I would make this a separate test with a descriptive test name.", "author": "tillrohrmann", "createdAt": "2020-10-01T13:26:31Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MzExMQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498243111", "bodyText": "Same here. I would split this into two tests.", "author": "tillrohrmann", "createdAt": "2020-10-01T13:27:18Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MDQxMQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498250411", "bodyText": "How can we tell that the excess resources are used to fulfill the requirement? Aren't we missing a assertThat(tracker.getRequiredResources(), empty());?", "author": "tillrohrmann", "createdAt": "2020-10-01T13:37:36Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithoutResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(resourceRequirement));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tint numAcquiredSlotsP1 = resourceRequirements[0][0].getNumberOfRequiredSlots() - 1;\n+\t\tint numAcquiredSlotsP2 = resourceRequirements[0][1].getNumberOfRequiredSlots();\n+\n+\t\tfor (int x = 0; x < numAcquiredSlotsP1; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\t\tfor (int x = 0; x < numAcquiredSlotsP2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\t\t}\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_1, resourceRequirement[0].getNumberOfRequiredSlots() - numAcquiredSlotsP1)));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceExceedingRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_1, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceLessThanRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithoutRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[] resourceRequirementsArray = new ResourceRequirement[]{\n+\t\t\tResourceRequirement.create(PROFILE_1, 2),\n+\t\t\tResourceRequirement.create(PROFILE_2, 1)\n+\t\t};\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirementsArray));\n+\n+\t\tfor (int x = 0; x < 2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyLostResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, 1), ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementReductionRetainsExceedingResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnRequirementIncrease() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MDYyMg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498250622", "bodyText": "Same here?", "author": "tillrohrmann", "createdAt": "2020-10-01T13:37:52Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTrackerTest.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link JobScopedResourceTracker}.\n+ */\n+public class JobScopedResourceTrackerTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1).build();\n+\tprivate static final ResourceProfile PROFILE_2 = ResourceProfile.newBuilder().setCpuCores(2).build();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\t// should not throw an exception\n+\t\ttracker.notifyLostResource(ResourceProfile.UNKNOWN);\n+\t}\n+\n+\t@Test\n+\tpublic void testIsEmpty() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithoutResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(resourceRequirement));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsNotificationWithResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[][] resourceRequirements = new ResourceRequirement[][]{\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 8),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)},\n+\t\t\tnew ResourceRequirement[]{\n+\t\t\t\tResourceRequirement.create(PROFILE_1, 4),\n+\t\t\t\tResourceRequirement.create(PROFILE_2, 2)}};\n+\n+\t\tint numAcquiredSlotsP1 = resourceRequirements[0][0].getNumberOfRequiredSlots() - 1;\n+\t\tint numAcquiredSlotsP2 = resourceRequirements[0][1].getNumberOfRequiredSlots();\n+\n+\t\tfor (int x = 0; x < numAcquiredSlotsP1; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\t\tfor (int x = 0; x < numAcquiredSlotsP2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\t\t}\n+\n+\t\tfor (ResourceRequirement[] resourceRequirement : resourceRequirements) {\n+\t\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirement));\n+\n+\t\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_1, resourceRequirement[0].getNumberOfRequiredSlots() - numAcquiredSlotsP1)));\n+\t\t}\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, numAcquiredSlotsP1), ResourceRequirement.create(PROFILE_2, numAcquiredSlotsP2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceExceedingRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_1, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_2);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testMatchingWithResourceLessThanRequirement() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithoutRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(false));\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.isEmpty(), is(true));\n+\t\tassertThat(tracker.getAcquiredResources(), empty());\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceNotificationsWithRequirements() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\tResourceRequirement[] resourceRequirementsArray = new ResourceRequirement[]{\n+\t\t\tResourceRequirement.create(PROFILE_1, 2),\n+\t\t\tResourceRequirement.create(PROFILE_2, 1)\n+\t\t};\n+\n+\t\ttracker.notifyResourceRequirements(Arrays.asList(resourceRequirementsArray));\n+\n+\t\tfor (int x = 0; x < 2; x++) {\n+\t\t\ttracker.notifyAcquiredResource(PROFILE_1);\n+\t\t}\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 2)));\n+\t\tassertThat(tracker.getRequiredResources(), contains(ResourceRequirement.create(PROFILE_2, 1)));\n+\n+\t\ttracker.notifyLostResource(PROFILE_1);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(PROFILE_1, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), containsInAnyOrder(ResourceRequirement.create(PROFILE_1, 1), ResourceRequirement.create(PROFILE_2, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementReductionRetainsExceedingResources() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.emptyList());\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t\tassertThat(tracker.getRequiredResources(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnRequirementIncrease() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));\n+\t}\n+\n+\t@Test\n+\tpublic void testExcessResourcesAreAssignedOnResourceLoss() {\n+\t\tJobScopedResourceTracker tracker = new JobScopedResourceTracker(JobID.generate());\n+\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\t\ttracker.notifyAcquiredResource(ResourceProfile.ANY);\n+\n+\t\ttracker.notifyResourceRequirements(Collections.singleton(ResourceRequirement.create(ResourceProfile.UNKNOWN, 1)));\n+\n+\t\ttracker.notifyLostResource(ResourceProfile.ANY);\n+\n+\t\tassertThat(tracker.getAcquiredResources(), contains(ResourceRequirement.create(ResourceProfile.ANY, 1)));", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTEyOQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498261129", "bodyText": "Why is this variable called exceedingOrRequiredResources and not requiredResources?", "author": "tillrohrmann", "createdAt": "2020-10-01T13:52:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTracker.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Default {@link ResourceTracker} implementation.\n+ */\n+public class DefaultResourceTracker implements ResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultResourceTracker.class);\n+\n+\tprivate final Map<JobID, JobScopedResourceTracker> trackers = new LinkedHashMap<>();\n+\n+\t@Override\n+\tpublic void notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceRequirements);\n+\t\tLOG.trace(\"Received notification for job {} having new resource requirements {}.\", jobId, resourceRequirements);\n+\t\tgetOrCreateTracker(jobId).notifyResourceRequirements(resourceRequirements);\n+\n+\t\tif (resourceRequirements.isEmpty()) {\n+\t\t\tcheckWhetherTrackerCanBeRemoved(jobId, trackers.get(jobId));\n+\t\t}\n+\t}\n+\n+\tprivate void checkWhetherTrackerCanBeRemoved(JobID jobId, JobScopedResourceTracker tracker) {\n+\t\tif (tracker.isEmpty()) {\n+\t\t\tLOG.debug(\"Stopping tracking of resources for job {}.\", jobId);\n+\t\t\ttrackers.remove(jobId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tLOG.trace(\"Received notification for job {} having acquired resource {}.\", jobId, resourceProfile);\n+\t\tgetOrCreateTracker(jobId).notifyAcquiredResource(resourceProfile);\n+\t}\n+\n+\tprivate JobScopedResourceTracker getOrCreateTracker(JobID jobId) {\n+\t\treturn trackers.computeIfAbsent(jobId, ignored -> {\n+\t\t\tLOG.debug(\"Initiating tracking of resources for job {}.\", jobId);\n+\t\t\treturn new JobScopedResourceTracker(jobId);\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic void notifyLostResource(JobID jobId, ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tJobScopedResourceTracker tracker = trackers.get(jobId);\n+\n+\t\t// during shutdown the tracker is cleared before task executors are unregistered,\n+\t\t// to prevent the loss of resources triggering new allocations\n+\t\tif (tracker != null) {\n+\t\t\tLOG.trace(\"Received notification for job {} having lost resource {}.\", jobId, resourceProfile);\n+\t\t\ttracker.notifyLostResource(resourceProfile);\n+\n+\t\t\tcheckWhetherTrackerCanBeRemoved(jobId, tracker);\n+\t\t} else {\n+\t\t\tLOG.trace(\"Received notification for job {} having lost resource {}, but no such job was tracked.\", jobId, resourceProfile);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\ttrackers.clear();\n+\t}\n+\n+\t@Override\n+\tpublic Map<JobID, Collection<ResourceRequirement>> getRequiredResources() {\n+\t\tMap<JobID, Collection<ResourceRequirement>> requiredResources = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, JobScopedResourceTracker> jobIDJobScopedRequirementsTrackerEntry : trackers.entrySet()) {\n+\t\t\tCollection<ResourceRequirement> exceedingOrRequiredResources = jobIDJobScopedRequirementsTrackerEntry.getValue().getRequiredResources();", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NTczMg==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499365732", "bodyText": "leftovers from a previous version where this method could return positive (==required) and negative (==excess) counts; will rename it.", "author": "zentol", "createdAt": "2020-10-05T06:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTk0Ng==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498261946", "bodyText": "Is it correct that this method returns the excess resources? Need and excess seems to be quite different to me.", "author": "tillrohrmann", "createdAt": "2020-10-01T13:53:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tracks for each job how many resource are required/acquired.\n+ */\n+public interface ResourceTracker {\n+\n+\t/**\n+\t * Notifies the tracker about a new or updated {@link ResourceRequirements}.\n+\t *\n+\t * @param jobId the job that that the resource requirements belongs to\n+\t * @param resourceRequirements new resource requirements\n+\t */\n+\tvoid notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements);\n+\n+\t/**\n+\t * Notifies the tracker about the acquisition of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that acquired the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Notifies the tracker about the loss of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that lost the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyLostResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Returns a collection of {@link ResourceRequirements} that describe which resources the corresponding job is\n+\t * in need/excess of.", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2NTc2MA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499365760", "bodyText": "leftovers from a previous version where this method could return positive (==required) and negative (==excess) counts; will rename it.", "author": "zentol", "createdAt": "2020-10-05T06:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2Mjg3Nw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498262877", "bodyText": "I would suggest to give this method a different name because here it means the required resources to fulfill all requirements whereas notifyResourceRequirements specifies the absolute set of required resources. I can see that this will cause confusion (at least it happened to me).", "author": "tillrohrmann", "createdAt": "2020-10-01T13:54:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/ResourceTracker.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tracks for each job how many resource are required/acquired.\n+ */\n+public interface ResourceTracker {\n+\n+\t/**\n+\t * Notifies the tracker about a new or updated {@link ResourceRequirements}.\n+\t *\n+\t * @param jobId the job that that the resource requirements belongs to\n+\t * @param resourceRequirements new resource requirements\n+\t */\n+\tvoid notifyResourceRequirements(JobID jobId, Collection<ResourceRequirement> resourceRequirements);\n+\n+\t/**\n+\t * Notifies the tracker about the acquisition of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that acquired the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyAcquiredResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Notifies the tracker about the loss of a resource with the given resource profile, for the given job.\n+\t *\n+\t * @param jobId the job that lost the resource\n+\t * @param resourceProfile profile of the resource\n+\t */\n+\tvoid notifyLostResource(JobID jobId, ResourceProfile resourceProfile);\n+\n+\t/**\n+\t * Returns a collection of {@link ResourceRequirements} that describe which resources the corresponding job is\n+\t * in need/excess of.\n+\t *\n+\t * @return required/exceeding resources for each jobs\n+\t */\n+\tMap<JobID, Collection<ResourceRequirement>> getRequiredResources();", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyOTMyNw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498929327", "bodyText": "is it important that we use a LinkedHashMap here?", "author": "tillrohrmann", "createdAt": "2020-10-02T16:36:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceTracker.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Default {@link ResourceTracker} implementation.\n+ */\n+public class DefaultResourceTracker implements ResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultResourceTracker.class);\n+\n+\tprivate final Map<JobID, JobScopedResourceTracker> trackers = new LinkedHashMap<>();", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MDMwNA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499370304", "bodyText": "It only ensures that that the Map returned by getRequiredResources orders jobs in a FIFO manner. It is technically not necessary, as it could be argued that the FIFO behavior is a more high-level concern of the ResourceManager/SlotManager. But it simplifies things a bit if you can just iterate over the map, instead if having to iterate over some other LinkedHashMap in the slot manager and do a look up for the required resources.", "author": "zentol", "createdAt": "2020-10-05T06:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NTg3Nw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499545877", "bodyText": "Hmm, then we have to state this in the JavaDocs of ResourceTracker and every implementation has to support this contract. Otherwise we implement against an internal implementation detail which might change in the future.", "author": "tillrohrmann", "createdAt": "2020-10-05T12:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyOTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA4MTYyNw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r500081627", "bodyText": "I changed my mind; it's not really easier; the slot manager can take of the ordering, which also makes us a bit more flexible in the future if we want to change prioritization.", "author": "zentol", "createdAt": "2020-10-06T08:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyOTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMDgyNw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498930827", "bodyText": "Should this ever happen or is this an invalid state?", "author": "tillrohrmann", "createdAt": "2020-10-02T16:39:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (assignedRequirement == null) {\n+\t\t\t\t// safeguard against programming errors\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Job %s lost a (non-excess) resource %s but no requirement was assigned to it.\", jobId, resourceProfile));\n+\t\t\t}\n+\n+\t\t\tresourceToRequirementMapping.decrementCount(assignedRequirement, resourceProfile, 1);\n+\n+\t\t\ttryAssigningExcessSlots();\n+\t\t} else {\n+\t\t\tLOG.warn(\"Job {} lost a resource {} but no such resource was tracked.\", jobId, resourceProfile);", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MTQxMQ==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499371411", "bodyText": "It should be an invalid state; so lets throw an exception.", "author": "zentol", "createdAt": "2020-10-05T06:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMDgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMzk5Ng==", "url": "https://github.com/apache/flink/pull/13464#discussion_r498933996", "bodyText": "Should this ever happen? I thought that all slots which over fulfill the requirements will be added to the excessResources field.", "author": "tillrohrmann", "createdAt": "2020-10-02T16:46:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/JobScopedResourceTracker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Tracks resource for a single job.\n+ */\n+class JobScopedResourceTracker {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JobScopedResourceTracker.class);\n+\n+\t// only for logging purposes\n+\tprivate final JobID jobId;\n+\n+\tprivate final ResourceCounter resourceRequirements = new ResourceCounter();\n+\tprivate final BiDirectionalResourceToRequirementMapping resourceToRequirementMapping = new BiDirectionalResourceToRequirementMapping();\n+\tprivate final ResourceCounter excessResources = new ResourceCounter();\n+\n+\tJobScopedResourceTracker(JobID jobId) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t}\n+\n+\tpublic void notifyResourceRequirements(Collection<ResourceRequirement> newResourceRequirements) {\n+\t\tPreconditions.checkNotNull(newResourceRequirements);\n+\n+\t\tresourceRequirements.clear();\n+\t\tfor (ResourceRequirement newResourceRequirement : newResourceRequirements) {\n+\t\t\tresourceRequirements.incrementCount(newResourceRequirement.getResourceProfile(), newResourceRequirement.getNumberOfRequiredSlots());\n+\t\t}\n+\t\tfindExcessSlots();\n+\t\ttryAssigningExcessSlots();\n+\t}\n+\n+\tpublic void notifyAcquiredResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tfinal Optional<ResourceProfile> matchingRequirement = findMatchingRequirement(resourceProfile);\n+\t\tif (matchingRequirement.isPresent()) {\n+\t\t\tresourceToRequirementMapping.incrementCount(matchingRequirement.get(), resourceProfile, 1);\n+\t\t} else {\n+\t\t\tLOG.debug(\"Job {} acquired excess resource {}.\", resourceProfile, jobId);\n+\t\t\texcessResources.incrementCount(resourceProfile, 1);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<ResourceProfile> findMatchingRequirement(ResourceProfile resourceProfile) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> requirementCandidate : resourceRequirements.getResourceProfilesWithCount().entrySet()) {\n+\t\t\tResourceProfile requirementProfile = requirementCandidate.getKey();\n+\n+\t\t\t// beware the order when matching resources to requirements, because ResourceProfile.UNKNOWN (which only\n+\t\t\t// occurs as a requirement) does not match any resource!\n+\t\t\tif (resourceProfile.isMatching(requirementProfile) && requirementCandidate.getValue() > resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\treturn Optional.of(requirementProfile);\n+\t\t\t}\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\tpublic void notifyLostResource(ResourceProfile resourceProfile) {\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tif (excessResources.getResourceCount(resourceProfile) > 0) {\n+\t\t\tLOG.trace(\"Job {} lost excess resource {}.\", jobId, resourceProfile);\n+\t\t\texcessResources.decrementCount(resourceProfile, 1);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSet<ResourceProfile> fulfilledRequirements = resourceToRequirementMapping.getRequirementsFulfilledBy(resourceProfile).keySet();\n+\n+\t\tif (!fulfilledRequirements.isEmpty()) {\n+\t\t\t// determine for which of the requirements, that the resource could be used for, the resource count should be reduced for\n+\t\t\tResourceProfile assignedRequirement = null;\n+\n+\t\t\tfor (ResourceProfile requirementProfile : fulfilledRequirements) {\n+\t\t\t\tassignedRequirement = requirementProfile;\n+\n+\t\t\t\t// try finding a requirement that has too many resources; if non are exceeding the requirements we deduct\n+\t\t\t\t// the resource from any requirement having such a resource\n+\t\t\t\tif (resourceRequirements.getResourceCount(requirementProfile) < resourceToRequirementMapping.getNumFulfillingResources(requirementProfile)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}", "originalCommit": "c39df1c9ae95ded8f61525e6bd39edb9ec44c955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MzIzMA==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499373230", "bodyText": "hmm...that is true.", "author": "zentol", "createdAt": "2020-10-05T06:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMzk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3MzUzNw==", "url": "https://github.com/apache/flink/pull/13464#discussion_r499373537", "bodyText": "It was necessary at some point because we did not always searched for excess slots when requirements changed, but only when acquiring resources.", "author": "zentol", "createdAt": "2020-10-05T06:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMzk5Ng=="}], "type": "inlineReview"}, {"oid": "962f799b61db881874c06dd4b3a38eb972d18a00", "url": "https://github.com/apache/flink/commit/962f799b61db881874c06dd4b3a38eb972d18a00", "message": "[FLINK-19307][coordination] Add ResourceTracker", "committedDate": "2020-10-05T07:25:12Z", "type": "commit"}, {"oid": "9c6650f6dd0028a481f1ce72318b11c3d901ac92", "url": "https://github.com/apache/flink/commit/9c6650f6dd0028a481f1ce72318b11c3d901ac92", "message": "+", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "618e7f37be12a163b5fefd4139a2556480993295", "url": "https://github.com/apache/flink/commit/618e7f37be12a163b5fefd4139a2556480993295", "message": "hide internal ResourceCounters", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "b362cb50d9bf689a0ab497458c39f1cb755d80c4", "url": "https://github.com/apache/flink/commit/b362cb50d9bf689a0ab497458c39f1cb755d80c4", "message": "Forbid decrement of non-existent profile", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "60890a83ce4ec657b7fa936c439265e7a3b54d78", "url": "https://github.com/apache/flink/commit/60890a83ce4ec657b7fa936c439265e7a3b54d78", "message": "Forbid decrements for non-existent primary keys", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "3a7e1a20c1641ce9c3dcc2693bf668fe83ba6caa", "url": "https://github.com/apache/flink/commit/3a7e1a20c1641ce9c3dcc2693bf668fe83ba6caa", "message": "unused import", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "4a96f363e02aa04fe0aba247b671225f2bfe4d29", "url": "https://github.com/apache/flink/commit/4a96f363e02aa04fe0aba247b671225f2bfe4d29", "message": "clarify javadoc", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "db0a92cdb12b3f554b4a2a48d5a4e3a880784f4b", "url": "https://github.com/apache/flink/commit/db0a92cdb12b3f554b4a2a48d5a4e3a880784f4b", "message": "clarify comment", "committedDate": "2020-10-05T07:25:13Z", "type": "commit"}, {"oid": "7bca073125251f8e92f1a3e3a9a62bad398b2fd0", "url": "https://github.com/apache/flink/commit/7bca073125251f8e92f1a3e3a9a62bad398b2fd0", "message": "address comments", "committedDate": "2020-10-05T07:25:13Z", "type": "forcePushed"}, {"oid": "007590e244fca615387ef854fd8c5fb5cd85fa45", "url": "https://github.com/apache/flink/commit/007590e244fca615387ef854fd8c5fb5cd85fa45", "message": "address comments", "committedDate": "2020-10-06T14:11:00Z", "type": "commit"}, {"oid": "e3b5127461f073d54c26f3fe6217361d95f50e97", "url": "https://github.com/apache/flink/commit/e3b5127461f073d54c26f3fe6217361d95f50e97", "message": "last comments", "committedDate": "2020-10-06T14:11:01Z", "type": "commit"}, {"oid": "e3b5127461f073d54c26f3fe6217361d95f50e97", "url": "https://github.com/apache/flink/commit/e3b5127461f073d54c26f3fe6217361d95f50e97", "message": "last comments", "committedDate": "2020-10-06T14:11:01Z", "type": "forcePushed"}]}