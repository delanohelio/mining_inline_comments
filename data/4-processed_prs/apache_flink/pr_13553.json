{"pr_number": 13553, "pr_title": "[FLINK-19306][coordination] Add DeclarativeSlotManager", "pr_createdAt": "2020-10-07T13:06:15Z", "pr_url": "https://github.com/apache/flink/pull/13553", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxOTA0MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501719040", "bodyText": "What is missing here?", "author": "tillrohrmann", "createdAt": "2020-10-08T13:26:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java", "diffHunk": "@@ -1190,6 +1215,11 @@ public void notifyAllocationFailure(JobID jobId, AllocationID allocationId, Exce\n \t\t\t\tjobManagerRegistration.getJobManagerGateway().notifyAllocationFailure(allocationId, cause);\n \t\t\t}\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic void notifyNotEnoughResourcesAvailable(JobID jobId, Collection<ResourceRequirement> acquiredResources) {\n+\t\t\tvalidateRunsInMainThread();\n+\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNzU1OQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502327559", "bodyText": "The call to JobMaster#notifyNotEnoughResourcesAvailable; but that wasn't added yet because I only wanted to touch the RM side.", "author": "zentol", "createdAt": "2020-10-09T10:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxOTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501720427", "bodyText": "Are you sure that we want to decrease the requirements of a job if the JobManager connection is being closed? I was wondering whether this shouldn't happen if we remove the job in ResourceManager.removeJob?", "author": "tillrohrmann", "createdAt": "2020-10-08T13:28:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java", "diffHunk": "@@ -861,6 +884,8 @@ protected void closeJobManagerConnection(JobID jobId, Exception cause) {\n \n \t\t\tjmResourceIdRegistrations.remove(jobManagerResourceId);\n \n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.empty(jobId, jobMasterGateway.getAddress()));", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMTc1MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501721750", "bodyText": "On the other hand a job will only be removed after resourcemanager.job.timeout which defaults to 5 minutes. Then I guess it is fine that we don't try to actively allocated new resources for a job whose job manager has died/timed out.", "author": "tillrohrmann", "createdAt": "2020-10-08T13:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2NDI3OA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502364278", "bodyText": "hmm...i think the current behavior is fine for the case where a JM just crashes, but when we have HA I think we are also clearing the requirements when the leader lost leadership.\nSoo...removeJob may be a better place to put it.", "author": "zentol", "createdAt": "2020-10-09T11:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyNTEzNg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502525136", "bodyText": "What happens in the non-HA case, where the job simply failed? Wouldn't we have to wait for 5 minutes until the resources will be freed for other jobs?", "author": "tillrohrmann", "createdAt": "2020-10-09T15:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1MDUzNw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503150537", "bodyText": "Current PR state(closeJobManagerConnection):\nIf the job fails, then resources are currently cleaned up immediately, because the JM closes the RM connection, leading to closeJobManagerConnection. The JM is also supposed to reduce the requirements to 0.\nIf the JM crashes, then we have to wait for the heartbeat.timeout.\nCleanup in removeJob:\nResources are always cleaned up after resourcemanager.job.timeout.\nConceptually, it seems correct to wait for the job timeout; it's just that for the non-HA case this should be set to 0?", "author": "zentol", "createdAt": "2020-10-12T09:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc2NjY1MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503766650", "bodyText": "I think I would be in favour of leaving it like it is because it gives a bit snappier behaviour wrt other jobs when a JM crashes.", "author": "tillrohrmann", "createdAt": "2020-10-13T08:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyMDQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyNTUyOQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501725529", "bodyText": "Since these fields can be null, we might wanna add @Nullable.", "author": "tillrohrmann", "createdAt": "2020-10-08T13:35:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MjE0Nw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502362147", "bodyText": "I did not want to add nullable since we enforce via checkInit() that these fields are not null usually. Otherwise we'll get a whole bunch of IDE warnings about potential null pointer exceptions.", "author": "zentol", "createdAt": "2020-10-09T11:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyNTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyOTEyOA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501729128", "bodyText": "Is it a problem that we might register the gauges multiple times in case that the DSM goes start -> suspend -> start -> suspend -> ...?", "author": "tillrohrmann", "createdAt": "2020-10-08T13:40:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MTYwMA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502361600", "bodyText": "not a problem in the sense that things will still work. But we are attempting to register metrics multiple which will cause warnings.", "author": "zentol", "createdAt": "2020-10-09T11:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyOTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyNzY5NQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502527695", "bodyText": "I guess the same problem already exists in the SlotManagerImpl. Hence, we can tackle it as a follow up.", "author": "tillrohrmann", "createdAt": "2020-10-09T15:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcyOTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczNjE3OQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501736179", "bodyText": "I would suggest to factor this out into a separate method something like requestsSlotsForJob or so.", "author": "tillrohrmann", "createdAt": "2020-10-08T13:49:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczOTcwNQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501739705", "bodyText": "Maybe move this to the top of the method.", "author": "tillrohrmann", "createdAt": "2020-10-08T13:54:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Mjc4OQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501742789", "bodyText": "Should we also call checkResourceRequirements in case of a successful allocation? Shouldn't we only call this method if the allocation failed for some reason and we need to find another slot?", "author": "tillrohrmann", "createdAt": "2020-10-08T13:58:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tLOG.warn(\"Slot allocation for slot {} for job {} failed.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t\tslotTracker.notifyFree(slotId);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcheckResourceRequirements();", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MDk2MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502360960", "bodyText": "I can't quite think of a reason at the moment to check the requirements after a successful allocation", "author": "zentol", "createdAt": "2020-10-09T11:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Mjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyODAxMg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502528012", "bodyText": "Then let's maybe not do it.", "author": "tillrohrmann", "createdAt": "2020-10-09T15:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NDE3MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501744170", "bodyText": "Where does the exception come from? If this exception is the result of an illegal state, then we should instead use handleAsync and wrap it with FutureUtils.assertNoException to fail hard in case of an illegal state.", "author": "tillrohrmann", "createdAt": "2020-10-08T13:59:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tLOG.warn(\"Slot allocation for slot {} for job {} failed.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t\tslotTracker.notifyFree(slotId);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcheckResourceRequirements();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n+\t\t\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MzUxOA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502343518", "bodyText": "This was just taken as is from the existing SlotManagerImpl. I can change it though.", "author": "zentol", "createdAt": "2020-10-09T10:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NDE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyODE5MQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502528191", "bodyText": "Yes, please do so.", "author": "tillrohrmann", "createdAt": "2020-10-09T15:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NDE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NTkwMQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501745901", "bodyText": "Where are we cancelling completableFuture?", "author": "tillrohrmann", "createdAt": "2020-10-08T14:02:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MDc0MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502340740", "bodyText": "Whenever a pending slot switches to another state (see createSlotStatusUpdateListener)", "author": "zentol", "createdAt": "2020-10-09T10:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyOTMzOA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502529338", "bodyText": "I think at the moment, we don't register these futures and, hence, it should never happen.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0NTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Njk2Mw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501746963", "bodyText": "Aren't we calling this method always with pending slots and no new slots?", "author": "tillrohrmann", "createdAt": "2020-10-08T14:03:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tLOG.warn(\"Slot allocation for slot {} for job {} failed.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t\tslotTracker.notifyFree(slotId);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcheckResourceRequirements();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tmainThreadExecutor);\n+\t}\n+\n+\tprivate void tryFulfillRequirementsWithPendingOrNewSlots(JobID jobId, Map<ResourceProfile, Integer> missingResources, ResourceCounter pendingSlots) {", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MDM1MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502340350", "bodyText": "yes", "author": "zentol", "createdAt": "2020-10-09T10:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Njk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyOTE0MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502529140", "bodyText": "Then let's change the name of the method.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0Njk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0OTg3OA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501749878", "bodyText": "Why is this method not implemented?", "author": "tillrohrmann", "createdAt": "2020-10-08T14:07:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tLOG.warn(\"Slot allocation for slot {} for job {} failed.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t\tslotTracker.notifyFree(slotId);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcheckResourceRequirements();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tmainThreadExecutor);\n+\t}\n+\n+\tprivate void tryFulfillRequirementsWithPendingOrNewSlots(JobID jobId, Map<ResourceProfile, Integer> missingResources, ResourceCounter pendingSlots) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> missingResource : missingResources.entrySet()) {\n+\t\t\tResourceProfile profile = missingResource.getKey();\n+\t\t\tfor (int i = 0; i < missingResource.getValue(); i++) {\n+\t\t\t\tif (!tryFulfillWithPendingSlots(profile, pendingSlots)) {\n+\t\t\t\t\tOptional<ResourceRequirement> newlyFulfillableRequirements = taskExecutorManager.allocateWorker(profile);\n+\t\t\t\t\tif (newlyFulfillableRequirements.isPresent()) {\n+\t\t\t\t\t\tResourceRequirement newSlots = newlyFulfillableRequirements.get();\n+\t\t\t\t\t\t// reserve one of the new slots\n+\t\t\t\t\t\tif (newSlots.getNumberOfRequiredSlots() > 1) {\n+\t\t\t\t\t\t\tpendingSlots.incrementCount(newSlots.getResourceProfile(), newSlots.getNumberOfRequiredSlots() - 1);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOG.warn(\"Could not fulfill resource requirements of job {}.\", jobId);\n+\t\t\t\t\t\tresourceActions.notifyNotEnoughResourcesAvailable(jobId, resourceTracker.getAcquiredResources(jobId));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean tryFulfillWithPendingSlots(ResourceProfile resourceProfile, ResourceCounter pendingSlots) {\n+\t\tSet<ResourceProfile> pendingSlotProfiles = pendingSlots.getResourceProfiles();\n+\n+\t\t// short-cut, pretty much only applicable to fine-grained resource management\n+\t\tif (pendingSlotProfiles.contains(resourceProfile)) {\n+\t\t\tpendingSlots.decrementCount(resourceProfile, 1);\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfor (ResourceProfile pendingSlotProfile : pendingSlotProfiles) {\n+\t\t\tif (pendingSlotProfile.isMatching(resourceProfile)) {\n+\t\t\t\tpendingSlots.decrementCount(pendingSlotProfile, 1);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Legacy APIs\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic int getNumberRegisteredSlots() {\n+\t\treturn taskExecutorManager.getNumberRegisteredSlots();\n+\t}\n+\n+\t@Override\n+\tpublic int getNumberRegisteredSlotsOf(InstanceID instanceId) {\n+\t\treturn taskExecutorManager.getNumberRegisteredSlotsOf(instanceId);\n+\t}\n+\n+\t@Override\n+\tpublic int getNumberFreeSlots() {\n+\t\treturn taskExecutorManager.getNumberFreeSlots();\n+\t}\n+\n+\t@Override\n+\tpublic int getNumberFreeSlotsOf(InstanceID instanceId) {\n+\t\treturn taskExecutorManager.getNumberFreeSlotsOf(instanceId);\n+\t}\n+\n+\t@Override\n+\tpublic Map<WorkerResourceSpec, Integer> getRequiredResources() {\n+\t\treturn taskExecutorManager.getRequiredWorkers();\n+\t}\n+\n+\t@Override\n+\tpublic ResourceProfile getRegisteredResource() {\n+\t\treturn taskExecutorManager.getTotalRegisteredResources();\n+\t}\n+\n+\t@Override\n+\tpublic ResourceProfile getRegisteredResourceOf(InstanceID instanceID) {\n+\t\treturn taskExecutorManager.getTotalRegisteredResourcesOf(instanceID);\n+\t}\n+\n+\t@Override\n+\tpublic ResourceProfile getFreeResource() {\n+\t\treturn taskExecutorManager.getTotalFreeResources();\n+\t}\n+\n+\t@Override\n+\tpublic ResourceProfile getFreeResourceOf(InstanceID instanceID) {\n+\t\treturn taskExecutorManager.getTotalFreeResourcesOf(instanceID);\n+\t}\n+\n+\t@Override\n+\tpublic void setFailUnfulfillableRequest(boolean failUnfulfillableRequest) {\n+\t\t// we always send notifications if we cannot fulfill requests, and it is the responsibility of the JobManager\n+\t\t// to handle it (e.g., by reducing requirements and failing outright)\n+\t}\n+\n+\t@Override\n+\tpublic int getNumberPendingSlotRequests() {\n+\t\t// only exists for testing purposes\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Internal utility methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkInit() {\n+\t\tPreconditions.checkState(started, \"The slot manager has not been started.\");\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Testing methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\t@VisibleForTesting\n+\tpublic void unregisterTaskManagersAndReleaseResources() {", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MDEwMQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502340101", "bodyText": "This method only exists for a single test case in the YarnResourceManagerTest. I think it is quite questionable because it not only relies on RM-internal components (the SlotManager) to trigger the unregistration/release (instead of unregistering the TE at the RM), but also introduces a custom codepath into the SlotManager for releasing resources that in this form doesn't appear to exist in production.\nThe test asserts that the container is released upon calling this method, but it begs the question what we are even testing. If we are just interested in whether the Yarn RM resource actions can properly shut down the container, then we shouldn't need the slot manager for that.", "author": "zentol", "createdAt": "2020-10-09T10:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0OTg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUyOTcyOA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502529728", "bodyText": "Can we refactor the test and get rid of this method then?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0OTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTcyMA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501751720", "bodyText": "One could factor this part out into a separate method which might make it a bit less complex.", "author": "tillrohrmann", "createdAt": "2020-10-08T14:09:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {\n+\t\tfinal Map<JobID, Collection<ResourceRequirement>> missingResources = resourceTracker.getMissingResources();\n+\t\tif (missingResources.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal Map<JobID, ResourceCounter> outstandingRequirements = new LinkedHashMap<>();\n+\t\tfor (Map.Entry<JobID, Collection<ResourceRequirement>> resourceRequirements : missingResources.entrySet()) {\n+\t\t\tJobID jobId = resourceRequirements.getKey();\n+\n+\t\t\tfor (ResourceRequirement resourceRequirement : resourceRequirements.getValue()) {\n+\t\t\t\tint numMissingSlots = internalRequestSlots(jobId, jobMasterTargetAddresses.get(jobId), resourceRequirement);\n+\t\t\t\tif (numMissingSlots > 0) {\n+\t\t\t\t\toutstandingRequirements\n+\t\t\t\t\t\t.computeIfAbsent(jobId, ignored -> new ResourceCounter())\n+\t\t\t\t\t\t.incrementCount(resourceRequirement.getResourceProfile(), numMissingSlots);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal ResourceCounter pendingSlots = new ResourceCounter(taskExecutorManager.getPendingTaskManagerSlots().stream().collect(\n+\t\t\tCollectors.groupingBy(\n+\t\t\t\tPendingTaskManagerSlot::getResourceProfile,\n+\t\t\t\tCollectors.summingInt(x -> 1))));\n+\n+\t\tfor (Map.Entry<JobID, ResourceCounter> unfulfilledRequirement : outstandingRequirements.entrySet()) {\n+\t\t\ttryFulfillRequirementsWithPendingOrNewSlots(\n+\t\t\t\tunfulfilledRequirement.getKey(),\n+\t\t\t\tunfulfilledRequirement.getValue().getResourceProfilesWithCount(),\n+\t\t\t\tpendingSlots);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tries to allocate slots for the given requirement. If there are not enough slots available, the\n+\t * resource manager is informed to allocate more resources.\n+\t *\n+\t * @param jobId job to allocate slots for\n+\t * @param targetAddress address of the jobmaster\n+\t * @param resourceRequirement required slots\n+\t * @return the number of missing slots\n+\t */\n+\tprivate int internalRequestSlots(JobID jobId, String targetAddress, ResourceRequirement resourceRequirement) {\n+\t\tfinal ResourceProfile requiredResource = resourceRequirement.getResourceProfile();\n+\t\tCollection<TaskManagerSlotInformation> freeSlots = slotTracker.getFreeSlots();\n+\n+\t\tint numUnfulfilled = 0;\n+\t\tfor (int x = 0; x < resourceRequirement.getNumberOfRequiredSlots(); x++) {\n+\n+\t\t\tfinal Optional<TaskManagerSlotInformation> reservedSlot = slotMatchingStrategy.findMatchingSlot(requiredResource, freeSlots, this::getNumberRegisteredSlotsOf);\n+\t\t\tif (reservedSlot.isPresent()) {\n+\t\t\t\t// we do not need to modify freeSlots because it is indirectly modified by the allocation\n+\t\t\t\tallocateSlot(reservedSlot.get(), jobId, targetAddress, requiredResource);\n+\t\t\t} else {\n+\t\t\t\tnumUnfulfilled++;\n+\t\t\t}\n+\t\t}\n+\t\treturn numUnfulfilled;\n+\t}\n+\n+\t/**\n+\t * Allocates the given slot. This entails sending a registration message to the task manager and treating failures.\n+\t *\n+\t * @param taskManagerSlot slot to allocate\n+\t * @param jobId job for which the slot should be allocated for\n+\t * @param targetAddress address of the job master\n+\t * @param resourceProfile resource profile for the requirement for which the slot is used\n+\t */\n+\tprivate void allocateSlot(TaskManagerSlotInformation taskManagerSlot, JobID jobId, String targetAddress, ResourceProfile resourceProfile) {\n+\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n+\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n+\n+\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n+\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n+\t\tfinal InstanceID instanceId = taskManagerSlot.getInstanceId();\n+\n+\t\tLOG.debug(\"Starting allocation of slot {} for job {} with resource profile {}.\", taskManagerSlot.getSlotId(), jobId, resourceProfile);\n+\n+\t\tslotTracker.notifyAllocationStart(slotId, jobId);\n+\n+\t\tif (!taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n+\t\t\t\tinstanceId + '.');\n+\t\t}\n+\n+\t\ttaskExecutorManager.markUsed(instanceId);\n+\n+\t\t// RPC call to the task manager\n+\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n+\t\t\tslotId,\n+\t\t\tjobId,\n+\t\t\tnew AllocationID(),\n+\t\t\tresourceProfile,\n+\t\t\ttargetAddress,\n+\t\t\tresourceManagerId,\n+\t\t\ttaskManagerRequestTimeout);\n+\n+\t\trequestFuture.whenComplete(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\tcompletableFuture.complete(acknowledge);\n+\t\t\t\t} else {\n+\t\t\t\t\tcompletableFuture.completeExceptionally(throwable);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\tcompletableFuture.whenCompleteAsync(\n+\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tif (acknowledge != null) {\n+\t\t\t\t\t\tLOG.trace(\"Completed allocation of slot {} for job {}.\", slotId, jobId);\n+\t\t\t\t\t\tslotTracker.notifyAllocationComplete(slotId, jobId);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (throwable instanceof SlotOccupiedException) {\n+\t\t\t\t\t\t\tSlotOccupiedException exception = (SlotOccupiedException) throwable;\n+\t\t\t\t\t\t\tLOG.debug(\"Tried allocating slot {} for job {}, but it was already allocated for job {}.\", slotId, jobId, exception.getJobId());\n+\t\t\t\t\t\t\t// report as a slot status to force the state transition\n+\t\t\t\t\t\t\t// this could be a problem if we ever assume that the task executor always reports about all slots\n+\t\t\t\t\t\t\tslotTracker.notifySlotStatus(Collections.singleton(new SlotStatus(slotId, taskManagerSlot.getResourceProfile(), exception.getJobId(), exception.getAllocationId())));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (throwable instanceof CancellationException) {\n+\t\t\t\t\t\t\t\tLOG.debug(\"Cancelled allocation of slot {} for job {}.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tLOG.warn(\"Slot allocation for slot {} for job {} failed.\", slotId, jobId, throwable);\n+\t\t\t\t\t\t\t\tslotTracker.notifyFree(slotId);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcheckResourceRequirements();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tmainThreadExecutor);\n+\t}\n+\n+\tprivate void tryFulfillRequirementsWithPendingOrNewSlots(JobID jobId, Map<ResourceProfile, Integer> missingResources, ResourceCounter pendingSlots) {\n+\t\tfor (Map.Entry<ResourceProfile, Integer> missingResource : missingResources.entrySet()) {\n+\t\t\tResourceProfile profile = missingResource.getKey();\n+\t\t\tfor (int i = 0; i < missingResource.getValue(); i++) {\n+\t\t\t\tif (!tryFulfillWithPendingSlots(profile, pendingSlots)) {\n+\t\t\t\t\tOptional<ResourceRequirement> newlyFulfillableRequirements = taskExecutorManager.allocateWorker(profile);\n+\t\t\t\t\tif (newlyFulfillableRequirements.isPresent()) {\n+\t\t\t\t\t\tResourceRequirement newSlots = newlyFulfillableRequirements.get();\n+\t\t\t\t\t\t// reserve one of the new slots\n+\t\t\t\t\t\tif (newSlots.getNumberOfRequiredSlots() > 1) {\n+\t\t\t\t\t\t\tpendingSlots.incrementCount(newSlots.getResourceProfile(), newSlots.getNumberOfRequiredSlots() - 1);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOG.warn(\"Could not fulfill resource requirements of job {}.\", jobId);\n+\t\t\t\t\t\tresourceActions.notifyNotEnoughResourcesAvailable(jobId, resourceTracker.getAcquiredResources(jobId));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1Mzk1OA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501753958", "bodyText": "I think pendingSlotAllocationFutures is never populated with any futures. What's the idea behind this structure?", "author": "tillrohrmann", "createdAt": "2020-10-08T14:12:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyODgxNQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502328815", "bodyText": "It is supposed to be populated in allocateSlot. It is mostly there since the current SM also does such book-keeping (just in the TaskManagerSlot), but it could very well be unnecessary at this point.", "author": "zentol", "createdAt": "2020-10-09T10:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1Mzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMjY4Ng==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502332686", "bodyText": "After all we aren't really doing anything on cancellation, although it might be useful for debugging purposes?", "author": "zentol", "createdAt": "2020-10-09T10:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1Mzk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUzNjY3NQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502536675", "bodyText": "Ah ok, I think I remember. The idea was to disable the callback on the response from the TaskExecutor when calling requestSlot.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1Mzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MDgzOQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501760839", "bodyText": "For what do we need the slotRequestTimeoutCheck?", "author": "tillrohrmann", "createdAt": "2020-10-08T14:21:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMjM5Ng==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502332396", "bodyText": "There should be no need for it.", "author": "zentol", "createdAt": "2020-10-09T10:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MDgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2NzUyMA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501767520", "bodyText": "Do we really have to look at the internal state of the slots in order to ensure that after a TM gets unregistered that there are no more slots? One could simply use slotManager.getNumberRegisteredSlots() for this.", "author": "tillrohrmann", "createdAt": "2020-10-08T14:29:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyOTQzNA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502329434", "bodyText": "Agreed.", "author": "zentol", "createdAt": "2020-10-09T10:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2NzUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2Nzk4Mw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r501767983", "bodyText": "Maybe check that the right sized resource is requested.", "author": "tillrohrmann", "createdAt": "2020-10-08T14:30:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMTg3NA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502331874", "bodyText": "The size of the requested resource is not really dependent on the resource requirements; the only thing that is checked (by the TaskExecutorManager) is that the slots of said resource can fulfill the requirements.\nThis is admittedly not tested, but belongs into the TaskExecutorManagerTest imo.", "author": "zentol", "createdAt": "2020-10-09T10:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2Nzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUzMjU2NA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502532564", "bodyText": "Ok sounds good.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2Nzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUzODEzOA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502538138", "bodyText": "We should state the computational complexity of this method and add a comment that we might need to revisit this logic in case that the matching takes too much time. An alternative approach would be to remember which pending slot was assigned to which job. This could decrease the complexity a bit.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:17:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.MetricNames;\n+import org.apache.flink.runtime.metrics.groups.SlotManagerMetricGroup;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceCounter;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Implementation of {@link SlotManager} supporting declarative slot management.\n+ */\n+public class DeclarativeSlotManager implements SlotManager {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotManager.class);\n+\n+\tprivate final SlotTracker slotTracker;\n+\tprivate final ResourceTracker resourceTracker;\n+\tprivate final BiFunction<Executor, ResourceActions, TaskExecutorManager> taskExecutorManagerFactory;\n+\tprivate TaskExecutorManager taskExecutorManager;\n+\n+\t/** Timeout for slot requests to the task manager. */\n+\tprivate final Time taskManagerRequestTimeout;\n+\tprivate ScheduledFuture<?> slotRequestTimeoutCheck;\n+\n+\tprivate final SlotMatchingStrategy slotMatchingStrategy;\n+\n+\tprivate final SlotManagerMetricGroup slotManagerMetricGroup;\n+\n+\tprivate final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();\n+\tprivate final HashMap<SlotID, CompletableFuture<Acknowledge>> pendingSlotAllocationFutures;\n+\n+\t/** ResourceManager's id. */\n+\tprivate ResourceManagerId resourceManagerId;\n+\n+\t/** Executor for future callbacks which have to be \"synchronized\". */\n+\tprivate Executor mainThreadExecutor;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate ResourceActions resourceActions;\n+\n+\t/** True iff the component has been started. */\n+\tprivate boolean started;\n+\n+\tpublic DeclarativeSlotManager(\n+\t\t\tScheduledExecutor scheduledExecutor,\n+\t\t\tSlotManagerConfiguration slotManagerConfiguration,\n+\t\t\tSlotManagerMetricGroup slotManagerMetricGroup,\n+\t\t\tResourceTracker resourceTracker,\n+\t\t\tSlotTracker slotTracker) {\n+\n+\t\tPreconditions.checkNotNull(slotManagerConfiguration);\n+\t\tthis.taskManagerRequestTimeout = slotManagerConfiguration.getTaskManagerRequestTimeout();\n+\t\tthis.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);\n+\t\tthis.resourceTracker = Preconditions.checkNotNull(resourceTracker);\n+\n+\t\tpendingSlotAllocationFutures = new HashMap<>(16);\n+\n+\t\tthis.slotTracker = Preconditions.checkNotNull(slotTracker);\n+\t\tslotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());\n+\n+\t\tslotMatchingStrategy = slotManagerConfiguration.getSlotMatchingStrategy();\n+\n+\t\ttaskExecutorManagerFactory = (executor, resourceActions) -> new TaskExecutorManager(\n+\t\t\tslotManagerConfiguration.getDefaultWorkerResourceSpec(),\n+\t\t\tslotManagerConfiguration.getNumSlotsPerWorker(),\n+\t\t\tslotManagerConfiguration.getMaxSlotNum(),\n+\t\t\tslotManagerConfiguration.isWaitResultConsumedBeforeRelease(),\n+\t\t\tslotManagerConfiguration.getRedundantTaskManagerNum(),\n+\t\t\tslotManagerConfiguration.getTaskManagerTimeout(),\n+\t\t\tscheduledExecutor,\n+\t\t\texecutor,\n+\t\t\tresourceActions);\n+\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tmainThreadExecutor = null;\n+\t\tslotRequestTimeoutCheck = null;\n+\t\ttaskExecutorManager = null;\n+\n+\t\tstarted = false;\n+\t}\n+\n+\tprivate SlotStatusUpdateListener createSlotStatusUpdateListener() {\n+\t\treturn (taskManagerSlot, previous, current, jobId) -> {\n+\t\t\tif (previous == SlotState.PENDING) {\n+\t\t\t\tcancelAllocationFuture(taskManagerSlot.getSlotId());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.PENDING) {\n+\t\t\t\tresourceTracker.notifyAcquiredResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\t\t\tif (current == SlotState.FREE) {\n+\t\t\t\tresourceTracker.notifyLostResource(jobId, taskManagerSlot.getResourceProfile());\n+\t\t\t}\n+\n+\t\t\tif (current == SlotState.ALLOCATED) {\n+\t\t\t\ttaskExecutorManager.occupySlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t\tif (previous == SlotState.ALLOCATED && current == SlotState.FREE) {\n+\t\t\t\ttaskExecutorManager.freeSlot(taskManagerSlot.getInstanceId());\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate void cancelAllocationFuture(SlotID slotId) {\n+\t\tfinal CompletableFuture<Acknowledge> acknowledgeCompletableFuture = pendingSlotAllocationFutures.remove(slotId);\n+\t\t// the future may be null if we are just re-playing the state transitions due to a slot report\n+\t\tif (acknowledgeCompletableFuture != null) {\n+\t\t\tacknowledgeCompletableFuture.cancel(false);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Component lifecycle methods\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Starts the slot manager with the given leader id and resource manager actions.\n+\t *\n+\t * @param newResourceManagerId to use for communication with the task managers\n+\t * @param newMainThreadExecutor to use to run code in the ResourceManager's main thread\n+\t * @param newResourceActions to use for resource (de-)allocations\n+\t */\n+\t@Override\n+\tpublic void start(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions) {\n+\t\tLOG.info(\"Starting the slot manager.\");\n+\n+\t\tthis.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);\n+\t\tmainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);\n+\t\tresourceActions = Preconditions.checkNotNull(newResourceActions);\n+\t\ttaskExecutorManager = taskExecutorManagerFactory.apply(newMainThreadExecutor, newResourceActions);\n+\n+\t\tstarted = true;\n+\n+\t\tregisterSlotManagerMetrics();\n+\t}\n+\n+\tprivate void registerSlotManagerMetrics() {\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_AVAILABLE,\n+\t\t\t() -> (long) getNumberFreeSlots());\n+\t\tslotManagerMetricGroup.gauge(\n+\t\t\tMetricNames.TASK_SLOTS_TOTAL,\n+\t\t\t() -> (long) getNumberRegisteredSlots());\n+\t}\n+\n+\t/**\n+\t * Suspends the component. This clears the internal state of the slot manager.\n+\t */\n+\t@Override\n+\tpublic void suspend() {\n+\t\tLOG.info(\"Suspending the slot manager.\");\n+\n+\t\tif (slotRequestTimeoutCheck != null) {\n+\t\t\tslotRequestTimeoutCheck.cancel(false);\n+\t\t\tslotRequestTimeoutCheck = null;\n+\t\t}\n+\n+\t\tresourceTracker.clear();\n+\t\ttaskExecutorManager.close();\n+\n+\t\tfor (InstanceID registeredTaskManager : taskExecutorManager.getTaskExecutors()) {\n+\t\t\tunregisterTaskManager(registeredTaskManager, new SlotManagerException(\"The slot manager is being suspended.\"));\n+\t\t}\n+\n+\t\ttaskExecutorManager = null;\n+\t\tresourceManagerId = null;\n+\t\tresourceActions = null;\n+\t\tstarted = false;\n+\t}\n+\n+\t/**\n+\t * Closes the slot manager.\n+\t *\n+\t * @throws Exception if the close operation fails\n+\t */\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tLOG.info(\"Closing the slot manager.\");\n+\n+\t\tsuspend();\n+\t\tslotManagerMetricGroup.close();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Public API\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void processResourceRequirements(ResourceRequirements resourceRequirements) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Received resource requirements from job {}: {}\", resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\n+\t\tif (resourceRequirements.getResourceRequirements().isEmpty()) {\n+\t\t\tjobMasterTargetAddresses.remove(resourceRequirements.getJobId());\n+\t\t} else {\n+\t\t\tjobMasterTargetAddresses.put(resourceRequirements.getJobId(), resourceRequirements.getTargetAddress());\n+\t\t}\n+\t\tresourceTracker.notifyResourceRequirements(resourceRequirements.getJobId(), resourceRequirements.getResourceRequirements());\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t/**\n+\t * Registers a new task manager at the slot manager. This will make the task managers slots\n+\t * known and, thus, available for allocation.\n+\t *\n+\t * @param taskExecutorConnection for the new task manager\n+\t * @param initialSlotReport for the new task manager\n+\t * @return True if the task manager has not been registered before and is registered successfully; otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Registering task executor {} under {} at the slot manager.\", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());\n+\n+\t\t// we identify task managers by their instance id\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(taskExecutorConnection.getInstanceID())) {\n+\t\t\tLOG.debug(\"Task executor {} was already registered.\", taskExecutorConnection.getResourceID());\n+\t\t\treportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tif (!taskExecutorManager.registerTaskManager(taskExecutorConnection, initialSlotReport)) {\n+\t\t\t\tLOG.debug(\"Task executor {} could not be registered.\", taskExecutorConnection.getResourceID());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\t// register the new slots\n+\t\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\t\tslotTracker.addSlot(\n+\t\t\t\t\tslotStatus.getSlotID(),\n+\t\t\t\t\tslotStatus.getResourceProfile(),\n+\t\t\t\t\ttaskExecutorConnection,\n+\t\t\t\t\tslotStatus.getJobID());\n+\t\t\t}\n+\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean unregisterTaskManager(InstanceID instanceId, Exception cause) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Unregistering task executor {} from the slot manager.\", instanceId);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.removeSlots(taskExecutorManager.getSlotsOf(instanceId));\n+\t\t\ttaskExecutorManager.unregisterTaskExecutor(instanceId);\n+\t\t\tcheckResourceRequirements();\n+\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"There is no task executor registered with instance ID {}. Ignoring this message.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reports the current slot allocations for a task manager identified by the given instance id.\n+\t *\n+\t * @param instanceId identifying the task manager for which to report the slot status\n+\t * @param slotReport containing the status for all of its slots\n+\t * @return true if the slot status has been updated successfully, otherwise false\n+\t */\n+\t@Override\n+\tpublic boolean reportSlotStatus(InstanceID instanceId, SlotReport slotReport) {\n+\t\tcheckInit();\n+\n+\t\tLOG.debug(\"Received slot report from instance {}: {}.\", instanceId, slotReport);\n+\n+\t\tif (taskExecutorManager.isTaskManagerRegistered(instanceId)) {\n+\t\t\tslotTracker.notifySlotStatus(slotReport);\n+\t\t\tcheckResourceRequirements();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\tLOG.debug(\"Received slot report for unknown task manager with instance id {}. Ignoring this report.\", instanceId);\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Free the given slot from the given allocation. If the slot is still allocated by the given\n+\t * allocation id, then the slot will be marked as free and will be subject to new slot requests.\n+\t *\n+\t * @param slotId identifying the slot to free\n+\t * @param allocationId with which the slot is presumably allocated\n+\t */\n+\t@Override\n+\tpublic void freeSlot(SlotID slotId, AllocationID allocationId) {\n+\t\tcheckInit();\n+\t\tLOG.debug(\"Freeing slot {}.\", slotId);\n+\n+\t\tslotTracker.notifyFree(slotId);\n+\t\tcheckResourceRequirements();\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Requirement matching\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void checkResourceRequirements() {", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MTEyOQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502541129", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * one the allocation completes.\n          \n          \n            \n            \t * once the allocation completes.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:23:21Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MTM2MQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502541361", "bodyText": "Why is this test ignored?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:23:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MjUwMg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502542502", "bodyText": "Is this really supported by the current DeclarativeSlotManager implementation?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:25:55Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2ODM2MQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503168361", "bodyText": "No, that's why it I added @Ignore initially, but I never got around to deleting it.\nOnce the requirements are reduced the SlotManager knows that the pending slots exceeds the requirements, but takes no further action. The TaskExecutor will offer the slot to the JM, which may or may not fail. In any case the TM will inform the SM about the resulting state, so we're good in regards to correctness. (And we'd introduce an odd edge-case where the SM actually frees a slot on the TM)", "author": "zentol", "createdAt": "2020-10-12T09:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MzMwMQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502543301", "bodyText": "This logic looks quite similar to the logic in testSlotRequestWithFreeSlot .", "author": "tillrohrmann", "createdAt": "2020-10-09T16:27:29Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc5MzcyNA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503793724", "bodyText": "They are; the only difference is the order in which requirements are declared / the task executor is registered. I'll check whether we can't de-duplicate things a bit.", "author": "zentol", "createdAt": "2020-10-13T09:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0MzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NTA5Mw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502545093", "bodyText": "Should we also test that the slo is being used to fulfill requirements of another job if the resource requirements of this job were already registered?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:31:00Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzODQ1OA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503338458", "bodyText": "that's a good idea, will add it", "author": "zentol", "createdAt": "2020-10-12T14:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NTczMQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502545731", "bodyText": "and slot1 should still be free, right?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:32:14Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMTA4MQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503331081", "bodyText": "correct", "author": "zentol", "createdAt": "2020-10-12T14:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NjQ4Ng==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502546486", "bodyText": "A slightly easier way to express this logic would be to use a queue from which you pop and you populate the queue with the answers you want to have.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:33:41Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0ODU3MA==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502548570", "bodyText": "It can happen that we retry with firstSlotId?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:37:24Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway());\n+\t\tfinal SlotReport slotReport = createSlotReport(taskManagerConnection.getResourceID(), 2);\n+\n+\t\tfinal Executor mainThreadExecutor = TestingUtils.defaultExecutor();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tCompletableFuture.runAsync(() -> slotManager.registerTaskManager(taskManagerConnection, slotReport), mainThreadExecutor)\n+\t\t\t\t.thenRun(() -> slotManager.processResourceRequirements(createResourceRequirementsForSingleSlot()))\n+\t\t\t\t.get(5, TimeUnit.SECONDS);\n+\n+\t\t\t// a second request is only sent if the first request timed out\n+\t\t\tsecondSlotRequestFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocation is retried if it times out on the task manager side.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerSlotAllocationTimeoutHandling() throws Exception {\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot(jobId);\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture1 = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture2 = new CompletableFuture<>();\n+\t\tfinal Iterator<CompletableFuture<Acknowledge>> slotRequestFutureIterator = Arrays.asList(slotRequestFuture1, slotRequestFuture2).iterator();\n+\t\tfinal ArrayBlockingQueue<SlotID> slotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\tslotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn slotRequestFutureIterator.next();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot failedSlot = slotTracker.getSlot(firstSlotId);\n+\n+\t\t\t// let the first attempt fail --> this should trigger a second attempt\n+\t\t\tslotRequestFuture1.completeExceptionally(new SlotAllocationException(\"Test exception.\"));\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobId)), is(1));\n+\n+\t\t\t// the second attempt succeeds\n+\t\t\tslotRequestFuture2.complete(Acknowledge.get());\n+\n+\t\t\tfinal SlotID secondSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondSlotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\t\t\tassertEquals(jobId, slot.getJobId());\n+\n+\t\t\tif (!failedSlot.getSlotId().equals(slot.getSlotId())) {\n+\t\t\t\tassertThat(failedSlot.getState(), is(SlotState.FREE));\n+\t\t\t}", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0MjYzMg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r503342632", "bodyText": "yes; when the allocation fails we go through the same process as on the first attempt, and neither the SlotTracker#getFreeSlots nor SlotMatchingStrategy#findMatchingSlot give any guarantees on the order in which slots are returned/matched.", "author": "zentol", "createdAt": "2020-10-12T14:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0ODU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTQwMg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502551402", "bodyText": "Could this be simplified by inserting the futures at creation time of the responseQueue?", "author": "tillrohrmann", "createdAt": "2020-10-09T16:42:46Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway());\n+\t\tfinal SlotReport slotReport = createSlotReport(taskManagerConnection.getResourceID(), 2);\n+\n+\t\tfinal Executor mainThreadExecutor = TestingUtils.defaultExecutor();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tCompletableFuture.runAsync(() -> slotManager.registerTaskManager(taskManagerConnection, slotReport), mainThreadExecutor)\n+\t\t\t\t.thenRun(() -> slotManager.processResourceRequirements(createResourceRequirementsForSingleSlot()))\n+\t\t\t\t.get(5, TimeUnit.SECONDS);\n+\n+\t\t\t// a second request is only sent if the first request timed out\n+\t\t\tsecondSlotRequestFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocation is retried if it times out on the task manager side.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerSlotAllocationTimeoutHandling() throws Exception {\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot(jobId);\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture1 = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture2 = new CompletableFuture<>();\n+\t\tfinal Iterator<CompletableFuture<Acknowledge>> slotRequestFutureIterator = Arrays.asList(slotRequestFuture1, slotRequestFuture2).iterator();\n+\t\tfinal ArrayBlockingQueue<SlotID> slotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\tslotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn slotRequestFutureIterator.next();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot failedSlot = slotTracker.getSlot(firstSlotId);\n+\n+\t\t\t// let the first attempt fail --> this should trigger a second attempt\n+\t\t\tslotRequestFuture1.completeExceptionally(new SlotAllocationException(\"Test exception.\"));\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobId)), is(1));\n+\n+\t\t\t// the second attempt succeeds\n+\t\t\tslotRequestFuture2.complete(Acknowledge.get());\n+\n+\t\t\tfinal SlotID secondSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondSlotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\t\t\tassertEquals(jobId, slot.getJobId());\n+\n+\t\t\tif (!failedSlot.getSlotId().equals(slot.getSlotId())) {\n+\t\t\t\tassertThat(failedSlot.getState(), is(SlotState.FREE));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a pending slot allocation is cancelled if a slot report indicates that the slot is already allocated\n+\t * by another job.\n+\t */\n+\t@Test\n+\tpublic void testSlotReportWithConflictingJobIdDuringSlotAllocation() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\tfinal ArrayBlockingQueue<SlotID> requestedSlotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\trequestedSlotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskExecutorConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setScheduledExecutor(mainThreadExecutor)\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, slotReport);\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstRequestedSlotId = requestedSlotIds.take();\n+\t\t\tfinal SlotID freeSlotId = firstRequestedSlotId.equals(slotId1) ? slotId2 : slotId1;\n+\n+\t\t\tfinal SlotReport newSlotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(firstRequestedSlotId), createFreeSlotStatus(freeSlotId)));\n+\n+\t\t\tslotManager.reportSlotStatus(taskExecutorConnection.getInstanceID(), newSlotReport);\n+\n+\t\t\tfinal SlotID secondRequestedSlotId = requestedSlotIds.take();\n+\n+\t\t\tassertEquals(freeSlotId, secondRequestedSlotId);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that free slots which are reported as allocated won't be considered for fulfilling\n+\t * other pending slot requests.\n+\t *\n+\t * <p>See: FLINK-8505\n+\t */\n+\t@Test\n+\tpublic void testReportAllocatedSlot() throws Exception {\n+\t\tfinal ResourceID taskManagerId = ResourceID.generate();\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(taskManagerId, taskExecutorGateway);\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// initially report a single slot as free\n+\t\t\tfinal SlotID slotId = new SlotID(taskManagerId, 0);\n+\t\t\tfinal SlotReport initialSlotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, initialSlotReport);\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(equalTo(1)));\n+\n+\t\t\t// Now report this slot as allocated\n+\t\t\tfinal SlotStatus slotStatus = createAllocatedSlotStatus(slotId);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.reportSlotStatus(\n+\t\t\t\ttaskExecutorConnection.getInstanceID(),\n+\t\t\t\tslotReport);\n+\n+\t\t\tfinal JobID jobId = new JobID();\n+\t\t\t// this resource requirement should not be fulfilled\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot(jobId);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(slotTracker.getSlot(slotId).getJobId(), is(slotStatus.getJobID()));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the SlotManager retries allocating a slot if the TaskExecutor#requestSlot call\n+\t * fails.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestFailure() throws Exception {\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTY4Mg==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502551682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testSlotRequestRemovedIfTMReportAllocation() throws Exception {\n          \n          \n            \n            \tpublic void testSlotRequestRemovedIfTMReportsAllocation() throws Exception {", "author": "tillrohrmann", "createdAt": "2020-10-09T16:43:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway());\n+\t\tfinal SlotReport slotReport = createSlotReport(taskManagerConnection.getResourceID(), 2);\n+\n+\t\tfinal Executor mainThreadExecutor = TestingUtils.defaultExecutor();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tCompletableFuture.runAsync(() -> slotManager.registerTaskManager(taskManagerConnection, slotReport), mainThreadExecutor)\n+\t\t\t\t.thenRun(() -> slotManager.processResourceRequirements(createResourceRequirementsForSingleSlot()))\n+\t\t\t\t.get(5, TimeUnit.SECONDS);\n+\n+\t\t\t// a second request is only sent if the first request timed out\n+\t\t\tsecondSlotRequestFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocation is retried if it times out on the task manager side.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerSlotAllocationTimeoutHandling() throws Exception {\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot(jobId);\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture1 = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture2 = new CompletableFuture<>();\n+\t\tfinal Iterator<CompletableFuture<Acknowledge>> slotRequestFutureIterator = Arrays.asList(slotRequestFuture1, slotRequestFuture2).iterator();\n+\t\tfinal ArrayBlockingQueue<SlotID> slotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\tslotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn slotRequestFutureIterator.next();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot failedSlot = slotTracker.getSlot(firstSlotId);\n+\n+\t\t\t// let the first attempt fail --> this should trigger a second attempt\n+\t\t\tslotRequestFuture1.completeExceptionally(new SlotAllocationException(\"Test exception.\"));\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobId)), is(1));\n+\n+\t\t\t// the second attempt succeeds\n+\t\t\tslotRequestFuture2.complete(Acknowledge.get());\n+\n+\t\t\tfinal SlotID secondSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondSlotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\t\t\tassertEquals(jobId, slot.getJobId());\n+\n+\t\t\tif (!failedSlot.getSlotId().equals(slot.getSlotId())) {\n+\t\t\t\tassertThat(failedSlot.getState(), is(SlotState.FREE));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a pending slot allocation is cancelled if a slot report indicates that the slot is already allocated\n+\t * by another job.\n+\t */\n+\t@Test\n+\tpublic void testSlotReportWithConflictingJobIdDuringSlotAllocation() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\tfinal ArrayBlockingQueue<SlotID> requestedSlotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\trequestedSlotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskExecutorConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setScheduledExecutor(mainThreadExecutor)\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, slotReport);\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstRequestedSlotId = requestedSlotIds.take();\n+\t\t\tfinal SlotID freeSlotId = firstRequestedSlotId.equals(slotId1) ? slotId2 : slotId1;\n+\n+\t\t\tfinal SlotReport newSlotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(firstRequestedSlotId), createFreeSlotStatus(freeSlotId)));\n+\n+\t\t\tslotManager.reportSlotStatus(taskExecutorConnection.getInstanceID(), newSlotReport);\n+\n+\t\t\tfinal SlotID secondRequestedSlotId = requestedSlotIds.take();\n+\n+\t\t\tassertEquals(freeSlotId, secondRequestedSlotId);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that free slots which are reported as allocated won't be considered for fulfilling\n+\t * other pending slot requests.\n+\t *\n+\t * <p>See: FLINK-8505\n+\t */\n+\t@Test\n+\tpublic void testReportAllocatedSlot() throws Exception {\n+\t\tfinal ResourceID taskManagerId = ResourceID.generate();\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(taskManagerId, taskExecutorGateway);\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// initially report a single slot as free\n+\t\t\tfinal SlotID slotId = new SlotID(taskManagerId, 0);\n+\t\t\tfinal SlotReport initialSlotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, initialSlotReport);\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(equalTo(1)));\n+\n+\t\t\t// Now report this slot as allocated\n+\t\t\tfinal SlotStatus slotStatus = createAllocatedSlotStatus(slotId);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.reportSlotStatus(\n+\t\t\t\ttaskExecutorConnection.getInstanceID(),\n+\t\t\t\tslotReport);\n+\n+\t\t\tfinal JobID jobId = new JobID();\n+\t\t\t// this resource requirement should not be fulfilled\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot(jobId);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(slotTracker.getSlot(slotId).getJobId(), is(slotStatus.getJobID()));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the SlotManager retries allocating a slot if the TaskExecutor#requestSlot call\n+\t * fails.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestFailure() throws Exception {\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);\n+\n+\t\t\t// fail first request\n+\t\t\tfirstManualSlotRequestResponse.completeExceptionally(new SlotAllocationException(\"Test exception\"));\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> secondRequest = requestSlotQueue.take();\n+\n+\t\t\tassertThat(secondRequest.f1, equalTo(firstRequest.f1));\n+\t\t\tassertThat(secondRequest.f0, equalTo(firstRequest.f0));\n+\n+\t\t\tsecondManualSlotRequestResponse.complete(Acknowledge.get());\n+\n+\t\t\tfinal DeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondRequest.f0);\n+\t\t\tassertThat(slot.getState(), equalTo(SlotState.ALLOCATED));\n+\t\t\tassertThat(slot.getJobId(), equalTo(secondRequest.f1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending request is removed if task executor reports a slot with the same job id.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestRemovedIfTMReportAllocation() throws Exception {", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MjkzMQ==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502552931", "bodyText": "Same here with the responseQueue.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:45:42Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway());\n+\t\tfinal SlotReport slotReport = createSlotReport(taskManagerConnection.getResourceID(), 2);\n+\n+\t\tfinal Executor mainThreadExecutor = TestingUtils.defaultExecutor();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tCompletableFuture.runAsync(() -> slotManager.registerTaskManager(taskManagerConnection, slotReport), mainThreadExecutor)\n+\t\t\t\t.thenRun(() -> slotManager.processResourceRequirements(createResourceRequirementsForSingleSlot()))\n+\t\t\t\t.get(5, TimeUnit.SECONDS);\n+\n+\t\t\t// a second request is only sent if the first request timed out\n+\t\t\tsecondSlotRequestFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocation is retried if it times out on the task manager side.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerSlotAllocationTimeoutHandling() throws Exception {\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot(jobId);\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture1 = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture2 = new CompletableFuture<>();\n+\t\tfinal Iterator<CompletableFuture<Acknowledge>> slotRequestFutureIterator = Arrays.asList(slotRequestFuture1, slotRequestFuture2).iterator();\n+\t\tfinal ArrayBlockingQueue<SlotID> slotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\tslotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn slotRequestFutureIterator.next();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot failedSlot = slotTracker.getSlot(firstSlotId);\n+\n+\t\t\t// let the first attempt fail --> this should trigger a second attempt\n+\t\t\tslotRequestFuture1.completeExceptionally(new SlotAllocationException(\"Test exception.\"));\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobId)), is(1));\n+\n+\t\t\t// the second attempt succeeds\n+\t\t\tslotRequestFuture2.complete(Acknowledge.get());\n+\n+\t\t\tfinal SlotID secondSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondSlotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\t\t\tassertEquals(jobId, slot.getJobId());\n+\n+\t\t\tif (!failedSlot.getSlotId().equals(slot.getSlotId())) {\n+\t\t\t\tassertThat(failedSlot.getState(), is(SlotState.FREE));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a pending slot allocation is cancelled if a slot report indicates that the slot is already allocated\n+\t * by another job.\n+\t */\n+\t@Test\n+\tpublic void testSlotReportWithConflictingJobIdDuringSlotAllocation() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\tfinal ArrayBlockingQueue<SlotID> requestedSlotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\trequestedSlotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskExecutorConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setScheduledExecutor(mainThreadExecutor)\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, slotReport);\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstRequestedSlotId = requestedSlotIds.take();\n+\t\t\tfinal SlotID freeSlotId = firstRequestedSlotId.equals(slotId1) ? slotId2 : slotId1;\n+\n+\t\t\tfinal SlotReport newSlotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(firstRequestedSlotId), createFreeSlotStatus(freeSlotId)));\n+\n+\t\t\tslotManager.reportSlotStatus(taskExecutorConnection.getInstanceID(), newSlotReport);\n+\n+\t\t\tfinal SlotID secondRequestedSlotId = requestedSlotIds.take();\n+\n+\t\t\tassertEquals(freeSlotId, secondRequestedSlotId);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that free slots which are reported as allocated won't be considered for fulfilling\n+\t * other pending slot requests.\n+\t *\n+\t * <p>See: FLINK-8505\n+\t */\n+\t@Test\n+\tpublic void testReportAllocatedSlot() throws Exception {\n+\t\tfinal ResourceID taskManagerId = ResourceID.generate();\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(taskManagerId, taskExecutorGateway);\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// initially report a single slot as free\n+\t\t\tfinal SlotID slotId = new SlotID(taskManagerId, 0);\n+\t\t\tfinal SlotReport initialSlotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, initialSlotReport);\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(equalTo(1)));\n+\n+\t\t\t// Now report this slot as allocated\n+\t\t\tfinal SlotStatus slotStatus = createAllocatedSlotStatus(slotId);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.reportSlotStatus(\n+\t\t\t\ttaskExecutorConnection.getInstanceID(),\n+\t\t\t\tslotReport);\n+\n+\t\t\tfinal JobID jobId = new JobID();\n+\t\t\t// this resource requirement should not be fulfilled\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot(jobId);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(slotTracker.getSlot(slotId).getJobId(), is(slotStatus.getJobID()));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the SlotManager retries allocating a slot if the TaskExecutor#requestSlot call\n+\t * fails.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestFailure() throws Exception {\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);\n+\n+\t\t\t// fail first request\n+\t\t\tfirstManualSlotRequestResponse.completeExceptionally(new SlotAllocationException(\"Test exception\"));\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> secondRequest = requestSlotQueue.take();\n+\n+\t\t\tassertThat(secondRequest.f1, equalTo(firstRequest.f1));\n+\t\t\tassertThat(secondRequest.f0, equalTo(firstRequest.f0));\n+\n+\t\t\tsecondManualSlotRequestResponse.complete(Acknowledge.get());\n+\n+\t\t\tfinal DeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondRequest.f0);\n+\t\t\tassertThat(slot.getState(), equalTo(SlotState.ALLOCATED));\n+\t\t\tassertThat(slot.getJobId(), equalTo(secondRequest.f1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending request is removed if task executor reports a slot with the same job id.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestRemovedIfTMReportAllocation() throws Exception {\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tfinal JobID jobID = new JobID();\n+\t\t\tslotManager.processResourceRequirements(createResourceRequirementsForSingleSlot(jobID));\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDQwNw==", "url": "https://github.com/apache/flink/pull/13553#discussion_r502554407", "bodyText": "Not sure whether this test needs to be so complex. I guess it would be good enough to test it only with a single TM.", "author": "tillrohrmann", "createdAt": "2020-10-09T16:48:28Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.api.java.tuple.Tuple6;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerId;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotAllocationException;\n+import org.apache.flink.runtime.taskexecutor.exceptions.SlotOccupiedException;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.function.FunctionUtils;\n+\n+import akka.pattern.AskTimeoutException;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotManager}.\n+ */\n+public class DeclarativeSlotManagerTest extends TestLogger {\n+\n+\tprivate static final FlinkException TEST_EXCEPTION = new FlinkException(\"Test exception\");\n+\n+\tprivate static final WorkerResourceSpec WORKER_RESOURCE_SPEC = new WorkerResourceSpec.Builder()\n+\t\t.setCpuCores(100.0)\n+\t\t.setTaskHeapMemoryMB(10000)\n+\t\t.setTaskOffHeapMemoryMB(10000)\n+\t\t.setNetworkMemoryMB(10000)\n+\t\t.setManagedMemoryMB(10000)\n+\t\t.build();\n+\n+\t/**\n+\t * Tests that we can register task manager and their slots at the slot manager.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerRegistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertThat(\"The number registered slots does not equal the expected number.\", slotManager.getNumberRegisteredSlots(), is(2));\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that un-registration of task managers will free and remove all registered slots.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerUnregistration() throws Exception {\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> new CompletableFuture<>())\n+\t\t\t.createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tassertEquals(\"The number registered slots does not equal the expected number.\", 2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot2.getState());\n+\n+\t\t\tslotManager.unregisterTaskManager(taskManagerConnection.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request with no free slots will trigger the resource allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithoutFreeSlots() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tCompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(allocateResourceFuture::complete)\n+\t\t\t.build();\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tallocateResourceFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that resources continue to be considered missing if we cannot allocate more resources.\n+\t */\n+\t@Test\n+\tpublic void testResourceDeclarationWithResourceAllocationFailure() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceFunction(value -> false)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec(ResourceManagerId.generate(), resourceManagerActions)) {\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal JobID jobId = resourceRequirements.getJobId();\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot request which can be fulfilled will trigger a slot allocation.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestWithFreeSlot() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, new TestingResourceActionsBuilder().build())) {\n+\n+\t\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t\t// accept an incoming slot request\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tResourceRequirements requirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected allocation id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks that reducing resource requirements while a slot allocation is in-progress results in the slot being freed\n+\t * one the allocation completes.\n+\t */\n+\t@Test\n+\t@Ignore\n+\tpublic void testResourceRequirementReductionDuringAllocation() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertSame(SlotState.PENDING, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements.getJobId(), \"foobar\", Collections.emptyList()));\n+\n+\t\t\tslot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending slot requests are tried to be fulfilled upon new slot registrations.\n+\t */\n+\t@Test\n+\tpublic void testFulfillingPendingSlotRequest() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal String targetAddress = \"localhost\";\n+\t\tfinal ResourceProfile resourceProfile = ResourceProfile.fromResources(42.0, 1337);\n+\n+\t\tfinal AtomicInteger numberAllocateResourceCalls = new AtomicInteger(0);\n+\t\tResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> numberAllocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\n+\t\tfinal CompletableFuture<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestFuture = new CompletableFuture<>();\n+\t\t// accept an incoming slot request\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(tuple6 -> {\n+\t\t\t\trequestFuture.complete(Tuple6.of(tuple6.f0, tuple6.f1, tuple6.f2, tuple6.f3, tuple6.f4, tuple6.f5));\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotStatus slotStatus = new SlotStatus(slotId, resourceProfile);\n+\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tfinal ResourceRequirements resourceRequirements = ResourceRequirements.create(\n+\t\t\t\tjobId,\n+\t\t\t\ttargetAddress,\n+\t\t\t\tCollections.singleton(ResourceRequirement.create(resourceProfile, 1)));\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tassertThat(numberAllocateResourceCalls.get(), is(1));\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tassertThat(requestFuture.get(), is(equalTo(Tuple6.of(slotId, jobId, requestFuture.get().f2, resourceProfile, targetAddress, resourceManagerId))));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", jobId, slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that freeing a slot will correctly reset the slot and mark it as a free slot.\n+\t */\n+\t@Test\n+\tpublic void testFreeSlot() throws Exception {\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskExecutorConnection.getResourceID();\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\n+\t\tfinal SlotReport slotReport = new SlotReport(createAllocatedSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(\n+\t\t\t\ttaskExecutorConnection,\n+\t\t\t\tslotReport);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertSame(SlotState.ALLOCATED, slot.getState());\n+\n+\t\t\tslotManager.freeSlot(slotId, new AllocationID());\n+\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tassertEquals(1, slotManager.getNumberFreeSlots());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that duplicate resource requirement declaration do not result in additional slots being allocated after a\n+\t * pending slot request has been fulfilled but not yet freed.\n+\t */\n+\t@Test\n+\tpublic void testDuplicateResourceRequirementDeclarationAfterSuccessfulAllocation() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal AtomicInteger allocateResourceCalls = new AtomicInteger(0);\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder()\n+\t\t\t.setAllocateResourceConsumer(ignored -> allocateResourceCalls.incrementAndGet())\n+\t\t\t.build();\n+\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceID = ResourceID.generate();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceID, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec(resourceManagerId, resourceManagerActions)) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\t\t}\n+\n+\t\t// check that we have only called the resource allocation only for the first slot request,\n+\t\t// since the second request is a duplicate\n+\t\tassertThat(allocateResourceCalls.get(), is(0));\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocated for one job can be allocated for another job after being freed.\n+\t */\n+\t@Test\n+\tpublic void testSlotCanBeAllocatedForDifferentJobAfterFree() throws Exception {\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal ResourceRequirements resourceRequirements1 = createResourceRequirementsForSingleSlot();\n+\t\tfinal ResourceRequirements resourceRequirements2 = createResourceRequirementsForSingleSlot();\n+\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceID = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId = new SlotID(resourceID, 0);\n+\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(slotId);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements1.getJobId(), slot.getJobId());\n+\n+\t\t\t// clear resource requirements, so that the slot isn't immediately re-assigned\n+\t\t\tslotManager.processResourceRequirements(ResourceRequirements.create(resourceRequirements1.getJobId(), resourceRequirements1.getTargetAddress(), Collections.emptyList()));\n+\t\t\tslotManager.freeSlot(slotId, allocationId);\n+\n+\t\t\t// check that the slot has been freed\n+\t\t\tassertSame(SlotState.FREE, slot.getState());\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements2);\n+\n+\t\t\tassertEquals(\"The slot has not been allocated to the expected job id.\", resourceRequirements2.getJobId(), slot.getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the slot manager ignores slot reports of unknown origin (not registered\n+\t * task managers).\n+\t */\n+\t@Test\n+\tpublic void testReceivingUnknownSlotReport() throws Exception {\n+\t\tfinal ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n+\t\tfinal ResourceActions resourceManagerActions = new TestingResourceActionsBuilder().build();\n+\n+\t\tfinal InstanceID unknownInstanceID = new InstanceID();\n+\t\tfinal SlotID unknownSlotId = new SlotID(ResourceID.generate(), 0);\n+\t\tfinal SlotReport unknownSlotReport = new SlotReport(createFreeSlotStatus(unknownSlotId));\n+\n+\t\ttry (SlotManager slotManager = createSlotManager(resourceManagerId, resourceManagerActions)) {\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\n+\t\t\t// this should not update anything since the instance id is not known to the slot manager\n+\t\t\tassertFalse(slotManager.reportSlotStatus(unknownInstanceID, unknownSlotReport));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that slots are updated with respect to the latest incoming slot report. This means that\n+\t * slots for which a report was received are updated accordingly.\n+\t */\n+\t@Test\n+\tpublic void testUpdateSlotReport() throws Exception {\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection();\n+\t\tfinal ResourceID resourceId = taskManagerConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\n+\t\tfinal SlotStatus slotStatus1 = createFreeSlotStatus(slotId1);\n+\t\tfinal SlotStatus slotStatus2 = createFreeSlotStatus(slotId2);\n+\n+\t\tfinal SlotStatus newSlotStatus2 = createAllocatedSlotStatus(slotId2);\n+\t\tfinal JobID jobId = newSlotStatus2.getJobID();\n+\n+\t\tfinal SlotReport slotReport1 = new SlotReport(Arrays.asList(slotStatus1, slotStatus2));\n+\t\tfinal SlotReport slotReport2 = new SlotReport(Arrays.asList(newSlotStatus2, slotStatus1));\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// check that we don't have any slots registered\n+\t\t\tassertEquals(0, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport1);\n+\n+\t\t\tDeclarativeTaskManagerSlot slot1 = slotTracker.getSlot(slotId1);\n+\t\t\tDeclarativeTaskManagerSlot slot2 = slotTracker.getSlot(slotId2);\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertSame(SlotState.FREE, slot1.getState());\n+\t\t\tassertSame(SlotState.FREE, slot2.getState());\n+\n+\t\t\tassertTrue(slotManager.reportSlotStatus(taskManagerConnection.getInstanceID(), slotReport2));\n+\n+\t\t\tassertEquals(2, slotManager.getNumberRegisteredSlots());\n+\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId1));\n+\t\t\tassertNotNull(slotTracker.getSlot(slotId2));\n+\n+\t\t\t// slotId2 should have been allocated for jobiD\n+\t\t\tassertEquals(jobId, slotTracker.getSlot(slotId2).getJobId());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that if a slot allocation times out we try to allocate another slot.\n+\t */\n+\t@Test\n+\tpublic void testSlotAllocationTimeout() throws Exception {\n+\t\tfinal CompletableFuture<Void> secondSlotRequestFuture = new CompletableFuture<>();\n+\t\tfinal AtomicInteger slotRequestsCount = new AtomicInteger();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = createTaskExecutorConnection(new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(ignored -> {\n+\t\t\t\tif (slotRequestsCount.getAndAdd(1) == 1) {\n+\t\t\t\t\tsecondSlotRequestFuture.complete(null);\n+\t\t\t\t} else {\n+\t\t\t\t\t// mimic RPC timeout\n+\t\t\t\t\treturn FutureUtils.completedExceptionally(new AskTimeoutException(\"timeout\"));\n+\t\t\t\t}\n+\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t})\n+\t\t\t.createTestingTaskExecutorGateway());\n+\t\tfinal SlotReport slotReport = createSlotReport(taskManagerConnection.getResourceID(), 2);\n+\n+\t\tfinal Executor mainThreadExecutor = TestingUtils.defaultExecutor();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tCompletableFuture.runAsync(() -> slotManager.registerTaskManager(taskManagerConnection, slotReport), mainThreadExecutor)\n+\t\t\t\t.thenRun(() -> slotManager.processResourceRequirements(createResourceRequirementsForSingleSlot()))\n+\t\t\t\t.get(5, TimeUnit.SECONDS);\n+\n+\t\t\t// a second request is only sent if the first request timed out\n+\t\t\tsecondSlotRequestFuture.get();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a slot allocation is retried if it times out on the task manager side.\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerSlotAllocationTimeoutHandling() throws Exception {\n+\t\tfinal JobID jobId = new JobID();\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot(jobId);\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture1 = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<Acknowledge> slotRequestFuture2 = new CompletableFuture<>();\n+\t\tfinal Iterator<CompletableFuture<Acknowledge>> slotRequestFutureIterator = Arrays.asList(slotRequestFuture1, slotRequestFuture2).iterator();\n+\t\tfinal ArrayBlockingQueue<SlotID> slotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\tslotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn slotRequestFutureIterator.next();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal ResourceID resourceId = ResourceID.generate();\n+\t\tfinal TaskExecutorConnection taskManagerConnection = new TaskExecutorConnection(resourceId, taskExecutorGateway);\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tslotManager.registerTaskManager(taskManagerConnection, slotReport);\n+\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot failedSlot = slotTracker.getSlot(firstSlotId);\n+\n+\t\t\t// let the first attempt fail --> this should trigger a second attempt\n+\t\t\tslotRequestFuture1.completeExceptionally(new SlotAllocationException(\"Test exception.\"));\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobId)), is(1));\n+\n+\t\t\t// the second attempt succeeds\n+\t\t\tslotRequestFuture2.complete(Acknowledge.get());\n+\n+\t\t\tfinal SlotID secondSlotId = slotIds.take();\n+\t\t\tassertThat(slotIds, is(empty()));\n+\n+\t\t\tDeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondSlotId);\n+\n+\t\t\tassertThat(slot.getState(), is(SlotState.ALLOCATED));\n+\t\t\tassertEquals(jobId, slot.getJobId());\n+\n+\t\t\tif (!failedSlot.getSlotId().equals(slot.getSlotId())) {\n+\t\t\t\tassertThat(failedSlot.getState(), is(SlotState.FREE));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a pending slot allocation is cancelled if a slot report indicates that the slot is already allocated\n+\t * by another job.\n+\t */\n+\t@Test\n+\tpublic void testSlotReportWithConflictingJobIdDuringSlotAllocation() throws Exception {\n+\t\tfinal ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n+\t\tfinal ArrayBlockingQueue<SlotID> requestedSlotIds = new ArrayBlockingQueue<>(2);\n+\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setRequestSlotFunction(FunctionUtils.uncheckedFunction(\n+\t\t\t\trequestSlotParameters -> {\n+\t\t\t\t\trequestedSlotIds.put(requestSlotParameters.f0);\n+\t\t\t\t\treturn new CompletableFuture<>();\n+\t\t\t\t}))\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection(taskExecutorGateway);\n+\t\tfinal ResourceID resourceId = taskExecutorConnection.getResourceID();\n+\n+\t\tfinal SlotID slotId1 = new SlotID(resourceId, 0);\n+\t\tfinal SlotID slotId2 = new SlotID(resourceId, 1);\n+\t\tfinal SlotReport slotReport = new SlotReport(Arrays.asList(createFreeSlotStatus(slotId1), createFreeSlotStatus(slotId2)));\n+\n+\t\tfinal ScheduledExecutor mainThreadExecutor = new ManuallyTriggeredScheduledExecutor();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setScheduledExecutor(mainThreadExecutor)\n+\t\t\t.build()) {\n+\n+\t\t\tslotManager.start(ResourceManagerId.generate(), mainThreadExecutor, new TestingResourceActionsBuilder().build());\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, slotReport);\n+\t\t\tslotManager.processResourceRequirements(resourceRequirements);\n+\n+\t\t\tfinal SlotID firstRequestedSlotId = requestedSlotIds.take();\n+\t\t\tfinal SlotID freeSlotId = firstRequestedSlotId.equals(slotId1) ? slotId2 : slotId1;\n+\n+\t\t\tfinal SlotReport newSlotReport = new SlotReport(Arrays.asList(createAllocatedSlotStatus(firstRequestedSlotId), createFreeSlotStatus(freeSlotId)));\n+\n+\t\t\tslotManager.reportSlotStatus(taskExecutorConnection.getInstanceID(), newSlotReport);\n+\n+\t\t\tfinal SlotID secondRequestedSlotId = requestedSlotIds.take();\n+\n+\t\t\tassertEquals(freeSlotId, secondRequestedSlotId);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that free slots which are reported as allocated won't be considered for fulfilling\n+\t * other pending slot requests.\n+\t *\n+\t * <p>See: FLINK-8505\n+\t */\n+\t@Test\n+\tpublic void testReportAllocatedSlot() throws Exception {\n+\t\tfinal ResourceID taskManagerId = ResourceID.generate();\n+\t\tfinal TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\tfinal TaskExecutorConnection taskExecutorConnection = new TaskExecutorConnection(taskManagerId, taskExecutorGateway);\n+\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// initially report a single slot as free\n+\t\t\tfinal SlotID slotId = new SlotID(taskManagerId, 0);\n+\t\t\tfinal SlotReport initialSlotReport = new SlotReport(createFreeSlotStatus(slotId));\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutorConnection, initialSlotReport);\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(equalTo(1)));\n+\n+\t\t\t// Now report this slot as allocated\n+\t\t\tfinal SlotStatus slotStatus = createAllocatedSlotStatus(slotId);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(slotStatus);\n+\n+\t\t\tslotManager.reportSlotStatus(\n+\t\t\t\ttaskExecutorConnection.getInstanceID(),\n+\t\t\t\tslotReport);\n+\n+\t\t\tfinal JobID jobId = new JobID();\n+\t\t\t// this resource requirement should not be fulfilled\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot(jobId);\n+\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tassertThat(slotTracker.getSlot(slotId).getJobId(), is(slotStatus.getJobID()));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that the SlotManager retries allocating a slot if the TaskExecutor#requestSlot call\n+\t * fails.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestFailure() throws Exception {\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tResourceRequirements requirements = createResourceRequirementsForSingleSlot();\n+\t\t\tslotManager.processResourceRequirements(requirements);\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);\n+\n+\t\t\t// fail first request\n+\t\t\tfirstManualSlotRequestResponse.completeExceptionally(new SlotAllocationException(\"Test exception\"));\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> secondRequest = requestSlotQueue.take();\n+\n+\t\t\tassertThat(secondRequest.f1, equalTo(firstRequest.f1));\n+\t\t\tassertThat(secondRequest.f0, equalTo(firstRequest.f0));\n+\n+\t\t\tsecondManualSlotRequestResponse.complete(Acknowledge.get());\n+\n+\t\t\tfinal DeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondRequest.f0);\n+\t\t\tassertThat(slot.getState(), equalTo(SlotState.ALLOCATED));\n+\t\t\tassertThat(slot.getJobId(), equalTo(secondRequest.f1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that pending request is removed if task executor reports a slot with the same job id.\n+\t */\n+\t@Test\n+\tpublic void testSlotRequestRemovedIfTMReportAllocation() throws Exception {\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\t\tfinal DefaultSlotTracker slotTracker = new DefaultSlotTracker();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.setSlotTracker(slotTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\tfinal JobID jobID = new JobID();\n+\t\t\tslotManager.processResourceRequirements(createResourceRequirementsForSingleSlot(jobID));\n+\n+\t\t\tfinal BlockingQueue<Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId>> requestSlotQueue = new ArrayBlockingQueue<>(1);\n+\t\t\tfinal BlockingQueue<CompletableFuture<Acknowledge>> responseQueue = new ArrayBlockingQueue<>(1);\n+\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t\t.setRequestSlotFunction(slotIDJobIDAllocationIDStringResourceManagerIdTuple6 -> {\n+\t\t\t\t\trequestSlotQueue.offer(slotIDJobIDAllocationIDStringResourceManagerIdTuple6);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn responseQueue.take();\n+\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Response queue was interrupted.\"));\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\t\tfinal ResourceID taskExecutorResourceId = ResourceID.generate();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection = new TaskExecutorConnection(taskExecutorResourceId, testingTaskExecutorGateway);\n+\t\t\tfinal SlotReport slotReport = new SlotReport(createFreeSlotStatus(new SlotID(taskExecutorResourceId, 0)));\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> firstManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(firstManualSlotRequestResponse);\n+\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection, slotReport);\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> firstRequest = requestSlotQueue.take();\n+\n+\t\t\tfinal CompletableFuture<Acknowledge> secondManualSlotRequestResponse = new CompletableFuture<>();\n+\t\t\tresponseQueue.offer(secondManualSlotRequestResponse);\n+\n+\t\t\t// fail first request\n+\t\t\tfirstManualSlotRequestResponse.completeExceptionally(new TimeoutException(\"Test exception to fail first allocation\"));\n+\n+\t\t\tfinal Tuple6<SlotID, JobID, AllocationID, ResourceProfile, String, ResourceManagerId> secondRequest = requestSlotQueue.take();\n+\n+\t\t\t// fail second request\n+\t\t\tsecondManualSlotRequestResponse.completeExceptionally(new SlotOccupiedException(\"Test exception\", new AllocationID(), jobID));\n+\n+\t\t\tassertThat(firstRequest.f1, equalTo(jobID));\n+\t\t\tassertThat(secondRequest.f1, equalTo(jobID));\n+\t\t\tassertThat(secondRequest.f0, equalTo(firstRequest.f0));\n+\n+\t\t\tfinal DeclarativeTaskManagerSlot slot = slotTracker.getSlot(secondRequest.f0);\n+\t\t\tassertThat(slot.getState(), equalTo(SlotState.ALLOCATED));\n+\t\t\tassertThat(slot.getJobId(), equalTo(firstRequest.f1));\n+\n+\t\t\tassertThat(slotManager.getNumberRegisteredSlots(), is(1));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getAcquiredResources(jobID)), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests notify the job manager of the allocations when the task manager is failed/killed.\n+\t */\n+\t@Test\n+\tpublic void testNotifyFailedAllocationWhenTaskManagerTerminated() throws Exception {\n+\t\tfinal ResourceTracker resourceTracker = new DefaultResourceTracker();\n+\n+\t\ttry (final DeclarativeSlotManager slotManager = createDeclarativeSlotManagerBuilder()\n+\t\t\t.setResourceTracker(resourceTracker)\n+\t\t\t.buildAndStartWithDirectExec()) {\n+\n+\t\t\t// register slot request for job1.\n+\t\t\tJobID jobId1 = new JobID();\n+\t\t\tslotManager.processResourceRequirements(createResourceRequirements(jobId1, 2));\n+\n+\t\t\t// create task-manager-1 with 2 slots.\n+\t\t\tfinal ResourceID taskExecutorResourceId1 = ResourceID.generate();\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway1 = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection1 = new TaskExecutorConnection(taskExecutorResourceId1, testingTaskExecutorGateway1);\n+\t\t\tfinal SlotReport slotReport1 = createSlotReport(taskExecutorResourceId1, 2);\n+\n+\t\t\t// register the task-manager-1 to the slot manager, this will trigger the slot allocation for job1.\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection1, slotReport1);\n+\n+\t\t\t// register slot request for job2.\n+\t\t\tJobID jobId2 = new JobID();\n+\t\t\tslotManager.processResourceRequirements(createResourceRequirements(jobId2, 2));\n+\n+\t\t\t// register slot request for job3.\n+\t\t\tJobID jobId3 = new JobID();\n+\t\t\tslotManager.processResourceRequirements(createResourceRequirements(jobId3, 1));\n+\n+\t\t\t// create task-manager-2 with 3 slots.\n+\t\t\tfinal ResourceID taskExecutorResourceId2 = ResourceID.generate();\n+\t\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway2 = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway();\n+\t\t\tfinal TaskExecutorConnection taskExecutionConnection2 = new TaskExecutorConnection(taskExecutorResourceId2, testingTaskExecutorGateway2);\n+\t\t\tfinal SlotReport slotReport2 = createSlotReport(taskExecutorResourceId2, 3);\n+\n+\t\t\t// register the task-manager-2 to the slot manager, this will trigger the slot allocation for job2 and job3.\n+\t\t\tslotManager.registerTaskManager(taskExecutionConnection2, slotReport2);\n+\n+\t\t\t// validate for job1.\n+\t\t\tslotManager.unregisterTaskManager(taskExecutionConnection1.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId1)), is(2));\n+\n+\t\t\t// validate the result for job2 and job3.\n+\t\t\tslotManager.unregisterTaskManager(taskExecutionConnection2.getInstanceID(), TEST_EXCEPTION);\n+\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId2)), is(2));\n+\t\t\tassertThat(getTotalResourceCount(resourceTracker.getMissingResources().get(jobId3)), is(1));", "originalCommit": "15d4c353c4c0a646b2bdf34bbedbd81359cb5b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b9288681085da65fc2c3f2742c898d13bf4af46", "url": "https://github.com/apache/flink/commit/4b9288681085da65fc2c3f2742c898d13bf4af46", "message": "clarify runtime + small optimization", "committedDate": "2020-10-14T06:30:44Z", "type": "forcePushed"}, {"oid": "2bd7bc9d905e743754842a9a1ffaa9cdcb781ffe", "url": "https://github.com/apache/flink/commit/2bd7bc9d905e743754842a9a1ffaa9cdcb781ffe", "message": "[hotfix][coordination] Remove unused SlotManager#unregisterTaskManagersAndReleaseResources", "committedDate": "2020-10-15T09:02:24Z", "type": "commit"}, {"oid": "f89b7098fb826ded9b17b0f2eb48c747451623d9", "url": "https://github.com/apache/flink/commit/f89b7098fb826ded9b17b0f2eb48c747451623d9", "message": "[FLINK-19306][coordination] ResourceManager supports declarative resource management", "committedDate": "2020-10-15T09:02:25Z", "type": "forcePushed"}, {"oid": "7bde2e9dfa1047d6fc79c7bf948e815bde056975", "url": "https://github.com/apache/flink/commit/7bde2e9dfa1047d6fc79c7bf948e815bde056975", "message": "[FLINK-19306][coordination] Add DeclarativeSlotManager", "committedDate": "2020-10-16T09:43:48Z", "type": "commit"}, {"oid": "a8eb317e44eb07959275437a44caa94f2d48d8ba", "url": "https://github.com/apache/flink/commit/a8eb317e44eb07959275437a44caa94f2d48d8ba", "message": "[FLINK-19306][coordination] ResourceManager supports declarative resource management", "committedDate": "2020-10-16T09:44:01Z", "type": "commit"}, {"oid": "a8eb317e44eb07959275437a44caa94f2d48d8ba", "url": "https://github.com/apache/flink/commit/a8eb317e44eb07959275437a44caa94f2d48d8ba", "message": "[FLINK-19306][coordination] ResourceManager supports declarative resource management", "committedDate": "2020-10-16T09:44:01Z", "type": "forcePushed"}]}