{"pr_number": 11351, "pr_title": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "pr_createdAt": "2020-03-09T06:13:21Z", "pr_url": "https://github.com/apache/flink/pull/11351", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406708848", "bodyText": "why the blocked partition would be pulled buffer since it was unavailable.", "author": "zhijiangW", "createdAt": "2020-04-10T10:56:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -179,6 +182,10 @@ public void release() {\n \t@Nullable\n \tBufferAndBacklog pollBuffer() {\n \t\tsynchronized (buffers) {\n+\t\t\tif (isBlockedByCheckpoint) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2Njk3Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407166977", "bodyText": "Because there are redundant notifications for local channel which means we may notify data available even when the downstream task in the poll loop. Maybe we fix it in another ticket if we think it's a problem.", "author": "wsry", "createdAt": "2020-04-12T08:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0OTQyMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408649420", "bodyText": "I see, it is for the case of local channel. I think we should supplement a test to cover this change if possible.", "author": "zhijiangW", "createdAt": "2020-04-15T07:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NDg0Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408654847", "bodyText": "Also it is better to give some descriptions here to explain this situation for better understanding.", "author": "zhijiangW", "createdAt": "2020-04-15T08:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMjY1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406712652", "bodyText": "it is ambiguous to distinguish the semantics between isAvailableWithoutCredit and isMoreAvailable if not back to see the implementation. I prefer to using dataAvailable and eventAvailable instead.\nAnd from the outside view, we only provide the isAvailable(int credit) method for hiding the details.", "author": "zhijiangW", "createdAt": "2020-04-10T11:11:11Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java", "diffHunk": "@@ -136,13 +136,13 @@ public void initializeState(ChannelStateReader stateReader) throws IOException,\n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isMoreAvailable;\n \t\tprivate final int buffersInBacklog;\n-\t\tprivate final boolean nextBufferIsEvent;\n+\t\tprivate final boolean isAvailableWithoutCredit;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406713682", "bodyText": "this change worths a separate hotfix commit", "author": "zhijiangW", "createdAt": "2020-04-10T11:14:59Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -883,16 +883,7 @@ private void configureCheckpointing() {\n \n \t\tCheckpointingMode mode = cfg.getCheckpointingMode();\n \n-\t\tboolean isExactlyOnce;\n-\t\tif (mode == CheckpointingMode.EXACTLY_ONCE) {\n-\t\t\tisExactlyOnce = true;\n-\t\t} else if (mode == CheckpointingMode.AT_LEAST_ONCE) {\n-\t\t\tisExactlyOnce = false;\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"Unexpected checkpointing mode. \" +\n-\t\t\t\t\"Did not expect there to be another checkpointing mode besides \" +\n-\t\t\t\t\"exactly-once or at-least-once.\");\n-\t\t}\n+\t\tboolean isExactlyOnce = cfg.isCheckpointingEnabled() && mode == CheckpointingMode.EXACTLY_ONCE;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2NzUzNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407167536", "bodyText": "I do something further in this round of fixup.", "author": "wsry", "createdAt": "2020-04-12T08:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2ODI1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408568257", "bodyText": "I move this to another PR.", "author": "wsry", "createdAt": "2020-04-15T04:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTMyMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406719321", "bodyText": "nit: Integer -> int", "author": "zhijiangW", "createdAt": "2020-04-10T11:33:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +325,13 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tprivate void unblockCheckpoint(Integer channelToUnblock) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTUyOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406719528", "bodyText": "I suggest renaming unblockCheckpoint to resumeConsumption to unify all the stacks.", "author": "zhijiangW", "createdAt": "2020-04-10T11:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxNjQ1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406816455", "bodyText": "channelIndexToInputChannel should be protected in sync by requestLock, because in code path this array would be modified by RPC thread via updateInputChannel. Although that method is never invoked in streaming job, it still has the potential risk to break this assumption.", "author": "zhijiangW", "createdAt": "2020-04-10T15:45:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +622,11 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void unblockCheckpoint(int channelIndex) {\n+\t\tchannelIndexToInputChannel[channelIndex].unblockCheckpoint();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxODI1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406818252", "bodyText": "nit: this argument seems redundant because it can be got from channelIndexToInputGate.length", "author": "zhijiangW", "createdAt": "2020-04-10T15:49:41Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -69,10 +79,14 @@\n \tCheckpointBarrierAligner(\n \t\t\tint totalNumberOfInputChannels,", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b3428a844d7cb5903f505686881be27970205f0", "url": "https://github.com/apache/flink/commit/3b3428a844d7cb5903f505686881be27970205f0", "message": "Fixup.", "committedDate": "2020-04-13T03:04:02Z", "type": "forcePushed"}, {"oid": "a0c7ff983988f27f5e47f4c71c8fb1ef28f8a24a", "url": "https://github.com/apache/flink/commit/a0c7ff983988f27f5e47f4c71c8fb1ef28f8a24a", "message": "Fixup.", "committedDate": "2020-04-13T03:39:24Z", "type": "forcePushed"}, {"oid": "9673d7ea41a3c7eb78a7e0d723c81086002dcc52", "url": "https://github.com/apache/flink/commit/9673d7ea41a3c7eb78a7e0d723c81086002dcc52", "message": "Fixup.", "committedDate": "2020-04-13T05:19:25Z", "type": "forcePushed"}, {"oid": "ad77253294c49bf4e967494c3dd520faee6f2033", "url": "https://github.com/apache/flink/commit/ad77253294c49bf4e967494c3dd520faee6f2033", "message": "Fixup.", "committedDate": "2020-04-13T12:47:11Z", "type": "forcePushed"}, {"oid": "1130ffe32e1f27241f5bf1bd42df0a7c4032a5e0", "url": "https://github.com/apache/flink/commit/1130ffe32e1f27241f5bf1bd42df0a7c4032a5e0", "message": "Fixup.", "committedDate": "2020-04-13T13:36:22Z", "type": "forcePushed"}, {"oid": "ad3964bfb00f5b3f93c933ff0d559d9df7d1991c", "url": "https://github.com/apache/flink/commit/ad3964bfb00f5b3f93c933ff0d559d9df7d1991c", "message": "Fixup.", "committedDate": "2020-04-13T13:48:17Z", "type": "forcePushed"}, {"oid": "b614959c881f48111893d798a8a0d28a4bbbf44e", "url": "https://github.com/apache/flink/commit/b614959c881f48111893d798a8a0d28a4bbbf44e", "message": "Fixup.", "committedDate": "2020-04-14T06:08:50Z", "type": "forcePushed"}, {"oid": "f2ba8a55cb8e441a1377b2cc00957e13e7445e47", "url": "https://github.com/apache/flink/commit/f2ba8a55cb8e441a1377b2cc00957e13e7445e47", "message": "Fixup.", "committedDate": "2020-04-15T03:50:00Z", "type": "forcePushed"}, {"oid": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "url": "https://github.com/apache/flink/commit/2462af49621e9f2ce29a26879a4b97d4ad752dc2", "message": "Fixup.", "committedDate": "2020-04-15T04:02:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NjE5Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408656192", "bodyText": "Unify this assert also for above isDataAvailableUnsafe?", "author": "zhijiangW", "createdAt": "2020-04-15T08:05:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -275,14 +283,24 @@ public PipelinedSubpartitionView createReadView(BufferAvailabilityListener avail\n \t\treturn readView;\n \t}\n \n-\tpublic boolean isAvailable() {\n+\tpublic boolean isAvailable(int numCreditsAvailable) {\n \t\tsynchronized (buffers) {\n-\t\t\treturn isAvailableUnsafe();\n+\t\t\tif (numCreditsAvailable > 0) {\n+\t\t\t\treturn isDataAvailableUnsafe();\n+\t\t\t}\n+\n+\t\t\treturn isEventAvailableUnsafe();\n \t\t}\n \t}\n \n-\tprivate boolean isAvailableUnsafe() {\n-\t\treturn flushRequested || getNumberOfFinishedBuffers() > 0;\n+\tprivate boolean isDataAvailableUnsafe() {\n+\t\treturn !isBlockedByCheckpoint && (flushRequested || getNumberOfFinishedBuffers() > 0);\n+\t}\n+\n+\tprivate boolean isEventAvailableUnsafe() {\n+\t\tassert Thread.holdsLock(buffers);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTQwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408731408", "bodyText": "nit: better to assert channelIndexToInputChannel[channelIndex] != null in advance and give some rich informations if exception.", "author": "zhijiangW", "createdAt": "2020-04-15T10:11:38Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +625,11 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void resumeConsumption(int channelIndex) {\n+\t\tchannelIndexToInputChannel[channelIndex].resumeConsumption();", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczNDY3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408734670", "bodyText": "@VisibleForTesting", "author": "zhijiangW", "createdAt": "2020-04-15T10:17:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -297,4 +312,8 @@ private void queueInputGate(InputGate inputGate) {\n \t\t\treturn Optional.of(inputGate);\n \t\t}\n \t}\n+\n+\tList<InputGate> getChannelIndexToInputGate() {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MTI3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408741272", "bodyText": "I guess this channel index change is irrelevant?", "author": "zhijiangW", "createdAt": "2020-04-15T10:29:56Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java", "diffHunk": "@@ -130,18 +130,18 @@ private void testRegisterTaskWithLimitedBuffers(int bufferPoolSize) throws Excep\n \t\tfinal SingleInputGate[] inputGates = new SingleInputGate[] {ig1, ig2, ig3, ig4};\n \n \t\tcreateRemoteInputChannel(ig4, 0, rp1, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig4, 0, rp2, connManager, network.getNetworkBufferPool());", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMDU0Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409430546", "bodyText": "yes, it is irrelevant.", "author": "wsry", "createdAt": "2020-04-16T09:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzM1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408743357", "bodyText": "nit: actually we can still retain testRecycleBuffer(boolean isBuffer) method and get the respective dataType before newBuffer here. Then we can avoid many above changes.", "author": "zhijiangW", "createdAt": "2020-04-15T10:33:45Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java", "diffHunk": "@@ -98,79 +98,79 @@ private static NetworkBuffer newBuffer(int length, int maxCapacity, boolean isBu\n \n \t@Test\n \tpublic void testDataBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testEventBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferTagAsEvent() {\n-\t\ttestTagAsEvent(true);\n+\t\ttestTagAsEvent(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferTagAsEvent() {\n-\t\ttestTagAsEvent(false);\n+\t\ttestTagAsEvent(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testTagAsEvent(boolean isBuffer) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n-\t\tbuffer.tagAsEvent();\n+\tprivate static void testTagAsEvent(Buffer.DataType dataType) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);\n+\t\tbuffer.setDataType(Buffer.DataType.EVENT_BUFFER);\n \t\tassertFalse(buffer.isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(true);\n+\t\ttestGetMemorySegment(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(false);\n+\t\ttestGetMemorySegment(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testGetMemorySegment(boolean isBuffer) {\n+\tprivate static void testGetMemorySegment(Buffer.DataType dataType) {\n \t\tfinal MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(1024);\n-\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, isBuffer);\n+\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, dataType);\n \t\tassertSame(segment, buffer.getMemorySegment());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetRecycler() {\n-\t\ttestGetRecycler(true);\n+\t\ttestGetRecycler(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetRecycler() {\n-\t\ttestGetRecycler(false);\n+\t\ttestGetRecycler(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testGetRecycler(boolean isBuffer) {\n+\tprivate static void testGetRecycler(Buffer.DataType dataType) {\n \t\tBufferRecycler recycler = MemorySegment::free;\n \n-\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, isBuffer, recycler);\n+\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, dataType, recycler);\n \t\tassertSame(recycler, dataBuffer.getRecycler());\n \t}\n \n \t@Test\n \tpublic void testDataBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(true);\n+\t\ttestRecycleBuffer(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(false);\n+\t\ttestRecycleBuffer(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n \t/**\n \t * Tests that {@link NetworkBuffer#recycleBuffer()} and {@link NetworkBuffer#isRecycled()} are\n \t * coupled and are also consistent with {@link NetworkBuffer#refCnt()}.\n \t */\n-\tprivate static void testRecycleBuffer(boolean isBuffer) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n+\tprivate static void testRecycleBuffer(Buffer.DataType dataType) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzYzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408743635", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T10:34:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java", "diffHunk": "@@ -341,16 +341,16 @@ private static void testReadableBytes(boolean isBuffer) {\n \n \t@Test\n \tpublic void testDataBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(true);\n+\t\ttestGetNioBufferReadable(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(false);\n+\t\ttestGetNioBufferReadable(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate void testGetNioBufferReadable(boolean isBuffer) {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NDE0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408744143", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T10:35:19Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java", "diffHunk": "@@ -219,20 +219,17 @@ private void testNettyMessageClientDecoding(\n \tprivate void addBufferResponse(\n \t\tList<NettyMessage> messages,\n \t\tInputChannelID inputChannelId,\n-\t\tboolean isBuffer,", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNTcwNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408905704", "bodyText": "\"and after that the buffered elements\" is not invalid", "author": "zhijiangW", "createdAt": "2020-04-15T14:53:20Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -146,7 +144,6 @@ public void testCheckpointBarriers() throws Exception {\n \n \t\t\t// now we should see the barrier and after that the buffered elements", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyOTA4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408929085", "bodyText": "It should be put before testHarness.waitForInputProcessing()", "author": "zhijiangW", "createdAt": "2020-04-15T15:23:40Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java", "diffHunk": "@@ -464,16 +452,16 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t\t// we should not yet see the barrier, only the two elements from non-blocked input\n \t\tTestHarnessUtil.assertOutputEquals(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n \n-\t\t// Now give a later barrier to all inputs, this should unblock the first channel,\n-\t\t// thereby allowing the two blocked elements through\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n+\t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n+\t\t// wait until the channel is unblocked\n+\t\ttestHarness.waitForInputProcessing();\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyOTY4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408929685", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T15:24:27Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java", "diffHunk": "@@ -369,16 +359,16 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t\t\t\texpectedOutput,\n \t\t\t\ttestHarness.getOutput());\n \n-\t\t// Now give a later barrier to all inputs, this should unblock the first channel,\n-\t\t// thereby allowing the two blocked elements through\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n+\t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n+\t\t// wait until the channel is unblocked\n+\t\ttestHarness.waitForInputProcessing();\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MDk5NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408960994", "bodyText": "This tests the?", "author": "zhijiangW", "createdAt": "2020-04-15T16:07:32Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -900,247 +580,185 @@ public void testMultiChannelAbortCheckpoint() throws Exception {\n \t\t\t\t// some buffers and a successful checkpoint\n \t\t\t/* 0 */ createBuffer(0), createBuffer(2), createBuffer(0),\n \t\t\t/* 3 */ createBarrier(1, 1), createBarrier(1, 2),\n-\t\t\t/* 5 */ createBuffer(2), createBuffer(1),\n-\t\t\t/* 7 */ createBarrier(1, 0),\n-\t\t\t/* 8 */ createBuffer(0), createBuffer(2),\n+\t\t\t/* 5 */ createBuffer(0),\n+\t\t\t/* 6 */ createBarrier(1, 0),\n+\t\t\t/* 7 */ createBuffer(0), createBuffer(2),\n \n \t\t\t\t// aborted on last barrier\n-\t\t\t/* 10 */ createBarrier(2, 0), createBarrier(2, 2),\n-\t\t\t/* 12 */ createBuffer(0), createBuffer(2),\n-\t\t\t/* 14 */ createCancellationBarrier(2, 1),\n+\t\t\t/* 9 */  createBarrier(2, 0), createBarrier(2, 2),\n+\t\t\t/* 11 */ createBuffer(1),\n+\t\t\t/* 12 */ createCancellationBarrier(2, 1),\n \n \t\t\t\t// successful checkpoint\n-\t\t\t/* 15 */ createBuffer(2), createBuffer(1),\n-\t\t\t/* 17 */ createBarrier(3, 1), createBarrier(3, 2), createBarrier(3, 0),\n+\t\t\t/* 13 */ createBuffer(2), createBuffer(1),\n+\t\t\t/* 15 */ createBarrier(3, 1), createBarrier(3, 2), createBarrier(3, 0),\n \n \t\t\t\t// abort on first barrier\n-\t\t\t/* 20 */ createBuffer(0), createBuffer(1),\n-\t\t\t/* 22 */ createCancellationBarrier(4, 1), createBarrier(4, 2),\n-\t\t\t/* 24 */ createBuffer(0),\n-\t\t\t/* 25 */ createBarrier(4, 0),\n+\t\t\t/* 18 */ createBuffer(0), createBuffer(1),\n+\t\t\t/* 20 */ createCancellationBarrier(4, 1), createBarrier(4, 2),\n+\t\t\t/* 22 */ createBuffer(2),\n+\t\t\t/* 23 */ createBarrier(4, 0),\n \n \t\t\t\t// another successful checkpoint\n-\t\t\t/* 26 */ createBuffer(0), createBuffer(1), createBuffer(2),\n-\t\t\t/* 29 */ createBarrier(5, 2), createBarrier(5, 1), createBarrier(5, 0),\n-\t\t\t/* 32 */ createBuffer(0), createBuffer(1),\n+\t\t\t/* 24 */ createBuffer(0), createBuffer(1), createBuffer(2),\n+\t\t\t/* 27 */ createBarrier(5, 2), createBarrier(5, 1), createBarrier(5, 0),\n+\t\t\t/* 30 */ createBuffer(0), createBuffer(1),\n \n \t\t\t\t// abort multiple cancellations and a barrier after the cancellations\n-\t\t\t/* 34 */ createCancellationBarrier(6, 1), createCancellationBarrier(6, 2),\n-\t\t\t/* 36 */ createBarrier(6, 0),\n+\t\t\t/* 32 */ createCancellationBarrier(6, 1), createCancellationBarrier(6, 2),\n+\t\t\t/* 34 */ createBarrier(6, 0),\n \n-\t\t\t/* 37 */ createBuffer(0)\n+\t\t\t/* 35 */ createBuffer(0)\n \t\t};\n-\t\tAbstractInvokable toNotify = mock(AbstractInvokable.class);\n+\t\tValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n \t\tinputGate = createBarrierBuffer(3, sequence, toNotify);\n \n \t\tlong startTs;\n \n \t\t// successful first checkpoint, with some aligned buffers\n+\t\ttoNotify.setNextExpectedCheckpointId(1);\n \t\tcheck(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tstartTs = System.nanoTime();\n \t\tcheck(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\tcheck(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n+\t\tInteger[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n-\t\tcheck(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tcheck(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// canceled checkpoint on last barrier\n-\t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(2L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tvalidateAlignmentTime(startTs, inputGate);\n \t\tcheck(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(2, toNotify.getLastCanceledCheckpointId());\n+\t\tInteger[] expectedUnblockedChannels2 = new Integer[] {0, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n+\t\tcheck(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// one more successful checkpoint\n-\t\tcheck(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(3L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\ttoNotify.setNextExpectedCheckpointId(3);\n+\t\tcheck(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n-\t\tcheck(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tInteger[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// this checkpoint gets immediately canceled\n-\t\tcheck(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(4L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n+\t\tcheck(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(4, toNotify.getLastCanceledCheckpointId());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n \t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n+\t\tInteger[] expectedUnblockedChannels4 = new Integer[] {2};\n+\t\tassertArrayEquals(expectedUnblockedChannels4, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n \t\t// some buffers\n+\t\tcheck(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tInteger[] expectedUnblockedChannels5 = new Integer[] {0};\n+\t\tassertArrayEquals(expectedUnblockedChannels5, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// a simple successful checkpoint\n \t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[32], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(5L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n-\t\tvalidateAlignmentTime(startTs, inputGate);\n-\t\tcheck(sequence[33], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\tcheck(sequence[37], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(6L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n-\t}\n-\n-\t@Test\n-\tpublic void testAbortViaQueuedBarriers() throws Exception {\n-\t\tBufferOrEvent[] sequence = {\n-\t\t\t\t// starting a checkpoint\n-\t\t\t/* 0 */ createBuffer(1),\n-\t\t\t/* 1 */ createBarrier(1, 1), createBarrier(1, 2),\n-\t\t\t/* 3 */ createBuffer(2), createBuffer(0), createBuffer(1),\n-\n-\t\t\t\t// queued barrier and cancellation barrier\n-\t\t\t/* 6 */ createCancellationBarrier(2, 2),\n-\t\t\t/* 7 */ createBarrier(2, 1),\n-\n-\t\t\t\t// some intermediate buffers (some queued)\n-\t\t\t/* 8 */ createBuffer(0), createBuffer(1), createBuffer(2),\n-\n-\t\t\t\t// complete initial checkpoint\n-\t\t\t/* 11 */ createBarrier(1, 0),\n-\n-\t\t\t\t// some buffers (none queued, since checkpoint is aborted)\n-\t\t\t/* 12 */ createBuffer(2), createBuffer(1), createBuffer(0),\n-\n-\t\t\t\t// final barrier of aborted checkpoint\n-\t\t\t/* 15 */ createBarrier(2, 0),\n-\n-\t\t\t\t// some more buffers\n-\t\t\t/* 16 */ createBuffer(0), createBuffer(1), createBuffer(2)\n-\t\t};\n-\t\tAbstractInvokable toNotify = mock(AbstractInvokable.class);\n-\t\tinputGate = createBarrierBuffer(3, sequence, toNotify);\n-\n-\t\tlong startTs;\n-\n-\t\tcheck(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// starting first checkpoint\n-\t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// finished first checkpoint\n-\t\tcheck(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\ttoNotify.setNextExpectedCheckpointId(5);\n+\t\tcheck(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n+\t\tInteger[] expectedUnblockedChannels6 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels6, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n \n-\t\tcheck(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// re-read the queued cancellation barriers\n-\t\tcheck(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(2L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n-\n-\t\tcheck(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\tcheck(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// no further alignment should have happened\n+\t\tcheck(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(6, toNotify.getLastCanceledCheckpointId());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n \t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n+\t\tInteger[] expectedUnblockedChannels7 = new Integer[] {0};\n+\t\tassertArrayEquals(expectedUnblockedChannels7, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n-\t\t// no further checkpoint (abort) notifications\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(anyLong(),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n+\t\tassertEquals(3, toNotify.getTriggerCheckpointCounter());\n+\t\tassertEquals(3, toNotify.getAbortCheckpointCounter());\n \t}\n \n \t/**\n-\t * This tests the where a replay of queued checkpoint barriers meets\n-\t * a canceled checkpoint.\n+\t * This tests the where a checkpoint barriers meets a canceled checkpoint.", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MzQ1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408963455", "bodyText": "nit: triggeredCheckpointCounter, abortedCheckpointCounter", "author": "zhijiangW", "createdAt": "2020-04-15T16:11:05Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -1284,8 +902,11 @@ private static void validateAlignmentTime(long alignmentStartTimestamp, Checkpoi\n \t */\n \tprivate static class ValidatingCheckpointHandler extends AbstractInvokable {\n \n+\t\tprivate CheckpointFailureReason failureReason;\n+\t\tprivate long lastCanceledCheckpointId = -1L;\n \t\tprivate long nextExpectedCheckpointId = -1L;\n-\t\tprivate long lastReportedBytesBufferedInAlignment = -1;\n+\t\tprivate long triggerCheckpointCounter = 0;", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3Njc0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408976743", "bodyText": "nit: formatting  only make the argument getConfiguration().isExactlyOnceCheckpointMode() as as separate line", "author": "zhijiangW", "createdAt": "2020-04-15T16:31:31Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java", "diffHunk": "@@ -89,7 +89,8 @@ public void triggerCheckpoint(long checkpointId) throws FlinkException {\n \t\t\t\t\t// TODO - we need to see how to derive those. We should probably not encode this in the\n \t\t\t\t\t// TODO -   source's trigger message, but do a handshake in this task between the trigger\n \t\t\t\t\t// TODO -   message from the master, and the source's trigger notification\n-\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation();\n+\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI1OTkwOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409259909", "bodyText": "it is no need to call finish for this test, otherwise we also need to assert EndofPartitionEvent below.", "author": "zhijiangW", "createdAt": "2020-04-16T03:29:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.finish();", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDI4NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409260284", "bodyText": "why we can not verify the real event class here and pass null for all the events, otherwise it is no need to introduce this expectedEventClass argument in assertNextEvent", "author": "zhijiangW", "createdAt": "2020-04-16T03:31:13Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.finish();\n+\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTgwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409461808", "bodyText": "The expectedEventClass is never used currently, and if we want to check the event class, we need to create a real event, however, we use fake events only.", "author": "wsry", "createdAt": "2020-04-16T10:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MTMxMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409261313", "bodyText": "I guess we also need to supplement the tests for covering the blocked subpartition for flush operation.", "author": "zhijiangW", "createdAt": "2020-04-16T03:35:32Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mjg4Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409262886", "bodyText": "Unify the same naming for expectedIsMoreAvailableWithoutCredit as below expectedIsEventAvailable? also for expectedIsMoreAvailable", "author": "zhijiangW", "createdAt": "2020-04-16T03:42:06Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -369,7 +388,7 @@ static void assertNextBuffer(\n \t\t\t\tnull,\n \t\t\t\texpectedIsMoreAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedNextBufferIsEvent,\n+\t\t\t\texpectedIsMoreAvailableWithoutCredit,", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2NDYzNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409264636", "bodyText": "typo adequate?", "author": "zhijiangW", "createdAt": "2020-04-16T03:49:10Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java", "diffHunk": "@@ -381,6 +387,47 @@ public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {\n \t\tassertNull(channel.readOutbound());\n \t}\n \n+\t/**\n+\t * Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},\n+\t * verifying the reader would be enqueued in the pipeline after resuming data consumption if there\n+\t * are credit and data available.\n+\t */\n+\t@Test\n+\tpublic void testEnqueueReaderByResumingConsumption() throws Exception {\n+\t\tPipelinedSubpartition subpartition = PipelinedSubpartitionTest.createPipelinedSubpartition();\n+\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.DATA_BUFFER));\n+\n+\t\tBufferAvailabilityListener bufferAvailabilityListener = new NoOpBufferAvailablityListener();\n+\t\tPipelinedSubpartitionView view = subpartition.createReadView(bufferAvailabilityListener);\n+\t\tResultPartitionProvider partitionProvider = (partitionId, index, availabilityListener) -> view;\n+\n+\t\tInputChannelID receiverId = new InputChannelID();\n+\t\tPartitionRequestQueue queue = new PartitionRequestQueue();\n+\t\tCreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue);\n+\t\tEmbeddedChannel channel = new EmbeddedChannel(queue);\n+\n+\t\treader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0);\n+\t\tqueue.notifyReaderCreated(reader);\n+\t\t// we have adequate credits", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MTUxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409471511", "bodyText": "There seems no problem?", "author": "wsry", "createdAt": "2020-04-16T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2NDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTQ4MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409271481", "bodyText": "is it possible to call inputChannel#resumeConsumption instead of client.resumeConsumption, then we can further verify the interaction between input channel and client.", "author": "zhijiangW", "createdAt": "2020-04-16T04:16:54Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java", "diffHunk": "@@ -142,6 +147,45 @@ public void testDoublePartitionRequest() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testResumeConsumption() throws Exception {\n+\t\tfinal CreditBasedPartitionRequestClientHandler handler = new CreditBasedPartitionRequestClientHandler();\n+\t\tfinal EmbeddedChannel channel = new EmbeddedChannel(handler);\n+\t\tfinal PartitionRequestClient client = createPartitionRequestClient(channel, handler);\n+\n+\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(10, 32, 2);\n+\t\tfinal SingleInputGate inputGate = createSingleInputGate(1);\n+\t\tfinal RemoteInputChannel inputChannel = createRemoteInputChannel(inputGate, client, networkBufferPool);\n+\n+\t\ttry {\n+\t\t\tclient.resumeConsumption(inputChannel);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2433d3d69e6e18b138a8672259da42bf619e994e", "url": "https://github.com/apache/flink/commit/2433d3d69e6e18b138a8672259da42bf619e994e", "message": "Fixup.", "committedDate": "2020-04-16T14:12:56Z", "type": "forcePushed"}, {"oid": "57564cc22bdc5fb9055a9896fce66bc0305b4e31", "url": "https://github.com/apache/flink/commit/57564cc22bdc5fb9055a9896fce66bc0305b4e31", "message": "Fixup.", "committedDate": "2020-04-16T14:24:39Z", "type": "forcePushed"}, {"oid": "3f566d7286ffa73fb26b729d76ccb5129ca3f974", "url": "https://github.com/apache/flink/commit/3f566d7286ffa73fb26b729d76ccb5129ca3f974", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T06:43:22Z", "type": "forcePushed"}, {"oid": "a11d205402403f51c637b6605e7e97ee98e37151", "url": "https://github.com/apache/flink/commit/a11d205402403f51c637b6605e7e97ee98e37151", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T07:09:34Z", "type": "forcePushed"}, {"oid": "f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "url": "https://github.com/apache/flink/commit/f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T08:31:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzNjEyNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r412036125", "bodyText": "nit: final", "author": "zhijiangW", "createdAt": "2020-04-21T09:43:29Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java", "diffHunk": "@@ -44,16 +45,16 @@\n  */\n public class EventSerializerTest {\n \n+\tprivate AbstractEvent[] events = {", "originalCommit": "f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da21a760104d6786dcfce33022bd3fd8ce659218", "url": "https://github.com/apache/flink/commit/da21a760104d6786dcfce33022bd3fd8ce659218", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of sender side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-21T13:18:31Z", "type": "forcePushed"}, {"oid": "0058feb1dfb56caaf7e4322948f5b9c05782f8c1", "url": "https://github.com/apache/flink/commit/0058feb1dfb56caaf7e4322948f5b9c05782f8c1", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-22T07:09:15Z", "type": "forcePushed"}, {"oid": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "url": "https://github.com/apache/flink/commit/725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "message": "[hotfix][checkpointing] Make CheckpointBarrierUnaligner#processEndOfPartition always return false\n\nFor unaligned checkpoint, no buffer is stored in BufferStorage so CheckpointBarrierUnaligner#processEndOfPartition should always return false.\n\nThis closes #11351.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "8d9b20a00c83e8c65904dd9dfc179298481f7759", "url": "https://github.com/apache/flink/commit/8d9b20a00c83e8c65904dd9dfc179298481f7759", "message": "[hotfix] Add more information to CheckpointCoordinatorConfiguration#toString\n\nThis closes #11351.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "d05bfb1ccc492a22a738da35135e372f7f2c48dc", "url": "https://github.com/apache/flink/commit/d05bfb1ccc492a22a738da35135e372f7f2c48dc", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "d05bfb1ccc492a22a738da35135e372f7f2c48dc", "url": "https://github.com/apache/flink/commit/d05bfb1ccc492a22a738da35135e372f7f2c48dc", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-27T02:42:56Z", "type": "forcePushed"}, {"oid": "715889a35cfcc3aaf1b17f39dadaa86f755cc75d", "url": "https://github.com/apache/flink/commit/715889a35cfcc3aaf1b17f39dadaa86f755cc75d", "message": "POC implementation.", "committedDate": "2020-03-09T06:45:35Z", "type": "forcePushed"}, {"oid": "5e0b21e2f80bc5c36a535f551b4092d65ecd5b2d", "url": "https://github.com/apache/flink/commit/5e0b21e2f80bc5c36a535f551b4092d65ecd5b2d", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T11:46:38Z", "type": "forcePushed"}, {"oid": "390cd7b46787bfc633f9389b9ad58e49e6ac5dde", "url": "https://github.com/apache/flink/commit/390cd7b46787bfc633f9389b9ad58e49e6ac5dde", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T12:44:46Z", "type": "forcePushed"}, {"oid": "72e2d899c555775ea9c91a34133ea53c1d30b476", "url": "https://github.com/apache/flink/commit/72e2d899c555775ea9c91a34133ea53c1d30b476", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T12:59:36Z", "type": "forcePushed"}, {"oid": "75745bb56c70eac5bbb2e5300097bb6a8c7bb59d", "url": "https://github.com/apache/flink/commit/75745bb56c70eac5bbb2e5300097bb6a8c7bb59d", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T01:08:40Z", "type": "forcePushed"}, {"oid": "548b22258f5e87fd53b45c7f4bb6de40bfd4e6d2", "url": "https://github.com/apache/flink/commit/548b22258f5e87fd53b45c7f4bb6de40bfd4e6d2", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T01:35:08Z", "type": "forcePushed"}, {"oid": "b797d2725d26d67674de8339e6d2714cf5ae98f3", "url": "https://github.com/apache/flink/commit/b797d2725d26d67674de8339e6d2714cf5ae98f3", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T05:11:46Z", "type": "forcePushed"}, {"oid": "9dba52d31972da8bc11d85737443253f764c6508", "url": "https://github.com/apache/flink/commit/9dba52d31972da8bc11d85737443253f764c6508", "message": "Fix.", "committedDate": "2020-03-12T05:36:06Z", "type": "forcePushed"}, {"oid": "00bb983974bea0bed9158d48df1731e16f946495", "url": "https://github.com/apache/flink/commit/00bb983974bea0bed9158d48df1731e16f946495", "message": "Fix.", "committedDate": "2020-03-12T08:09:13Z", "type": "forcePushed"}, {"oid": "5397788869b81d0748153365bca510869fcb517a", "url": "https://github.com/apache/flink/commit/5397788869b81d0748153365bca510869fcb517a", "message": "Fix.", "committedDate": "2020-03-12T10:52:37Z", "type": "forcePushed"}, {"oid": "9179aab74eeaf80ea30c0894f3e5a0171338baed", "url": "https://github.com/apache/flink/commit/9179aab74eeaf80ea30c0894f3e5a0171338baed", "message": "Fix.", "committedDate": "2020-03-12T15:25:59Z", "type": "forcePushed"}, {"oid": "b55b4758c11950f6f1458ce707159fa0aca49311", "url": "https://github.com/apache/flink/commit/b55b4758c11950f6f1458ce707159fa0aca49311", "message": "Fix.", "committedDate": "2020-03-12T15:51:06Z", "type": "forcePushed"}, {"oid": "7c8f2ea9149fda45a6185323d2ed2312f2999acb", "url": "https://github.com/apache/flink/commit/7c8f2ea9149fda45a6185323d2ed2312f2999acb", "message": "Fix.", "committedDate": "2020-03-13T01:24:56Z", "type": "forcePushed"}, {"oid": "a90d241233087fe4f3aa753dbf1fe993a4724b3b", "url": "https://github.com/apache/flink/commit/a90d241233087fe4f3aa753dbf1fe993a4724b3b", "message": "Fix.", "committedDate": "2020-03-13T04:32:55Z", "type": "forcePushed"}, {"oid": "cd89aaad78cc8d5aaa3189725c8a3a183be23c2c", "url": "https://github.com/apache/flink/commit/cd89aaad78cc8d5aaa3189725c8a3a183be23c2c", "message": "Fix.", "committedDate": "2020-03-13T06:55:10Z", "type": "forcePushed"}, {"oid": "037afa2d30072bcb7822ec2933aac81b7e60a52b", "url": "https://github.com/apache/flink/commit/037afa2d30072bcb7822ec2933aac81b7e60a52b", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-18T18:41:11Z", "type": "forcePushed"}, {"oid": "eff786e8e89a13d4603daefdbcf841b9bfccf9f5", "url": "https://github.com/apache/flink/commit/eff786e8e89a13d4603daefdbcf841b9bfccf9f5", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T01:26:32Z", "type": "forcePushed"}, {"oid": "659fc3566aa008d1b688d189049add6944fed460", "url": "https://github.com/apache/flink/commit/659fc3566aa008d1b688d189049add6944fed460", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T03:15:10Z", "type": "forcePushed"}, {"oid": "7345f2aaac30d38cde01e0e84e7f127287d5c0c6", "url": "https://github.com/apache/flink/commit/7345f2aaac30d38cde01e0e84e7f127287d5c0c6", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T06:16:04Z", "type": "forcePushed"}, {"oid": "e068c1bff7d95844e1e24612abb1e66fc51c7925", "url": "https://github.com/apache/flink/commit/e068c1bff7d95844e1e24612abb1e66fc51c7925", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T07:59:49Z", "type": "forcePushed"}, {"oid": "5027d78272e7ff61fb81c07dd3b14da7db0b953d", "url": "https://github.com/apache/flink/commit/5027d78272e7ff61fb81c07dd3b14da7db0b953d", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T14:55:53Z", "type": "forcePushed"}, {"oid": "618ee8eece00841d86c0566c6e7c68cf0579be9e", "url": "https://github.com/apache/flink/commit/618ee8eece00841d86c0566c6e7c68cf0579be9e", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-21T13:27:18Z", "type": "forcePushed"}, {"oid": "0a9fd0d3530d2d504d8b535d0892a34a5d2d5e07", "url": "https://github.com/apache/flink/commit/0a9fd0d3530d2d504d8b535d0892a34a5d2d5e07", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T05:06:03Z", "type": "forcePushed"}, {"oid": "cd385c55e9dc111a061e19e2387f2ae9ce21369e", "url": "https://github.com/apache/flink/commit/cd385c55e9dc111a061e19e2387f2ae9ce21369e", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T05:21:13Z", "type": "forcePushed"}, {"oid": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "url": "https://github.com/apache/flink/commit/395bc07a4fca4e2f3ee8b96b4ef8054595227157", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T08:52:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwNjk1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396206957", "bodyText": "This change is irrelated?\nIf so, I suggest not making this change.", "author": "zhijiangW", "createdAt": "2020-03-23T04:23:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +309,13 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\tcheckState(!isBlockedByCheckpoint, \"Channel blocked by checkpoint.\");\n+\n+\t\t\tint numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\tnotifyAvailable = numAddedBuffers > 0 && unannouncedCredit++ == 0;\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (notifyAvailable) {", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxMTEyMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396211120", "bodyText": "inputChannel ->  optionalInputChannel , irrelated changes, should revert.", "author": "zhijiangW", "createdAt": "2020-03-23T04:45:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -507,20 +510,27 @@ public boolean isFinished() {\n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> optionalInputChannel = getChannel(blocking);", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Njk5Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396356997", "bodyText": "name conflicts with the flowing InputChannel", "author": "wsry", "createdAt": "2020-03-23T10:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxMTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2NDc2NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396264764", "bodyText": "It is better to reuse the blocked states from CheckpointBarrierAligner if possible to avoid managing it duplicated in another place and causing potential inconsistency.", "author": "zhijiangW", "createdAt": "2020-03-23T07:59:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -140,6 +141,8 @@\n \t/** Channels, which notified this input gate about available data. */\n \tprivate final ArrayDeque<InputChannel> inputChannelsWithData = new ArrayDeque<>();\n \n+\tprivate final HashMap<Integer, InputChannel> channelsBlockedByCheckpoint = new HashMap<>();", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2OTY0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396269643", "bodyText": "It is tricky to make zero credit has a special meaning, and we also break the previous assumption without negative credits.\nI think it might be better to define a separate message to describe the semantic of barrier alignment to unblock upstream side. Then the credit is always positive to be consistent as before, and we only define another blocked state on upstream side to control the buffer transport besides with positive credits.", "author": "zhijiangW", "createdAt": "2020-03-23T08:10:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -416,7 +452,18 @@ public int getUnannouncedCredit() {\n \t * @return Credit which was not announced to the sender yet.\n \t */\n \tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tint credit = unannouncedCredit;\n+\t\t\tunannouncedCredit = 0;\n+\t\t\tif (credit == 0) {", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0603121a692db91a39416b27977843bb7c7db0a7", "url": "https://github.com/apache/flink/commit/0603121a692db91a39416b27977843bb7c7db0a7", "message": "Fixup.", "committedDate": "2020-03-23T10:52:09Z", "type": "forcePushed"}, {"oid": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "url": "https://github.com/apache/flink/commit/47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "message": "Fixup.", "committedDate": "2020-03-23T14:16:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA1MDUzNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397050537", "bodyText": "It seems a bit strange to see this field in BufferConsumer.\nAfter discussing offline, we introduce another enum type for identifying the specific AbstractEvent instance inside Buffer without deserialization. Then the required components can judge the type from buffer to make some improvements. At the beginning we only focus on CheckpointBarrier event and make others unknown.", "author": "zhijiangW", "createdAt": "2020-03-24T10:32:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java", "diffHunk": "@@ -44,6 +44,8 @@\n \n \tprivate int currentReaderPosition;\n \n+\tprivate final boolean isExactlyOnceBarrier;", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzgxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397113817", "bodyText": "inputChannels are accessed via synchronized requestLock in other places. Do we need the sync here?", "author": "zhijiangW", "createdAt": "2020-03-24T12:27:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +628,13 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tfor (InputChannel inputChannel: inputChannels.values()) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0MzA3NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398343075", "bodyText": "I have removed this code", "author": "wsry", "createdAt": "2020-03-26T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598435", "bodyText": "There are five paths for calling notifyCheckpointCompletedOrCanceled in this method, then it is a bit hard to trace every path and analysis whether it needs this call. In contrast, we can analysis this issue from a reverse way to make it easy. E.g. only two paths (begin new alignment and under current alignment) do not need the notify call, so we can make a boolean tag only for these two paths, and handle the unified notification at the end of this method.\nIn detail, we can define a boolean shouldNotify = true at the beginning of this method and also set the notifyCheckpointId = currentCheckpointId. Then tag this boolean as false in below two paths, and finally call notifyCheckpointCompletedOrCanceled at the end of this method if shouldNotify = true.", "author": "zhijiangW", "createdAt": "2020-03-25T04:05:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -100,21 +105,20 @@ public boolean isBlocked(int channelIndex) {\n \t}\n \n \t@Override\n-\tpublic boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception {\n+\tpublic void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {\n \t\tfinal long barrierId = receivedBarrier.getId();\n \n \t\t// fast path for single channel cases\n \t\tif (totalNumberOfInputChannels == 1) {\n \t\t\tif (barrierId > currentCheckpointId) {\n \t\t\t\t// new checkpoint\n \t\t\t\tcurrentCheckpointId = barrierId;\n-\t\t\t\tnotifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);\n+\t\t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n \t\t\t}\n-\t\t\treturn false;\n+\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODg4Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598886", "bodyText": "For the case of totalNumberOfInputChannels == 1, it should be handled separately for fast path. Then I suggest moving this path as a separate method to make #processBarrier seem shorter, and also it can be reused by below processCancellationBarrier if providing a function argument.", "author": "zhijiangW", "createdAt": "2020-03-25T04:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0NDkwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398344908", "bodyText": "I have changed the implementation", "author": "wsry", "createdAt": "2020-03-26T06:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODk4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598985", "bodyText": "we can reduce this path for simple by https://github.com/apache/flink/pull/11351/files#r397598435", "author": "zhijiangW", "createdAt": "2020-03-25T04:08:29Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -140,14 +144,15 @@ else if (barrierId > currentCheckpointId) {\n \n \t\t\t\t// abort the current checkpoint\n \t\t\t\treleaseBlocksAndResetBarriers();\n-\t\t\t\tcheckpointAborted = true;\n+\t\t\t\tnotifyCheckpointCompletedOrCanceled(currentCheckpointId);\n \n \t\t\t\t// begin a new checkpoint\n \t\t\t\tbeginNewAlignment(barrierId, channelIndex, receivedBarrier.getTimestamp());\n \t\t\t}\n \t\t\telse {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTA2OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599068", "bodyText": "we can also reduce this path for simple by https://github.com/apache/flink/pull/11351/files#r397598435", "author": "zhijiangW", "createdAt": "2020-03-25T04:08:46Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -157,7 +162,8 @@ else if (barrierId > currentCheckpointId) {\n \t\telse {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTQ3OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599479", "bodyText": "Refer to this idea https://github.com/apache/flink/pull/11351/files#r397598435, we can also avoid calling notifyCheckpointCompletedOrCanceled in five paths.", "author": "zhijiangW", "createdAt": "2020-03-25T04:10:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -214,7 +219,7 @@ protected void onBarrier(int channelIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic boolean processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n+\tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTY5NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599694", "bodyText": "nit: should be private method.", "author": "zhijiangW", "createdAt": "2020-03-25T04:11:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +326,16 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {\n+\t\tinputGates.add(checkNotNull(inputGate));\n+\t}\n+\n+\tpublic void notifyCheckpointCompletedOrCanceled(long checkpointId) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMTgwOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397601809", "bodyText": "We might need to adjust this method naming, because it is not indicating for the checkpoint really completed (the async checkpoint process). notifyUnblockInputChannels?", "author": "zhijiangW", "createdAt": "2020-03-25T04:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397600950", "bodyText": "I am considering the call sequence for notifyCheckpoint and notifyCheckpointCompletedOrCanceled.\nnotifyCheckpoint might take some time for local IO operations I guess. If we can notifyCheckpointCompletedOrCanceled beforehand to unblock upstream to send data, then it might get benefit for performance.", "author": "zhijiangW", "createdAt": "2020-03-25T04:16:56Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -172,10 +178,9 @@ else if (barrierId > currentCheckpointId) {\n \t\t\t}\n \n \t\t\treleaseBlocksAndResetBarriers();\n-\t\t\tnotifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);\n-\t\t\treturn true;\n+\t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n+\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0Njk5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398346990", "bodyText": "As suggested above, I move notify to the end of this method which unifies the notify process", "author": "wsry", "createdAt": "2020-03-26T06:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM1OTExMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398359110", "bodyText": "As suggested above, I have moved the notify to the end of the method to unify the notifications.", "author": "wsry", "createdAt": "2020-03-26T07:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMjUyOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397602529", "bodyText": "Another option is passing inputGate in constructor instead to avoid exposing another methods outside. Otherwise in tests if someone constructs the CheckpointBarrierAligner, but forgets to register gate afterwards, then the gates are actually touched in the internal related processes to bring unexpected behaviors.", "author": "zhijiangW", "createdAt": "2020-03-25T04:24:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +326,16 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzE2Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397603167", "bodyText": "we can avoid introducing the interface method and this empty implementation by https://github.com/apache/flink/pull/11351/files#r397602529", "author": "zhijiangW", "createdAt": "2020-03-25T04:26:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java", "diffHunk": "@@ -230,8 +227,7 @@ public long getAlignmentDurationNanos() {\n \t}\n \n \t@Override\n-\tpublic void checkpointSizeLimitExceeded(long maxBufferedBytes) throws Exception {\n-\t\tthrow new UnsupportedOperationException(\"This should never happened as this class doesn't block any data\");\n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNTg3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397605870", "bodyText": "We can also avoid this synchronized after removing states by #11351 (comment)", "author": "zhijiangW", "createdAt": "2020-03-25T04:40:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -397,6 +409,17 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tsynchronized (bufferQueue) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjAzNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397606034", "bodyText": "if (isBlockedByCheckpoint(checkpointId)) {\n    notifyResumeConsumption()\n}", "author": "zhijiangW", "createdAt": "2020-03-25T04:40:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -397,6 +409,17 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tif (!isBlockedByCheckpoint(checkpointId)) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxMDUxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397610517", "bodyText": "I considered discarding these two states in InputChannel level to unify reuse the states inside CheckpointBarrierAligner.\nRegarding the RemoteInputChannel case, these two states are used for avoiding unnecessary notification for upstream side if the unblock is triggered by other channels.\nOne possible option is to pass the boolean array of blocked channelsfromCheckpointBarrierAlignerwhile callingnotifyCheckpointCompletedOrCanceled. In CheckpointedInputGateandUnionInputGatelevel, they can also  pass the maintainedoffsetIndexto dedicatedSingleInputGate, then the single gate can judge whether the respective RemoteInputChannel` is actually blocked or not to notify the upstream side if necessary.\nRegarding the LocalInputChannel case, we can consider it separately.", "author": "zhijiangW", "createdAt": "2020-03-25T05:01:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -56,6 +57,10 @@\n \n \tprotected final SingleInputGate inputGate;\n \n+\tprotected long currentCheckpointId = -1;\n+\n+\tprotected ChannelState channelState = ChannelState.CONSUMING;", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxODI2Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397618266", "bodyText": "For the case of LocalInputChannel, the current problem is that when the subparition view notifies the data available, then the respective local channel would be added into gate data queue. When the gate pools buffer from such local channel, it should be aware whether this local channel was already blocked by CheckpointBarrierAligner or not. If blocked, it should not return this buffer to upper component to avoid caching.\nAnother option to solve this issue is to avoid adding local channel into gate queue via tagging the blocked state in ResultSubpartitionView. We already added this state in NetworkSequenceViewReader for remote channel. If we can migrate this state into ResultSubpartitionView level, then we can make reuse of this state for both remote and local channels. And I think it should be transparent to do the similar things either in  NetworkSequenceViewReader or ResultSubpartitionView.", "author": "zhijiangW", "createdAt": "2020-03-25T05:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxMDUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY0Njc1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397646752", "bodyText": "This can be removed if removing states by #11351 (comment)", "author": "zhijiangW", "createdAt": "2020-03-25T07:14:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -419,6 +442,17 @@ public int getAndResetUnannouncedCredit() {\n \t\treturn unannouncedCredit.getAndSet(0);\n \t}\n \n+\t/**\n+\t * Unblocks this channel from exactly once checkpoint.\n+\t */\n+\tpublic void unblockChannel() {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MDQ0MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397650441", "bodyText": "It should make use of existing writeAndFlushNextMessageIfPossible for writing any messages on downstream side, otherwise we might miss some conditions such as if (channelError.get() != null || !channel.isWritable())  inside previous writeAndFlushNextMessageIfPossible. And also bring much overhead work for maintaining two different paths (e.g. for failure handling).\nWe can refactor the existing inputChannelsWithCredit as a more general outbound message queue to insert both AddCredit and ResumeConsumption messages. And define an abstract ClientOutboundMessage with buildMessage method to be implemented by AddCredit and ResumeConsumption separately during writeAndFlushNextMessageIfPossible.", "author": "zhijiangW", "createdAt": "2020-03-25T07:25:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -193,6 +199,16 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exc\n \t\t\tif (triggerWrite) {\n \t\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n \t\t\t}\n+\t\t} else if (msg instanceof ResumeConsumptionEvent) {\n+\t\t\tRemoteInputChannel inputChannel = ((ResumeConsumptionEvent) msg).inputChannel;\n+\t\t\tinputChannel.unblockChannel();\n+\t\t\tResumeConsumption resumeConsumption = new ResumeConsumption(inputChannel.getInputChannelId());\n+\n+\t\t\tctx.channel().writeAndFlush(resumeConsumption).addListener((ChannelFutureListener) channelFuture -> {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59b1e101500b638019f58c27daa18b19ebcbaa3b", "url": "https://github.com/apache/flink/commit/59b1e101500b638019f58c27daa18b19ebcbaa3b", "message": "Fixup.", "committedDate": "2020-03-26T08:38:10Z", "type": "forcePushed"}, {"oid": "f86372054c1c4724b8dabc8d06e369475e64ac29", "url": "https://github.com/apache/flink/commit/f86372054c1c4724b8dabc8d06e369475e64ac29", "message": "Fixup.", "committedDate": "2020-03-26T10:43:25Z", "type": "forcePushed"}, {"oid": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "url": "https://github.com/apache/flink/commit/ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "message": "Fixup.", "committedDate": "2020-03-26T15:48:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5NTEwMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402795100", "bodyText": "It seems not clear whether the passed dataType must be an event type or not. So the method naming with argument seems not consistent, i prefer to naming the method as tagDataType or setDataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:45:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -55,9 +57,9 @@\n \tboolean isBuffer();\n \n \t/**\n-\t * Tags this buffer to represent an event.\n+\t * Tags this buffer to represent an event of the given type.\n \t */\n-\tvoid tagAsEvent();\n+\tvoid tagAsEvent(DataType dataType);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5ODE1NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402798154", "bodyText": "nit: add an empty line after each value.", "author": "zhijiangW", "createdAt": "2020-04-03T07:50:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5OTM2NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402799364", "bodyText": "OTHER_EVENT instead", "author": "zhijiangW", "createdAt": "2020-04-03T07:52:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tUNKNOWN_EVENT(false, false);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwMzkxOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402803918", "bodyText": "It does not need to maintain this so specific property, otherwise when we further extend the data type enum future, it also needs to extend the respective field here.\nisBuffer is a general property to be retained for widely use.  Then we can also judge via getDataType == DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER  to replace isExactlyOnceCheckpointBarrier.", "author": "zhijiangW", "createdAt": "2020-04-03T07:58:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tUNKNOWN_EVENT(false, false);\n+\n+\t\tprivate final boolean isBuffer;\n+\n+\t\tprivate final boolean isExactlyOnceCheckpointBarrier;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDg4MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402804880", "bodyText": "nit: bufferDataType -> dataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:59:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java", "diffHunk": "@@ -53,23 +53,23 @@ public BufferConsumer(\n \t\t\tPositionMarker currentWriterPosition,\n \t\t\tint currentReaderPosition) {\n \t\tthis(\n-\t\t\tnew NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler), true),\n+\t\t\tnew NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler)),\n \t\t\tcurrentWriterPosition,\n \t\t\tcurrentReaderPosition);\n \t}\n \n \t/**\n \t * Constructs {@link BufferConsumer} instance with static content.\n \t */\n-\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, boolean isBuffer) {\n-\t\tthis(memorySegment, recycler, memorySegment.size(), isBuffer);\n+\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, Buffer.DataType bufferDataType) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNTY1OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402805658", "bodyText": "ditto: dataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:59:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -52,8 +52,8 @@\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** Whether this buffer represents a buffer or an event. */\n-\tprivate boolean isBuffer;\n+\t/** The {@link DataType} this buffer contains. */\n+\tprivate DataType bufferDataType;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNTk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402805950", "bodyText": "contains -> represents", "author": "zhijiangW", "createdAt": "2020-04-03T08:00:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -52,8 +52,8 @@\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** Whether this buffer represents a buffer or an event. */\n-\tprivate boolean isBuffer;\n+\t/** The {@link DataType} this buffer contains. */", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402811882", "bodyText": "why remove condition of finish?", "author": "zhijiangW", "createdAt": "2020-04-03T08:07:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -114,7 +114,7 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = shouldNotifyDataAvailable() || finish;\n+\t\t\tnotifyDataAvailable = shouldNotifyDataAvailable();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc3NjMyNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404776325", "bodyText": "We don't need special handling for EOF here, if I keep the || finish, considering the blockByCheckpoint tag, the condition looks this\nnotifyDataAvailable = shouldNotifyDataAvailable() || (finish && !isBlockedByCheckpoint);, which is not elegant enough.", "author": "wsry", "createdAt": "2020-04-07T12:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwNjI3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406606270", "bodyText": "If this condition is actually redundant irrelevant with this PR, then we can create a separate ticket for removing it.\nI am not sure whether there were any considerations for adding this tag before and might impact behaviors, then it is better for a separate ticket for checking instead of a hotfix commit.", "author": "zhijiangW", "createdAt": "2020-04-10T05:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNTk3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402815971", "bodyText": "use buffer.getDataType() == Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER instead.", "author": "zhijiangW", "createdAt": "2020-04-03T08:11:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NzgwMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402897802", "bodyText": "I add a util method in Buffer.DataType to judge if a Buffer is an ExactlyOnceCheckpointBarrier", "author": "wsry", "createdAt": "2020-04-03T10:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402818491", "bodyText": "The readerView maintains the blocked state, then I prefer to moving this judgement inside subpartition view. So we can remove this method blockOnCheckpointBarrier completely.", "author": "zhijiangW", "createdAt": "2020-04-03T08:14:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n+\t\t\tif (isExactlyOnceCheckpointBarrier) {\n+\t\t\t\treadView.blockOnCheckpointBarrier();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMzAyNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402823026", "bodyText": "To do so, we have three components to maintain the separate states to finalize the final available state.\nResultSubpartition:  data available via BufferAndBacklog internal state\nResultSubpartitionView: blocked state when polling barrier\nNetworkSequenceViewReader: credit available", "author": "zhijiangW", "createdAt": "2020-04-03T08:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MzA5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404583090", "bodyText": "As discussed, I moved the blockedByCheckpoint tag to subpartition.", "author": "wsry", "createdAt": "2020-04-07T07:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402824407", "bodyText": "Remove !isExactlyOnceCheckpointBarrier to not mix this state with ResultSubpartition component, we can get this blocked state separately from ResultSubpartitionView, then every concept is clean.", "author": "zhijiangW", "createdAt": "2020-04-03T08:21:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n+\t\t\tif (isExactlyOnceCheckpointBarrier) {\n+\t\t\t\treadView.blockOnCheckpointBarrier();\n+\t\t\t}\n+\n \t\t\tupdateStatistics(buffer);\n \t\t\t// Do not report last remaining buffer on buffers as available to read (assuming it's unfinished).\n \t\t\t// It will be reported for reading either on flush or when the number of buffers in the queue\n \t\t\t// will be 2 or more.\n \t\t\treturn new BufferAndBacklog(\n \t\t\t\tbuffer,\n-\t\t\t\tisAvailableUnsafe(),\n+\t\t\t\tisAvailableUnsafe() && !isExactlyOnceCheckpointBarrier,", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDY4OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402900689", "bodyText": "the downstream task of LocalChannel will check this isAvailable state and decide whether to add the corresponding input channel to available queue again.\nI will move this to constructor of BufferAndBacklog.", "author": "wsry", "createdAt": "2020-04-03T10:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MzU3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404583572", "bodyText": "I have unified this tag with isAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMzU0MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402833540", "bodyText": "I know it can avoid entering the following actions if readerView is not fitted.  But another issue is that notifyDataAvailable would be called in three places in this class, and it already judges the readerView inside for unification. So I suggested to add the condition readView.isBlockedByCheckpoint() inside notifyDataAvailable.", "author": "zhijiangW", "createdAt": "2020-04-03T08:32:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -302,7 +307,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty()) {\n+\t\t\tif (buffers.isEmpty() || readView == null || readView.isBlockedByCheckpoint()) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NDUzOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404584539", "bodyText": "Some tags should be  checked in lock, I removed the check in notifyDataAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMzU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNTM4Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402835387", "bodyText": "also we can remove this condition by reusing it inside notifyDataAvailable as mentioned above.", "author": "zhijiangW", "createdAt": "2020-04-03T08:34:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -376,7 +381,7 @@ public int getBuffersInBacklog() {\n \n \tprivate boolean shouldNotifyDataAvailable() {\n \t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && getNumberOfFinishedBuffers() == 1;\n+\t\treturn readView != null && !flushRequested && !readView.isBlockedByCheckpoint() && getNumberOfFinishedBuffers() == 1;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NDgxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404584811", "bodyText": "Some tags should be checked in lock, I removed the check in notifyDataAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NjI5MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402896291", "bodyText": "It is sensitive to maintain a volatile variable in core stack. Actually we can avoid it for RemoteInputChannel by accessing it only by netty stack, it would only bring one more unnecessary UserEventTrigger in netty stack. But for local channel, it has problems now, let us think whether they are other options to bypass.", "author": "zhijiangW", "createdAt": "2020-04-03T10:01:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java", "diffHunk": "@@ -39,6 +40,8 @@\n \t/** Flag indicating whether this view has been released. */\n \tprivate final AtomicBoolean isReleased;\n \n+\tprivate volatile boolean isBlockedByCheckpoint = false;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NTAxNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404585014", "bodyText": "As discussed, I moved the blockedByCheckpoint tag to subpartition.", "author": "wsry", "createdAt": "2020-04-07T07:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NjI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5OTg3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402899871", "bodyText": "From subpartitionView prospective , it is better to give a overall method for judging its condition, not spreading multiple conditions. we might need to refactor the current ResultSubpartition#isAvailable for also considering blocked state with nextBufferIsEvent.", "author": "zhijiangW", "createdAt": "2020-04-03T10:08:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -119,7 +124,7 @@ public boolean isAvailable() {\n \t\t\treturn subpartitionView.isAvailable();\n \t\t}\n \t\telse {\n-\t\t\treturn subpartitionView.nextBufferIsEvent();\n+\t\t\treturn !subpartitionView.isBlockedByCheckpoint() && subpartitionView.nextBufferIsEvent();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NTk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404585950", "bodyText": "I unified the isBlockedByCheckpoint tag with isAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5OTg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDcxNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402900715", "bodyText": "As above commented, if we can avoid task thread touching the blocked state, then together with https://github.com/apache/flink/pull/11351/files#r402899871, we can remove this method completely.", "author": "zhijiangW", "createdAt": "2020-04-03T10:09:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java", "diffHunk": "@@ -50,6 +50,10 @@\n \n \tboolean isReleased();\n \n+\tboolean isBlockedByCheckpoint();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTE1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402901150", "bodyText": "Actually i want this state already be covered by part of existing isAvailable method.", "author": "zhijiangW", "createdAt": "2020-04-03T10:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMjIyNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402912224", "bodyText": "I notice that some usages are relying on the ordinal  of enum value. So do you think we should give some notes to avoid adjusting the existing sequence if extending it future?", "author": "zhijiangW", "createdAt": "2020-04-03T10:31:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NzI1OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404587258", "bodyText": "The ordinal of enum value is used when writing buffer to disk and sending buffers through network. As suggested, I have removed those logic so the ordinal of enum value is never used now.", "author": "wsry", "createdAt": "2020-04-07T07:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMjIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMzg3OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402913879", "bodyText": "we can still retain the isBuffer as before, because it is enough now to avoid increasing the header size.", "author": "zhijiangW", "createdAt": "2020-04-03T10:35:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java", "diffHunk": "@@ -276,22 +279,22 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception\n \n \t\tfinal int backlog;\n \n-\t\tfinal boolean isBuffer;\n+\t\tfinal Buffer.DataType bufferDataType;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDU2Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914566", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:36:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +310,11 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDYzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914635", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:36:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -299,7 +299,6 @@ private void notifyCreditAvailable() {\n \t@Override\n \tpublic void recycle(MemorySegment segment) {\n \t\tint numAddedBuffers;\n-", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDgxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914811", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:37:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -482,7 +492,6 @@ public Buffer requestBuffer() {\n \t */\n \tvoid onSenderBacklog(int backlog) throws IOException {\n \t\tint numRequestedBuffers = 0;\n-", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTE3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915171", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:37:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -383,7 +383,7 @@ public NotificationResult notifyBufferAvailable(Buffer buffer) {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n+\t\t\tif (unannouncedCredit.getAndIncrement() == 0) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTI2OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915268", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:38:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +310,11 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndIncrement() == 0) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTU0MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915540", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:38:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java", "diffHunk": "@@ -681,8 +684,6 @@ static CloseRequest readFrom(@SuppressWarnings(\"unused\") ByteBuf buffer) throws\n \t\tfinal InputChannelID receiverId;\n \n \t\tAddCredit(int credit, InputChannelID receiverId) {\n-\t\t\tcheckArgument(credit > 0, \"The announced credit should be greater than 0\");", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzE3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517172", "bodyText": "nit: adjust the comment as well.", "author": "zhijiangW", "createdAt": "2020-04-07T03:40:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -310,19 +316,17 @@ private void writeAndFlushNextMessageIfPossible(Channel channel) {\n \t\t}\n \n \t\twhile (true) {\n-\t\t\tRemoteInputChannel inputChannel = inputChannelsWithCredit.poll();\n+\t\t\tClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n \n \t\t\t// The input channel may be null because of the write callbacks\n \t\t\t// that are executed after each write.\n-\t\t\tif (inputChannel == null) {\n+\t\t\tif (outboundMessage == null) {\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\t//It is no need to notify credit for the released channel.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzk1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517955", "bodyText": "nit: checkNotNull(inputChannel)", "author": "zhijiangW", "createdAt": "2020-04-07T03:44:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -350,4 +354,38 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate static abstract class ClientOutboundMessage {\n+\t\tprotected final RemoteInputChannel inputChannel;\n+\n+\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n+\t\t\tthis.inputChannel = inputChannel;\n+\t\t}\n+\n+\t\tabstract Object buildMessage();\n+\t}\n+\n+\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n+\n+\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzk4OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517989", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-07T03:44:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -350,4 +354,38 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate static abstract class ClientOutboundMessage {\n+\t\tprotected final RemoteInputChannel inputChannel;\n+\n+\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n+\t\t\tthis.inputChannel = inputChannel;\n+\t\t}\n+\n+\t\tabstract Object buildMessage();\n+\t}\n+\n+\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n+\n+\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object buildMessage() {\n+\t\t\treturn new AddCredit(inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+\t\t}\n+\t}\n+\n+\tprivate static class ResumeConsumptionMessage extends ClientOutboundMessage {\n+\n+\t\tResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMjEyMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404522122", "bodyText": "request->requests, exactly-once", "author": "zhijiangW", "createdAt": "2020-04-07T04:03:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -161,6 +161,26 @@ void addCredit(InputChannelID receiverId, int credit) throws Exception {\n \t\t}\n \t}\n \n+\t/**\n+\t * The consumer request to resume data consumption after an exactly once checkpoint.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyOTkxNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404529915", "bodyText": "should we further remove this method because it is always return 0 after this PR? If so, how many changes it will be involved?", "author": "zhijiangW", "createdAt": "2020-04-07T04:36:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java", "diffHunk": "@@ -59,19 +56,13 @@ public CheckpointMetrics(\n \t\tcheckArgument(bytesBufferedInAlignment >= -1);\n \t\tcheckArgument(alignmentDurationNanos >= -1);\n \n-\t\tthis.bytesBufferedInAlignment = bytesBufferedInAlignment;\n \t\tthis.alignmentDurationNanos = alignmentDurationNanos;\n \t\tthis.syncDurationMillis = syncDurationMillis;\n \t\tthis.asyncDurationMillis = asyncDurationMillis;\n \t}\n \n \tpublic long getBytesBufferedInAlignment() {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MzI2MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404683261", "bodyText": "I further removed the relevant code except those in rest handler, the rest handler always return 0 to the web ui, I think we need another ticket to further remove it in web ui.", "author": "wsry", "createdAt": "2020-04-07T09:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyOTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MTc4NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404541784", "bodyText": "In mostly normal cases, this list should not be created beforehand, so it is better to create based on demand.\nI know it is for unification consideration. Another option is that we can migrate partial resume notification inside releaseBlocksAndResetBarriers which is involved in batch of channels to be notified.\nThen the other cases are all for the single channel notification which can be done inside #processBarrier. Then we can define boolean shouldNotify beforehand, and to remove unnecessary two else conditions below to make the logics seem shorter. And at the end to notify the channelIndex if shouldNotify set as false intermediate steps.\nAnother potential benefit is to make notification happen before notifyCheckpoint. notifyCheckpoint would be involved in some IO operations during sync process, so it is better to notify light-weight unblock actions beforehand to make data ready earlier.", "author": "zhijiangW", "createdAt": "2020-04-07T05:21:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -100,21 +119,22 @@ public boolean isBlocked(int channelIndex) {\n \t}\n \n \t@Override\n-\tpublic boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception {\n+\tpublic void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {\n \t\tfinal long barrierId = receivedBarrier.getId();\n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MjU1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404542555", "bodyText": "Considering my above concerns, all the resume notification can be done inside releaseBlocksAndResetBarriers instead", "author": "zhijiangW", "createdAt": "2020-04-07T05:24:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -214,8 +233,9 @@ protected void onBarrier(int channelIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic boolean processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n+\tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tfinal long barrierId = cancelBarrier.getCheckpointId();\n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MjkxOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404542918", "bodyText": "ditto: make notification inside releaseBlocksAndResetBarriers", "author": "zhijiangW", "createdAt": "2020-04-07T05:25:34Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -280,28 +298,29 @@ else if (barrierId > currentCheckpointId) {\n \t\t\t}\n \n \t\t\tnotifyAbortOnCancellationBarrier(barrierId);\n-\t\t\treturn false;\n \t\t}\n \n \t\t// else: trailing barrier from either\n \t\t//   - a previous (subsumed) checkpoint\n \t\t//   - the current checkpoint if it was already canceled\n-\t\treturn false;\n+\n+\t\tunblockCheckpoint(channelsToUnblock);\n \t}\n \n \t@Override\n-\tpublic boolean processEndOfPartition() throws Exception {\n+\tpublic void processEndOfPartition() throws Exception {\n \t\tnumClosedChannels++;\n \n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTA3NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404575075", "bodyText": "return Optional.empty(); can be merged in condition. also remove throws Exception\n\nprivate Optional handleEmptyBuffer()  {\nif (inputGate.isFinished()) {\nisFinished = true;\n}\nreturn Optional.empty();\n}", "author": "zhijiangW", "createdAt": "2020-04-07T06:52:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -180,40 +141,15 @@ private int offsetChannelIndex(int channelIndex) {\n \t\t\treturn Optional.empty();\n \t\t}\n \n-\t\tif (endOfInputGate) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MjY5OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404582698", "bodyText": "it would be better to make isExactlyOnceMode as an internal field of CheckpointOptions, then we can avoid touching the changes of multiple related classes.", "author": "zhijiangW", "createdAt": "2020-04-07T07:08:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "diffHunk": "@@ -47,11 +48,18 @@\n \tprivate final long id;\n \tprivate final long timestamp;\n \tprivate final CheckpointOptions checkpointOptions;\n+\tprivate final boolean isExactlyOnceMode;\n \n+\t@VisibleForTesting\n \tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) {\n+\t\tthis(id, timestamp, checkpointOptions, true);\n+\t}\n+\n+\tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions, boolean isExactlyOnceMode) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjU0Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404586547", "bodyText": "nit: package private", "author": "zhijiangW", "createdAt": "2020-04-07T07:16:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -130,26 +112,26 @@ private static CheckpointBarrierHandler createCheckpointBarrierHandler(\n \t\t}\n \t}\n \n-\tprivate static BufferStorage createBufferStorage(\n-\t\t\tCheckpointingMode checkpointMode,\n-\t\t\tint pageSize,\n-\t\t\tConfiguration taskManagerConfig,\n-\t\t\tString taskName) {\n-\t\tswitch (checkpointMode) {\n-\t\t\tcase EXACTLY_ONCE: {\n-\t\t\t\tlong maxAlign = taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);\n-\t\t\t\tif (!(maxAlign == -1 || maxAlign > 0)) {\n-\t\t\t\t\tthrow new IllegalConfigurationException(\n-\t\t\t\t\t\tTaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()\n-\t\t\t\t\t\t\t+ \" must be positive or -1 (infinite)\");\n-\t\t\t\t}\n-\t\t\t\treturn new CachedBufferStorage(pageSize, maxAlign, taskName);\n+\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjYyMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404586622", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-07T07:16:17Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -130,26 +112,26 @@ private static CheckpointBarrierHandler createCheckpointBarrierHandler(\n \t\t}\n \t}\n \n-\tprivate static BufferStorage createBufferStorage(\n-\t\t\tCheckpointingMode checkpointMode,\n-\t\t\tint pageSize,\n-\t\t\tConfiguration taskManagerConfig,\n-\t\t\tString taskName) {\n-\t\tswitch (checkpointMode) {\n-\t\t\tcase EXACTLY_ONCE: {\n-\t\t\t\tlong maxAlign = taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);\n-\t\t\t\tif (!(maxAlign == -1 || maxAlign > 0)) {\n-\t\t\t\t\tthrow new IllegalConfigurationException(\n-\t\t\t\t\t\tTaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()\n-\t\t\t\t\t\t\t+ \" must be positive or -1 (infinite)\");\n-\t\t\t\t}\n-\t\t\t\treturn new CachedBufferStorage(pageSize, maxAlign, taskName);\n+\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n+\t\tInputGate[] channelIndexToInputGate = new InputGate[numberOfInputChannels];\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (InputGate inputGate: inputGates) {\n+\t\t\tfor (int i = 0; i < inputGate.getNumberOfInputChannels(); ++i) {\n+\t\t\t\tchannelIndexToInputGate[channelIndexOffset + i] = inputGate;\n \t\t\t}\n-\t\t\tcase AT_LEAST_ONCE:\n-\t\t\t\treturn new EmptyBufferStorage();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Unrecognized Checkpointing Mode: \" + checkpointMode);\n+\t\t\tchannelIndexOffset += inputGate.getNumberOfInputChannels();\n+\t\t}\n+\t\treturn channelIndexToInputGate;\n+\t}\n+\n+\tpublic static Map<InputGate, Integer> generateInputGateToChannelIndexOffsetMap(InputGate ...inputGates) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "302fb27f0a4a3639a442d2c54ddbcf0d323c7c76", "url": "https://github.com/apache/flink/commit/302fb27f0a4a3639a442d2c54ddbcf0d323c7c76", "message": "Fixup.", "committedDate": "2020-04-07T13:30:36Z", "type": "forcePushed"}, {"oid": "e2b1460ce15ca62960d1e4a4f431d6f7a7022e5a", "url": "https://github.com/apache/flink/commit/e2b1460ce15ca62960d1e4a4f431d6f7a7022e5a", "message": "Fixup.", "committedDate": "2020-04-08T04:32:02Z", "type": "forcePushed"}, {"oid": "16d04e41554d5244bb4907f1d0afed7826cda523", "url": "https://github.com/apache/flink/commit/16d04e41554d5244bb4907f1d0afed7826cda523", "message": "Fixup.", "committedDate": "2020-04-08T08:08:16Z", "type": "forcePushed"}, {"oid": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "url": "https://github.com/apache/flink/commit/20f4e859705d31fd8a0821241bc9813cb39d0c32", "message": "Fixup.", "committedDate": "2020-04-08T15:33:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwOTA4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406609085", "bodyText": "nit: whitespace for { and =", "author": "zhijiangW", "createdAt": "2020-04-10T05:30:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java", "diffHunk": "@@ -90,7 +111,11 @@ else if (obj != null && obj.getClass() == CheckpointOptions.class) {\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"CheckpointOptions: \" + checkpointType + \" @ \" + targetLocation;\n+\t\treturn \"CheckpointOptions{\" +", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwOTE4Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406609183", "bodyText": "nit: increase indentation for arguments", "author": "zhijiangW", "createdAt": "2020-04-10T05:31:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java", "diffHunk": "@@ -42,12 +43,23 @@\n \t/** Target location for the checkpoint. */\n \tprivate final CheckpointStorageLocationReference targetLocation;\n \n+\tprivate final boolean isExactlyOnceMode;\n+\n+\t@VisibleForTesting\n+\tpublic CheckpointOptions(\n+\t\tCheckpointType checkpointType,", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNTU0NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406635545", "bodyText": "the description is not correct.", "author": "zhijiangW", "createdAt": "2020-04-10T07:15:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java", "diffHunk": "@@ -50,6 +50,13 @@ void requestSubpartition(\n \t */\n \tvoid notifyCreditAvailable(RemoteInputChannel inputChannel);\n \n+\t/**\n+\t * Notifies available credits from one remote input channel.", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MjI5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406642290", "bodyText": "Is it necessary to ensureAccessible for setter?", "author": "zhijiangW", "createdAt": "2020-04-10T07:36:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -639,4 +632,16 @@ public boolean isCompressed() {\n \tpublic void setCompressed(boolean isCompressed) {\n \t\tthis.isCompressed = isCompressed;\n \t}\n+\n+\t@Override\n+\tpublic DataType getDataType() {\n+\t\treturn dataType;\n+\t}\n+\n+\t@Override\n+\tpublic void setDataType(DataType dataType) {\n+\t\tensureAccessible();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDA3Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407160076", "bodyText": "I copied this from tagAsEvent, IMO, ensureAccessible is not a must here and I checked the code, ensureAccessible method mainly checks about the reference count and ensures that the buffer is not recycled, so I  think it should be ok to keep this check.", "author": "wsry", "createdAt": "2020-04-12T07:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NTQxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406645417", "bodyText": "Some general usages also reference this, so I prefer to defining EVENT_BUFFER instead for general purpose. The semantic here is also covering the above EXACTLY_ONCE_CHECKPOINT_BARRIER. If we defined as OTHER_EVENT, it seems exclude the EXACTLY_ONCE_CHECKPOINT_BARRIER.", "author": "zhijiangW", "createdAt": "2020-04-10T07:45:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +224,58 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer represents.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true),\n+\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false),\n+\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tOTHER_EVENT(false);", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NTczOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406645738", "bodyText": "The descriptions should also be adjusted.", "author": "zhijiangW", "createdAt": "2020-04-10T07:46:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +224,58 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer represents.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true),\n+\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false),\n+\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTExMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406701113", "bodyText": "I think we should not modify the condition of flushRequested, and only work on the condition of notifyDataAvailable.\nThen isBlockedByCheckpoint can be added into below notifyDataAvailable, but now touch readerView condition which is out of scope of this PR.", "author": "zhijiangW", "createdAt": "2020-04-10T10:29:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -322,7 +341,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty()) {\n+\t\t\tif (buffers.isEmpty() || readView == null || isBlockedByCheckpoint) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406701445", "bodyText": "better to make this change as a separate hotfix commit", "author": "zhijiangW", "createdAt": "2020-04-10T10:30:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -396,13 +415,11 @@ public int getBuffersInBacklog() {\n \n \tprivate boolean shouldNotifyDataAvailable() {\n \t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && getNumberOfFinishedBuffers() == 1;\n+\t\treturn readView != null && !flushRequested && !isBlockedByCheckpoint && getNumberOfFinishedBuffers() == 1;\n \t}\n \n \tprivate void notifyDataAvailable() {\n-\t\tif (readView != null) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2Mzc0Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407163746", "bodyText": "I remove the readView != null condition check in flush as suggested, so I add this condition back.", "author": "wsry", "createdAt": "2020-04-12T08:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NTMzMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408665333", "bodyText": "Actually this condition even this method can be removed if we can reuse the preceding three conditions inside shouldNotifyDataAvailable for #flush() operation, because only the available conditions inside #flush not check the readerView != null.", "author": "zhijiangW", "createdAt": "2020-04-15T08:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTQwMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406705401", "bodyText": "it is better to merge isAvailableWithoutCredit() with existing isAvailable() to avoid maintaining two separate interface methods. We can integrate them into isAvailable(int credit) method for distinguishing the condition inside implementations.", "author": "zhijiangW", "createdAt": "2020-04-10T10:44:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java", "diffHunk": "@@ -50,12 +50,14 @@\n \n \tboolean isReleased();\n \n+\tvoid resumeConsumption();\n+\n \tThrowable getFailureCause();\n \n \t/**\n-\t * Returns whether the next buffer is an event or not.\n+\t * Returns true if we can read data without available credits.\n \t */\n-\tboolean nextBufferIsEvent();\n+\tboolean isAvailableWithoutCredit();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNjk2MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406706960", "bodyText": "@GuardedBy(\"buffers\")", "author": "zhijiangW", "createdAt": "2020-04-10T10:49:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -86,6 +86,9 @@\n \t/** The total number of bytes (both data and event buffers). */\n \tprivate long totalNumberOfBytes;\n \n+\t/** Whether this subpartition is blocked by exactly once checkpoint and is waiting for resumption. */\n+\tprivate boolean isBlockedByCheckpoint = false;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}