{"pr_number": 12261, "pr_title": "[FLINK-17823][network] Resolve the race condition while releasing RemoteInputChannel", "pr_createdAt": "2020-05-20T04:22:53Z", "pr_url": "https://github.com/apache/flink/pull/12261", "timeline": [{"oid": "26afeb03aa30f84994a8aa85ca2d223d44672067", "url": "https://github.com/apache/flink/commit/26afeb03aa30f84994a8aa85ca2d223d44672067", "message": "[FLINK-17823][network] Resolve the race condition while releasing RemoteInputChannel\n\nRemoteInputChannel#releaseAllResources might be called by canceler thread. Meanwhile, the task thread can also call RemoteInputChannel#getNextBuffer.\nThere probably cause two potential problems:\n\n1. Task thread might get null buffer after canceler thread already released all the buffers, then it might cause misleading NPE in getNextBuffer.\n2. Task thread and canceler thread might pull the same buffer concurrently, which causes unexpected exception when the same buffer is recycled twice.\n\nThe solution is to properly synchronize the buffer queue in release method to avoid the same buffer pulled by both canceler thread and task thread.\nAnd in getNextBuffer method, we add some explicit checks to avoid misleading NPE and hint some valid exceptions.", "committedDate": "2020-05-20T04:18:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA==", "url": "https://github.com/apache/flink/pull/12261#discussion_r427749670", "bodyText": "I guess it's theoretically impossible that we get a null buffer here with your changes in releaseAllResources, which seems to solve two cases you mentioned in description. So.. this check is just for other unknown bad cases?", "author": "Jiayi-Liao", "createdAt": "2020-05-20T05:28:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -181,6 +181,14 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n \t\t}\n \n+\t\tif (next == null) {", "originalCommit": "26afeb03aa30f84994a8aa85ca2d223d44672067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzOTEwNw==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428139107", "bodyText": "I guess it can probably happen in practice. When the canceler thread already released the respective input channel, but the task thread might still call getNextBuffer in the case of released receivedBuffers, then it can get the null buffer.", "author": "zhijiangW", "createdAt": "2020-05-20T16:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3OTM4Mw==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428179383", "bodyText": "What do you mean @zhijiangW ? At first glance I would agree with @Jiayi-Liao, that it shouldn't happen after your fix in this commit in this class below.", "author": "pnowojski", "createdAt": "2020-05-20T17:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMDY1MQ==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428430651", "bodyText": "Let me further explain it.\nThe canceler thread will close the InputGate in advance so the task thread might be aware of the released state to exit early. When the canceler thread called RemoteInputChannel#releaseAllResources before, then all the buffers in receivedBuffers would be drained and recycled.\nBut the task thread was not aware of this then, and it would probably call getNextBuffer to get a null buffer here. We only expect the null buffer in the case of released channel, so we throw the expected CancelTaskException to make task thread exit. If not released case, there must be some logic bugs. E.g this channel notifies gate of available data by fault.  So we throw IllegalStateException for such case, to avoid the misleading NullPointerException when reference with the buffer below.\nMy fix in #releaseAllResources is only for avoiding concurrent pulling receivedBuffers by both task thread and canceler thread, which might cause recycle the same buffer twice and misleading exception thrown by netty stack.\nAnother option for modifying the logic in #getNextBuffer like below:\n                  synchronized (receivedBuffers) {\n\t\t\tif (isReleased.get()) {\n\t\t\t\tthrow new CancelTaskException(\"Queried for a buffer after channel has been released.\");\n\t\t\t}\n\t\t\tnext = receivedBuffers.poll();\n\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n\t\t}\n\nBut it might still make sense to also judge whether the buffer is null out of the synchronized, which is not the race condition case, and only for avoiding potential logic bugs in data notification logic to cause misleading NPE.", "author": "zhijiangW", "createdAt": "2020-05-21T03:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzMTY3OA==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428431678", "bodyText": "FYI: before my changes, we can reproduce these two potential issues in my below introduced unit tests stable. One case is throwing NPE exception sometimes, and another case is throwing netty stack exception when same buffer recycled twice.", "author": "zhijiangW", "createdAt": "2020-05-21T03:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ0Njk3Mg==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428446972", "bodyText": "Get it! Thanks for the explaination!", "author": "Jiayi-Liao", "createdAt": "2020-05-21T05:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0MTUxNg==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428641516", "bodyText": "Ops, sorry, yes it's obvious, I don't know why I've missed it \ud83d\ude33", "author": "pnowojski", "createdAt": "2020-05-21T13:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0OTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428180875", "bodyText": "I think we could have tested this bug without concurrency/multi threading by just calling releaseAllResources before getNextBuffer. Test would be much easier to understand and debug and this would be worth a bit worse testing coverage - especially that we still have ITCases, and in the long run we are planning/hoping to make releasing resources go through mailbox.", "author": "pnowojski", "createdAt": "2020-05-20T17:20:59Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1010,6 +1011,56 @@ public void testConcurrentRecycleAndRelease2() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testConcurrentGetNextBufferAndRelease() throws Exception {", "originalCommit": "26afeb03aa30f84994a8aa85ca2d223d44672067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzNjg3Ng==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428436876", "bodyText": "I am not quite sure whether ITCase can stable reproduce the concurrent issues if not constructed well.\nE.g. we need to guarantee that when the canceler thread is releasing the channel, this channel must already be queued into the input gate with data in receivedBuffers, then it can simulate the scenario of executing releaseAllResources and getNextBuffers concurrently.\nUnit test can work on these two methods directly to stable reproduce the potential bugs, but ITCase might be hard to control and it might never have the chance to enter this path in practice.\nI found most of the previous race condition bugs in core codes was just missing such concurrent unit tests before, and simply verify the results by executing related methods by sequence, not concurrently.\nE.g. If we execute the #releaseAllResources() in different steps of #getNextBuffer, it would have different effects. So maybe only unit test can cover all the potential possibilities if we are not sure ITCase can achieve it.\nOptional<BufferAndAvailability> getNextBuffer() {\n                 1. execute #releaseAllResources() here\n  \n\t\tcheckState(!isReleased.get(), \"Queried for a buffer after channel has been closed.\");\n\t\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\");\n\n\t\tcheckError();\n\n\t\tfinal Buffer next;\n\t\tfinal boolean moreAvailable;\n\n                 2. execute #releaseAllResources() here\n\n\t\tsynchronized (receivedBuffers) {\n\t\t\tnext = receivedBuffers.poll();\n\t\t\tmoreAvailable = !receivedBuffers.isEmpty();\n\t\t}\n\n                 3. execute #releaseAllResources() here\n\n\t\tnumBytesIn.inc(next.getSize());\n\t\tnumBuffersIn.inc();\n\t\treturn Optional.of(new BufferAndAvailability(next, moreAvailable, 0));\n\t}\n\n\nMaybe it seems complex to let unit tests handle such scenarios. If ITCase can handle this work well, i am happy to make only simple unit tests.", "author": "zhijiangW", "createdAt": "2020-05-21T04:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY0MzA3NQ==", "url": "https://github.com/apache/flink/pull/12261#discussion_r428643075", "bodyText": "I'm not a fan of such concurrency tests, I wouldn't be personally adding them I think, but you are right - single threaded unit test wouldn't reproduce this issue because of checkState(!isReleased.get()).\nLGTM", "author": "pnowojski", "createdAt": "2020-05-21T13:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxODU2OA==", "url": "https://github.com/apache/flink/pull/12261#discussion_r429018568", "bodyText": "I thought of some other considerations for this issue to share.\nIn the ITCase, even though we can reproduce some potential concurrent bugs, it is hard to debug and find the root cause, because it is involved in all the components. I really have such feeling when debugging the UnalignedCheckpointITCase these days.\nReversely, unit test only works on two concurrent methods directly, so it is easy to find the bugs by limiting the scopes/components. We already had 6 unit tests written by concurrent way in RemoteInputChannelTest before, to guarantee the stability among different concurrent methods executed by task thread, netty thread, canceler thread separately.  If replaced by ITCase, we need to debug among all these methods to find the potential root cause.\nIn general, it is better for unit tests only focus on one component or less, otherwise we should rely on ITCase. In this case, we only limit the scope inside RemoteInputChannel component, so it also makes sense from this aspect.\nAnyway besides the pros I mentioned above for unit tests, I also agree that the cons you concerned, merely the pros are a bit more than cons on my side. :)", "author": "zhijiangW", "createdAt": "2020-05-22T03:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MDg3NQ=="}], "type": "inlineReview"}]}