{"pr_number": 12996, "pr_title": "[FLINK-18688][table-planner-blink] Fix binary row writing with incorrect order in ProjectionCodeGenerator by removing for loop optimization", "pr_createdAt": "2020-07-27T09:52:40Z", "pr_url": "https://github.com/apache/flink/pull/12996", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0Njc1OQ==", "url": "https://github.com/apache/flink/pull/12996#discussion_r461446759", "bodyText": "Can you just use exprGenerator.generateResultExpression?", "author": "JingsongLi", "createdAt": "2020-07-28T09:28:57Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGenerator.scala", "diffHunk": "@@ -50,74 +50,18 @@ object ProjectionCodeGenerator {\n       inputTerm: String = DEFAULT_INPUT1_TERM,\n       outRecordTerm: String = DEFAULT_OUT_RECORD_TERM,\n       outRecordWriterTerm: String = DEFAULT_OUT_RECORD_WRITER_TERM,\n-      reusedOutRecord: Boolean = true,\n-      nullCheck: Boolean = true): GeneratedExpression = {\n-\n-    // we use a for loop to do all the projections for the same field type\n-    // instead of generating separated code for each field.\n-    // when the number of fields of the same type is large, this can improve performance.\n-    def generateLoop(\n-        fieldType: LogicalType,\n-        inIdxs: mutable.ArrayBuffer[Int],\n-        outIdxs: mutable.ArrayBuffer[Int]): String = {\n-      // this array contains the indices of the fields\n-      // whose type equals to `fieldType` in the input row\n-      val inIdxArr = newName(\"inIdx\")\n-      ctx.addReusableMember(s\"int[] $inIdxArr = null;\")\n-      ctx.addReusableInitStatement(s\"$inIdxArr = new int[] {${inIdxs.mkString(\", \")}};\")\n-\n-      // this array contains the indices of the fields\n-      // whose type equals to `fieldType` in the output row\n-      val outIdxArr = newName(\"outIdx\")\n-      ctx.addReusableMember(s\"int[] $outIdxArr = null;\")\n-      ctx.addReusableInitStatement(s\"$outIdxArr = new int[] {${outIdxs.mkString(\", \")}};\")\n-\n-      val loopIdx = newName(\"i\")\n-\n-      val fieldVal = CodeGenUtils.rowFieldReadAccess(\n-        ctx, s\"$inIdxArr[$loopIdx]\", inputTerm, fieldType)\n-\n-      val inIdx = s\"$inIdxArr[$loopIdx]\"\n-      val outIdx = s\"$outIdxArr[$loopIdx]\"\n-      val nullTerm = s\"$inputTerm.isNullAt($inIdx)\"\n-      s\"\"\"\n-         |for (int $loopIdx = 0; $loopIdx < $inIdxArr.length; $loopIdx++) {\n-         |  ${CodeGenUtils.rowSetField(ctx, outClass, outRecordTerm, outIdx,\n-                GeneratedExpression(fieldVal, nullTerm, \"\", fieldType),\n-                Some(outRecordWriterTerm))}\n-         |}\n-       \"\"\".stripMargin\n-    }\n-\n+      reusedOutRecord: Boolean = true): GeneratedExpression = {\n     val outFieldTypes = outType.getChildren\n-    val typeIdxs = new mutable.HashMap[\n-      LogicalType,\n-      (mutable.ArrayBuffer[Int], mutable.ArrayBuffer[Int])]()\n-\n-    for (i <- 0 until outFieldTypes.size()) {\n-      val (inIdxs, outIdxs) = typeIdxs.getOrElseUpdate(\n-        outFieldTypes.get(i), (mutable.ArrayBuffer.empty[Int], mutable.ArrayBuffer.empty[Int]))\n-      inIdxs.append(inputMapping(i))\n-      outIdxs.append(i)\n-    }\n \n     val codeBuffer = mutable.ArrayBuffer.empty[String]\n-    for ((fieldType, (inIdxs, outIdxs)) <- typeIdxs) {\n-      if (inIdxs.length >= FOR_LOOP_FIELD_LIMIT) {\n-        // for loop optimization will only be enabled\n-        // if the number of fields to be project exceeds the limit\n-        codeBuffer.append(generateLoop(fieldType, inIdxs, outIdxs))\n-      } else {\n-        // otherwise we do not use for loop\n-        for (i <- inIdxs.indices) {\n-          val nullTerm = s\"$inputTerm.isNullAt(${inIdxs(i)})\"\n-          codeBuffer.append(\n-            CodeGenUtils.rowSetField(ctx, outClass, outRecordTerm, outIdxs(i).toString,\n-              GeneratedExpression(rowFieldReadAccess(\n-                ctx, inIdxs(i), inputTerm, fieldType), nullTerm, \"\", fieldType),\n-              Some(outRecordWriterTerm)))\n-        }\n-      }\n+    for (i <- inputMapping.indices) {", "originalCommit": "187dfe0edcd8356d0db8e0ad5996e180ebbad08a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "940eb2ce79d88c9c8ed8596441127ee253150236", "url": "https://github.com/apache/flink/commit/940eb2ce79d88c9c8ed8596441127ee253150236", "message": "[FLINK-18688][table-planner-blink] Fix binary row writing with incorrect order in ProjectionCodeGenerator", "committedDate": "2020-08-10T03:20:04Z", "type": "commit"}, {"oid": "13a8ba700f0b3468f7a0da776bba1e5494ad6faf", "url": "https://github.com/apache/flink/commit/13a8ba700f0b3468f7a0da776bba1e5494ad6faf", "message": "[FLINK-18688] Use exprGenerator.generateResultExpression to simplify code", "committedDate": "2020-08-10T03:20:04Z", "type": "commit"}]}