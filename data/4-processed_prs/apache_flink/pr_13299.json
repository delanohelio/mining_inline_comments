{"pr_number": 13299, "pr_title": "[FLINK-19072][table-planner] Import Temporal Table join rule for Stream", "pr_createdAt": "2020-09-01T12:54:12Z", "pr_url": "https://github.com/apache/flink/pull/13299", "timeline": [{"oid": "2ed16425d7018bbb39be1edd6519fcb99cb45000", "url": "https://github.com/apache/flink/commit/2ed16425d7018bbb39be1edd6519fcb99cb45000", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-01T15:33:24Z", "type": "forcePushed"}, {"oid": "ade459ff295c6994b7d6d377674e02d668faee71", "url": "https://github.com/apache/flink/commit/ade459ff295c6994b7d6d377674e02d668faee71", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-02T06:57:23Z", "type": "forcePushed"}, {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7", "url": "https://github.com/apache/flink/commit/8928b195cdec50dee6df1e364df250c9283d0af7", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-23T13:38:20Z", "type": "forcePushed"}, {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "url": "https://github.com/apache/flink/commit/1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-09-28T08:53:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDQ2Nw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495764467", "bodyText": "nit: redundant period", "author": "godfreyhe", "createdAt": "2020-09-28T08:16:28Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecLookupJoin.scala", "diffHunk": "@@ -34,7 +34,7 @@ import java.util\n import scala.collection.JavaConversions._\n \n /**\n-  * Batch physical RelNode for temporal table join.\n+  * Batch physical RelNode for temporal table join that implements by lookup..", "originalCommit": "8928b195cdec50dee6df1e364df250c9283d0af7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3OTgwMg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495779802", "bodyText": "please add some comments about the limitation like: this rule can only be used in HepPlanner", "author": "godfreyhe", "createdAt": "2020-09-28T08:43:39Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -17,19 +17,30 @@\n  */\n package org.apache.flink.table.planner.plan.rules.logical\n \n-import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n-\n import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.hep.HepRelVertex\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelOptRuleOperand}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.logical.{LogicalCorrelate, LogicalFilter, LogicalSnapshot}\n-import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess, RexInputRef, RexNode, RexShuttle}\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical._\n+import org.apache.calcite.rex._\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.isRowtimeIndicatorType\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n   * The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into a Join\n   * to make join condition can be pushed-down. The join will be translated into\n-  * [[StreamExecLookupJoin]] in physical and might be translated into [[StreamExecTemporalJoin]]\n-  * in the future.\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDA5Nw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495780097", "bodyText": "nit: redundant blank", "author": "godfreyhe", "createdAt": "2020-09-28T08:44:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjI1MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495782251", "bodyText": "it's better to add some comments like \"do nothing\" at the end of this line", "author": "godfreyhe", "createdAt": "2020-09-28T08:47:31Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjQyMA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495782420", "bodyText": "left table -> right table ?", "author": "godfreyhe", "createdAt": "2020-09-28T08:47:47Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyODI2Ng==", "url": "https://github.com/apache/flink/pull/13299#discussion_r497228266", "bodyText": "A JOIN B FOR SYSTEM_TIME AS OF A.proctime AS B_temporal here we check wether user used the left time attribute column followed AS OF or not", "author": "leonardBang", "createdAt": "2020-09-30T03:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NDA0Nw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495784047", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T08:50:37Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NTM4OA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495785388", "bodyText": "nit: move => into above line ?", "author": "godfreyhe", "createdAt": "2020-09-28T08:52:59Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)", "originalCommit": "25a14e17dc399bc80687a4882b6e38aeddec2f3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTMyMw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495789323", "bodyText": "remove if and call getTableScan(trimHep(project.getInput)) directly", "author": "godfreyhe", "createdAt": "2020-09-28T08:59:27Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDIwNg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495790206", "bodyText": "we should also check whether the table in a LogicalTableScan is a TableSourceTable", "author": "godfreyhe", "createdAt": "2020-09-28T09:00:49Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -40,12 +51,105 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n \n   def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot\n \n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {\n+    node match {\n+      case hepRelVertex: HepRelVertex =>\n+        hepRelVertex.getCurrentRel\n+      case _ => node\n+    }\n+  }\n+\n+  protected def validateSnapshotInCorrelate(\n+      snapshot: LogicalSnapshot,\n+      correlate: LogicalCorrelate): Unit = {\n+    // period specification check\n+    snapshot.getPeriod.getType match {\n+      // validate type is  event-time or processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+\n+    snapshot.getPeriod match {\n+      // validate period comes from left table's field\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] &&\n+        correlate.getCorrelationId.equals(r.getReferenceExpr.asInstanceOf[RexCorrelVariable].id) =>\n+      case _ =>\n+        throw new ValidationException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field'\")\n+    }\n+  }\n+\n+  protected def isLookupJoin(snapshot: LogicalSnapshot, snapshotInput: RelNode): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+        => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]\n+        => Some(trimHep(project.getInput).asInstanceOf[TableScan])\n+      case _ => None\n+    }\n+  }\n+\n+  private def isTableSourceScan(relNode: RelNode): Boolean = {\n+    relNode match {\n+      case _: LogicalTableScan | _: FlinkLogicalLegacyTableSourceScan |", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NTkyOA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495795928", "bodyText": "nit: redundant blank", "author": "godfreyhe", "createdAt": "2020-09-28T09:10:37Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5ODEyNQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495798125", "bodyText": "timeAttributeFields  is never null", "author": "godfreyhe", "createdAt": "2020-09-28T09:14:18Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5OTQ4MA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495799480", "bodyText": "move it to where it is used", "author": "godfreyhe", "createdAt": "2020-09-28T09:16:33Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMTEwOA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495801108", "bodyText": "let leftFieldCnt be the parameter directly", "author": "godfreyhe", "createdAt": "2020-09-28T09:19:22Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwNTM2Mg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495805362", "bodyText": "lookupTable => temporalTable", "author": "godfreyhe", "createdAt": "2020-09-28T09:26:33Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -103,18 +334,86 @@ class LogicalCorrelateToJoinFromTemporalTableRuleWithFilter\n }\n \n /**\n-  * Planner rule that matches temporal table join which join condition is true,\n-  * that means the right input of the Correlate is a Snapshot.\n-  * e.g. SELECT * FROM MyTable AS T JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D ON true\n+  * Planner rule that matches temporal table join which implemented by lookup join, the join\n+  * condition is true, that means the right input of the Correlate is a Snapshot.\n+  * e.g. SELECT * FROM MyTable AS T JOIN lookupTable FOR SYSTEM_TIME AS OF T.proctime AS D ON true\n   */\n+class LogicalCorrelateToJoinFromLookupTableRuleWithoutFilter\n+  extends LogicalCorrelateToJoinFromLookupTemporalTableRule(\n+    operand(classOf[LogicalCorrelate],\n+      operand(classOf[RelNode], any()),\n+      operand(classOf[LogicalSnapshot],\n+        operand(classOf[RelNode], any()))),\n+    \"LogicalCorrelateToJoinFromLookupTableRuleWithoutFilter\"\n+  ) {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val snapshot: LogicalSnapshot = call.rel(2)\n+    val snapshotInput: RelNode = trimHep(call.rel(3))\n+    isLookupJoin(snapshot, snapshotInput)\n+  }\n+\n+  override def getFilterCondition(call: RelOptRuleCall): RexNode = {\n+    call.builder().literal(true)\n+  }\n+\n+  override def getLogicalSnapshot(call: RelOptRuleCall): LogicalSnapshot = {\n+    call.rels(2).asInstanceOf[LogicalSnapshot]\n+  }\n+}\n+\n+/**\n+ * Planner rule that matches general temporal table join except lookup join, the join\n+ * condition is not true, that means the right input of the Correlate is a Filter.\n+ * e.g. SELECT * FROM MyTable AS T JOIN lookupTable FOR SYSTEM_TIME AS OF T.rowtime AS D", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDE4Ng==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495820186", "bodyText": "move this line out of map", "author": "godfreyhe", "createdAt": "2020-09-28T09:51:21Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDU4Mw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495820583", "bodyText": "we can reuse rexBuilder", "author": "godfreyhe", "createdAt": "2020-09-28T09:52:01Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMjYzOQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495822639", "bodyText": "do we really check primary key constraint ?", "author": "godfreyhe", "createdAt": "2020-09-28T09:55:33Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4Njg0Mg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r502886842", "bodyText": "The primary key will checked in TemporalJoinRewriteWithUniqueKeyRule.", "author": "leonardBang", "createdAt": "2020-10-11T08:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMzAxNw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495823017", "bodyText": "can be found", "author": "godfreyhe", "createdAt": "2020-09-28T09:56:09Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +\n+            s\" but no row time attribute found.\")", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNTA2Mw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495825063", "bodyText": "nit: redundant blank", "author": "godfreyhe", "createdAt": "2020-09-28T09:59:43Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -74,23 +178,150 @@ abstract class LogicalCorrelateToJoinFromTemporalTableRule(\n     val rel = builder.build()\n     call.transformTo(rel)\n   }\n+}\n+\n+\n+/**\n+ * General temporal table join rule to rewrite the original Correlate into a Join.\n+ */\n+abstract class LogicalCorrelateToJoinFromGeneralTemporalTableRule(\n+    operand: RelOptRuleOperand,\n+    description: String)\n+  extends LogicalCorrelateToJoinFromTemporalTableRule(operand, description) {\n+\n+  protected def extractRightTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexNode] = {\n+    val rightFields = snapshot.getRowType.getFieldList.asScala\n+    val timeAttributeFields = rightFields.filter(\n+      f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+    val rexBuilder = snapshot.getCluster.getRexBuilder\n+\n+    if (timeAttributeFields != null && timeAttributeFields.length == 1) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      val timeColIndex = leftFieldCnt + rightFields.indexOf(timeAttributeFields.get(0))\n+      val timeColDataType = timeAttributeFields.get(0).getType\n+      Some(rexBuilder.makeInputRef(timeColDataType, timeColIndex))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  protected def extractSnapshotTimeInputRef(\n+      leftInput: RelNode,\n+      snapshot: LogicalSnapshot): Option[RexInputRef] = {\n+    val leftRowType = leftInput.getRowType\n+    val leftFields = leftRowType.getFieldList\n+    val periodField = snapshot.getPeriod.asInstanceOf[RexFieldAccess].getField\n+    if (leftFields.contains(periodField)) {\n+      val index = leftRowType.getFieldList.indexOf(periodField)\n+      Some(RexInputRef.of(index, leftRowType))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val correlate: LogicalCorrelate = call.rel(0)\n+    val leftInput: RelNode = call.rel(1)\n+    val filterCondition = getFilterCondition(call)\n+    val snapshot = getLogicalSnapshot(call)\n+\n+    val leftRowType = leftInput.getRowType\n+    val joinCondition = filterCondition.accept(new RexShuttle() {\n+      // change correlate variable expression to normal RexInputRef (which is from left side)\n+      override def visitFieldAccess(fieldAccess: RexFieldAccess): RexNode = {\n+        fieldAccess.getReferenceExpr match {\n+          case corVar: RexCorrelVariable =>\n+            require(correlate.getCorrelationId.equals(corVar.id))\n+            val index = leftRowType.getFieldList.indexOf(fieldAccess.getField)\n+            RexInputRef.of(index, leftRowType)\n+          case _ => super.visitFieldAccess(fieldAccess)\n+        }\n+      }\n \n+      // update the field index from right side\n+      override def visitInputRef(inputRef: RexInputRef): RexNode = {\n+        val rightIndex = leftRowType.getFieldCount + inputRef.getIndex\n+        new RexInputRef(rightIndex, inputRef.getType)\n+      }\n+    })\n+\n+    validateSnapshotInCorrelate(snapshot, correlate)\n+\n+    val (leftJoinKey, rightJoinKey) = {\n+      val rexBuilder = correlate.getCluster.getRexBuilder\n+      val relBuilder = call.builder()\n+      relBuilder.push(leftInput)\n+      relBuilder.push(snapshot)\n+      val rewriteJoin = relBuilder.join(correlate.getJoinType, joinCondition).build()\n+      val joinInfo = rewriteJoin.asInstanceOf[LogicalJoin].analyzeCondition()\n+      val leftJoinKey = joinInfo.leftKeys.map(i => rexBuilder.makeInputRef(leftInput, i))\n+      val rightJoinKey = joinInfo.rightKeys.map(i => {\n+        val leftFieldCnt = leftInput.getRowType.getFieldCount\n+        val leftKeyType = snapshot.getRowType.getFieldList.get(i).getType\n+        rexBuilder.makeInputRef(leftKeyType, leftFieldCnt + i)\n+      })\n+      (leftJoinKey, rightJoinKey)\n+    }\n+\n+    val snapshotTimeInputRef = extractSnapshotTimeInputRef(leftInput, snapshot)\n+      .getOrElse(throw new ValidationException(\"Temporal Table Join requires time attribute in the \" +\n+        s\"left table, but no row time attribute found.\"))\n+\n+    val rexBuilder = correlate.getCluster.getRexBuilder\n+    val temporalCondition = if(isRowTimeTemporalTableJoin(snapshot)) {\n+      val rightTimeInputRef = extractRightTimeInputRef(leftInput, snapshot)\n+      if (rightTimeInputRef.isEmpty || !isRowtimeIndicatorType(rightTimeInputRef.get.getType)) {\n+          throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+            s\" primary key and row time attribute in versioned table,\" +\n+            s\" but no row time attribute found.\")\n+      }\n+      // Deal primary key in TemporalJoinRewriteUniqueKeyRule\n+      TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+        rightTimeInputRef.get, leftJoinKey, rightJoinKey)\n+    } else {\n+      TemporalJoinUtil.makeProcTimeTemporalJoinConditionCall(\n+        rexBuilder, snapshotTimeInputRef, leftJoinKey, rightJoinKey)\n+    }\n+\n+    val builder = call.builder()\n+    val condition =  builder.and(joinCondition, temporalCondition)", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNjAxOQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495826019", "bodyText": "revert this change", "author": "godfreyhe", "createdAt": "2020-09-28T10:01:23Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/common/CommonLookupJoinRule.scala", "diffHunk": "@@ -132,7 +127,7 @@ abstract class BaseSnapshotOnTableScanRule(description: String)\n     val join = call.rel[FlinkLogicalJoin](0)\n     val snapshot = call.rel[FlinkLogicalSnapshot](2)\n     val tableScan = call.rel[TableScan](3)\n-    matches(join, snapshot, tableScan)\n+     matches(join, snapshot, tableScan)", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyODgwNg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495828806", "bodyText": "Similar comments like LogicalCorrelateToJoinFromTemporalTableRule\nand create a common package which both logical rules and physical rules can both use common utils", "author": "godfreyhe", "createdAt": "2020-09-28T10:06:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/common/CommonTemporalTableJoinRule.scala", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.flink.table.planner.plan.rules.physical.common\n+\n+import org.apache.calcite.plan.hep.HepRelVertex\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical.{LogicalProject, LogicalTableScan}\n+import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess}\n+\n+import org.apache.flink.table.planner.plan.nodes.logical._\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecLegacyTemporalJoin\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecLookupJoin\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+/**\n+  * Base implementation that matches temporal join node.\n+  *\n+  * <p> The temporal join node is a [[FlinkLogicalJoin]] whose left input is a [[FlinkLogicalRel]]\n+  * and right input is a [[FlinkLogicalSnapshot]].\n+  * It may be translated into [[StreamExecLookupJoin]] or [[StreamExecLegacyTemporalJoin]] in\n+  * physical phase.\n+  */\n+trait CommonTemporalTableJoinRule {", "originalCommit": "9d19cb8dda823844673eebad1bdd6dea54f7198e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MTgxOQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495861819", "bodyText": "move these imports behind org.apache.flink.", "author": "godfreyhe", "createdAt": "2020-09-28T11:12:10Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecLegacyTemporalJoin.scala", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.nodes.physical.stream\n+\n+import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n+import org.apache.calcite.rex._", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MjMwNg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495862306", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T11:13:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,19 +18,27 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import java.util\n+\n+import org.apache.calcite.plan.{RelOptCluster, RelTraitSet}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.{Join, JoinInfo, JoinRelType}\n+import org.apache.calcite.rex._", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NDU1Ng==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495864556", "bodyText": "joinKeys is unique iff joinKeys is the super-set of uniqueKey", "author": "godfreyhe", "createdAt": "2020-09-28T11:17:56Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -59,21 +64,21 @@ class StreamExecTemporalJoin(\n   with StreamPhysicalRel\n   with StreamExecNode[RowData] {\n \n-  override def requireWatermark: Boolean = {\n-    val nonEquiJoinRex = getJoinInfo.getRemaining(cluster.getRexBuilder)\n-\n-    var rowtimeJoin: Boolean = false\n-    val visitor = new RexVisitorImpl[Unit](true) {\n-      override def visitCall(call: RexCall): Unit = {\n-        if (call.getOperator == TEMPORAL_JOIN_CONDITION) {\n-          rowtimeJoin = TemporalJoinUtil.isRowtimeCall(call)\n-        } else {\n-          call.getOperands.foreach(node => node.accept(this))\n-        }\n+  def rightInputUniqueKeyContainsJoinKey(): Boolean = {\n+    val right = getInput(1)\n+    val rightUniqueKeys = getCluster.getMetadataQuery.getUniqueKeys(right)\n+    if (rightUniqueKeys != null) {\n+      val joinKeys = keyPairs.map(_.target).toArray\n+      rightUniqueKeys.exists {\n+        uniqueKey => joinKeys.forall(uniqueKey.toArray.contains(_))", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg5MTU5Ng==", "url": "https://github.com/apache/flink/pull/13299#discussion_r502891596", "bodyText": "good catch", "author": "leonardBang", "createdAt": "2020-10-11T09:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2ODE2Mg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495868162", "bodyText": "use local variable to store each value of the Tuple2, which could improve code readability", "author": "godfreyhe", "createdAt": "2020-09-28T11:24:59Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2ODc2MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495868761", "bodyText": "please throw the same exception for the validation", "author": "godfreyhe", "createdAt": "2020-09-28T11:26:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get,\n+          textualRepresentation),\n+          temporalJoinConditionExtractor.rightTimeAttribute.map(\n+            rightTimeAttribute =>\n+              extractInputRef(\n+                rightTimeAttribute,\n+                textualRepresentation\n+              ) - leftType.getFieldCount))\n+      } else {\n+        val leftTimeAttributes = leftInput.getRowType.getFieldList\n+          .filter(f => f.getType.isInstanceOf[TimeIndicatorRelDataType])\n+        if (leftTimeAttributes.isEmpty) {\n+          throw new ValidationException(", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2OTkzMQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495869931", "bodyText": "what if the left side has both row-time attribute and proc-time attribute ?", "author": "godfreyhe", "createdAt": "2020-09-28T11:28:38Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -275,27 +280,47 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     joinInfo: JoinInfo,\n     rexBuilder: RexBuilder): StreamExecTemporalJoinToCoProcessTranslator = {\n \n-    checkState(\n-      !joinInfo.isEqui,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n \n     val leftType = FlinkTypeFactory.toLogicalRowType(leftInput.getRowType)\n     val rightType = FlinkTypeFactory.toLogicalRowType(rightInput.getRowType)\n-    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n+\n     val temporalJoinConditionExtractor = new TemporalJoinConditionExtractor(\n       textualRepresentation,\n       leftType.getFieldCount,\n       joinInfo,\n       rexBuilder)\n \n+    val nonEquiJoinRex: RexNode = joinInfo.getRemaining(rexBuilder)\n     val remainingNonEquiJoinPredicates = temporalJoinConditionExtractor.apply(nonEquiJoinRex)\n \n-    checkState(\n-      temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n-        temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n-      \"Missing %s in join condition\",\n-      TEMPORAL_JOIN_CONDITION)\n+    val (leftTimeAttributeInputRef, rightTimeAttributeInputRef) =\n+      if (TemporalJoinUtil.isRowTimeJoin(rexBuilder, joinInfo)) {\n+      checkState(\n+        temporalJoinConditionExtractor.leftTimeAttribute.isDefined &&\n+          temporalJoinConditionExtractor.rightPrimaryKeyExpression.isDefined,\n+        \"Missing %s in Event-Time temporal join condition\",\n+        TEMPORAL_JOIN_CONDITION)\n+        (extractInputRef(\n+          temporalJoinConditionExtractor.leftTimeAttribute.get,\n+          textualRepresentation),\n+          temporalJoinConditionExtractor.rightTimeAttribute.map(\n+            rightTimeAttribute =>\n+              extractInputRef(\n+                rightTimeAttribute,\n+                textualRepresentation\n+              ) - leftType.getFieldCount))\n+      } else {\n+        val leftTimeAttributes = leftInput.getRowType.getFieldList", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NTY2Nw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495875667", "bodyText": "please use RelOptUtil.InputFinder.bits(rexNode)", "author": "godfreyhe", "createdAt": "2020-09-28T11:40:46Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -327,6 +345,16 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n     inputReferenceVisitor.getFields.head\n   }\n \n+  private def extractInputRefs(rexNode: RexNode, textualRepresentation: String): Array[Int] = {\n+    val inputReferenceVisitor = new InputRefVisitor\n+    rexNode.accept(inputReferenceVisitor)\n+    checkState(\n+      inputReferenceVisitor.getFields.length == 1,\n+      \"Failed to find input reference in [%s]\",\n+      textualRepresentation)\n+    inputReferenceVisitor.getFields", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3ODAyOQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495878029", "bodyText": "use match", "author": "godfreyhe", "createdAt": "2020-09-28T11:45:42Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -339,75 +367,50 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n \n     var rightTimeAttribute: Option[RexNode] = None\n \n-    var rightPrimaryKeyExpression: Option[RexNode] = None\n+    var rightPrimaryKeyExpression: Option[Array[RexNode]] = None\n \n     override def visitCall(call: RexCall): RexNode = {\n       if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n         return super.visitCall(call)\n       }\n \n-      checkState(\n-        leftTimeAttribute.isEmpty\n-          && rightPrimaryKeyExpression.isEmpty\n-          && rightTimeAttribute.isEmpty,\n-        \"Multiple %s functions in [%s]\",\n-        TEMPORAL_JOIN_CONDITION,\n-        textualRepresentation)\n-\n-      if (TemporalJoinUtil.isRowtimeCall(call)) {\n+      if (TemporalJoinUtil.isRowTimeTemporalJoinConditionCall(call)) {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n         rightTimeAttribute = Some(call.getOperands.get(1))\n-\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(2)))\n-\n-        if (!isRowtimeIndicatorType(rightTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${rightTimeAttribute.get.getType}] \" +\n-              s\"used to create TemporalTableFunction\")\n-        }\n-        if (!isRowtimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else if (TemporalJoinUtil.isProctimeCall(call)) {\n+        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(4)))\n+      } else {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(1)))\n-\n-        if (!isProctimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non processing timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else {\n-        throw new IllegalStateException(\n-          s\"Unsupported invocation $call in [$textualRepresentation]\")\n       }\n       rexBuilder.makeLiteral(true)\n     }\n \n-    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): RexNode = {\n-      if (joinInfo.rightKeys.size() != 1) {\n+    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): Array[RexNode]  = {", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3OTQxOA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495879418", "bodyText": "use (ref, index) instead of r in map", "author": "godfreyhe", "createdAt": "2020-09-28T11:48:36Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -339,75 +367,50 @@ object StreamExecTemporalJoinToCoProcessTranslator {\n \n     var rightTimeAttribute: Option[RexNode] = None\n \n-    var rightPrimaryKeyExpression: Option[RexNode] = None\n+    var rightPrimaryKeyExpression: Option[Array[RexNode]] = None\n \n     override def visitCall(call: RexCall): RexNode = {\n       if (call.getOperator != TEMPORAL_JOIN_CONDITION) {\n         return super.visitCall(call)\n       }\n \n-      checkState(\n-        leftTimeAttribute.isEmpty\n-          && rightPrimaryKeyExpression.isEmpty\n-          && rightTimeAttribute.isEmpty,\n-        \"Multiple %s functions in [%s]\",\n-        TEMPORAL_JOIN_CONDITION,\n-        textualRepresentation)\n-\n-      if (TemporalJoinUtil.isRowtimeCall(call)) {\n+      if (TemporalJoinUtil.isRowTimeTemporalJoinConditionCall(call)) {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n         rightTimeAttribute = Some(call.getOperands.get(1))\n-\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(2)))\n-\n-        if (!isRowtimeIndicatorType(rightTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${rightTimeAttribute.get.getType}] \" +\n-              s\"used to create TemporalTableFunction\")\n-        }\n-        if (!isRowtimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non rowtime timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else if (TemporalJoinUtil.isProctimeCall(call)) {\n+        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(4)))\n+      } else {\n         leftTimeAttribute = Some(call.getOperands.get(0))\n-        rightPrimaryKeyExpression = Some(validateRightPrimaryKey(call.getOperands.get(1)))\n-\n-        if (!isProctimeIndicatorType(leftTimeAttribute.get.getType)) {\n-          throw new ValidationException(\n-            s\"Non processing timeAttribute [${leftTimeAttribute.get.getType}] \" +\n-              s\"passed as the argument to TemporalTableFunction\")\n-        }\n-      }\n-      else {\n-        throw new IllegalStateException(\n-          s\"Unsupported invocation $call in [$textualRepresentation]\")\n       }\n       rexBuilder.makeLiteral(true)\n     }\n \n-    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): RexNode = {\n-      if (joinInfo.rightKeys.size() != 1) {\n+    private def validateRightPrimaryKey(rightPrimaryKey: RexNode): Array[RexNode]  = {\n+      if (!rightPrimaryKey.isInstanceOf[RexCall] ||\n+        rightPrimaryKey.asInstanceOf[RexCall].getOperator != TEMPORAL_JOIN_CONDITION_PRIMARY_KEY) {\n         throw new ValidationException(\n-          s\"Only single column join key is supported. \" +\n-            s\"Found ${joinInfo.rightKeys} in [$textualRepresentation]\")\n-      }\n-      val rightJoinKeyInputReference = joinInfo.rightKeys.get(0) + rightKeysStartingOffset\n+          s\"No primary key [${rightPrimaryKey.asInstanceOf[RexCall]}] \" +\n+            s\"defined in versioned table of Event-time temporal table join\")\n+       }\n \n-      val rightPrimaryKeyInputReference = extractInputReference(\n+      val rightJoinKeyInputRefs = joinInfo.rightKeys\n+        .map(index => index + rightKeysStartingOffset)\n+        .toArray\n+\n+      val rightPrimaryKeyInputRefs = extractInputRefs(\n         rightPrimaryKey,\n         textualRepresentation)\n \n-      if (rightPrimaryKeyInputReference != rightJoinKeyInputReference) {\n+      val primaryKeyContainedInJoinKey = rightPrimaryKeyInputRefs.zipWithIndex\n+        .map(r => (r._1, rightJoinKeyInputRefs(r._2)))", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MTI2OA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495881268", "bodyText": "BEFORE_AND_AFTER ?", "author": "godfreyhe", "createdAt": "2020-09-28T11:52:12Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -504,6 +512,39 @@ class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOpti\n             None\n         }\n \n+      case temporalJoin: StreamExecTemporalJoin =>\n+        val left = temporalJoin.getLeft.asInstanceOf[StreamPhysicalRel]\n+        val right = temporalJoin.getRight.asInstanceOf[StreamPhysicalRel]\n+\n+        // the left input required trait depends on it's parent in temporal join\n+        // the left input will send message to parent\n+        val requiredUpdateBeforeByParent = requiredTrait.updateKind == UpdateKind.ONLY_UPDATE_AFTER", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzUwNg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495887506", "bodyText": "reorder imports", "author": "godfreyhe", "createdAt": "2020-09-28T12:04:57Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/StreamExecTemporalJoinRule.scala", "diffHunk": "@@ -18,56 +18,53 @@\n \n package org.apache.flink.table.planner.plan.rules.physical.stream\n \n-import org.apache.flink.table.planner.plan.`trait`.FlinkRelDistribution\n-import org.apache.flink.table.planner.plan.nodes.FlinkConventions\n-import org.apache.flink.table.planner.plan.nodes.logical._\n-import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecTemporalJoin\n-import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil.containsTemporalJoinCondition\n-import org.apache.flink.table.planner.plan.utils.{FlinkRelOptUtil, IntervalJoinUtil}\n+import java.util\n \n import org.apache.calcite.plan.RelOptRule.{any, operand}\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelTraitSet}\n import org.apache.calcite.rel.RelNode\n import org.apache.calcite.rel.core.JoinRelType\n \n-import java.util\n+import org.apache.flink.table.planner.plan.`trait`.FlinkRelDistribution", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzAxMw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893013", "bodyText": "LegacyTemporalProcessTimeJoinOperator and TemporalProcessTimeJoinOperator is almost same, can we reuse them ?", "author": "godfreyhe", "createdAt": "2020-09-28T12:15:31Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.functions.util.FunctionUtils;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+/**\n+ * The operator to temporal join a stream on processing time.\n+ */\n+public class LegacyTemporalProcessTimeJoinOperator", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzExNQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893115", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T12:15:44Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * This operator works by keeping on the state collection of probe and build records to process\n+ * on next watermark. The idea is that between watermarks we are collecting those elements\n+ * and once we are sure that there will be no updates we emit the correct result and clean up the\n+ * state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * however we always keep at least one record - the latest one - even if it's past the last\n+ * watermark.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class LegacyTemporalRowTimeJoinOperator", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzQ0NA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893444", "bodyText": "reorder import", "author": "godfreyhe", "createdAt": "2020-09-28T12:16:22Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -42,11 +41,11 @@ import org.apache.calcite.rex.{RexCall, RexInputRef, RexNode}\n import org.apache.calcite.sql.SqlKind\n import org.apache.calcite.sql.fun.SqlStdOperatorTable\n import org.apache.calcite.util.{Bug, BuiltInMethod, ImmutableBitSet, Util}\n-\n import com.google.common.collect.ImmutableSet\n-\n import java.util\n \n+import org.apache.calcite.plan.hep.HepRelVertex", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NTQ0Nw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495895447", "bodyText": "it's better we can put them into a separate commit", "author": "godfreyhe", "createdAt": "2020-09-28T12:20:09Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkwMTE3NQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r502901175", "bodyText": "yes, this part will be rework in the commit of supporting deduplicate on row time.", "author": "leonardBang", "createdAt": "2020-10-11T11:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5Njk1Mw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495896953", "bodyText": "!rel.outputRankNumber is unnecessary ? because even Rank output rank number, its value is always 1", "author": "godfreyhe", "createdAt": "2020-09-28T12:22:56Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {\n+      val rankRange = rel.rankRange\n+      val isRowNumberType = rel.rankType == RankType.ROW_NUMBER\n+      val isLimit1 = rankRange match {\n+        case rankRange: ConstantRankRange =>\n+          rankRange.getRankStart() == 1 && rankRange.getRankEnd() == 1\n+        case _ => false\n+      }\n+      !rel.outputRankNumber && isRowNumberType && isLimit1", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NzYxNQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495897615", "bodyText": "please add related tests in FlinkRelMdUniqueKeysTest", "author": "godfreyhe", "createdAt": "2020-09-28T12:24:07Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -244,7 +243,25 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n       ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n     val inputUniqueKeys = mq.getUniqueKeys(rel.getInput, ignoreNulls)\n     val rankFunColumnIndex = RankUtil.getRankNumberColumnIndex(rel).getOrElse(-1)\n-    if (rankFunColumnIndex < 0) {\n+    //TODO current deduplicate on row time is still a Rank,\n+    // remove this after support deduplicate on row time\n+    val canConvertToDeduplicate: Boolean = {\n+      val rankRange = rel.rankRange\n+      val isRowNumberType = rel.rankType == RankType.ROW_NUMBER\n+      val isLimit1 = rankRange match {\n+        case rankRange: ConstantRankRange =>\n+          rankRange.getRankStart() == 1 && rankRange.getRankEnd() == 1\n+        case _ => false\n+      }\n+      !rel.outputRankNumber && isRowNumberType && isLimit1\n+    }\n+\n+    if (canConvertToDeduplicate) {\n+      val retSet = new JHashSet[ImmutableBitSet]\n+      retSet.add(rel.partitionKey)\n+      retSet\n+    }", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5Nzc2MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495897761", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T12:24:20Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeys.scala", "diffHunk": "@@ -553,6 +570,20 @@ class FlinkRelMdUniqueKeys private extends MetadataHandler[BuiltInMetadata.Uniqu\n     }\n   }\n \n+  def getUniqueKeys(\n+      subset: HepRelVertex,\n+      mq: RelMetadataQuery,\n+      ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n+    mq.getUniqueKeys(subset.getCurrentRel, ignoreNulls)\n+  }\n+\n+  def getUniqueKeys(\n+      subset: WatermarkAssigner,\n+      mq: RelMetadataQuery,\n+      ignoreNulls: Boolean): JSet[ImmutableBitSet] = {\n+    mq.getUniqueKeys(subset.getInput, ignoreNulls)\n+  }", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMjcxOA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495902718", "bodyText": "it's hard to read, it's better to add some comments and split them into a few steps", "author": "godfreyhe", "createdAt": "2020-09-28T12:33:10Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.JoinRelType\n+import org.apache.calcite.rex.{RexBuilder, RexCall, RexNode, RexShuttle}\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.planner.plan.metadata.FlinkRelMetadataQuery\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalJoin, FlinkLogicalRel, FlinkLogicalSnapshot}\n+import org.apache.flink.table.planner.plan.rules.physical.common.CommonTemporalTableJoinRule\n+import org.apache.flink.table.planner.plan.schema.TimeIndicatorRelDataType\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+  * Planner rule that rewrites temporal join with extracted primary key, Event-time temporal\n+  * table join requires primary key and row time attribute of versioned table. The versioned table\n+  * could be a table source or a view only if it contains the unique key and time attribute.\n+  *\n+  * <p> Flink support extract the primary key and row time attribute from the view if the view comes\n+  * from [[LogicalRank]] node which can convert to a [[Deduplicate]] node.\n+  */\n+class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n+  operand(classOf[FlinkLogicalJoin],\n+    operand(classOf[FlinkLogicalRel], any()),\n+    operand(classOf[FlinkLogicalSnapshot],\n+      operand(classOf[FlinkLogicalRel], any()))),\n+  \"TemporalJoinRewriteWithUniqueKeyRule\")\n+  with CommonTemporalTableJoinRule {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+    val snapshotInput = call.rel[FlinkLogicalRel](3)\n+\n+    val isTemporalJoin = matches(snapshot)\n+    val canConvertToLookup = canConvertToLookupJoin(snapshot, snapshotInput)\n+    val supportedJoinTypes = Seq(JoinRelType.INNER)\n+\n+    isTemporalJoin && !canConvertToLookup && supportedJoinTypes.contains(join.getJoinType)\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val leftInput = call.rel[FlinkLogicalRel](1)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+\n+    val joinCondition = join.getCondition\n+\n+    val newJoinCondition = joinCondition.accept(new RexShuttle {\n+      override def visitCall(call: RexCall): RexNode = {\n+        if (call.getOperator == TemporalJoinUtil.TEMPORAL_JOIN_CONDITION &&\n+        isRowTimeTemporalTableJoin(snapshot)) {\n+          val snapshotTimeInputRef = call.operands(0)\n+          val rightTimeInputRef = call.operands(1)\n+          val leftJoinKey = call.operands(2).asInstanceOf[RexCall].operands\n+          val rightJoinKey = call.operands(3).asInstanceOf[RexCall].operands\n+\n+          val rexBuilder = join.getCluster.getRexBuilder\n+          val primaryKeyInputRefs = extractPrimaryKeyInputRefs(leftInput, snapshot, rexBuilder)\n+          if (primaryKeyInputRefs.isEmpty) {\n+            throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+              s\" primary key and row time attribute in versioned table,\" +\n+              s\" but no primary key found.\")\n+          }\n+          TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+            rightTimeInputRef, leftJoinKey, rightJoinKey, primaryKeyInputRefs.get)\n+        }\n+        else {\n+          super.visitCall(call)\n+        }\n+      }\n+    })\n+    val rewriteJoin = FlinkLogicalJoin.create(\n+      leftInput, snapshot, newJoinCondition, join.getJoinType)\n+    call.transformTo(rewriteJoin)\n+  }\n+\n+  private def extractPrimaryKeyInputRefs(\n+      leftInput: RelNode,\n+      snapshot: FlinkLogicalSnapshot,\n+      rexBuilder: RexBuilder): Option[Seq[RexNode]] = {\n+    val rightFields = snapshot.getRowType.getFieldList\n+    val fmq = FlinkRelMetadataQuery.reuseOrCreate(snapshot.getCluster.getMetadataQuery)\n+\n+    val uniqueKeys = fmq.getUniqueKeys(snapshot.getInput())\n+    val fields = snapshot.getRowType.getFieldList\n+\n+    if (uniqueKeys != null && uniqueKeys.size() > 0) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      uniqueKeys\n+        .filter(_.nonEmpty)\n+        .map(_.toArray\n+          .map(fields)\n+          .map(f => rexBuilder.makeInputRef(\n+            f.getType,\n+            leftFieldCnt + rightFields.indexOf(f)))\n+          .toSeq)\n+        .toArray\n+        .sortBy(_.length)\n+        .headOption", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMzEwMA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495903100", "bodyText": "nit: redundant blank", "author": "godfreyhe", "createdAt": "2020-09-28T12:33:50Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/TemporalJoinRewriteWithUniqueKeyRule.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.JoinRelType\n+import org.apache.calcite.rex.{RexBuilder, RexCall, RexNode, RexShuttle}\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.planner.plan.metadata.FlinkRelMetadataQuery\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalJoin, FlinkLogicalRel, FlinkLogicalSnapshot}\n+import org.apache.flink.table.planner.plan.rules.physical.common.CommonTemporalTableJoinRule\n+import org.apache.flink.table.planner.plan.schema.TimeIndicatorRelDataType\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+\n+import scala.collection.JavaConversions._\n+\n+/**\n+  * Planner rule that rewrites temporal join with extracted primary key, Event-time temporal\n+  * table join requires primary key and row time attribute of versioned table. The versioned table\n+  * could be a table source or a view only if it contains the unique key and time attribute.\n+  *\n+  * <p> Flink support extract the primary key and row time attribute from the view if the view comes\n+  * from [[LogicalRank]] node which can convert to a [[Deduplicate]] node.\n+  */\n+class TemporalJoinRewriteWithUniqueKeyRule extends RelOptRule(\n+  operand(classOf[FlinkLogicalJoin],\n+    operand(classOf[FlinkLogicalRel], any()),\n+    operand(classOf[FlinkLogicalSnapshot],\n+      operand(classOf[FlinkLogicalRel], any()))),\n+  \"TemporalJoinRewriteWithUniqueKeyRule\")\n+  with CommonTemporalTableJoinRule {\n+\n+  override def matches(call: RelOptRuleCall): Boolean = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+    val snapshotInput = call.rel[FlinkLogicalRel](3)\n+\n+    val isTemporalJoin = matches(snapshot)\n+    val canConvertToLookup = canConvertToLookupJoin(snapshot, snapshotInput)\n+    val supportedJoinTypes = Seq(JoinRelType.INNER)\n+\n+    isTemporalJoin && !canConvertToLookup && supportedJoinTypes.contains(join.getJoinType)\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val leftInput = call.rel[FlinkLogicalRel](1)\n+    val snapshot = call.rel[FlinkLogicalSnapshot](2)\n+\n+    val joinCondition = join.getCondition\n+\n+    val newJoinCondition = joinCondition.accept(new RexShuttle {\n+      override def visitCall(call: RexCall): RexNode = {\n+        if (call.getOperator == TemporalJoinUtil.TEMPORAL_JOIN_CONDITION &&\n+        isRowTimeTemporalTableJoin(snapshot)) {\n+          val snapshotTimeInputRef = call.operands(0)\n+          val rightTimeInputRef = call.operands(1)\n+          val leftJoinKey = call.operands(2).asInstanceOf[RexCall].operands\n+          val rightJoinKey = call.operands(3).asInstanceOf[RexCall].operands\n+\n+          val rexBuilder = join.getCluster.getRexBuilder\n+          val primaryKeyInputRefs = extractPrimaryKeyInputRefs(leftInput, snapshot, rexBuilder)\n+          if (primaryKeyInputRefs.isEmpty) {\n+            throw new ValidationException(\"Event-Time Temporal Table Join requires both\" +\n+              s\" primary key and row time attribute in versioned table,\" +\n+              s\" but no primary key found.\")\n+          }\n+          TemporalJoinUtil.makeRowTimeTemporalJoinConditionCall(rexBuilder, snapshotTimeInputRef,\n+            rightTimeInputRef, leftJoinKey, rightJoinKey, primaryKeyInputRefs.get)\n+        }\n+        else {\n+          super.visitCall(call)\n+        }\n+      }\n+    })\n+    val rewriteJoin = FlinkLogicalJoin.create(\n+      leftInput, snapshot, newJoinCondition, join.getJoinType)\n+    call.transformTo(rewriteJoin)\n+  }\n+\n+  private def extractPrimaryKeyInputRefs(\n+      leftInput: RelNode,\n+      snapshot: FlinkLogicalSnapshot,\n+      rexBuilder: RexBuilder): Option[Seq[RexNode]] = {\n+    val rightFields = snapshot.getRowType.getFieldList\n+    val fmq = FlinkRelMetadataQuery.reuseOrCreate(snapshot.getCluster.getMetadataQuery)\n+\n+    val uniqueKeys = fmq.getUniqueKeys(snapshot.getInput())\n+    val fields = snapshot.getRowType.getFieldList\n+\n+    if (uniqueKeys != null && uniqueKeys.size() > 0) {\n+      val leftFieldCnt = leftInput.getRowType.getFieldCount\n+      uniqueKeys\n+        .filter(_.nonEmpty)\n+        .map(_.toArray\n+          .map(fields)\n+          .map(f => rexBuilder.makeInputRef(\n+            f.getType,\n+            leftFieldCnt + rightFields.indexOf(f)))\n+          .toSeq)\n+        .toArray\n+        .sortBy(_.length)\n+        .headOption\n+    } else {\n+      None\n+    }\n+  }\n+\n+  private def isRowTimeTemporalTableJoin(snapshot: FlinkLogicalSnapshot): Boolean =\n+    snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if t.isEventTime => true\n+      case _ => false\n+    }\n+}\n+\n+object TemporalJoinRewriteWithUniqueKeyRule {\n+  val INSTANCE: TemporalJoinRewriteWithUniqueKeyRule = new TemporalJoinRewriteWithUniqueKeyRule\n+}\n+\n+", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNDY4MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495904681", "bodyText": "indent", "author": "godfreyhe", "createdAt": "2020-09-28T12:36:45Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -17,75 +17,152 @@\n  */\n package org.apache.flink.table.planner.plan.utils\n \n-import org.apache.flink.util.Preconditions.checkArgument\n-\n+import org.apache.calcite.rel.core.JoinInfo\n import org.apache.calcite.rex._\n import org.apache.calcite.sql.`type`.{OperandTypes, ReturnTypes}\n import org.apache.calcite.sql.{SqlFunction, SqlFunctionCategory, SqlKind}\n \n+import scala.collection.JavaConversions._\n+\n /**\n-  * Utilities for temporal table join\n+  * Utilities for temporal table join.\n   */\n object TemporalJoinUtil {\n \n   // ----------------------------------------------------------------------------------------\n-  //                          Temporal TableFunction Join Utilities\n+  //                          Temporal Join Condition Utilities\n   // ----------------------------------------------------------------------------------------\n \n   /**\n-    * [[TEMPORAL_JOIN_CONDITION]] is a specific condition which correctly defines\n+    * [[TEMPORAL_JOIN_CONDITION]] is a specific join condition which correctly defines\n     * references to rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute.\n-    * The condition is used to mark this is a temporal tablefunction join.\n-    * Later rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n-    * extracted from the condition.\n+    * The condition is used to mark this is a temporal table join and ensure columns these\n+    * expressions depends on will not be pruned. The join key pair is necessary to ensure the\n+    * the condition will not push down.\n+    *\n+    * The rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n+    * extracted from the condition in physical phase.\n     */\n   val TEMPORAL_JOIN_CONDITION = new SqlFunction(\n     \"__TEMPORAL_JOIN_CONDITION\",\n     SqlKind.OTHER_FUNCTION,\n     ReturnTypes.BOOLEAN_NOT_NULL,\n     null,\n     OperandTypes.or(\n+      // right time attribute and primary key are required in event-time temporal table join,\n+      OperandTypes.sequence(\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)'\",\n+        OperandTypes.DATETIME,\n+        OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY),\n+      // the primary key may inferred later in event-time temporal table join,\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n         OperandTypes.ANY),\n+      // Only left time attribute is required for processing-time temporal table join,\n+      // primary key is optional\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n         OperandTypes.ANY)),\n     SqlFunctionCategory.SYSTEM)\n \n-  def isRowtimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 3\n-  }\n+  val TEMPORAL_JOIN_LEFT_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_LEFT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_RIGHT_KEY = new SqlFunction(\n+    \"TEMPORAL_JOIN_RIGHT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_CONDITION_PRIMARY_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_CONDITION_PRIMARY_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n \n-  def isProctimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 2\n-  }\n \n   def makeRowTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n     rightTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode],\n+    rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNTA2MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495905061", "bodyText": "indent", "author": "godfreyhe", "createdAt": "2020-09-28T12:37:24Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -17,75 +17,152 @@\n  */\n package org.apache.flink.table.planner.plan.utils\n \n-import org.apache.flink.util.Preconditions.checkArgument\n-\n+import org.apache.calcite.rel.core.JoinInfo\n import org.apache.calcite.rex._\n import org.apache.calcite.sql.`type`.{OperandTypes, ReturnTypes}\n import org.apache.calcite.sql.{SqlFunction, SqlFunctionCategory, SqlKind}\n \n+import scala.collection.JavaConversions._\n+\n /**\n-  * Utilities for temporal table join\n+  * Utilities for temporal table join.\n   */\n object TemporalJoinUtil {\n \n   // ----------------------------------------------------------------------------------------\n-  //                          Temporal TableFunction Join Utilities\n+  //                          Temporal Join Condition Utilities\n   // ----------------------------------------------------------------------------------------\n \n   /**\n-    * [[TEMPORAL_JOIN_CONDITION]] is a specific condition which correctly defines\n+    * [[TEMPORAL_JOIN_CONDITION]] is a specific join condition which correctly defines\n     * references to rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute.\n-    * The condition is used to mark this is a temporal tablefunction join.\n-    * Later rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n-    * extracted from the condition.\n+    * The condition is used to mark this is a temporal table join and ensure columns these\n+    * expressions depends on will not be pruned. The join key pair is necessary to ensure the\n+    * the condition will not push down.\n+    *\n+    * The rightTimeAttribute, rightPrimaryKeyExpression and leftTimeAttribute will be\n+    * extracted from the condition in physical phase.\n     */\n   val TEMPORAL_JOIN_CONDITION = new SqlFunction(\n     \"__TEMPORAL_JOIN_CONDITION\",\n     SqlKind.OTHER_FUNCTION,\n     ReturnTypes.BOOLEAN_NOT_NULL,\n     null,\n     OperandTypes.or(\n+      // right time attribute and primary key are required in event-time temporal table join,\n+      OperandTypes.sequence(\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY, PRIMARY_KEY)'\",\n+        OperandTypes.DATETIME,\n+        OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY),\n+      // the primary key may inferred later in event-time temporal table join,\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, RIGHT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n         OperandTypes.ANY),\n+      // Only left time attribute is required for processing-time temporal table join,\n+      // primary key is optional\n       OperandTypes.sequence(\n-        \"'(LEFT_TIME_ATTRIBUTE, PRIMARY_KEY)'\",\n+        \"'(LEFT_TIME_ATTRIBUTE, LEFT_KEY, RIGHT_KEY)'\",\n         OperandTypes.DATETIME,\n+        OperandTypes.ANY,\n+        OperandTypes.ANY,\n         OperandTypes.ANY)),\n     SqlFunctionCategory.SYSTEM)\n \n-  def isRowtimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 3\n-  }\n+  val TEMPORAL_JOIN_LEFT_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_LEFT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_RIGHT_KEY = new SqlFunction(\n+    \"TEMPORAL_JOIN_RIGHT_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n+\n+  val TEMPORAL_JOIN_CONDITION_PRIMARY_KEY = new SqlFunction(\n+    \"__TEMPORAL_JOIN_CONDITION_PRIMARY_KEY\",\n+    SqlKind.OTHER_FUNCTION,\n+    ReturnTypes.BOOLEAN_NOT_NULL,\n+    null,\n+    OperandTypes.ARRAY,\n+    SqlFunctionCategory.SYSTEM)\n \n-  def isProctimeCall(call: RexCall): Boolean = {\n-    checkArgument(call.getOperator == TEMPORAL_JOIN_CONDITION)\n-    call.getOperands.size() == 2\n-  }\n \n   def makeRowTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n     rightTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode],\n+    rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {\n     rexBuilder.makeCall(\n       TEMPORAL_JOIN_CONDITION,\n       leftTimeAttribute,\n       rightTimeAttribute,\n+      makeLeftJoinKeyCall(rexBuilder, leftJoinKeyExpression),\n+      makeRightJoinKeyCall(rexBuilder, rightJoinKeyExpression),\n+      makePrimaryKeyCall(rexBuilder, rightPrimaryKeyExpression))\n+  }\n+\n+  def makeRowTimeTemporalJoinConditionCall(\n+      rexBuilder: RexBuilder,\n+      leftTimeAttribute: RexNode,\n+      rightTimeAttribute: RexNode,\n+      leftJoinKeyExpression: Seq[RexNode],\n+      rightJoinKeyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_CONDITION,\n+      leftTimeAttribute,\n+      rightTimeAttribute,\n+      makeLeftJoinKeyCall(rexBuilder, leftJoinKeyExpression),\n+      makeRightJoinKeyCall(rexBuilder, rightJoinKeyExpression))\n+  }\n+\n+  private def makePrimaryKeyCall(\n+      rexBuilder: RexBuilder,\n+      rightPrimaryKeyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_CONDITION_PRIMARY_KEY,\n       rightPrimaryKeyExpression)\n   }\n \n+  private def makeLeftJoinKeyCall(\n+      rexBuilder: RexBuilder,\n+      keyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_LEFT_KEY,\n+      keyExpression)\n+  }\n+\n+  private def makeRightJoinKeyCall(\n+      rexBuilder: RexBuilder,\n+      keyExpression: Seq[RexNode]): RexNode = {\n+    rexBuilder.makeCall(\n+      TEMPORAL_JOIN_RIGHT_KEY,\n+      keyExpression)\n+  }\n+\n   def makeProcTimeTemporalJoinConditionCall(\n     rexBuilder: RexBuilder,\n     leftTimeAttribute: RexNode,\n-    rightPrimaryKeyExpression: RexNode): RexNode = {\n+    leftJoinKeyExpression: Seq[RexNode],\n+    rightJoinKeyExpression: Seq[RexNode]): RexNode = {", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwNjA2Mw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495906063", "bodyText": "super.visitCall(call)", "author": "godfreyhe", "createdAt": "2020-09-28T12:39:12Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/TemporalJoinUtil.scala", "diffHunk": "@@ -103,4 +180,25 @@ object TemporalJoinUtil {\n     hasTemporalJoinCondition\n   }\n \n+  def isRowTimeJoin(rexBuilder: RexBuilder, joinInfo: JoinInfo): Boolean = {\n+    val nonEquiJoinRex = joinInfo.getRemaining(rexBuilder)\n+\n+    var rowtimeJoin: Boolean = false\n+    val visitor = new RexVisitorImpl[Unit](true) {\n+      override def visitCall(call: RexCall): Unit = {\n+        if (isRowTimeTemporalJoinConditionCall(call)) {\n+           rowtimeJoin = true\n+        } else {\n+          call.getOperands.foreach(node => node.accept(this))", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwOTM1Mg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495909352", "bodyText": "move them into before method", "author": "godfreyhe", "createdAt": "2020-09-28T12:44:55Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,95 +17,136 @@\n  */\n package org.apache.flink.table.planner.plan.batch.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.TableException\n import org.apache.flink.table.planner.utils.{BatchTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in batch mode.\n+ *\n+ * <p> Flink only supports lookup join in batch mode, the others Temporal join is not supported yet.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: BatchTableTestUtil = batchTestUtil()\n \n-  val orders = util.addDataStream[(Long, String, Timestamp)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'true'\n+      |)\n+      \"\"\".stripMargin)\n+\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n+\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT currency, rate, proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T\" +\n+      \"  WHERE rowNum = 1\")\n+\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxMTUzMA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495911530", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T12:48:25Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNDQ5OQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495914499", "bodyText": "another case: join keys does not match pk", "author": "godfreyhe", "createdAt": "2020-09-28T12:53:15Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val ratesHistory = util.addDataStream[(String, Int, Timestamp)](\n-    \"RatesHistory\", 'currency, 'rate, 'rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  util.addFunction(\n-    \"Rates\",\n-    ratesHistory.createTemporalTableFunction($\"rowtime\", $\"currency\"))\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val proctimeOrders = util.addDataStream[(Long, String)](\n-    \"ProctimeOrders\", 'o_amount, 'o_currency, 'o_proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n \n-  private val proctimeRatesHistory = util.addDataStream[(String, Int)](\n-    \"ProctimeRatesHistory\", 'currency, 'rate, 'proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT T.currency, T.rate, T.proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T \" +\n+      \"  WHERE T.rowNum = 1\")\n \n-  util.addFunction(\n-    \"ProctimeRates\",\n-    proctimeRatesHistory.createTemporalTableFunction($\"proctime\", $\"currency\"))\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")\n \n   @Test\n-  def testSimpleJoin(): Unit = {\n+  def testEventTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testSimpleProctimeJoin(): Unit = {\n+  def testEventTimeTemporalJoinWithView(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM ProctimeOrders AS o, \" +\n-      \"LATERAL TABLE (ProctimeRates(o.o_proctime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"DeduplicatedView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_rowtime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testJoinOnQueryLeft(): Unit = {\n-    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n-    util.tableEnv.createTemporaryView(\"Orders2\", orders)\n-\n+  def testProcTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders2 AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"latestView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n-  /**\n-    * Test versioned joins with more complicated query.\n-    * Important thing here is that we have complex OR join condition\n-    * and there are some columns that are not being used (are being pruned).\n-    */\n   @Test\n-  def testComplexJoin(): Unit = {\n-    val util = streamTestUtil()\n-    util.addDataStream[(String, Int)](\"Table3\", 't3_comment, 't3_secondary_key)\n-    util.addDataStream[(Timestamp, String, Long, String, Int)](\n-      \"Orders\", 'o_rowtime.rowtime, 'o_comment, 'o_amount, 'o_currency, 'o_secondary_key)\n-\n-    util.addDataStream[(Timestamp, String, String, Int, Int)](\n-      \"RatesHistory\", 'rowtime.rowtime, 'comment, 'currency, 'rate, 'secondary_key)\n-    val rates = util.tableEnv\n-      .sqlQuery(\"SELECT * FROM RatesHistory WHERE rate > 110\")\n-      .createTemporalTableFunction($\"rowtime\", $\"currency\")\n-    util.addTemporarySystemFunction(\"Rates\", rates)\n-\n-    val sqlQuery =\n-      \"SELECT * FROM \" +\n-        \"(SELECT \" +\n-        \"o_amount * rate as rate, \" +\n-        \"secondary_key as secondary_key \" +\n-        \"FROM Orders AS o, \" +\n-        \"LATERAL TABLE (Rates(o_rowtime)) AS r \" +\n-        \"WHERE currency = o_currency OR secondary_key = o_secondary_key), \" +\n-        \"Table3 \" +\n-        \"WHERE t3_secondary_key = secondary_key\"\n+  def testProcTimeTemporalJoinWithView(): Unit = {\n+    val sqlQuery = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"latest_rates \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testUncorrelatedJoin(): Unit = {\n-    expectedException.expect(classOf[TableException])\n-    expectedException.expectMessage(containsString(\"Cannot generate a valid execution plan\"))\n+  def testInvalidTemporalTablJoin(): Unit = {\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE leftTableWithoutTimeAttribute (\n+        | o_amount INT,\n+        | o_currency STRING,\n+        | o_time TIMESTAMP(3)\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery1 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM leftTableWithoutTimeAttribute AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_time as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery1,\n+      s\"Temporal table join currently only supports 'FOR SYSTEM_TIME AS OF'\" +\n+        s\" left table's time attribute field\",\n+      classOf[ValidationException])\n \n-    val sqlQuery = \"SELECT \" +\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutPk (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | WATERMARK FOR rowtime AS rowtime\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery2 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutPk FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery2,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no primary key found.\",\n+      classOf[ValidationException])\n+\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutTimeAttribute (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | PRIMARY KEY(currency) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery3 = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(TIMESTAMP '2016-06-27 10:10:42.123')) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutTimeAttribute FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery3,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no row time attribute found.\",\n+      classOf[ValidationException])\n \n-    util.verifyExplain(sqlQuery)\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE versionedTableWithoutRowtime (\n+        | currency STRING,\n+        | rate INT,\n+        | rowtime TIMESTAMP(3),\n+        | proctime AS PROCTIME(),\n+        | PRIMARY KEY(currency) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+    val sqlQuery4 = \"SELECT \" +\n+      \"o_amount * rate as rate \" +\n+      \"FROM Orders AS o JOIN \" +\n+      \"versionedTableWithoutRowtime FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n+    expectExceptionThrown(\n+      sqlQuery4,\n+      s\"Event-Time Temporal Table Join requires both primary key and row time attribute in \" +\n+        s\"versioned table, but no row time attribute found.\",\n+      classOf[ValidationException])", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxNTQ1Ng==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495915456", "bodyText": "other cases: non-equal join condition,  equal join condition with other predicates, etc", "author": "godfreyhe", "createdAt": "2020-09-28T12:54:46Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.scala", "diffHunk": "@@ -17,129 +17,256 @@\n  */\n package org.apache.flink.table.planner.plan.stream.sql.join\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.table.api._\n+import org.apache.flink.table.api.ValidationException\n import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}\n-\n-import org.hamcrest.Matchers.containsString\n+import org.junit.Assert.{assertTrue, fail}\n import org.junit.Test\n \n-import java.sql.Timestamp\n-\n+/**\n+ * Test temporal join in stream mode.\n+ */\n class TemporalJoinTest extends TableTestBase {\n \n   val util: StreamTableTestUtil = streamTestUtil()\n \n-  private val orders = util.addDataStream[(Long, String)](\n-    \"Orders\", 'o_amount, 'o_currency, 'o_rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE Orders (\n+      | o_amount INT,\n+      | o_currency STRING,\n+      | o_rowtime TIMESTAMP(3),\n+      | o_proctime as PROCTIME(),\n+      | WATERMARK FOR o_rowtime AS o_rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistory (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val ratesHistory = util.addDataStream[(String, Int, Timestamp)](\n-    \"RatesHistory\", 'currency, 'rate, 'rowtime.rowtime)\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesHistoryWithPK (\n+      | currency STRING,\n+      | rate INT,\n+      | rowtime TIMESTAMP(3),\n+      | WATERMARK FOR rowtime AS rowtime,\n+      | PRIMARY KEY(currency) NOT ENFORCED\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  util.addFunction(\n-    \"Rates\",\n-    ratesHistory.createTemporalTableFunction($\"rowtime\", $\"currency\"))\n+  util.addTable(\n+    \"\"\"\n+      |CREATE TABLE RatesOnly (\n+      | currency STRING,\n+      | rate INT,\n+      | proctime AS PROCTIME()\n+      |) WITH (\n+      | 'connector' = 'COLLECTION',\n+      | 'is-bounded' = 'false'\n+      |)\n+      \"\"\".stripMargin)\n \n-  private val proctimeOrders = util.addDataStream[(Long, String)](\n-    \"ProctimeOrders\", 'o_amount, 'o_currency, 'o_proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW DeduplicatedView as SELECT currency, rate, rowtime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY rowtime DESC) AS rowNum \" +\n+      \"   FROM RatesHistory\" +\n+      \"  ) T \" +\n+      \"  WHERE rowNum = 1\")\n \n-  private val proctimeRatesHistory = util.addDataStream[(String, Int)](\n-    \"ProctimeRatesHistory\", 'currency, 'rate, 'proctime.proctime)\n+  util.addTable(\n+    \" CREATE VIEW latestView as SELECT T.currency, T.rate, T.proctime FROM \" +\n+      \"  (SELECT *, \" +\n+      \"          ROW_NUMBER() OVER (PARTITION BY currency ORDER BY proctime DESC) AS rowNum \" +\n+      \"   FROM RatesOnly\" +\n+      \"  ) T \" +\n+      \"  WHERE T.rowNum = 1\")\n \n-  util.addFunction(\n-    \"ProctimeRates\",\n-    proctimeRatesHistory.createTemporalTableFunction($\"proctime\", $\"currency\"))\n+  util.addTable(\"CREATE VIEW latest_rates AS SELECT currency, LAST_VALUE(rate) AS rate \" +\n+    \"FROM RatesHistory \" +\n+    \"GROUP BY currency \")\n \n   @Test\n-  def testSimpleJoin(): Unit = {\n+  def testEventTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"RatesHistoryWithPK FOR SYSTEM_TIME AS OF o.o_rowtime as r \" +\n+      \"on o.o_currency = r.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testSimpleProctimeJoin(): Unit = {\n+  def testEventTimeTemporalJoinWithView(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM ProctimeOrders AS o, \" +\n-      \"LATERAL TABLE (ProctimeRates(o.o_proctime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"DeduplicatedView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_rowtime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n   @Test\n-  def testJoinOnQueryLeft(): Unit = {\n-    val orders = util.tableEnv.sqlQuery(\"SELECT * FROM Orders WHERE o_amount > 1000\")\n-    util.tableEnv.createTemporaryView(\"Orders2\", orders)\n-\n+  def testProcTimeTemporalJoin(): Unit = {\n     val sqlQuery = \"SELECT \" +\n       \"o_amount * rate as rate \" +\n-      \"FROM Orders2 AS o, \" +\n-      \"LATERAL TABLE (Rates(o.o_rowtime)) AS r \" +\n-      \"WHERE currency = o_currency\"\n+      \"FROM Orders AS o JOIN \" +\n+      \"latestView \" +\n+      \"FOR SYSTEM_TIME AS OF o.o_proctime as r1 \" +\n+      \"on o.o_currency = r1.currency\"\n \n     util.verifyPlan(sqlQuery)\n   }\n \n-  /**\n-    * Test versioned joins with more complicated query.\n-    * Important thing here is that we have complex OR join condition\n-    * and there are some columns that are not being used (are being pruned).\n-    */\n   @Test\n-  def testComplexJoin(): Unit = {\n-    val util = streamTestUtil()\n-    util.addDataStream[(String, Int)](\"Table3\", 't3_comment, 't3_secondary_key)\n-    util.addDataStream[(Timestamp, String, Long, String, Int)](\n-      \"Orders\", 'o_rowtime.rowtime, 'o_comment, 'o_amount, 'o_currency, 'o_secondary_key)\n-\n-    util.addDataStream[(Timestamp, String, String, Int, Int)](\n-      \"RatesHistory\", 'rowtime.rowtime, 'comment, 'currency, 'rate, 'secondary_key)\n-    val rates = util.tableEnv\n-      .sqlQuery(\"SELECT * FROM RatesHistory WHERE rate > 110\")\n-      .createTemporalTableFunction($\"rowtime\", $\"currency\")\n-    util.addTemporarySystemFunction(\"Rates\", rates)\n-\n-    val sqlQuery =\n-      \"SELECT * FROM \" +\n-        \"(SELECT \" +\n-        \"o_amount * rate as rate, \" +\n-        \"secondary_key as secondary_key \" +\n-        \"FROM Orders AS o, \" +\n-        \"LATERAL TABLE (Rates(o_rowtime)) AS r \" +\n-        \"WHERE currency = o_currency OR secondary_key = o_secondary_key), \" +\n-        \"Table3 \" +\n-        \"WHERE t3_secondary_key = secondary_key\"\n+  def testProcTimeTemporalJoinWithView(): Unit = {", "originalCommit": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "url": "https://github.com/apache/flink/commit/b0e40b37f7993240764dce3280c9c59d5b0b6e75", "message": "add tests", "committedDate": "2020-10-14T10:37:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY0NzU3MA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r504647570", "bodyText": "The join will be translated into [[StreamExecLookupJoin]] or [[StreamExecTemporalJoin]] in physical.", "author": "godfreyhe", "createdAt": "2020-10-14T12:47:31Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRule.scala", "diffHunk": "@@ -17,19 +17,32 @@\n  */\n package org.apache.flink.table.planner.plan.rules.logical\n \n-import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n-\n import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.plan.hep.{HepPlanner, HepRelVertex}\n import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelOptRuleOperand}\n import org.apache.calcite.rel.RelNode\n-import org.apache.calcite.rel.logical.{LogicalCorrelate, LogicalFilter, LogicalSnapshot}\n-import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess, RexInputRef, RexNode, RexShuttle}\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical._\n+import org.apache.calcite.rex._\n+\n+import org.apache.flink.table.api.ValidationException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory.isRowtimeIndicatorType\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.planner.plan.utils.TemporalJoinUtil\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.JavaConverters._\n \n /**\n   * The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into a Join\n   * to make join condition can be pushed-down. The join will be translated into\n-  * [[StreamExecLookupJoin]] in physical and might be translated into [[StreamExecTemporalJoin]]\n-  * in the future.\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].", "originalCommit": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY2MDk4NQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r504660985", "bodyText": "move this close to testGetUniqueKeysOnStreamExecDeduplicate method", "author": "godfreyhe", "createdAt": "2020-10-14T13:06:52Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUniqueKeysTest.scala", "diffHunk": "@@ -70,6 +70,16 @@ class FlinkRelMdUniqueKeysTest extends FlinkRelMdHandlerTestBase {\n     assertEquals(uniqueKeys(Array(0)), mq.getUniqueKeys(logicalFilter).toSet)\n   }\n \n+  @Test\n+  def testGetUniqueKeysOnWatermark(): Unit = {\n+    assertEquals(uniqueKeys(Array(0)), mq.getUniqueKeys(logicalWatermarkAssigner).toSet)\n+  }\n+\n+  @Test\n+  def testGetUniqueKeysOnRowtimeDeduplicate(): Unit = {", "originalCommit": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7f001da22368aed31002c28199b4f97d2a2b63b", "url": "https://github.com/apache/flink/commit/e7f001da22368aed31002c28199b4f97d2a2b63b", "message": "add more tests", "committedDate": "2020-10-14T16:22:09Z", "type": "forcePushed"}, {"oid": "9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "url": "https://github.com/apache/flink/commit/9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "message": "add more tests(changelogmode tests)", "committedDate": "2020-10-15T02:08:45Z", "type": "forcePushed"}, {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f", "url": "https://github.com/apache/flink/commit/55acd8f52fd5df5316efd04068754cdeca4d612f", "message": "add more tests(changelogmode tests)", "committedDate": "2020-10-15T02:46:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjE1MQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505142151", "bodyText": "it's better we can do some refactor, many test cases do not involve aggregation", "author": "godfreyhe", "createdAt": "2020-10-15T03:25:32Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/physical/stream/ChangelogModeInferenceTest.scala", "diffHunk": "@@ -73,6 +122,28 @@ class ChangelogModeInferenceTest(aggMode: AggMode) extends TableTestBase {\n     util.verifyPlan(sql, ExplainDetail.CHANGELOG_MODE)\n   }\n \n+  @Test\n+  def testTemporalJoinWithDeduplicateView(): Unit = {", "originalCommit": "55acd8f52fd5df5316efd04068754cdeca4d612f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0NDQ1MA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505144450", "bodyText": "both StreamExecTemporalJoinRule and TemporalJoinRewriteWithUniqueKeyRule will use this method indirectly, while StreamExecTemporalJoinRule is used in volcano planner.", "author": "godfreyhe", "createdAt": "2020-10-15T03:35:09Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/common/CommonTemporalTableJoinRule.scala", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.common\n+\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.connector.source.LookupTableSource\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalLegacyTableSourceScan, FlinkLogicalRel, FlinkLogicalSnapshot, FlinkLogicalTableSourceScan}\n+import org.apache.flink.table.planner.plan.nodes.physical.stream.{StreamExecLookupJoin, StreamExecTemporalJoin}\n+import org.apache.flink.table.planner.plan.schema.{LegacyTableSourceTable, TableSourceTable, TimeIndicatorRelDataType}\n+import org.apache.flink.table.sources.LookupableTableSource\n+\n+import org.apache.calcite.plan.hep.HepRelVertex\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rel.core.TableScan\n+import org.apache.calcite.rel.logical.{LogicalProject, LogicalTableScan}\n+import org.apache.calcite.rex.{RexCorrelVariable, RexFieldAccess}\n+\n+/**\n+  * Base implementation that matches temporal join node.\n+  *\n+  * <p> The initial temporal table join (FOR SYSTEM_TIME AS OF) is a Correlate, rewrite it into\n+  * a Join to make join condition can be pushed-down. The join will be translated into\n+  * [[StreamExecLookupJoin]] in physical or translated into [[StreamExecTemporalJoin]].\n+  */\n+trait CommonTemporalTableJoinRule {\n+\n+  protected def matches(snapshot: FlinkLogicalSnapshot): Boolean = {\n+\n+    // period specification check\n+    snapshot.getPeriod match {\n+      // it's left table's field, pass\n+      case r: RexFieldAccess if r.getReferenceExpr.isInstanceOf[RexCorrelVariable] =>\n+      case _ =>\n+        throw new TableException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field, doesn't support 'PROCTIME()'\")\n+    }\n+\n+    snapshot.getPeriod.getType match {\n+      // supports both event-time and processing time\n+      case t: TimeIndicatorRelDataType =>\n+      case _ =>\n+        throw new TableException(\"Temporal table join currently only supports \" +\n+          \"'FOR SYSTEM_TIME AS OF' left table's time attribute field\")\n+    }\n+    true\n+  }\n+\n+  protected def canConvertToLookupJoin(\n+      snapshot: FlinkLogicalSnapshot,\n+      snapshotInput: FlinkLogicalRel): Boolean = {\n+    val isProcessingTime = snapshot.getPeriod.getType match {\n+      case t: TimeIndicatorRelDataType if !t.isEventTime => true\n+      case _ => false\n+    }\n+\n+    val tableScan = getTableScan(snapshotInput)\n+    val snapshotOnLookupSource = tableScan match {\n+      case Some(scan) => isTableSourceScan(scan) && isLookupTableSource(scan)\n+      case _ => false\n+    }\n+\n+    isProcessingTime && snapshotOnLookupSource\n+  }\n+\n+  private def getTableScan(snapshotInput: RelNode): Option[TableScan] = {\n+    snapshotInput match {\n+      case tableScan: TableScan\n+      => Some(tableScan)\n+      // computed column on lookup table\n+      case project: LogicalProject if trimHep(project.getInput).isInstanceOf[TableScan]\n+      => Some(trimHep(project.getInput).asInstanceOf[TableScan])\n+      case _ => None\n+    }\n+  }\n+\n+  private def isTableSourceScan(relNode: RelNode): Boolean = {\n+    relNode match {\n+      case r: LogicalTableScan =>\n+        val table = r.getTable\n+        table match {\n+          case _: LegacyTableSourceTable[Any] | _: TableSourceTable => true\n+          case _ => false\n+        }\n+      case _: FlinkLogicalLegacyTableSourceScan | _: FlinkLogicalTableSourceScan => true\n+      case _ => false\n+    }\n+  }\n+\n+  private def isLookupTableSource(relNode: RelNode): Boolean = relNode match {\n+    case scan: FlinkLogicalLegacyTableSourceScan =>\n+      scan.tableSource.isInstanceOf[LookupableTableSource[_]]\n+    case scan: FlinkLogicalTableSourceScan =>\n+      scan.tableSource.isInstanceOf[LookupTableSource]\n+    case scan: LogicalTableScan =>\n+      scan.getTable match {\n+        case table: LegacyTableSourceTable[_] =>\n+          table.tableSource.isInstanceOf[LookupableTableSource[_]]\n+        case table: TableSourceTable =>\n+          table.tableSource.isInstanceOf[LookupTableSource]\n+        case _ => false\n+      }\n+    case _ => false\n+  }\n+\n+  /** Trim out the HepRelVertex wrapper and get current relational expression. */\n+  protected def trimHep(node: RelNode): RelNode = {", "originalCommit": "55acd8f52fd5df5316efd04068754cdeca4d612f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3NDgwOA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505174808", "bodyText": "add a test about right join and full join", "author": "godfreyhe", "createdAt": "2020-10-15T05:35:40Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRuleTest.scala", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule\n+import org.apache.calcite.plan.hep.HepMatchOrder\n+import org.apache.calcite.tools.RuleSets\n+\n+import org.apache.flink.api.scala._\n+import org.apache.flink.table.api._\n+import org.apache.flink.table.planner.plan.optimize.program.{FlinkChainedProgram, FlinkHepRuleSetProgramBuilder, HEP_RULES_EXECUTION_TYPE, StreamOptimizeContext}\n+import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase, TableTestUtil}\n+import org.junit.{Before, Test}\n+\n+/**\n+ * Test for [[LogicalCorrelateToJoinFromTemporalTableRule]].\n+ */\n+class LogicalCorrelateToJoinFromTemporalTableRuleTest extends TableTestBase {", "originalCommit": "69b257fae4b61dd7e2df59afccdf83da9c85a70a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3NjQzNg==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505176436", "bodyText": "also add a test about non-equal condition", "author": "godfreyhe", "createdAt": "2020-10-15T05:40:45Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/LogicalCorrelateToJoinFromTemporalTableRuleTest.scala", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical\n+\n+import org.apache.calcite.plan.RelOptRule\n+import org.apache.calcite.plan.hep.HepMatchOrder\n+import org.apache.calcite.tools.RuleSets\n+\n+import org.apache.flink.api.scala._\n+import org.apache.flink.table.api._\n+import org.apache.flink.table.planner.plan.optimize.program.{FlinkChainedProgram, FlinkHepRuleSetProgramBuilder, HEP_RULES_EXECUTION_TYPE, StreamOptimizeContext}\n+import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase, TableTestUtil}\n+import org.junit.{Before, Test}\n+\n+/**\n+ * Test for [[LogicalCorrelateToJoinFromTemporalTableRule]].\n+ */\n+class LogicalCorrelateToJoinFromTemporalTableRuleTest extends TableTestBase {\n+\n+  protected val util: StreamTableTestUtil = streamTestUtil()\n+\n+  @Before\n+  def setup(): Unit = {\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE T1 (\n+        | id STRING,\n+        | mount INT,\n+        | proctime as PROCTIME(),\n+        | rowtime TIMESTAMP(3),\n+        | WATERMARK FOR rowtime AS rowtime\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+\n+    //lookup table, CollectionTableSource implements LookupableTableSource interface\n+    util.addTable(\n+      \"\"\"\n+        |CREATE TABLE T2 (\n+        | id STRING,\n+        | rate INT,\n+        | PRIMARY KEY(id) NOT ENFORCED\n+        |) WITH (\n+        | 'connector' = 'COLLECTION',\n+        | 'is-bounded' = 'false'\n+        |)\n+      \"\"\".stripMargin)\n+\n+    // non-lookup table\n+    util.addTableSource[(String, Int)](\"T3\", 'id, 'rate, 'rowtime.rowtime())\n+  }\n+\n+  @Test\n+  def testLookupJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.LOOKUP_JOIN_WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T2 FOR SYSTEM_TIME AS OF T1.proctime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testLeftLookupJoinOnTrue(): Unit = {\n+    // lookup join also does not support ON TRUE condition in runtime\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.LOOKUP_JOIN_WITHOUT_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 LEFT JOIN T2 FOR SYSTEM_TIME AS OF \" +\n+      \"T1.proctime AS dimTable ON TRUE\")\n+  }\n+\n+  @Test\n+  def testProcTimeTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T3 FOR SYSTEM_TIME AS OF T1.proctime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testRowTimeTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 JOIN T3 FOR SYSTEM_TIME AS OF T1.rowtime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testRowTimeLeftTemporalJoinWithFilter(): Unit = {\n+    setUpCurrentRule(LogicalCorrelateToJoinFromTemporalTableRule.WITH_FILTER)\n+    util.verifyPlan(\"SELECT * FROM T1 LEFT JOIN T3 FOR SYSTEM_TIME AS OF T1.rowtime AS dimTable \" +\n+      \"ON T1.id = dimTable.id AND dimTable.rate > 10\")\n+  }\n+\n+  @Test\n+  def testLookupJoinOnTrue(): Unit = {", "originalCommit": "69b257fae4b61dd7e2df59afccdf83da9c85a70a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3ODE4MA==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505178180", "bodyText": "Does runtime support left join? this change should be covered by at least one IT case", "author": "godfreyhe", "createdAt": "2020-10-15T05:46:16Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -241,7 +233,7 @@ class StreamExecTemporalJoinToCoProcessTranslator private (\n     val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n     val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n     joinType match {\n-      case JoinRelType.INNER =>\n+      case JoinRelType.INNER | JoinRelType.LEFT =>", "originalCommit": "69b257fae4b61dd7e2df59afccdf83da9c85a70a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTIwNDYyMQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r505204621", "bodyText": "Yes, runtime will support left join in next PR", "author": "leonardBang", "createdAt": "2020-10-15T06:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE3ODE4MA=="}], "type": "inlineReview"}, {"oid": "bb79e997201a60f34a935ee41905bbbb3969d6e8", "url": "https://github.com/apache/flink/commit/bb79e997201a60f34a935ee41905bbbb3969d6e8", "message": "[FLINK-19072][table-planner] Import Temporal Table join rule for stream", "committedDate": "2020-10-15T13:48:37Z", "type": "commit"}, {"oid": "a4175b42f65fec599c2821e33bce595b07cd8083", "url": "https://github.com/apache/flink/commit/a4175b42f65fec599c2821e33bce595b07cd8083", "message": "[FLINK-19073][table-planner] Imporve streamExecTemporalJoinRule for stream", "committedDate": "2020-10-15T13:49:08Z", "type": "commit"}, {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-10-15T13:50:07Z", "type": "commit"}, {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-10-15T13:50:07Z", "type": "forcePushed"}]}