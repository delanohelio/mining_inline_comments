{"pr_number": 13596, "pr_title": "[FLINK-19475] Implement a time service for the batch execution mode", "pr_createdAt": "2020-10-12T15:36:02Z", "pr_url": "https://github.com/apache/flink/pull/13596", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503729515", "bodyText": "This relies on setCurrentKey only being called for key changes, not on every element, right?", "author": "aljoscha", "createdAt": "2020-10-13T07:34:56Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeService.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimerHeapInternalTimer;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.function.BiConsumerWithException;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An implementation of a {@link InternalTimerService} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeService<K, N> implements InternalTimerService<N> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\t/**\n+\t * Processing time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> processingTimeTimersQueue;\n+\n+\t/**\n+\t * Event time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> eventTimeTimersQueue;\n+\n+\t/**\n+\t * The local event time, as denoted by the last received\n+\t * {@link org.apache.flink.streaming.api.watermark.Watermark Watermark}.\n+\t */\n+\tprivate long currentWatermark = Long.MIN_VALUE;\n+\n+\tprivate final Triggerable<K, N> triggerTarget;\n+\n+\tprivate K currentKey;\n+\n+\tBatchExecutionInternalTimeService(\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tTriggerable<K, N> triggerTarget) {\n+\n+\t\tthis.processingTimeService = checkNotNull(processingTimeService);\n+\t\tthis.triggerTarget = checkNotNull(triggerTarget);\n+\n+\t\tthis.processingTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t\tthis.eventTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic long currentProcessingTime() {\n+\t\treturn processingTimeService.getCurrentProcessingTime();\n+\t}\n+\n+\t@Override\n+\tpublic long currentWatermark() {\n+\t\treturn currentWatermark;\n+\t}\n+\n+\t@Override\n+\tpublic void registerProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void registerEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void forEachEventTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\t@Override\n+\tpublic void forEachProcessingTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\tpublic void setCurrentKey(K currentKey) throws Exception {", "originalCommit": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzczMDc5OA==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503730798", "bodyText": "Yes. I will change it to check if the key changed. Good point.", "author": "dawidwys", "createdAt": "2020-10-13T07:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNzc2OA==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503817768", "bodyText": "Had the same comment as @aljoscha plus, shouldn't we here prevent the user-code from registering any new timers? If not, it looks like we risk ending up in a loop where every fired timer will register a new one, right?\nWe can simply add in the register timer if(watermark ==Long.MAX) -> ignore or sth like that. Same for processing time (and I think it is ok to check again the watermark).\nIn addition, we are relying on each key being processed in its entirety and then move to the next, which is totally valid. In this case, I think we should somehow disable the DataStreamUtils.reinterpretAsKeyedStream() for batch because, if I am not mistaken, it messes things up, right? Maybe at another ticket @dawidwys ?", "author": "kl0u", "createdAt": "2020-10-13T09:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg0ODQ5OA==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503848498", "bodyText": "As for the:\n\nIf not, it looks like we risk ending up in a loop where every fired timer will register a new one, right?\nWe can simply add in the register timer if(watermark ==Long.MAX) -> ignore or sth like that. Same for processing time (and I think it is ok to check again the watermark).\n\nIf I am not mistaken that's also the current behaviour in a regular timer service. If you register a timer for time < currentWatermark you might end up in an infinite loop. Not sure if we should diverge the two implementations.", "author": "dawidwys", "createdAt": "2020-10-13T10:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg0OTMxNQ==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503849315", "bodyText": "I don't think reinterpretAsKeyedStream breaks anything. It just tells the stream is keyed. The sorting/grouping happens on the receiver side.", "author": "dawidwys", "createdAt": "2020-10-13T10:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg1NDc1NQ==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503854755", "bodyText": "What if it is the source \"chain\"? Which I think is the main usecase. \"I have my Kafka input stream already grouped by key(group) so avoid the extra shuffle.\"", "author": "kl0u", "createdAt": "2020-10-13T10:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg1NzU0MA==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503857540", "bodyText": "As for the infinite loop, before we were \"assuming\" (maybe not correctly) that we are in an \"unbounded stream\" scenario, where there is no \"MAX_WATERMARK\". Of course this can happen at any point in time if we keep on registering timers for \"earlier\", but for that, there is no easy way of correcting it. Now, at the end of the stream, even if the user writes correct code that registers a timer to periodically execute something, this may lead to an infinite loop if the user-code does not check for MAX_WATERMARK.", "author": "kl0u", "createdAt": "2020-10-13T10:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkyMDM4MA==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503920380", "bodyText": "Good point with the chaining. I will keep that in mind when exposing this feature.", "author": "dawidwys", "createdAt": "2020-10-13T12:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzMzA2Nw==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503933067", "bodyText": "After some more thinking, I agree with you @kl0u in regards to registering timers in the callback. Any such patterns that make sense in streaming, do not necessarily make sense in BATCH and will result in pausing the processing for a longer period of time.\nI will quiesce the timer service as you suggested.", "author": "dawidwys", "createdAt": "2020-10-13T13:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcyOTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzAwNg==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503813006", "bodyText": "I would add a checkNotNull().", "author": "kl0u", "createdAt": "2020-10-13T09:41:50Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -174,6 +176,14 @@ public StateBackend getStateBackend() {\n \t\treturn this.stateBackend;\n \t}\n \n+\tpublic InternalTimeServiceManager.Provider getTimerServiceProvider() {\n+\t\treturn timerServiceProvider;\n+\t}\n+\n+\tpublic void setTimerServiceProvider(InternalTimeServiceManager.Provider timerServiceProvider) {\n+\t\tthis.timerServiceProvider = timerServiceProvider;", "originalCommit": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzY5Mw==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503813693", "bodyText": "What about a checkNotNull?", "author": "kl0u", "createdAt": "2020-10-13T09:42:52Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeServiceManager.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyedStateBackend;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.operators.InternalTimeServiceManager;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.KeyContext;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.WrappingRuntimeException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of a {@link InternalTimeServiceManager} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeServiceManager<K> implements InternalTimeServiceManager<K>,\n+\t\tKeyedStateBackend.KeySelectionListener<K> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\tprivate final Map<String, BatchExecutionInternalTimeService<K, ?>> timerServices = new HashMap<>();\n+\n+\tpublic BatchExecutionInternalTimeServiceManager(ProcessingTimeService processingTimeService) {\n+\t\tthis.processingTimeService = processingTimeService;", "originalCommit": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNDA3Mw==", "url": "https://github.com/apache/flink/pull/13596#discussion_r503814073", "bodyText": "This could be a checkState right?", "author": "kl0u", "createdAt": "2020-10-13T09:43:28Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeServiceManager.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupStatePartitionStreamProvider;\n+import org.apache.flink.runtime.state.KeyedStateBackend;\n+import org.apache.flink.runtime.state.StateSnapshotContext;\n+import org.apache.flink.streaming.api.operators.InternalTimeServiceManager;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.KeyContext;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.WrappingRuntimeException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of a {@link InternalTimeServiceManager} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeServiceManager<K> implements InternalTimeServiceManager<K>,\n+\t\tKeyedStateBackend.KeySelectionListener<K> {\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\tprivate final Map<String, BatchExecutionInternalTimeService<K, ?>> timerServices = new HashMap<>();\n+\n+\tpublic BatchExecutionInternalTimeServiceManager(ProcessingTimeService processingTimeService) {\n+\t\tthis.processingTimeService = processingTimeService;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <N> InternalTimerService<N> getInternalTimerService(\n+\t\t\tString name,\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tTriggerable<K, N> triggerable) {\n+\t\tBatchExecutionInternalTimeService<K, N> timerService =\n+\t\t\t(BatchExecutionInternalTimeService<K, N>) timerServices.get(name);\n+\t\tif (timerService == null) {\n+\t\t\ttimerService = new BatchExecutionInternalTimeService<>(\n+\t\t\t\tprocessingTimeService,\n+\t\t\t\ttriggerable\n+\t\t\t);\n+\t\t\ttimerServices.put(name, timerService);\n+\t\t}\n+\n+\t\treturn timerService;\n+\t}\n+\n+\t@Override\n+\tpublic void advanceWatermark(Watermark watermark) {\n+\t\tif (watermark.getTimestamp() == Long.MAX_VALUE) {\n+\t\t\tkeySelected(null);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void snapshotState(\n+\t\t\tStateSnapshotContext context,\n+\t\t\tString operatorName) throws Exception {\n+\t\tthrow new UnsupportedOperationException(\"Checkpoints are not supported in BATCH execution\");\n+\t}\n+\n+\tpublic static <K> InternalTimeServiceManager<K> create(\n+\t\t\tCheckpointableKeyedStateBackend<K> keyedStatedBackend,\n+\t\t\tClassLoader userClassloader,\n+\t\t\tKeyContext keyContext, //the operator\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tIterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) {\n+\t\tif (!(keyedStatedBackend instanceof BatchExecutionKeyedStateBackend)) {", "originalCommit": "961ff3e8d8e3ea30e5d534ecc53b5447c40e2e9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c312c540329ba186a8c43e54f917f93486c6370e", "url": "https://github.com/apache/flink/commit/c312c540329ba186a8c43e54f917f93486c6370e", "message": "Comments addressed", "committedDate": "2020-10-14T07:24:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ2NDU1Nw==", "url": "https://github.com/apache/flink/pull/13596#discussion_r504464557", "bodyText": "I think that these can become:\nwhile ((timer = eventTimeTimersQueue.poll()) != null) {\n\t\t\ttriggerTarget.onEventTime(timer);\n\t\t}\n\nand the same for the processing time.", "author": "kl0u", "createdAt": "2020-10-14T07:37:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/BatchExecutionInternalTimeService.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimerHeapInternalTimer;\n+import org.apache.flink.streaming.api.operators.Triggerable;\n+import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;\n+import org.apache.flink.util.function.BiConsumerWithException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * An implementation of a {@link InternalTimerService} that manages timers with a single active key at a time.\n+ * Can be used in a BATCH execution mode.\n+ */\n+public class BatchExecutionInternalTimeService<K, N> implements InternalTimerService<N> {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BatchExecutionInternalTimeService.class);\n+\n+\tprivate final ProcessingTimeService processingTimeService;\n+\n+\t/**\n+\t * Processing time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> processingTimeTimersQueue;\n+\n+\t/**\n+\t * Event time timers that are currently in-flight.\n+\t */\n+\tprivate final KeyGroupedInternalPriorityQueue<TimerHeapInternalTimer<K, N>> eventTimeTimersQueue;\n+\n+\t/**\n+\t * The local event time, as denoted by the last received\n+\t * {@link org.apache.flink.streaming.api.watermark.Watermark Watermark}.\n+\t */\n+\tprivate long currentWatermark = Long.MIN_VALUE;\n+\n+\tprivate final Triggerable<K, N> triggerTarget;\n+\n+\tprivate K currentKey;\n+\n+\tBatchExecutionInternalTimeService(\n+\t\t\tProcessingTimeService processingTimeService,\n+\t\t\tTriggerable<K, N> triggerTarget) {\n+\n+\t\tthis.processingTimeService = checkNotNull(processingTimeService);\n+\t\tthis.triggerTarget = checkNotNull(triggerTarget);\n+\n+\t\tthis.processingTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t\tthis.eventTimeTimersQueue = new BatchExecutionInternalPriorityQueueSet<>(\n+\t\t\tPriorityComparator.forPriorityComparableObjects(),\n+\t\t\t128\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic long currentProcessingTime() {\n+\t\treturn processingTimeService.getCurrentProcessingTime();\n+\t}\n+\n+\t@Override\n+\tpublic long currentWatermark() {\n+\t\treturn currentWatermark;\n+\t}\n+\n+\t@Override\n+\tpublic void registerProcessingTimeTimer(N namespace, long time) {\n+\t\t// the currentWatermark == Long.MAX_VALUE indicates the timer was registered from the callback\n+\t\t// we quiesce the TimerService to prohibit infinite loops at the end of a key\n+\t\tif (currentWatermark == Long.MAX_VALUE) {\n+\t\t\tLOG.warn(\"Timer service is quiesced. Processing time timer for timestamp '{}' will be ignored.\", time);\n+\t\t\treturn;\n+\t\t}\n+\t\tprocessingTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void registerEventTimeTimer(N namespace, long time) {\n+\t\t// the currentWatermark == Long.MAX_VALUE indicates the timer was registered from the callback\n+\t\t// we quiesce the TimerService to prohibit infinite loops at the end of a key\n+\t\tif (currentWatermark == Long.MAX_VALUE) {\n+\t\t\tLOG.warn(\"Timer service is quiesced. Event time timer for timestamp '{}' will be ignored.\", time);\n+\t\t\treturn;\n+\t\t}\n+\t\teventTimeTimersQueue.add(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteProcessingTimeTimer(N namespace, long time) {\n+\t\tprocessingTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void deleteEventTimeTimer(N namespace, long time) {\n+\t\teventTimeTimersQueue.remove(new TimerHeapInternalTimer<>(time, currentKey, namespace));\n+\t}\n+\n+\t@Override\n+\tpublic void forEachEventTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\t@Override\n+\tpublic void forEachProcessingTimeTimer(BiConsumerWithException<N, Long, Exception> consumer) {\n+\t\tthrow new UnsupportedOperationException(\n+\t\t\t\"The BatchExecutionInternalTimeService should not be used in State Processor API.\");\n+\t}\n+\n+\tpublic void setCurrentKey(K currentKey) throws Exception {\n+\t\tif (currentKey != null && currentKey.equals(this.currentKey)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tcurrentWatermark = Long.MAX_VALUE;\n+\t\tInternalTimer<K, N> timer;\n+\t\twhile ((timer = eventTimeTimersQueue.peek()) != null) {", "originalCommit": "c312c540329ba186a8c43e54f917f93486c6370e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87182aba60f671ef6acfff0bd8b28aeb811ca75b", "url": "https://github.com/apache/flink/commit/87182aba60f671ef6acfff0bd8b28aeb811ca75b", "message": "[FLINK-19475] Implement a time service for the batch execution mode\n\nI introduce a BatchExecutionInternalTimeServiceManager and\nBatchExecutionInternalTimeService which can be used in the batch\nexecution mode along with the BatchExecutionStateBackend. These services\nonly ever keep state for a single key at a time. They assume a perfect\nWatermark and fire timers only upon switching the current key. Therefore\nthey require the input to be sorted/grouped by the key.", "committedDate": "2020-10-14T07:48:35Z", "type": "commit"}, {"oid": "87182aba60f671ef6acfff0bd8b28aeb811ca75b", "url": "https://github.com/apache/flink/commit/87182aba60f671ef6acfff0bd8b28aeb811ca75b", "message": "[FLINK-19475] Implement a time service for the batch execution mode\n\nI introduce a BatchExecutionInternalTimeServiceManager and\nBatchExecutionInternalTimeService which can be used in the batch\nexecution mode along with the BatchExecutionStateBackend. These services\nonly ever keep state for a single key at a time. They assume a perfect\nWatermark and fire timers only upon switching the current key. Therefore\nthey require the input to be sorted/grouped by the key.", "committedDate": "2020-10-14T07:48:35Z", "type": "forcePushed"}]}