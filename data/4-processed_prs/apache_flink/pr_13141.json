{"pr_number": 13141, "pr_title": "[FLINK-18852] Fix StreamScan doesn't inherit parallelism from input in legacy planner", "pr_createdAt": "2020-08-13T13:19:49Z", "pr_url": "https://github.com/apache/flink/pull/13141", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyNDczOA==", "url": "https://github.com/apache/flink/pull/13141#discussion_r470424738", "bodyText": "use new methods instead of depreacted methods\nuse DDL to register a table (StreamTableSourceScan path). registerTableSourceInternal is a hack way.\nWe may need to support parallelism property for the COLLECTION source (TestCollectionTableFactory).\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                val table = env.fromElements[String]()\n          \n          \n            \n                  .setParallelism(1)\n          \n          \n            \n                  .toTable(tEnv, 'a)\n          \n          \n            \n            \n          \n          \n            \n                tEnv.registerTable(\"MyTable1\", table)\n          \n          \n            \n                val parallelism = tEnv.scan(\"MyTable1\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .getParallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism)\n          \n          \n            \n            \n          \n          \n            \n                // test StreamTableSourceScan\n          \n          \n            \n                val tableSource = new StreamTableSource[String]() {\n          \n          \n            \n            \n          \n          \n            \n                  override def getDataStream(execEnv: JExecEnv): DataStream[String] = {\n          \n          \n            \n                    execEnv.fromElements[String](\"blabla\")\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  override def getTableSchema: TableSchema = {\n          \n          \n            \n                    new TableSchema(Array(\"a\"), Array(Types.STRING()))\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  override def getReturnType: TypeInformation[String] = {\n          \n          \n            \n                    Types.STRING()\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                tEnv.asInstanceOf[TableEnvironmentInternal].registerTableSourceInternal(\"MyTable2\", tableSource)\n          \n          \n            \n                val parallelism2 = tEnv.scan(\"MyTable2\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .getParallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism2)\n          \n          \n            \n               tEnv.createTemporaryView(\"MyTable1\", table)\n          \n          \n            \n                val parallelism = tEnv.from(\"MyTable1\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .parallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism)\n          \n          \n            \n            \n          \n          \n            \n                // test StreamTableSourceScan\n          \n          \n            \n                val createTableStmt =\n          \n          \n            \n                  \"\"\"\n          \n          \n            \n                    |CREATE TEMPORARY TABLE MyTable2 (\n          \n          \n            \n                    |  str varchar\n          \n          \n            \n                    |) with (\n          \n          \n            \n                    |  'connector' = 'COLLECTION',\n          \n          \n            \n                    |  'is-bounded' = 'false',\n          \n          \n            \n                    | 'parallelism' = '1'\n          \n          \n            \n                    |)\n          \n          \n            \n                  \"\"\".stripMargin\n          \n          \n            \n                tEnv.executeSql(createTableStmt)\n          \n          \n            \n            \n          \n          \n            \n                val parallelism2 = tEnv.from(\"MyTable2\")\n          \n          \n            \n                  .toAppendStream[String]\n          \n          \n            \n                  .parallelism\n          \n          \n            \n            \n          \n          \n            \n                assertEquals(1, parallelism2)", "author": "wuchong", "createdAt": "2020-08-14T05:55:23Z", "path": "flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/runtime/stream/table/TableSourceITCase.scala", "diffHunk": "@@ -81,6 +81,51 @@ class TableSourceITCase extends AbstractTestBase {\n     // info.\n   }\n \n+  @Test\n+  def testStreamScanParallelism(): Unit = {\n+    val env = StreamExecutionEnvironment.getExecutionEnvironment\n+    val settings = EnvironmentSettings.newInstance().useOldPlanner().build()\n+    val tEnv = StreamTableEnvironment.create(env, settings)\n+\n+    // set environment parallelism to 4\n+    env.setParallelism(4)\n+\n+    // test DataStreamScan\n+    val table = env.fromElements[String]()\n+      .setParallelism(1)\n+      .toTable(tEnv, 'a)\n+\n+    tEnv.registerTable(\"MyTable1\", table)\n+    val parallelism = tEnv.scan(\"MyTable1\")\n+      .toAppendStream[String]\n+      .getParallelism\n+\n+    assertEquals(1, parallelism)\n+\n+    // test StreamTableSourceScan\n+    val tableSource = new StreamTableSource[String]() {\n+\n+      override def getDataStream(execEnv: JExecEnv): DataStream[String] = {\n+        execEnv.fromElements[String](\"blabla\")\n+      }\n+\n+      override def getTableSchema: TableSchema = {\n+        new TableSchema(Array(\"a\"), Array(Types.STRING()))\n+      }\n+\n+      override def getReturnType: TypeInformation[String] = {\n+        Types.STRING()\n+      }\n+    }\n+\n+    tEnv.asInstanceOf[TableEnvironmentInternal].registerTableSourceInternal(\"MyTable2\", tableSource)\n+    val parallelism2 = tEnv.scan(\"MyTable2\")\n+      .toAppendStream[String]\n+      .getParallelism\n+\n+    assertEquals(1, parallelism2)", "originalCommit": "ed47271c426abff4426ccf2d0fd5858e6f3d8390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ae1223cf2a3be7c8fea0666821a217e8fa2c841", "url": "https://github.com/apache/flink/commit/2ae1223cf2a3be7c8fea0666821a217e8fa2c841", "message": "[FLINK-18852][table-planner] Fix StreamScan don't inherit parallelism from input in legacy planner\n\nThis closes #13141", "committedDate": "2020-09-01T09:27:15Z", "type": "commit"}, {"oid": "2ae1223cf2a3be7c8fea0666821a217e8fa2c841", "url": "https://github.com/apache/flink/commit/2ae1223cf2a3be7c8fea0666821a217e8fa2c841", "message": "[FLINK-18852][table-planner] Fix StreamScan don't inherit parallelism from input in legacy planner\n\nThis closes #13141", "committedDate": "2020-09-01T09:27:15Z", "type": "forcePushed"}]}