{"pr_number": 13466, "pr_title": "[FLINK-18907][task] Add watermarks and metrics tests for MultipleSourceOperatorStreamTask", "pr_createdAt": "2020-09-23T14:29:46Z", "pr_url": "https://github.com/apache/flink/pull/13466", "timeline": [{"oid": "2094ea7713efb32120188b25765e1887a4cabfca", "url": "https://github.com/apache/flink/commit/2094ea7713efb32120188b25765e1887a4cabfca", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-23T14:33:03Z", "type": "forcePushed"}, {"oid": "c855e4e249ddee6e2bdba3057182b40a16779e1e", "url": "https://github.com/apache/flink/commit/c855e4e249ddee6e2bdba3057182b40a16779e1e", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-24T07:27:55Z", "type": "forcePushed"}, {"oid": "7eb8f6bd3f92b03760701f3208190ee3330867f7", "url": "https://github.com/apache/flink/commit/7eb8f6bd3f92b03760701f3208190ee3330867f7", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-25T06:48:51Z", "type": "forcePushed"}, {"oid": "865276a80d53ecc628caf9b4e8e889ddc93c7293", "url": "https://github.com/apache/flink/commit/865276a80d53ecc628caf9b4e8e889ddc93c7293", "message": "[FLINK-18907][test] Move MultipleInputStreamTaskChainedSourcesTest to MultipleInputStreamTaskTest", "committedDate": "2020-09-25T08:25:38Z", "type": "commit"}, {"oid": "e3728ea45538546b24d96081697a108eccab13cd", "url": "https://github.com/apache/flink/commit/e3728ea45538546b24d96081697a108eccab13cd", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-25T08:25:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMTkwOA==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494811908", "bodyText": "Why do we need this override?", "author": "rkhachatryan", "createdAt": "2020-09-25T07:53:28Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -726,15 +803,188 @@ public void processElement(StreamRecord<T> element) throws Exception {\n \t * Factory for {@link MapToStringMultipleInputOperator}.\n \t */\n \tprotected static class MapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\tprivate final int numberOfInputs;\n+\n+\t\tpublic MapToStringMultipleInputOperatorFactory(int numberOfInputs) {\n+\t\t\tthis.numberOfInputs = numberOfInputs;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n-\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters);\n+\t\t\treturn (T) new MapToStringMultipleInputOperator(parameters, numberOfInputs);\n \t\t}\n \n \t\t@Override\n \t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n \t\t\treturn MapToStringMultipleInputOperator.class;\n \t\t}\n \t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness() throws Exception {\n+\t\treturn buildTestHarness(false);\n+\t}\n+\n+\tstatic StreamTaskMailboxTestHarness<String> buildTestHarness(boolean unaligned) throws Exception {\n+\t\treturn new StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n+\t\t\t.modifyStreamConfig(config -> config.setUnalignedCheckpointsEnabled(unaligned))\n+\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t.addSourceInput(\n+\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\tnew MockSource(Boundedness.BOUNDED, 1),\n+\t\t\t\t\tWatermarkStrategy.noWatermarks()))\n+\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO)\n+\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n+\t\t\t.build();\n+\t}\n+\n+\tstatic void addSourceRecords(\n+\t\t\tStreamTaskMailboxTestHarness<String> testHarness,\n+\t\t\tint sourceId,\n+\t\t\tint... records) throws Exception {\n+\t\tOperatorID sourceOperatorID = getSourceOperatorID(testHarness, sourceId);\n+\n+\t\t// Prepare the source split and assign it to the source reader.\n+\t\tMockSourceSplit split = new MockSourceSplit(0, 0, records.length);\n+\t\tfor (int record : records) {\n+\t\t\tsplit.addRecord(record);\n+\t\t}\n+\n+\t\t// Assign the split to the source reader.\n+\t\tAddSplitEvent<MockSourceSplit> addSplitEvent =\n+\t\t\tnew AddSplitEvent<>(Collections.singletonList(split), new MockSourceSplitSerializer());\n+\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tsourceOperatorID,\n+\t\t\tnew SerializedValue<>(addSplitEvent));\n+\t}\n+\n+\tprivate static OperatorID getSourceOperatorID(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) {\n+\t\tStreamConfig.InputConfig[] inputs = testHarness.getStreamTask().getConfiguration().getInputs(testHarness.getClass().getClassLoader());\n+\t\tStreamConfig.SourceInputConfig input = (StreamConfig.SourceInputConfig) inputs[sourceId];\n+\t\treturn testHarness.getStreamTask().operatorChain.getSourceTaskInput(input).getOperatorID();\n+\t}\n+\n+\tprivate void finishAddingRecords(StreamTaskMailboxTestHarness<String> testHarness, int sourceId) throws Exception {\n+\t\ttestHarness.getStreamTask().dispatchOperatorEvent(\n+\t\t\tgetSourceOperatorID(testHarness, sourceId),\n+\t\t\tnew SerializedValue<>(new SourceEventWrapper(new MockNoMoreSplitsEvent())));\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperator\n+\t\t\textends MapToStringMultipleInputOperator implements BoundedMultiInput {\n+\t\tpublic static final String OPEN = \"MultipleInputOperator#open\";\n+\t\tpublic static final String CLOSE = \"MultipleInputOperator#close\";\n+\t\tpublic static final String END_INPUT = \"MultipleInputOperator#endInput\";\n+\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\tpublic LifeCycleTrackingMapToStringMultipleInputOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\tsuper(parameters, 3);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(OPEN);\n+\t\t\tsuper.open();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws Exception {\n+\t\t\tLIFE_CYCLE_EVENTS.add(CLOSE);\n+\t\t\tsuper.close();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void endInput(int inputId) {\n+\t\t\tLIFE_CYCLE_EVENTS.add(END_INPUT);\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMapToStringMultipleInputOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\t@Override\n+\t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\treturn (T) new LifeCycleTrackingMapToStringMultipleInputOperator(parameters);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<? extends StreamOperator<String>> getStreamOperatorClass(ClassLoader classLoader) {\n+\t\t\treturn LifeCycleTrackingMapToStringMultipleInputOperator.class;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSource extends MockSource {\n+\t\tpublic LifeCycleTrackingMockSource(Boundedness boundedness, int numSplits) {\n+\t\t\tsuper(boundedness, numSplits);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SourceReader<Integer, MockSourceSplit> createReader(SourceReaderContext readerContext) {\n+\t\t\tLifeCycleTrackingMockSourceReader sourceReader = new LifeCycleTrackingMockSourceReader();\n+\t\t\tcreatedReaders.add(sourceReader);\n+\t\t\treturn sourceReader;\n+\t\t}\n+\t}\n+\n+\tstatic class LifeCycleTrackingMockSourceReader extends MockSourceReader {\n+\t\tpublic static final String START = \"SourceReader#start\";\n+\t\tpublic static final String CLOSE = \"SourceReader#close\";\n+\n+\t\t@Override\n+\t\tpublic void start() {\n+\t\t\tLIFE_CYCLE_EVENTS.add(START);\n+\t\t\tsuper.start();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic InputStatus pollNext(ReaderOutput<Integer> sourceOutput) throws Exception {\n+\t\t\treturn super.pollNext(sourceOutput);", "originalCommit": "7eb8f6bd3f92b03760701f3208190ee3330867f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg2NzgxNg==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494867816", "bodyText": "Probably some left over of a previous version. Removed.", "author": "pnowojski", "createdAt": "2020-09-25T09:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxNTk5Mw==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494815993", "bodyText": "Can you elaborate on this change in the commit message please?\n[FLINK-18907][task] Fix numRecordsIn metric with chained sources", "author": "rkhachatryan", "createdAt": "2020-09-25T08:00:47Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -68,7 +69,9 @@\n \t */\n \tprivate final StreamStatus[] streamStatuses;\n \n-\tprivate final Counter numRecordsIn;\n+\tprivate final Counter networkRecordsIn = new SimpleCounter();\n+\n+\tprivate final Counter mainOperatorRecordsIn;", "originalCommit": "7eb8f6bd3f92b03760701f3208190ee3330867f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgzNTc0NQ==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494835745", "bodyText": "The method is ~70 LOC now with 7 assertions and a bit generic name testWatermark.\nI think it can be shortened if we extract method for the sequence: processElement, expectedOutput.add, assert output equals.", "author": "rkhachatryan", "createdAt": "2020-09-25T08:37:10Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -417,20 +451,22 @@ public void testWatermark() throws Exception {\n \n \t\t\t// advance watermark from one of the inputs, now we should get a new one since the\n \t\t\t// minimum increases\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 1);\n \t\t\texpectedOutput.add(new Watermark(initialTime + 3));\n \t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n \n-\t\t\t// advance the other two inputs, now we should get a new one since the\n-\t\t\t// minimum increases again\n+\t\t\t// advance the other inputs, now we should get a new one since the minimum increases again\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 1);\n+\n+\t\t\taddSourceRecords(testHarness, 1, initialTime + 4);\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"\" + (initialTime + 4), TimestampAssigner.NO_TIMESTAMP));\n+\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 0);\n \t\t\texpectedOutput.add(new Watermark(initialTime + 4));\n \t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n \n \t\t\tList<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput());\n-\t\t\tassertEquals(2, resultElements.size());\n+\t\t\tassertEquals(5, resultElements.size());", "originalCommit": "e3728ea45538546b24d96081697a108eccab13cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MDgzOA==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494840838", "bodyText": "How about inlining this constructor (and maybe commenting at call site) to make it clear when (and why) there is no inputWatermarkGauge.", "author": "rkhachatryan", "createdAt": "2020-09-25T08:46:20Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java", "diffHunk": "@@ -63,13 +66,22 @@ public void init() {\n \tpublic static class AsyncDataOutputToOutput<T> extends AbstractDataOutput<T> {\n \n \t\tprivate final Output<StreamRecord<T>> output;\n+\t\t@Nullable private final WatermarkGauge inputWatermarkGauge;\n \n \t\tpublic AsyncDataOutputToOutput(\n \t\t\t\tOutput<StreamRecord<T>> output,\n \t\t\t\tStreamStatusMaintainer streamStatusMaintainer) {\n+\t\t\tthis(output, streamStatusMaintainer, null);", "originalCommit": "e3728ea45538546b24d96081697a108eccab13cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NDk2Ng==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494844966", "bodyText": "Extract method in test harness? (or use existing processWhileAvailable?)", "author": "rkhachatryan", "createdAt": "2020-09-25T08:53:11Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -443,38 +479,66 @@ public void testWatermark() throws Exception {\n \tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n \t\t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n \t\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO, 2)\n-\t\t\t\t\t.addInput(BasicTypeInfo.INT_TYPE_INFO, 2)\n+\t\t\t\t\t.addSourceInput(\n+\t\t\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\t\t\tnew MockSource(Boundedness.CONTINUOUS_UNBOUNDED, 2, true, true),\n+\t\t\t\t\t\t\tWatermarkStrategy.forGenerator(ctx -> new RecordToWatermarkGenerator())))\n \t\t\t\t\t.addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, 2)\n \t\t\t\t\t.setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n \t\t\t\t\t.build()) {\n \t\t\tArrayDeque<Object> expectedOutput = new ArrayDeque<>();\n \n-\t\t\tlong initialTime = 0L;\n+\t\t\tint initialTime = 0;\n \n \t\t\t// test whether idle input channels are acknowledged correctly when forwarding watermarks\n \t\t\ttestHarness.processElement(StreamStatus.IDLE, 0, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 1);\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 0);\n \t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 0, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 1, 0);\n-\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 2, 1); // this watermark should be advanced first\n-\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 1); // once this is acknowledged,\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 1, 1); // this watermark should be advanced first\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 0); // once this is acknowledged,\n \n-\t\t\texpectedOutput.add(new Watermark(initialTime + 5));\n \t\t\t// We don't expect to see Watermark(6) here because the idle status of one\n \t\t\t// input doesn't propagate to the other input. That is, if input 1 is at WM 6 and input\n \t\t\t// two was at WM 5 before going to IDLE then the output watermark will not jump to WM 6.\n+\n+\t\t\t// OPS, there is a known bug: https://issues.apache.org/jira/browse/FLINK-18934\n+\t\t\t// that prevents this check from succeeding (AbstractStreamOperator and AbstractStreamOperatorV2\n+\t\t\t// are ignoring StreamStatus), so those checks needs to be commented out ...\n+\n+\t\t\t//expectedOutput.add(new Watermark(initialTime + 5));\n+\t\t\t//assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// and in as a temporary replacement we need this code block:\n+\t\t\t{\n+\t\t\t\t// we wake up the source and emit watermark\n+\t\t\t\taddSourceRecords(testHarness, 1, initialTime + 5);\n+\t\t\t\twhile (testHarness.processSingleStep()) {\n+\t\t\t\t}", "originalCommit": "e3728ea45538546b24d96081697a108eccab13cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkxMTk3MA==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494911970", "bodyText": "Ok, I went a step further and I have dropped the old processIfAvailable and processWhileAvailable and replaced them with processSingleStep. Previously I was afraid that some tests might be relaying on the previous behaviour, but apparently that's not the case:\nceb02da", "author": "pnowojski", "createdAt": "2020-09-25T11:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NzA0MQ==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494847041", "bodyText": "nit: flatten nested else { if {} } to else if {}?", "author": "rkhachatryan", "createdAt": "2020-09-25T08:56:42Z", "path": "flink-core/src/test/java/org/apache/flink/api/connector/source/mocks/MockSourceReader.java", "diffHunk": "@@ -68,7 +78,16 @@ public InputStatus pollNext(ReaderOutput<Integer> sourceOutput) throws Exception\n \t\t\treturn InputStatus.MORE_AVAILABLE;\n \t\t} else {\n \t\t\t// In case no split has available record, return depending on whether all the splits has finished.\n-\t\t\treturn finished ? InputStatus.END_OF_INPUT : InputStatus.NOTHING_AVAILABLE;\n+\t\t\tif (finished) {", "originalCommit": "e3728ea45538546b24d96081697a108eccab13cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODE0Mw==", "url": "https://github.com/apache/flink/pull/13466#discussion_r494858143", "bodyText": "Can you add a comment explaining this line?", "author": "rkhachatryan", "createdAt": "2020-09-25T09:16:59Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -210,45 +233,63 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testOperatorMetricReuse() throws Exception {\n+\tpublic void testMetrics() throws Exception {\n+\n+\t\tHashMap<String, OperatorMetricGroup> operatorMetrics = new HashMap<>();\n \n \t\tTaskMetricGroup taskMetricGroup = new UnregisteredMetricGroups.UnregisteredTaskMetricGroup() {\n \t\t\t@Override\n \t\t\tpublic OperatorMetricGroup getOrAddOperator(OperatorID operatorID, String name) {\n-\t\t\t\treturn new OperatorMetricGroup(NoOpMetricRegistry.INSTANCE, this, operatorID, name);\n+\t\t\t\tOperatorMetricGroup operatorMetricGroup = new OperatorMetricGroup(NoOpMetricRegistry.INSTANCE, this, operatorID, name);\n+\t\t\t\toperatorMetrics.put(name, operatorMetricGroup);\n+\t\t\t\treturn operatorMetricGroup;\n \t\t\t}\n \t\t};\n \n+\t\tString mainOperatorName = \"MainOperator\";\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n \t\t\tnew StreamTaskMailboxTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t.modifyExecutionConfig(config -> config.enableObjectReuse())\n \t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t.addSourceInput(\n+\t\t\t\t\tnew SourceOperatorFactory<>(\n+\t\t\t\t\t\tnew LifeCycleTrackingMockSource(Boundedness.BOUNDED, 1),\n+\t\t\t\t\t\tWatermarkStrategy.noWatermarks()))\n \t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n-\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n-\t\t\t\t.setupOperatorChain(new DuplicatingOperatorFactory())\n+\t\t\t\t.setupOperatorChain(new MapToStringMultipleInputOperatorFactory(3))\n+\t\t\t\t.name(mainOperatorName)\n+\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n \t\t\t\t.finish()\n \t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n \t\t\t\t.build()) {\n+\n+\t\t\tassertTrue(operatorMetrics.containsKey(mainOperatorName));\n+\t\t\tOperatorMetricGroup mainOperatorMetrics = operatorMetrics.get(mainOperatorName);\n \t\t\tCounter numRecordsInCounter = taskMetricGroup.getIOMetricGroup().getNumRecordsInCounter();\n \t\t\tCounter numRecordsOutCounter = taskMetricGroup.getIOMetricGroup().getNumRecordsOutCounter();\n \n \t\t\tint numRecords1 = 5;\n \t\t\tint numRecords2 = 3;\n \t\t\tint numRecords3 = 2;\n+\t\t\t// add source splits before processing any elements, so the MockSourceReader does not end prematurely\n+\t\t\tfor (int x = 0; x < numRecords2; x++) {\n+\t\t\t\taddSourceRecords(testHarness, 1, 42);\n+\t\t\t}\n \t\t\tfor (int x = 0; x < numRecords1; x++) {\n \t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 0, 0);\n \t\t\t}\n-\t\t\tfor (int x = 0; x < numRecords2; x++) {\n-\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 1, 0);\n-\t\t\t}\n \t\t\tfor (int x = 0; x < numRecords3; x++) {\n-\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 2, 0);\n+\t\t\t\ttestHarness.processElement(new StreamRecord<>(\"hello\"), 1, 0);\n \t\t\t}\n \n-\t\t\tint totalRecords = numRecords1 + numRecords2 + numRecords3;\n-\t\t\tassertEquals(totalRecords, numRecordsInCounter.getCount());\n-\t\t\tassertEquals((totalRecords) * 2 * 2 * 2, numRecordsOutCounter.getCount());\n+\t\t\tint networkRecordsIn = numRecords1 + numRecords3;\n+\t\t\tint mainOpeartorRecordsIn = networkRecordsIn + numRecords2;\n+\t\t\tint totalRecordsOut = (networkRecordsIn + numRecords2) * 2 * 2 * 2;", "originalCommit": "e3728ea45538546b24d96081697a108eccab13cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f7f9d299ec6ed690016d7bd88f416aac794657ac", "url": "https://github.com/apache/flink/commit/f7f9d299ec6ed690016d7bd88f416aac794657ac", "message": "[FLINK-18907][task] Fix too many endInput calls with chained sources\n\nSourceOperator's StreamOperatorWrapper was incorrectly emitting endInput event\nto the mainOperatorWrapper, based on too simple chaining logic. It was replaced\nwith `isHead` check.", "committedDate": "2020-09-25T09:40:50Z", "type": "commit"}, {"oid": "919857583fc2673d964f4ab9d4de2608510b9081", "url": "https://github.com/apache/flink/commit/919857583fc2673d964f4ab9d4de2608510b9081", "message": "[FLINK-18907][test] Remove now duplicated testClosingAllOperatorsOnChainProperly test", "committedDate": "2020-09-25T09:40:50Z", "type": "commit"}, {"oid": "fb715ebadd06144cf742059fa8a7e2c194191a7b", "url": "https://github.com/apache/flink/commit/fb715ebadd06144cf742059fa8a7e2c194191a7b", "message": "[FLINK-18907][task] Fix numRecordsIn metric with chained sources\n\nWith chained sources, task's and main operator's number of input records\nare two different things. The first one should take into account only records\ncomming in from the network, ignoring records produced inside the task itself\n(like via a chained source). Main operator should on the other hand report\nall records from all of the inputs (regardless if it's a network or chained input).", "committedDate": "2020-09-25T09:47:25Z", "type": "commit"}, {"oid": "551df4679a5fea0890e52b5d09c0fad814e2b5bb", "url": "https://github.com/apache/flink/commit/551df4679a5fea0890e52b5d09c0fad814e2b5bb", "message": "[FLINK-18907][test] Refactor MockSourceReader\n\nMake the synchronisation around availability easier to understand.", "committedDate": "2020-09-25T09:48:15Z", "type": "commit"}, {"oid": "49e7f4d15a15a2ccedce6237cb325181a8c6850d", "url": "https://github.com/apache/flink/commit/49e7f4d15a15a2ccedce6237cb325181a8c6850d", "message": "[FLINK-18907][task] Add test coverage for watermarks with chained sources", "committedDate": "2020-09-25T09:48:19Z", "type": "commit"}, {"oid": "d969eb2c692a2d31b3e5ad64f0612314bd3f0267", "url": "https://github.com/apache/flink/commit/d969eb2c692a2d31b3e5ad64f0612314bd3f0267", "message": "[FLINK-18907][hotfix] Rename headOperator to mainOperator in the MultipleInputStreamTaskTest", "committedDate": "2020-09-25T09:48:19Z", "type": "commit"}, {"oid": "ceb02daced0ebde702daad7b68f220a5c231cced", "url": "https://github.com/apache/flink/commit/ceb02daced0ebde702daad7b68f220a5c231cced", "message": "[FLINK-18907][hotfix] Replace old processIf/WhileAvailable with processSingleStep\n\nThe new versions have a bit different semantc. They process data/keep processing data,\nas long something was processed, instead of relaying on input/output availability.\nThe biggest difference is, that processSingleStep can process mailbox actions\neven if input is not available.", "committedDate": "2020-09-25T10:58:16Z", "type": "commit"}, {"oid": "1cfb3616ae80e91754137114a4f18022dbf5ae1d", "url": "https://github.com/apache/flink/commit/1cfb3616ae80e91754137114a4f18022dbf5ae1d", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-25T11:01:54Z", "type": "forcePushed"}, {"oid": "89460be2a8f804543114eef190bbc7ece534f0fc", "url": "https://github.com/apache/flink/commit/89460be2a8f804543114eef190bbc7ece534f0fc", "message": "[FLINK-18907][task] Fix and add test coverage for watermarks gauges with chained sources", "committedDate": "2020-09-25T13:48:30Z", "type": "commit"}, {"oid": "056eb5ed1d2d4facf6dca11a176db5796d5da26b", "url": "https://github.com/apache/flink/commit/056eb5ed1d2d4facf6dca11a176db5796d5da26b", "message": "[FLINK-18907][hotfix] Fix the testWatermarkAndStreamStatusForwarding to do what it was intended to do", "committedDate": "2020-09-25T13:48:30Z", "type": "commit"}, {"oid": "8f6944d92d2efb3095c3b57dc95657c23507c3d5", "url": "https://github.com/apache/flink/commit/8f6944d92d2efb3095c3b57dc95657c23507c3d5", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-25T13:48:30Z", "type": "commit"}, {"oid": "8f6944d92d2efb3095c3b57dc95657c23507c3d5", "url": "https://github.com/apache/flink/commit/8f6944d92d2efb3095c3b57dc95657c23507c3d5", "message": "[FLINK-18907][test] Add stream status forwarding test for chained sources\n\nCurrently the test is affected by a known bug FLINK-18934.", "committedDate": "2020-09-25T13:48:30Z", "type": "forcePushed"}]}