{"pr_number": 13465, "pr_title": "[FLINK-18906][task] Support checkpointing with multiple input operator chained with sources", "pr_createdAt": "2020-09-23T14:15:18Z", "pr_url": "https://github.com/apache/flink/pull/13465", "timeline": [{"oid": "0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "url": "https://github.com/apache/flink/commit/0820bc41b3f7f3961ebf9f2f3c05d4ed1561e93b", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-23T14:21:58Z", "type": "forcePushed"}, {"oid": "ac0d032298233f33ea335341728c254a11db51b3", "url": "https://github.com/apache/flink/commit/ac0d032298233f33ea335341728c254a11db51b3", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-24T07:27:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MTQ2Nw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494181467", "bodyText": "I think less if nesting would be more readabile:\nif (first == AVAILABLE && second == AVAILABLE) return AVAILABLE;\nelse if (first == AVAILABLE) return second;\nelse if (second == AVAILABLE) return first;\nelse return allOf(first, second);", "author": "rkhachatryan", "createdAt": "2020-09-24T09:45:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java", "diffHunk": "@@ -66,6 +66,32 @@ default boolean isApproximatelyAvailable() {\n \t\treturn getAvailableFuture() == AVAILABLE;\n \t}\n \n+\tstatic CompletableFuture<?> and(CompletableFuture<?> first, CompletableFuture<?> second) {\n+\t\tif (first == AVAILABLE) {\n+\t\t\tif (second == AVAILABLE) {", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4OTQ5NA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494189494", "bodyText": "Why not just return false here?", "author": "rkhachatryan", "createdAt": "2020-09-24T09:58:35Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -249,25 +259,34 @@ private void sendControlMail(RunnableWithException mail, String descriptionForma\n \t}\n \n \t/**\n-\t * This helper method handles all special actions from the mailbox. It returns true if the mailbox loop should\n-\t * continue running, false if it should stop. In the current design, this method also evaluates all control flag\n-\t * changes. This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n+\t * This helper method handles all special actions from the mailbox.\n+\t * In the current design, this method also evaluates all control flag changes.\n+\t * This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n \t * that all flag changes must make sure that the mailbox signals mailbox#hasMail.\n+\t *\n+\t * @return true if a mail has been processed.\n \t */\n-\tprivate boolean processMail(TaskMailbox mailbox) throws Exception {\n-\n+\tprivate boolean processMail(TaskMailbox mailbox, boolean singleStep) throws Exception {\n+\t\tboolean processed = false;\n \t\t// Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only\n \t\t// acquired after this point.\n \t\tif (!mailbox.createBatch()) {\n \t\t\t// We can also directly return true because all changes to #isMailboxLoopRunning must be connected to\n \t\t\t// mailbox.hasMail() == true.\n-\t\t\treturn true;\n+\t\t\treturn processed;", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1OTE3Nw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494259177", "bodyText": "I wanted to make it consistent, but I don't care much one way or another. Changed to return false", "author": "pnowojski", "createdAt": "2020-09-24T12:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4OTQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MDUwMg==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494190502", "bodyText": "Why not just return true here?\nAnd then after the loop if singleStep == true we can also return false.", "author": "rkhachatryan", "createdAt": "2020-09-24T10:00:13Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -249,25 +259,34 @@ private void sendControlMail(RunnableWithException mail, String descriptionForma\n \t}\n \n \t/**\n-\t * This helper method handles all special actions from the mailbox. It returns true if the mailbox loop should\n-\t * continue running, false if it should stop. In the current design, this method also evaluates all control flag\n-\t * changes. This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n+\t * This helper method handles all special actions from the mailbox.\n+\t * In the current design, this method also evaluates all control flag changes.\n+\t * This keeps the hot path in {@link #runMailboxLoop()} free from any other flag checking, at the cost\n \t * that all flag changes must make sure that the mailbox signals mailbox#hasMail.\n+\t *\n+\t * @return true if a mail has been processed.\n \t */\n-\tprivate boolean processMail(TaskMailbox mailbox) throws Exception {\n-\n+\tprivate boolean processMail(TaskMailbox mailbox, boolean singleStep) throws Exception {\n+\t\tboolean processed = false;\n \t\t// Doing this check is an optimization to only have a volatile read in the expected hot path, locks are only\n \t\t// acquired after this point.\n \t\tif (!mailbox.createBatch()) {\n \t\t\t// We can also directly return true because all changes to #isMailboxLoopRunning must be connected to\n \t\t\t// mailbox.hasMail() == true.\n-\t\t\treturn true;\n+\t\t\treturn processed;\n \t\t}\n \n \t\t// Take mails in a non-blockingly and execute them.\n \t\tOptional<Mail> maybeMail;\n \t\twhile (isMailboxLoopRunning() && (maybeMail = mailbox.tryTakeFromBatch()).isPresent()) {\n \t\t\tmaybeMail.get().run();\n+\t\t\tprocessed = true;\n+\t\t\tif (singleStep) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2MTEwMQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494261101", "bodyText": "Here actually I think single one less exit point would be easier to understand", "author": "pnowojski", "createdAt": "2020-09-24T12:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MDUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5MjIwNQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494192205", "bodyText": "This is a change in the production code, so I think it's better to not mark it as [test] in commit message (even though the motivation is to fix tests).", "author": "rkhachatryan", "createdAt": "2020-09-24T10:03:02Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -178,17 +178,27 @@ public void runMailboxLoop() throws Exception {\n \n \t\tfinal MailboxController defaultActionContext = new MailboxController(this);\n \n-\t\twhile (runMailboxStep(localMailbox, defaultActionContext)) {\n+\t\twhile (isMailboxLoopRunning()) {", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494202103", "bodyText": "How about using vararg parameter and replacing here with just Arrays.asList(inputGates)?", "author": "rkhachatryan", "createdAt": "2020-09-24T10:20:12Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -56,12 +59,13 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\ttaskIOMetricGroup,\n \t\t\ttaskName,\n \t\t\tmailboxExecutor,\n-\t\t\tArrays.asList(inputGates));\n+\t\t\tnew List[]{ Arrays.asList(inputGates) },", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3NTYzMQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494275631", "bodyText": "? It used to be like that, but now we are submitting two different lists, so having a vararg for just one of them would be a bit inconsistent.", "author": "pnowojski", "createdAt": "2020-09-24T12:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5MDk3MA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494290970", "bodyText": "Currently, they are array-of-lists and a list:\nList<IndexedInputGate>[] inputGates,\nList<StreamTaskSourceInput<?>> sourceInputs)\n\nSo changing one array to vararg doesn't change consistency:\nList<StreamTaskSourceInput<?>> sourceInputs,\nList<IndexedInputGate>... inputGates)", "author": "rkhachatryan", "createdAt": "2020-09-24T12:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwNDY0NA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494304644", "bodyText": "inputGates probably should be migrated to List as well at some point of time. I don't like using varargs if there are others lists/arrays/collection like arguments :(", "author": "pnowojski", "createdAt": "2020-09-24T13:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwMjEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzM0Mg==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494207342", "bodyText": "nit: this comment doesn't say much to me", "author": "rkhachatryan", "createdAt": "2020-09-24T10:29:30Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java", "diffHunk": "@@ -34,30 +40,75 @@\n  * unavailable or finished.\n  */\n @Internal\n-public final class StreamTaskSourceInput<T> implements StreamTaskInput<T> {\n+public final class StreamTaskSourceInput<T> implements StreamTaskInput<T>, BlockableInput {\n \n \tprivate final SourceOperator<T, ?> operator;\n+\tprivate final int inputGateIndex;\n+\tprivate final AvailabilityHelper isBlockedAvailability = new AvailabilityHelper();\n+\tprivate final List<InputChannelInfo> inputChannelInfos;\n \n-\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator) {\n+\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator, int inputGateIndex) {\n \t\tthis.operator = checkNotNull(operator);\n+\t\tthis.inputGateIndex = inputGateIndex;\n+\t\tinputChannelInfos = Collections.singletonList(new InputChannelInfo(inputGateIndex, 0));\n+\t\tisBlockedAvailability.resetAvailable();\n \t}\n \n \t@Override\n \tpublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n+\t\tif (!isBlockedAvailability.isApproximatelyAvailable()) {\n+\t\t\t// Safe guard", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3OTkzOQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494279939", "bodyText": "expanded", "author": "pnowojski", "createdAt": "2020-09-24T12:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNzU1OA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494207558", "bodyText": "nit: this is a bit difficult to read (maybe just invert the condition?)", "author": "rkhachatryan", "createdAt": "2020-09-24T10:29:52Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java", "diffHunk": "@@ -34,30 +40,75 @@\n  * unavailable or finished.\n  */\n @Internal\n-public final class StreamTaskSourceInput<T> implements StreamTaskInput<T> {\n+public final class StreamTaskSourceInput<T> implements StreamTaskInput<T>, BlockableInput {\n \n \tprivate final SourceOperator<T, ?> operator;\n+\tprivate final int inputGateIndex;\n+\tprivate final AvailabilityHelper isBlockedAvailability = new AvailabilityHelper();\n+\tprivate final List<InputChannelInfo> inputChannelInfos;\n \n-\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator) {\n+\tpublic StreamTaskSourceInput(SourceOperator<T, ?> operator, int inputGateIndex) {\n \t\tthis.operator = checkNotNull(operator);\n+\t\tthis.inputGateIndex = inputGateIndex;\n+\t\tinputChannelInfos = Collections.singletonList(new InputChannelInfo(inputGateIndex, 0));\n+\t\tisBlockedAvailability.resetAvailable();\n \t}\n \n \t@Override\n \tpublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n+\t\tif (!isBlockedAvailability.isApproximatelyAvailable()) {", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxODkwNA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494218904", "bodyText": "Shouldn't we also update super.latestAsyncCheckpointStartDelayNanos?", "author": "rkhachatryan", "createdAt": "2020-09-24T10:51:38Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4MjUxOA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494282518", "bodyText": "No. This field is used only in the SourceStreamTask. MetricNames#CHECKPOINT_START_DELAY_TIME metric is defined in two ways:\n\nin SourceStreamTask via latestAsyncCheckpointStartDelayNanos\neverywhere else via CheckpointBarrierHandler#getCheckpointStartDelayNanos\n\nMultipleInputStreamTask is using the second way.\nI've added a comment about that.", "author": "pnowojski", "createdAt": "2020-09-24T12:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxODkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIyNjcwMA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494226700", "bodyText": "I'm concerned about the cleanup of this map.\nFrom the code, I see it's assumed at least one triggerOnBarrier or abortOnBarrier after triggerAsync, right?\nBut can abort come after triggerAsync?\nShould we state these ordering assumptions?\nOr maybe we can just remove the map? I see the future result is only used by SourceStreamTask which is irrelevant here.", "author": "rkhachatryan", "createdAt": "2020-09-24T11:06:46Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -18,32 +18,48 @@\n package org.apache.flink.streaming.runtime.tasks;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;\n import org.apache.flink.runtime.metrics.MetricNames;\n import org.apache.flink.streaming.api.graph.StreamConfig;\n import org.apache.flink.streaming.api.graph.StreamConfig.InputConfig;\n import org.apache.flink.streaming.api.graph.StreamEdge;\n import org.apache.flink.streaming.api.operators.InputSelectable;\n import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.runtime.io.CheckpointBarrierHandler;\n import org.apache.flink.streaming.runtime.io.CheckpointedInputGate;\n import org.apache.flink.streaming.runtime.io.InputProcessorUtil;\n import org.apache.flink.streaming.runtime.io.MultipleInputSelectionHandler;\n import org.apache.flink.streaming.runtime.io.StreamMultipleInputProcessor;\n+import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;\n import org.apache.flink.streaming.runtime.metrics.MinWatermarkGauge;\n import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n \n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n-\n-import static org.apache.flink.util.Preconditions.checkState;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n \n /**\n  * A {@link StreamTask} for executing a {@link MultipleInputStreamOperator} and supporting\n  * the {@link MultipleInputStreamOperator} to select input for reading.\n  */\n @Internal\n public class MultipleInputStreamTask<OUT> extends StreamTask<OUT, MultipleInputStreamOperator<OUT>> {\n+\tprivate final HashMap<Long, CompletableFuture<Boolean>> pendingCheckpointCompletedFutures = new HashMap<>();", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMzEwOA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494303108", "bodyText": "It\u2019s even worse. The future is currently used only for tests\u2026\nI\u2019ve tried to refactor it in someway to avoid it for the MultipleInputStreamTask, but it turned out more difficult then implementing this Map.\nAnd yes, currently triggerOnBarrier happens always after triggerCheckpointAsync.\nI also reasoned that if we accumulated some garbage in case of some problem with a cancellation/checkpoint failure that I might have missed, it shouldn't be a big deal, as long it's rare? But maybe we can cap it's size to 100 * CheckpointConfig#getMaxConcurrentCheckpoints?\nHowever it might be better to get rid of the future somehow...\nWhat do you think? Do you have some idea?", "author": "pnowojski", "createdAt": "2020-09-24T13:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIyNjcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNTM3NA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494315374", "bodyText": "Without changing the signature, I think the only way is to rely on mailbox: after triggering, enqueue a mail and wait for its completion.\nWhich is far from ideal, but at least it wouldn't affect production code path and is correct.\nWDYT?", "author": "rkhachatryan", "createdAt": "2020-09-24T13:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIyNjcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2MTQ0Nw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494361447", "bodyText": "As discussed offline, while it's not perfect, it's currently easiest to go on with with the current pending map with a capped size.", "author": "pnowojski", "createdAt": "2020-09-24T14:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIyNjcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzNTUxNQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494235515", "bodyText": "Shouldn't we differentiate for which sourceInput current barrier is (and call processBarrier only for it)?", "author": "rkhachatryan", "createdAt": "2020-09-24T11:23:36Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +134,67 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tpendingCheckpointCompletedFutures.put(metadata.getCheckpointId(), resultFuture);\n+\t\t\t\t\ttriggerSourcesCheckpoint(new CheckpointBarrier(metadata.getCheckpointId(), metadata.getTimestamp(), options));\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t// Report the failure both via the Future result but also to the mailbox\n+\t\t\t\t\tpendingCheckpointCompletedFutures.remove(metadata.getCheckpointId());\n+\t\t\t\t\tresultFuture.completeExceptionally(ex);\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\t\"checkpoint %s with %s\",\n+\t\t\tmetadata,\n+\t\t\toptions);\n+\t\treturn resultFuture;\n+\t}\n+\n+\tprivate void triggerSourcesCheckpoint(CheckpointBarrier checkpointBarrier) throws IOException {\n+\t\tfor (StreamTaskSourceInput<?> sourceInput : operatorChain.getSourceTaskInputs()) {", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NDc0NQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494284745", "bodyText": "There is no need to do that. Please check the updated java doc in StreamTaskSourceInput#checkpointStarted.\nRuntime has a flexibility to checkpoint the sources at any point of time, as long as it is in sync with network inputs.", "author": "pnowojski", "createdAt": "2020-09-24T12:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzNTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0OTMyOA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494249328", "bodyText": "Why do we block source inputs when we receive a barrier from a non-source input?\n(maybe a comment is missing here or for StreamTaskSourceInput.checkpointStarted)", "author": "rkhachatryan", "createdAt": "2020-09-24T11:46:07Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -101,10 +101,8 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \t\t\tallBarriersReceivedFuture = new CompletableFuture<>();\n \t\t\tcheckpointCoordinator.initCheckpoint(barrierId, barrier.getCheckpointOptions());\n \n-\t\t\tfor (final InputGate gate : inputGates) {\n-\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n-\t\t\t\t\tgate.getChannel(index).checkpointStarted(barrier);\n-\t\t\t\t}\n+\t\t\tfor (final BlockableInput input : inputs) {\n+\t\t\t\tinput.checkpointStarted(barrier);", "originalCommit": "ac0d032298233f33ea335341728c254a11db51b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3NDMxNA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494274314", "bodyText": "Good question. I've added a larger explanation why in StreamTaskSourceInput#checkpointStarted", "author": "pnowojski", "createdAt": "2020-09-24T12:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0OTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1OTg2Nw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494359867", "bodyText": "Thanks!", "author": "rkhachatryan", "createdAt": "2020-09-24T14:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0OTMyOA=="}], "type": "inlineReview"}, {"oid": "3bd46778d0a609df1923acee5a0647ed61e14c69", "url": "https://github.com/apache/flink/commit/3bd46778d0a609df1923acee5a0647ed61e14c69", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-24T12:42:29Z", "type": "forcePushed"}, {"oid": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "url": "https://github.com/apache/flink/commit/ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-24T14:21:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2NjMxNQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494366315", "bodyText": "Can this be private?", "author": "rkhachatryan", "createdAt": "2020-09-24T14:29:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -18,32 +18,51 @@\n package org.apache.flink.streaming.runtime.tasks;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;\n+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;\n import org.apache.flink.runtime.metrics.MetricNames;\n import org.apache.flink.streaming.api.graph.StreamConfig;\n import org.apache.flink.streaming.api.graph.StreamConfig.InputConfig;\n import org.apache.flink.streaming.api.graph.StreamEdge;\n import org.apache.flink.streaming.api.operators.InputSelectable;\n import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.runtime.io.CheckpointBarrierHandler;\n import org.apache.flink.streaming.runtime.io.CheckpointedInputGate;\n import org.apache.flink.streaming.runtime.io.InputProcessorUtil;\n import org.apache.flink.streaming.runtime.io.MultipleInputSelectionHandler;\n import org.apache.flink.streaming.runtime.io.StreamMultipleInputProcessor;\n+import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;\n import org.apache.flink.streaming.runtime.metrics.MinWatermarkGauge;\n import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n \n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n-\n-import static org.apache.flink.util.Preconditions.checkState;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n \n /**\n  * A {@link StreamTask} for executing a {@link MultipleInputStreamOperator} and supporting\n  * the {@link MultipleInputStreamOperator} to select input for reading.\n  */\n @Internal\n public class MultipleInputStreamTask<OUT> extends StreamTask<OUT, MultipleInputStreamOperator<OUT>> {\n+\tpublic static final int MAX_TRACKED_CHECKPOINTS = 100_000;", "originalCommit": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NDQxMg==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494374412", "bodyText": "It can", "author": "pnowojski", "createdAt": "2020-09-24T14:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM2NjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3MTY5OA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494371698", "bodyText": "I think we can end up with O(MAX_TRACKED_CHECKPOINTS ^ 2) here, right?\nEven though it shouldn't happen normally (if map is cleared by triggerOnBarrier/abort), I think it's better to cap it by either using LinkedHashMap, TreeMap, or just reducing\nMAX_TRACKED_CHECKPOINTS to something very small.", "author": "rkhachatryan", "createdAt": "2020-09-24T14:36:14Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java", "diffHunk": "@@ -114,4 +137,81 @@ protected void createInputProcessor(\n \t\t\toperatorChain,\n \t\t\tsetupNumRecordsInCounter(mainOperator));\n \t}\n+\n+\t@Override\n+\tpublic Future<Boolean> triggerCheckpointAsync(\n+\t\t\tCheckpointMetaData metadata,\n+\t\t\tCheckpointOptions options,\n+\t\t\tboolean advanceToEndOfEventTime) {\n+\n+\t\tCompletableFuture<Boolean> resultFuture = new CompletableFuture<>();\n+\t\tmainMailboxExecutor.execute(\n+\t\t\t() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\t/**\n+\t\t\t\t\t * Contrary to {@link SourceStreamTask}, we are not using here\n+\t\t\t\t\t * {@link StreamTask#latestAsyncCheckpointStartDelayNanos} to measure the start delay\n+\t\t\t\t\t * metric, but we will be using {@link CheckpointBarrierHandler#getCheckpointStartDelayNanos()}\n+\t\t\t\t\t * instead.\n+\t\t\t\t\t */\n+\t\t\t\t\tpendingCheckpointCompletedFutures.put(metadata.getCheckpointId(), resultFuture);\n+\t\t\t\t\tcheckPendingCheckpointCompletedFuturesSize();\n+\t\t\t\t\ttriggerSourcesCheckpoint(new CheckpointBarrier(metadata.getCheckpointId(), metadata.getTimestamp(), options));\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t// Report the failure both via the Future result but also to the mailbox\n+\t\t\t\t\tpendingCheckpointCompletedFutures.remove(metadata.getCheckpointId());\n+\t\t\t\t\tresultFuture.completeExceptionally(ex);\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\t\"checkpoint %s with %s\",\n+\t\t\tmetadata,\n+\t\t\toptions);\n+\t\treturn resultFuture;\n+\t}\n+\n+\tprivate void checkPendingCheckpointCompletedFuturesSize() {\n+\t\twhile (pendingCheckpointCompletedFutures.size() > MAX_TRACKED_CHECKPOINTS) {\n+\t\t\tLong minCheckpointID = Collections.min(pendingCheckpointCompletedFutures.keySet());", "originalCommit": "ea1357818c4d38824d587d2ac2329fcf68f1c0e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NjM3MQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494376371", "bodyText": "Ehhhh... ok, but that's overengineering a bit", "author": "pnowojski", "createdAt": "2020-09-24T14:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3MTY5OA=="}], "type": "inlineReview"}, {"oid": "ef4d75dea974295ad688c5866dbde706cffe579c", "url": "https://github.com/apache/flink/commit/ef4d75dea974295ad688c5866dbde706cffe579c", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-24T14:47:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4NTIwMw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494385203", "bodyText": "It's odd to see BlockableInput without any explicit block function. Maybe it's more about CheckpointableInput?", "author": "AHeise", "createdAt": "2020-09-24T14:53:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BlockableInput.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Input, with just basic methods for blocking and resuming consumption. It can be for example an {@link InputGate}\n+ */\n+@Internal\n+public interface BlockableInput {", "originalCommit": "57fd9e04e148e73743f469bb53be84ef523fb8f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5MTA1OQ==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494391059", "bodyText": "There is added later on blockConsumption method, but yes, CheckpointableInput is a better name.", "author": "pnowojski", "createdAt": "2020-09-24T15:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM4NTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NjYwMw==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494396603", "bodyText": "resumeConsumption could be implicitly triggered by checkpointStopped.\nThen, the last unfitting method is blockConsumption, which could be modeled as void barrierReceived(int channelIndex, CheckpointBarrier barrier); (and it wouldn't be odd that it's ignored by InputGate).", "author": "AHeise", "createdAt": "2020-09-24T15:08:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BlockableInput.java", "diffHunk": "@@ -26,9 +26,12 @@\n \n /**\n  * Input, with just basic methods for blocking and resuming consumption. It can be for example an {@link InputGate}\n+ * or a chained source.\n  */\n @Internal\n public interface BlockableInput {\n+\tvoid blockConsumption(int inputChannelIdx);\n+\n \tvoid resumeConsumption(int channelIndex) throws IOException;", "originalCommit": "ef4d75dea974295ad688c5866dbde706cffe579c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODE5NA==", "url": "https://github.com/apache/flink/pull/13465#discussion_r494408194", "bodyText": "As discussed offline, we decided to keep it as it is for now.", "author": "pnowojski", "createdAt": "2020-09-24T15:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM5NjYwMw=="}], "type": "inlineReview"}, {"oid": "d11ce95c29fc032e38c57228fb07e85106a6931e", "url": "https://github.com/apache/flink/commit/d11ce95c29fc032e38c57228fb07e85106a6931e", "message": "[FLINK-18906][hotfix] Fix JavaDoc for in InputProcessorUtil", "committedDate": "2020-09-24T16:22:46Z", "type": "commit"}, {"oid": "96537b7ee5f691eebf2376ae93398eba1415c713", "url": "https://github.com/apache/flink/commit/96537b7ee5f691eebf2376ae93398eba1415c713", "message": "[FLINK-18906][hotfix] Move isFinished checkState inside InputGate#resumeConsumption\n\nThis will minimize the visible interface of an Input as used by CheckpointBarrierHandlers", "committedDate": "2020-09-24T16:22:46Z", "type": "commit"}, {"oid": "b8d28ce802579551dc21d2d5c0fd8c6c67a9beef", "url": "https://github.com/apache/flink/commit/b8d28ce802579551dc21d2d5c0fd8c6c67a9beef", "message": "[FLINK-18906][hotfix] Fix method names in CheckpointBarrierAlignerTestBase", "committedDate": "2020-09-24T16:22:47Z", "type": "commit"}, {"oid": "21c86aaf89cd1282e90610b82d717e624eb3819e", "url": "https://github.com/apache/flink/commit/21c86aaf89cd1282e90610b82d717e624eb3819e", "message": "[FLINK-18906][task] Construct StreamTaskSourceInput earlier in the OperatorChain\n\ninstead of in StreamMultipleInputProcessor. This will allow CheckpointBarrierHandlers to\nuse and reference StreamTaskSourceInput instances.", "committedDate": "2020-09-24T16:22:47Z", "type": "commit"}, {"oid": "67dd035175275021c1470c0349cbd52e99682554", "url": "https://github.com/apache/flink/commit/67dd035175275021c1470c0349cbd52e99682554", "message": "[FLINK-18906][task] Decouple CheckpointBarrierHandlers from InputGates\n\nThis is still only a refactor. It extracts an interface from the IndexedInputGate\nto be used by CheckpointBarierHandlers.", "committedDate": "2020-09-24T16:22:47Z", "type": "commit"}, {"oid": "59bd0e18fb1d3d74e6b84e1501c1175e8baed76a", "url": "https://github.com/apache/flink/commit/59bd0e18fb1d3d74e6b84e1501c1175e8baed76a", "message": "[FLINK-18906][hotfix] Provide helper and/or functions on availability futures", "committedDate": "2020-09-24T16:22:47Z", "type": "commit"}, {"oid": "68d7dd1c9f46d2f1c2351af923d725d2646132c1", "url": "https://github.com/apache/flink/commit/68d7dd1c9f46d2f1c2351af923d725d2646132c1", "message": "[FLINK-18906][task] Fix processSingleStep semantic\n\nPreviously processSingleStep call could be ignored, and wouldn't process mail actions", "committedDate": "2020-09-24T16:22:48Z", "type": "commit"}, {"oid": "4b6162725a47e5f7e994077f8ac00b2dc758f3c7", "url": "https://github.com/apache/flink/commit/4b6162725a47e5f7e994077f8ac00b2dc758f3c7", "message": "[FLINK-18906][test] Generalise testing code for MultipleInputStreamTask\n\nThis will allow to re-use it for checkpointing tests with chained sources", "committedDate": "2020-09-24T16:22:48Z", "type": "commit"}, {"oid": "fc93dcd36ffa5fb0449fcfa51a8bce3bc2aee27e", "url": "https://github.com/apache/flink/commit/fc93dcd36ffa5fb0449fcfa51a8bce3bc2aee27e", "message": "[FLINK-18906][task] Expose InputProcessorUtil#createCheckpointBarrierHandler\n\nThis will be useful in a next commit, where MultipleInputStreamTask will need\nto have an access to the CheckpointBarrierHandler", "committedDate": "2020-09-24T16:22:48Z", "type": "commit"}, {"oid": "5799b14d314e5b58b2c46a56c3a6ca8132660303", "url": "https://github.com/apache/flink/commit/5799b14d314e5b58b2c46a56c3a6ca8132660303", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-24T16:22:48Z", "type": "forcePushed"}, {"oid": "c3276e0e9b8c435529255acc155a3c3236418330", "url": "https://github.com/apache/flink/commit/c3276e0e9b8c435529255acc155a3c3236418330", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-25T06:08:39Z", "type": "commit"}, {"oid": "c3276e0e9b8c435529255acc155a3c3236418330", "url": "https://github.com/apache/flink/commit/c3276e0e9b8c435529255acc155a3c3236418330", "message": "[FLINK-18906][task] Support StreamTaskSourceInput as BlockabledInput\n\nThis commit adds support for StreamTaskSourceInput as BlockableInput passed to CheckpointBarrierHandlers.\nEffectively this enables checkpointing with chained sources for MultipleInputStreamTask.", "committedDate": "2020-09-25T06:08:39Z", "type": "forcePushed"}]}