{"pr_number": 14404, "pr_title": "[FLINK-20624][table-planner]Refactor StreamExecJoinRule, StreamExecIntervalJoinRule and StreamExecTemporalJoinRule", "pr_createdAt": "2020-12-16T11:18:41Z", "pr_url": "https://github.com/apache/flink/pull/14404", "timeline": [{"oid": "b8f43eb25f0360886d7cf5bf47449d7122347f79", "url": "https://github.com/apache/flink/commit/b8f43eb25f0360886d7cf5bf47449d7122347f79", "message": "refactor flink stream-stream join rules", "committedDate": "2020-12-16T07:51:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5NTY0Mg==", "url": "https://github.com/apache/flink/pull/14404#discussion_r545795642", "bodyText": "The only concern from my side is that the base rule class has some special transformation logic for temporal join. This may has some side effect in the long future, e.g. we may support regular join with snapshot in the future. Would be better to let the temporal join rule to handle this transformation.\nIn order to this, one idea is that we can provide conversion function instead of the converted rel node:\n  protected def transform(\n      join: FlinkLogicalJoin,\n      leftConversion: RelNode => RelNode,\n      rightConversion: RelNode => RelNode,\n      providedTraitSet: RelTraitSet): FlinkRelNode", "author": "wuchong", "createdAt": "2020-12-18T12:19:00Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/StreamExecJoinRuleBase.scala", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.physical.stream\n+\n+import org.apache.flink.table.planner.plan.`trait`.FlinkRelDistribution\n+import org.apache.flink.table.planner.plan.nodes.{FlinkConventions, FlinkRelNode}\n+import org.apache.flink.table.planner.plan.nodes.logical.{FlinkLogicalJoin, FlinkLogicalRel, FlinkLogicalSnapshot}\n+import org.apache.flink.table.planner.plan.utils.IntervalJoinUtil.WindowBounds\n+import org.apache.flink.table.planner.plan.utils.{FlinkRelOptUtil, IntervalJoinUtil}\n+import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall, RelTraitSet}\n+import org.apache.calcite.plan.RelOptRule.{any, operand}\n+import org.apache.calcite.rel.RelNode\n+import org.apache.calcite.rex.RexNode\n+\n+import java.util\n+\n+/**\n+ * Base implementation for rules match stream-stream join, including\n+ * regular stream join, interval join and temporal join.\n+ */\n+abstract class StreamExecJoinRuleBase(description: String)\n+  extends RelOptRule(\n+    operand(classOf[FlinkLogicalJoin],\n+      operand(classOf[FlinkLogicalRel], any()),\n+      operand(classOf[FlinkLogicalRel], any())),\n+    description) {\n+\n+  protected def extractWindowBounds(join: FlinkLogicalJoin):\n+    (Option[WindowBounds], Option[RexNode]) = {\n+    val tableConfig = FlinkRelOptUtil.getTableConfigFromContext(join)\n+    IntervalJoinUtil.extractWindowBoundsFromPredicate(\n+      join.getCondition,\n+      join.getLeft.getRowType.getFieldCount,\n+      join.getRowType,\n+      join.getCluster.getRexBuilder,\n+      tableConfig)\n+  }\n+\n+  override def onMatch(call: RelOptRuleCall): Unit = {\n+    val join = call.rel[FlinkLogicalJoin](0)\n+    val left = call.rel[FlinkLogicalRel](1)\n+    val right = call.rel[FlinkLogicalRel](2)\n+\n+    def toHashTraitByColumns(\n+        columns: util.Collection[_ <: Number],\n+        inputTraitSet: RelTraitSet): RelTraitSet = {\n+      val distribution = if (columns.size() == 0) {\n+        FlinkRelDistribution.SINGLETON\n+      } else {\n+        FlinkRelDistribution.hash(columns)\n+      }\n+      inputTraitSet\n+          .replace(FlinkConventions.STREAM_PHYSICAL)\n+          .replace(distribution)\n+    }\n+\n+    val newRight = right match {\n+      case snapshot: FlinkLogicalSnapshot =>\n+        snapshot.getInput\n+      case rel: FlinkLogicalRel => rel\n+    }", "originalCommit": "b8f43eb25f0360886d7cf5bf47449d7122347f79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1Njc4Mg==", "url": "https://github.com/apache/flink/pull/14404#discussion_r546256782", "bodyText": "@wuchong Thanks for your review, I have made an update based on the comment.", "author": "jrthe42", "createdAt": "2020-12-19T16:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5NTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ4ODM4OA==", "url": "https://github.com/apache/flink/pull/14404#discussion_r546488388", "bodyText": "I think we don't need the leftInput parameter, it can be derived from the join node join.getLeft.", "author": "wuchong", "createdAt": "2020-12-21T03:11:42Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/physical/stream/StreamExecJoinRuleBase.scala", "diffHunk": "@@ -70,28 +70,30 @@ abstract class StreamExecJoinRuleBase(description: String)\n           .replace(distribution)\n     }\n \n-    val newRight = right match {\n-      case snapshot: FlinkLogicalSnapshot =>\n-        snapshot.getInput\n-      case rel: FlinkLogicalRel => rel\n+    def convertInput(input: RelNode, columns: util.Collection[_ <: Number]): RelNode = {\n+      val requiredTraitSet = toHashTraitByColumns(columns, input.getTraitSet)\n+      RelOptRule.convert(input, requiredTraitSet)\n     }\n \n     val joinInfo = join.analyzeCondition\n-    val (leftRequiredTrait, rightRequiredTrait) = (\n-        toHashTraitByColumns(joinInfo.leftKeys, left.getTraitSet),\n-        toHashTraitByColumns(joinInfo.rightKeys, newRight.getTraitSet))\n-\n-    val convertedLeft: RelNode = RelOptRule.convert(left, leftRequiredTrait)\n-    val convertedRight: RelNode = RelOptRule.convert(newRight, rightRequiredTrait)\n     val providedTraitSet: RelTraitSet = join.getTraitSet.replace(FlinkConventions.STREAM_PHYSICAL)\n \n-    val newJoin = transform(join, convertedLeft, convertedRight, providedTraitSet)\n+    val leftConversion = leftInput => {\n+      convertInput(leftInput, joinInfo.leftKeys)\n+    }\n+    val rightConversion = rightInput => {\n+      convertInput(rightInput, joinInfo.rightKeys)\n+    }\n+\n+    val newJoin = transform(join, left, leftConversion, right, rightConversion, providedTraitSet)\n     call.transformTo(newJoin)\n   }\n \n   protected def transform(\n       join: FlinkLogicalJoin,\n-      convertedLeft: RelNode,\n-      convertedRight: RelNode,\n+      leftInput: FlinkRelNode,", "originalCommit": "dd0716385b6e0c59ae8d9b33cd56d191bd65342a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU3MTkyOA==", "url": "https://github.com/apache/flink/pull/14404#discussion_r546571928", "bodyText": "join.getLeft and join.getRight will return RelSubset, we can not use that directly", "author": "jrthe42", "createdAt": "2020-12-21T08:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ4ODM4OA=="}], "type": "inlineReview"}, {"oid": "794ff7d81e8a74032fe24dc9fbceb7ec54f14fa0", "url": "https://github.com/apache/flink/commit/794ff7d81e8a74032fe24dc9fbceb7ec54f14fa0", "message": "address review comment", "committedDate": "2020-12-21T08:25:38Z", "type": "commit"}, {"oid": "794ff7d81e8a74032fe24dc9fbceb7ec54f14fa0", "url": "https://github.com/apache/flink/commit/794ff7d81e8a74032fe24dc9fbceb7ec54f14fa0", "message": "address review comment", "committedDate": "2020-12-21T08:25:38Z", "type": "forcePushed"}]}