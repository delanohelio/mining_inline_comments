{"pr_number": 11718, "pr_title": "[FLINK-17118][python] Add Cython support for primitive data types", "pr_createdAt": "2020-04-13T14:52:17Z", "pr_url": "https://github.com/apache/flink/pull/11718", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MTYwNw==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407841607", "bodyText": "False -> nested", "author": "dianfu", "createdAt": "2020-04-14T03:16:17Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MjU1NA==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407842554", "bodyText": "What about removed the prefix _output?", "author": "dianfu", "createdAt": "2020-04-14T03:19:48Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4Njk5Nw==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407886997", "bodyText": "Rename to InputStreamWrapper?", "author": "dianfu", "createdAt": "2020-04-14T06:04:49Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5MjMwOQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407892309", "bodyText": "Rename to InputStreamAndFunctionWrapper?", "author": "dianfu", "createdAt": "2020-04-14T06:20:28Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5MjU5Mw==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407892593", "bodyText": "Add some description about this class.", "author": "dianfu", "createdAt": "2020-04-14T06:21:27Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NDU5MQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407894591", "bodyText": "_load_next_row", "author": "dianfu", "createdAt": "2020-04-14T06:26:45Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5ODYzNQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407898635", "bodyText": "Move this method to TableFunctionRowCoderImpl", "author": "dianfu", "createdAt": "2020-04-14T06:37:37Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            self._write_data(result)\n+            self._dump_row()\n+        self._after_encode(out_stream)\n+\n+    cdef encode_table_row_result(self, WrapperFuncInputElement wrapper_func_input_element,", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5OTA3MQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407899071", "bodyText": "Remove this method and move the implementation to encode_to_stream directly.", "author": "dianfu", "createdAt": "2020-04-14T06:38:38Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNzQ5Mg==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407907492", "bodyText": "_before_encode -> _prepare_encode", "author": "dianfu", "createdAt": "2020-04-14T06:58:45Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwODU0Mw==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407908543", "bodyText": "_write_data -> _encode_one_row", "author": "dianfu", "createdAt": "2020-04-14T07:00:58Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            self._write_data(result)", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTg2Mg==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407909862", "bodyText": "Could you add some explain how 719163 is computed?", "author": "dianfu", "createdAt": "2020-04-14T07:04:02Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            self._write_data(result)\n+            self._dump_row()\n+        self._after_encode(out_stream)\n+\n+    cdef encode_table_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                                 OutputStream out_stream):\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._write_data(value)\n+            self._dump_end_message()\n+\n+        self._after_encode(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef void _consume_input_data(self, WrapperInputElement wrapper_input_element, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        wrapper_input_element.input_field_coders = self._output_field_coders\n+        wrapper_input_element.input_remaining_bits_num = self._output_remaining_bits_num\n+        wrapper_input_element.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        wrapper_input_element.input_field_count = self._output_field_count\n+        wrapper_input_element.input_field_type = self._output_field_type\n+        wrapper_input_element.input_coder_type = self._output_coder_type\n+        wrapper_input_element.input_stream.pos = size\n+        wrapper_input_element.input_buffer_size = size\n+\n+    cdef void _write_data(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == PRIMITIVE:\n+                    self._dump_field_primitive(self._output_field_type[i], item)\n+\n+        self._dump_row()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _load_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == PRIMITIVE:\n+                    self.row[i] = self._load_field_primitive(self._input_field_type[i])\n+\n+    cdef object _load_field_primitive(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._load_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._load_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._load_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._load_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._load_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._load_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._load_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._load_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._load_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            return datetime.date.fromordinal(self._load_int() + 719163)", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxNTk5MQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407915991", "bodyText": "_wrapInputStream", "author": "dianfu", "createdAt": "2020-04-14T07:16:52Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            self._write_data(result)\n+            self._dump_row()\n+        self._after_encode(out_stream)\n+\n+    cdef encode_table_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                                 OutputStream out_stream):\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._write_data(value)\n+            self._dump_end_message()\n+\n+        self._after_encode(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef void _consume_input_data(self, WrapperInputElement wrapper_input_element, size_t size):", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxNzA0MQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r407917041", "bodyText": "Remove the parentheses", "author": "dianfu", "createdAt": "2020-04-14T07:18:47Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,558 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class WrapperFuncInputElement:\n+    def __cinit__(self, func, wrapper_input_element):\n+        self.func = func\n+        self.wrapper_input_element = wrapper_input_element\n+\n+cdef class WrapperInputElement:\n+    def __cinit__(self, input_stream):\n+        self.input_stream = input_stream\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, False)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, flatten_row_coder):\n+        self._flatten_row_coder = flatten_row_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._flatten_row_coder.encode_table_row_result(value, out_stream)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._flatten_row_coder.decode_from_stream(in_stream, nested)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef WrapperInputElement wrapper_input_element\n+        wrapper_input_element = WrapperInputElement(in_stream)\n+        self._consume_input_data(wrapper_input_element, in_stream.size())\n+        return wrapper_input_element\n+\n+    cpdef encode_to_stream(self, wrapper_stream, OutputStream out_stream, bint nested):\n+        self.encode_row_result(wrapper_stream, out_stream)\n+\n+    cdef encode_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                           OutputStream out_stream):\n+        cdef list result\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            self._write_data(result)\n+            self._dump_row()\n+        self._after_encode(out_stream)\n+\n+    cdef encode_table_row_result(self, WrapperFuncInputElement wrapper_func_input_element,\n+                                 OutputStream out_stream):\n+        self._before_encode(wrapper_func_input_element, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._load_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._write_data(value)\n+            self._dump_end_message()\n+\n+        self._after_encode(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef void _consume_input_data(self, WrapperInputElement wrapper_input_element, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        wrapper_input_element.input_field_coders = self._output_field_coders\n+        wrapper_input_element.input_remaining_bits_num = self._output_remaining_bits_num\n+        wrapper_input_element.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        wrapper_input_element.input_field_count = self._output_field_count\n+        wrapper_input_element.input_field_type = self._output_field_type\n+        wrapper_input_element.input_coder_type = self._output_coder_type\n+        wrapper_input_element.input_stream.pos = size\n+        wrapper_input_element.input_buffer_size = size\n+\n+    cdef void _write_data(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == PRIMITIVE:\n+                    self._dump_field_primitive(self._output_field_type[i], item)\n+\n+        self._dump_row()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _load_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == PRIMITIVE:\n+                    self.row[i] = self._load_field_primitive(self._input_field_type[i])\n+\n+    cdef object _load_field_primitive(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._load_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._load_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._load_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._load_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._load_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._load_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._load_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._load_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._load_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            return datetime.date.fromordinal(self._load_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._load_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _load_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _load_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _load_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _load_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _load_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._load_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _load_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._load_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _load_bytes(self):\n+        cdef libc.stdint.int32_t size = self._load_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _before_encode(self, WrapperFuncInputElement wrapper_func_input_element,\n+                             OutputStream out_stream):\n+        cdef WrapperInputElement wrapper_input_element\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        # get the data pointer of input_stream\n+        self._input_data = wrapper_func_input_element.wrapper_input_element.input_stream.allc\n+        self._input_buffer_size = wrapper_func_input_element.wrapper_input_element.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        wrapper_input_element = wrapper_func_input_element.wrapper_input_element\n+        self._input_field_count = wrapper_input_element.input_field_count\n+        self._input_leading_complete_bytes_num = wrapper_input_element.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = wrapper_input_element.input_remaining_bits_num\n+        self._input_field_type = wrapper_input_element.input_field_type\n+        self._input_coder_type = wrapper_input_element.input_coder_type\n+        self._input_field_coders = wrapper_input_element.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = wrapper_func_input_element.func\n+\n+    cdef void _after_encode(self, OutputStream out_stream):\n+        # map the output_data to the buffer of output_stream\n+        out_stream.data = self._output_data\n+        out_stream.pos = self._output_pos\n+        out_stream.buffer_size = self._output_buffer_size\n+\n+    cdef void _dump_field_primitive(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._dump_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._dump_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._dump_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._dump_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._dump_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._dump_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._dump_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._dump_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._dump_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            self._dump_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._dump_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _dump_end_message(self):\n+        if self._output_buffer_size < self._output_pos + 2:\n+            self._output_buffer_size *= 2\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        self._output_data[self._output_pos] = 0x01\n+        self._output_data[self._output_pos + 1] = 0x00\n+        self._output_pos += 2\n+\n+    cdef void _dump_row(self):\n+        cdef size_t size\n+        cdef size_t i\n+        cdef bint is_realloc\n+        cdef char bits\n+        # the length of the variable prefix length will be less than 9 bytes\n+        if self._output_buffer_size < self._output_pos + self._output_row_pos + 9:\n+            self._output_buffer_size += self._output_row_buffer_size + 9\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        size = self._output_row_pos\n+        # write variable prefix length\n+        while size:\n+            bits = size & 0x7F\n+            size >>= 7\n+            if size:\n+                bits |= 0x80\n+            self._output_data[self._output_pos] = bits\n+            self._output_pos += 1\n+        if self._output_row_pos < 8:\n+            # This is faster than memcpy when the string is short.\n+            for i in range(self._output_row_pos):\n+                self._output_data[self._output_pos + i] = self._output_row_data[i]\n+        else:\n+            libc.string.memcpy(self._output_data + self._output_pos, self._output_row_data,\n+                               self._output_row_pos)\n+        self._output_pos += self._output_row_pos\n+        self._output_row_pos = 0\n+\n+    cdef void _dump_byte(self, unsigned char val):\n+        if self._output_row_buffer_size < self._output_row_pos + 1:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = val\n+        self._output_row_pos += 1\n+\n+    cdef void _dump_smallint(self, libc.stdint.int16_t v):\n+        if self._output_row_buffer_size < self._output_row_pos + 2:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = <unsigned char> (v >> 8)\n+        self._output_row_data[self._output_row_pos + 1] = <unsigned char> (v)", "originalCommit": "f95e65edce3fa51ca0caa98c53987c581bd0ab92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1OTQzMA==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408759430", "bodyText": "Could you refactor this a bit and make it reusable for all the _encode_xxx functions?", "author": "dianfu", "createdAt": "2020-04-15T11:04:59Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = self._wrap_input_stream(in_stream, in_stream.size())\n+        return input_stream_wrapper\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        cdef list result\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            self._encode_one_row(result)\n+            self._maybe_flush(out_stream)\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef InputStreamWrapper _wrap_input_stream(self, InputStream input_stream, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = InputStreamWrapper()\n+        input_stream_wrapper.input_stream = input_stream\n+        input_stream_wrapper.input_field_coders = self._output_field_coders\n+        input_stream_wrapper.input_remaining_bits_num = self._output_remaining_bits_num\n+        input_stream_wrapper.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        input_stream_wrapper.input_field_count = self._output_field_count\n+        input_stream_wrapper.input_field_type = self._output_field_type\n+        input_stream_wrapper.input_coder_type = self._output_coder_type\n+        input_stream_wrapper.input_stream.pos = size\n+        input_stream_wrapper.input_buffer_size = size\n+        return input_stream_wrapper\n+\n+    cdef void _encode_one_row(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == SIMPLE:\n+                    self._encode_field_simple(self._output_field_type[i], item)\n+\n+        self._copy_row_buffer_to_output_buffer()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _decode_next_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == SIMPLE:\n+                    self.row[i] = self._decode_field_simple(self._input_field_type[i])\n+\n+    cdef object _decode_field_simple(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._decode_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._decode_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._decode_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._decode_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._decode_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._decode_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._decode_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._decode_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._decode_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            return datetime.date.fromordinal(self._decode_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._decode_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _decode_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _decode_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _decode_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _decode_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _decode_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._decode_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _decode_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._decode_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _decode_bytes(self):\n+        cdef libc.stdint.int32_t size = self._decode_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _prepare_encode(self, InputStreamAndFunctionWrapper input_stream_and_function_wrapper,\n+                              OutputStream out_stream):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        input_stream_wrapper = input_stream_and_function_wrapper.input_stream_wrapper\n+        # get the data pointer of input_stream\n+        self._input_data = input_stream_wrapper.input_stream.allc\n+        self._input_buffer_size = input_stream_wrapper.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        self._input_field_count = input_stream_wrapper.input_field_count\n+        self._input_leading_complete_bytes_num = input_stream_wrapper.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = input_stream_wrapper.input_remaining_bits_num\n+        self._input_field_type = input_stream_wrapper.input_field_type\n+        self._input_coder_type = input_stream_wrapper.input_coder_type\n+        self._input_field_coders = input_stream_wrapper.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = input_stream_and_function_wrapper.func\n+\n+    cdef void _encode_field_simple(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._encode_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._encode_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._encode_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._encode_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._encode_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._encode_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._encode_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._encode_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._encode_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            self._encode_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._encode_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _encode_end_message(self):\n+        if self._output_buffer_size < self._output_pos + 2:\n+            self._output_buffer_size *= 2\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        self._output_data[self._output_pos] = 0x01\n+        self._output_data[self._output_pos + 1] = 0x00\n+        self._output_pos += 2\n+\n+    cdef void _copy_row_buffer_to_output_buffer(self):\n+        cdef size_t size\n+        cdef size_t i\n+        cdef bint is_realloc\n+        cdef char bits\n+        # the length of the variable prefix length will be less than 9 bytes\n+        if self._output_buffer_size < self._output_pos + self._output_row_pos + 9:\n+            self._output_buffer_size += self._output_row_buffer_size + 9\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        size = self._output_row_pos\n+        # write variable prefix length\n+        while size:\n+            bits = size & 0x7F\n+            size >>= 7\n+            if size:\n+                bits |= 0x80\n+            self._output_data[self._output_pos] = bits\n+            self._output_pos += 1\n+        if self._output_row_pos < 8:\n+            # This is faster than memcpy when the string is short.\n+            for i in range(self._output_row_pos):\n+                self._output_data[self._output_pos + i] = self._output_row_data[i]\n+        else:\n+            libc.string.memcpy(self._output_data + self._output_pos, self._output_row_data,\n+                               self._output_row_pos)\n+        self._output_pos += self._output_row_pos\n+        self._output_row_pos = 0\n+\n+    cdef void _maybe_flush(self, OutputStream out_stream):\n+        # Currently, it will trigger flushing when the size of buffer reach to 10_000_000\n+        if self._output_pos > 10_000_000:\n+            self._map_output_data_to_output_stream(out_stream)\n+            out_stream.flush()\n+            self._output_pos = 0\n+\n+    cdef void _map_output_data_to_output_stream(self, OutputStream out_stream):\n+        out_stream.data = self._output_data\n+        out_stream.pos = self._output_pos\n+        out_stream.buffer_size = self._output_buffer_size\n+\n+    cdef void _encode_byte(self, unsigned char val):\n+        if self._output_row_buffer_size < self._output_row_pos + 1:", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTgyMA==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408761820", "bodyText": "There is possibility that the buffer size _output_row_buffer_size *= 2 isn't large enough.", "author": "dianfu", "createdAt": "2020-04-15T11:09:49Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = self._wrap_input_stream(in_stream, in_stream.size())\n+        return input_stream_wrapper\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        cdef list result\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            self._encode_one_row(result)\n+            self._maybe_flush(out_stream)\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef InputStreamWrapper _wrap_input_stream(self, InputStream input_stream, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = InputStreamWrapper()\n+        input_stream_wrapper.input_stream = input_stream\n+        input_stream_wrapper.input_field_coders = self._output_field_coders\n+        input_stream_wrapper.input_remaining_bits_num = self._output_remaining_bits_num\n+        input_stream_wrapper.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        input_stream_wrapper.input_field_count = self._output_field_count\n+        input_stream_wrapper.input_field_type = self._output_field_type\n+        input_stream_wrapper.input_coder_type = self._output_coder_type\n+        input_stream_wrapper.input_stream.pos = size\n+        input_stream_wrapper.input_buffer_size = size\n+        return input_stream_wrapper\n+\n+    cdef void _encode_one_row(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == SIMPLE:\n+                    self._encode_field_simple(self._output_field_type[i], item)\n+\n+        self._copy_row_buffer_to_output_buffer()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _decode_next_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == SIMPLE:\n+                    self.row[i] = self._decode_field_simple(self._input_field_type[i])\n+\n+    cdef object _decode_field_simple(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._decode_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._decode_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._decode_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._decode_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._decode_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._decode_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._decode_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._decode_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._decode_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            return datetime.date.fromordinal(self._decode_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._decode_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _decode_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _decode_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _decode_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _decode_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _decode_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._decode_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _decode_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._decode_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _decode_bytes(self):\n+        cdef libc.stdint.int32_t size = self._decode_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _prepare_encode(self, InputStreamAndFunctionWrapper input_stream_and_function_wrapper,\n+                              OutputStream out_stream):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        input_stream_wrapper = input_stream_and_function_wrapper.input_stream_wrapper\n+        # get the data pointer of input_stream\n+        self._input_data = input_stream_wrapper.input_stream.allc\n+        self._input_buffer_size = input_stream_wrapper.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        self._input_field_count = input_stream_wrapper.input_field_count\n+        self._input_leading_complete_bytes_num = input_stream_wrapper.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = input_stream_wrapper.input_remaining_bits_num\n+        self._input_field_type = input_stream_wrapper.input_field_type\n+        self._input_coder_type = input_stream_wrapper.input_coder_type\n+        self._input_field_coders = input_stream_wrapper.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = input_stream_and_function_wrapper.func\n+\n+    cdef void _encode_field_simple(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._encode_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._encode_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._encode_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._encode_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._encode_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._encode_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._encode_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._encode_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._encode_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            self._encode_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._encode_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _encode_end_message(self):\n+        if self._output_buffer_size < self._output_pos + 2:\n+            self._output_buffer_size *= 2\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        self._output_data[self._output_pos] = 0x01\n+        self._output_data[self._output_pos + 1] = 0x00\n+        self._output_pos += 2\n+\n+    cdef void _copy_row_buffer_to_output_buffer(self):\n+        cdef size_t size\n+        cdef size_t i\n+        cdef bint is_realloc\n+        cdef char bits\n+        # the length of the variable prefix length will be less than 9 bytes\n+        if self._output_buffer_size < self._output_pos + self._output_row_pos + 9:\n+            self._output_buffer_size += self._output_row_buffer_size + 9\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        size = self._output_row_pos\n+        # write variable prefix length\n+        while size:\n+            bits = size & 0x7F\n+            size >>= 7\n+            if size:\n+                bits |= 0x80\n+            self._output_data[self._output_pos] = bits\n+            self._output_pos += 1\n+        if self._output_row_pos < 8:\n+            # This is faster than memcpy when the string is short.\n+            for i in range(self._output_row_pos):\n+                self._output_data[self._output_pos + i] = self._output_row_data[i]\n+        else:\n+            libc.string.memcpy(self._output_data + self._output_pos, self._output_row_data,\n+                               self._output_row_pos)\n+        self._output_pos += self._output_row_pos\n+        self._output_row_pos = 0\n+\n+    cdef void _maybe_flush(self, OutputStream out_stream):\n+        # Currently, it will trigger flushing when the size of buffer reach to 10_000_000\n+        if self._output_pos > 10_000_000:\n+            self._map_output_data_to_output_stream(out_stream)\n+            out_stream.flush()\n+            self._output_pos = 0\n+\n+    cdef void _map_output_data_to_output_stream(self, OutputStream out_stream):\n+        out_stream.data = self._output_data\n+        out_stream.pos = self._output_pos\n+        out_stream.buffer_size = self._output_buffer_size\n+\n+    cdef void _encode_byte(self, unsigned char val):\n+        if self._output_row_buffer_size < self._output_row_pos + 1:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = val\n+        self._output_row_pos += 1\n+\n+    cdef void _encode_smallint(self, libc.stdint.int16_t v):\n+        if self._output_row_buffer_size < self._output_row_pos + 2:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = <unsigned char> (v >> 8)\n+        self._output_row_data[self._output_row_pos + 1] = <unsigned char> v\n+        self._output_row_pos += 2\n+\n+    cdef void _encode_int(self, libc.stdint.int32_t v):\n+        if self._output_row_buffer_size < self._output_row_pos + 4:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = <unsigned char> (v >> 24)\n+        self._output_row_data[self._output_row_pos + 1] = <unsigned char> (v >> 16)\n+        self._output_row_data[self._output_row_pos + 2] = <unsigned char> (v >> 8)\n+        self._output_row_data[self._output_row_pos + 3] = <unsigned char> v\n+        self._output_row_pos += 4\n+\n+    cdef void _encode_bigint(self, libc.stdint.int64_t v):\n+        if self._output_row_buffer_size < self._output_row_pos + 8:\n+            self._output_row_buffer_size *= 2\n+            self._output_row_data = <char*> libc.stdlib.realloc(self._output_row_data,\n+                                                                self._output_row_buffer_size)\n+        self._output_row_data[self._output_row_pos] = <unsigned char> (v >> 56)\n+        self._output_row_data[self._output_row_pos + 1] = <unsigned char> (v >> 48)\n+        self._output_row_data[self._output_row_pos + 2] = <unsigned char> (v >> 40)\n+        self._output_row_data[self._output_row_pos + 3] = <unsigned char> (v >> 32)\n+        self._output_row_data[self._output_row_pos + 4] = <unsigned char> (v >> 24)\n+        self._output_row_data[self._output_row_pos + 5] = <unsigned char> (v >> 16)\n+        self._output_row_data[self._output_row_pos + 6] = <unsigned char> (v >> 8)\n+        self._output_row_data[self._output_row_pos + 7] = <unsigned char> v\n+        self._output_row_pos += 8\n+\n+    cdef void _encode_float(self, float v):\n+        self._encode_int((<libc.stdint.int32_t*> <char*> &v)[0])\n+\n+    cdef void _encode_double(self, double v):\n+        self._encode_bigint((<libc.stdint.int64_t*> <char*> &v)[0])\n+\n+    cdef void _encode_bytes(self, char*b):\n+        cdef libc.stdint.int32_t length = strlen(b)\n+        self._encode_int(length)\n+        if self._output_row_buffer_size < self._output_row_pos + length:\n+            self._output_row_buffer_size *= 2", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NjUwNA==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408766504", "bodyText": "Move this method to TableFunctionRowCoderImpl?", "author": "dianfu", "createdAt": "2020-04-15T11:18:57Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = self._wrap_input_stream(in_stream, in_stream.size())\n+        return input_stream_wrapper\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        cdef list result\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            self._encode_one_row(result)\n+            self._maybe_flush(out_stream)\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef InputStreamWrapper _wrap_input_stream(self, InputStream input_stream, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = InputStreamWrapper()\n+        input_stream_wrapper.input_stream = input_stream\n+        input_stream_wrapper.input_field_coders = self._output_field_coders\n+        input_stream_wrapper.input_remaining_bits_num = self._output_remaining_bits_num\n+        input_stream_wrapper.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        input_stream_wrapper.input_field_count = self._output_field_count\n+        input_stream_wrapper.input_field_type = self._output_field_type\n+        input_stream_wrapper.input_coder_type = self._output_coder_type\n+        input_stream_wrapper.input_stream.pos = size\n+        input_stream_wrapper.input_buffer_size = size\n+        return input_stream_wrapper\n+\n+    cdef void _encode_one_row(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == SIMPLE:\n+                    self._encode_field_simple(self._output_field_type[i], item)\n+\n+        self._copy_row_buffer_to_output_buffer()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _decode_next_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == SIMPLE:\n+                    self.row[i] = self._decode_field_simple(self._input_field_type[i])\n+\n+    cdef object _decode_field_simple(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._decode_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._decode_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._decode_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._decode_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._decode_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._decode_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._decode_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._decode_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._decode_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            return datetime.date.fromordinal(self._decode_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._decode_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _decode_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _decode_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _decode_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _decode_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _decode_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._decode_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _decode_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._decode_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _decode_bytes(self):\n+        cdef libc.stdint.int32_t size = self._decode_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _prepare_encode(self, InputStreamAndFunctionWrapper input_stream_and_function_wrapper,\n+                              OutputStream out_stream):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        input_stream_wrapper = input_stream_and_function_wrapper.input_stream_wrapper\n+        # get the data pointer of input_stream\n+        self._input_data = input_stream_wrapper.input_stream.allc\n+        self._input_buffer_size = input_stream_wrapper.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        self._input_field_count = input_stream_wrapper.input_field_count\n+        self._input_leading_complete_bytes_num = input_stream_wrapper.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = input_stream_wrapper.input_remaining_bits_num\n+        self._input_field_type = input_stream_wrapper.input_field_type\n+        self._input_coder_type = input_stream_wrapper.input_coder_type\n+        self._input_field_coders = input_stream_wrapper.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = input_stream_and_function_wrapper.func\n+\n+    cdef void _encode_field_simple(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._encode_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._encode_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._encode_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._encode_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._encode_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._encode_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._encode_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._encode_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._encode_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            self._encode_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._encode_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _encode_end_message(self):", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc3MTg3Ng==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408771876", "bodyText": "Rename it to something like _tmp_output_buffer to make it more explicitly that this is a tempory buffer?", "author": "dianfu", "createdAt": "2020-04-15T11:29:32Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc3MjYyNg==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408772626", "bodyText": "Rename to _copy_to_output_buffer?", "author": "dianfu", "createdAt": "2020-04-15T11:31:07Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = self._wrap_input_stream(in_stream, in_stream.size())\n+        return input_stream_wrapper\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        cdef list result\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            self._encode_one_row(result)\n+            self._maybe_flush(out_stream)\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef InputStreamWrapper _wrap_input_stream(self, InputStream input_stream, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = InputStreamWrapper()\n+        input_stream_wrapper.input_stream = input_stream\n+        input_stream_wrapper.input_field_coders = self._output_field_coders\n+        input_stream_wrapper.input_remaining_bits_num = self._output_remaining_bits_num\n+        input_stream_wrapper.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        input_stream_wrapper.input_field_count = self._output_field_count\n+        input_stream_wrapper.input_field_type = self._output_field_type\n+        input_stream_wrapper.input_coder_type = self._output_coder_type\n+        input_stream_wrapper.input_stream.pos = size\n+        input_stream_wrapper.input_buffer_size = size\n+        return input_stream_wrapper\n+\n+    cdef void _encode_one_row(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == SIMPLE:\n+                    self._encode_field_simple(self._output_field_type[i], item)\n+\n+        self._copy_row_buffer_to_output_buffer()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _decode_next_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == SIMPLE:\n+                    self.row[i] = self._decode_field_simple(self._input_field_type[i])\n+\n+    cdef object _decode_field_simple(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._decode_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._decode_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._decode_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._decode_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._decode_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._decode_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._decode_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._decode_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._decode_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            return datetime.date.fromordinal(self._decode_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._decode_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _decode_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _decode_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _decode_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _decode_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _decode_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._decode_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _decode_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._decode_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _decode_bytes(self):\n+        cdef libc.stdint.int32_t size = self._decode_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _prepare_encode(self, InputStreamAndFunctionWrapper input_stream_and_function_wrapper,\n+                              OutputStream out_stream):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        input_stream_wrapper = input_stream_and_function_wrapper.input_stream_wrapper\n+        # get the data pointer of input_stream\n+        self._input_data = input_stream_wrapper.input_stream.allc\n+        self._input_buffer_size = input_stream_wrapper.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        self._input_field_count = input_stream_wrapper.input_field_count\n+        self._input_leading_complete_bytes_num = input_stream_wrapper.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = input_stream_wrapper.input_remaining_bits_num\n+        self._input_field_type = input_stream_wrapper.input_field_type\n+        self._input_coder_type = input_stream_wrapper.input_coder_type\n+        self._input_field_coders = input_stream_wrapper.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = input_stream_and_function_wrapper.func\n+\n+    cdef void _encode_field_simple(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._encode_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._encode_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._encode_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._encode_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._encode_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._encode_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._encode_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._encode_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._encode_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            self._encode_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._encode_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _encode_end_message(self):\n+        if self._output_buffer_size < self._output_pos + 2:\n+            self._output_buffer_size *= 2\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        self._output_data[self._output_pos] = 0x01\n+        self._output_data[self._output_pos + 1] = 0x00\n+        self._output_pos += 2\n+\n+    cdef void _copy_row_buffer_to_output_buffer(self):", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc3OTEzMw==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408779133", "bodyText": "Add some comments describing why we need to establish this map.", "author": "dianfu", "createdAt": "2020-04-15T11:43:44Z", "path": "flink-python/pyflink/fn_execution/fast_coder_impl.pyx", "diffHunk": "@@ -0,0 +1,559 @@\n+################################################################################\n+#  Licensed to the Apache Software Foundation (ASF) under one\n+#  or more contributor license agreements.  See the NOTICE file\n+#  distributed with this work for additional information\n+#  regarding copyright ownership.  The ASF licenses this file\n+#  to you under the Apache License, Version 2.0 (the\n+#  \"License\"); you may not use this file except in compliance\n+#  with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+# limitations under the License.\n+################################################################################\n+# cython: language_level = 3\n+# cython: infer_types = True\n+# cython: profile=True\n+# cython: boundscheck=False, wraparound=False, initializedcheck=False, cdivision=True\n+\n+cimport libc.stdlib\n+from libc.string cimport strlen\n+\n+import datetime\n+\n+cdef class InputStreamAndFunctionWrapper:\n+    def __cinit__(self, func, input_stream_wrapper):\n+        self.func = func\n+        self.input_stream_wrapper = input_stream_wrapper\n+\n+cdef class PassThroughLengthPrefixCoderImpl(StreamCoderImpl):\n+    def __cinit__(self, value_coder):\n+        self._value_coder = value_coder\n+\n+    cpdef encode_to_stream(self, value, OutputStream out_stream, bint nested):\n+        self._value_coder.encode_to_stream(value, out_stream, nested)\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        return self._value_coder.decode_from_stream(in_stream, nested)\n+\n+    cpdef get_estimated_size_and_observables(self, value, bint nested=False):\n+        return 0, []\n+\n+cdef class TableFunctionRowCoderImpl(FlattenRowCoderImpl):\n+    def __init__(self, flatten_row_coder):\n+        super(TableFunctionRowCoderImpl, self).__init__(flatten_row_coder._output_field_coders)\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            if result:\n+                for value in result:\n+                    if self._output_field_count == 1:\n+                        value = (value,)\n+                    self._encode_one_row(value)\n+                    self._maybe_flush(out_stream)\n+            self._encode_end_message()\n+\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+cdef class FlattenRowCoderImpl(StreamCoderImpl):\n+    def __init__(self, field_coders):\n+        self._output_field_coders = field_coders\n+        self._output_field_count = len(self._output_field_coders)\n+        self._output_field_type = <TypeName*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(TypeName))\n+        self._output_coder_type = <CoderType*> libc.stdlib.malloc(\n+            self._output_field_count * sizeof(CoderType))\n+        self._output_leading_complete_bytes_num = self._output_field_count // 8\n+        self._output_remaining_bits_num = self._output_field_count % 8\n+        self._output_row_buffer_size = 1024\n+        self._output_row_pos = 0\n+        self._output_row_data = <char*> libc.stdlib.malloc(self._output_row_buffer_size)\n+        self._null_byte_search_table = <unsigned char*> libc.stdlib.malloc(\n+            8 * sizeof(unsigned char))\n+        self._init_attribute()\n+\n+    cpdef decode_from_stream(self, InputStream in_stream, bint nested):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = self._wrap_input_stream(in_stream, in_stream.size())\n+        return input_stream_wrapper\n+\n+    cpdef encode_to_stream(self, input_stream_and_function_wrapper, OutputStream out_stream,\n+                           bint nested):\n+        cdef list result\n+        self._prepare_encode(input_stream_and_function_wrapper, out_stream)\n+        while self._input_buffer_size > self._input_pos:\n+            self._decode_next_row()\n+            result = self.func(self.row)\n+            self._encode_one_row(result)\n+            self._maybe_flush(out_stream)\n+        self._map_output_data_to_output_stream(out_stream)\n+\n+    cdef void _init_attribute(self):\n+        self._null_byte_search_table[0] = 0x80\n+        self._null_byte_search_table[1] = 0x40\n+        self._null_byte_search_table[2] = 0x20\n+        self._null_byte_search_table[3] = 0x10\n+        self._null_byte_search_table[4] = 0x08\n+        self._null_byte_search_table[5] = 0x04\n+        self._null_byte_search_table[6] = 0x02\n+        self._null_byte_search_table[7] = 0x01\n+        for i in range(self._output_field_count):\n+            self._output_field_type[i] = self._output_field_coders[i].type_name()\n+            self._output_coder_type[i] = self._output_field_coders[i].coder_type()\n+\n+    cdef InputStreamWrapper _wrap_input_stream(self, InputStream input_stream, size_t size):\n+        # wrappers the input field coders and input_stream together\n+        # so that it can be transposed to operations\n+        cdef InputStreamWrapper input_stream_wrapper\n+        input_stream_wrapper = InputStreamWrapper()\n+        input_stream_wrapper.input_stream = input_stream\n+        input_stream_wrapper.input_field_coders = self._output_field_coders\n+        input_stream_wrapper.input_remaining_bits_num = self._output_remaining_bits_num\n+        input_stream_wrapper.input_leading_complete_bytes_num = \\\n+            self._output_leading_complete_bytes_num\n+        input_stream_wrapper.input_field_count = self._output_field_count\n+        input_stream_wrapper.input_field_type = self._output_field_type\n+        input_stream_wrapper.input_coder_type = self._output_coder_type\n+        input_stream_wrapper.input_stream.pos = size\n+        input_stream_wrapper.input_buffer_size = size\n+        return input_stream_wrapper\n+\n+    cdef void _encode_one_row(self, value):\n+        cdef libc.stdint.int32_t i\n+        self._write_null_mask(value, self._output_leading_complete_bytes_num,\n+                              self._output_remaining_bits_num)\n+        for i in range(self._output_field_count):\n+            item = value[i]\n+            if item is not None:\n+                if self._output_coder_type[i] == SIMPLE:\n+                    self._encode_field_simple(self._output_field_type[i], item)\n+\n+        self._copy_row_buffer_to_output_buffer()\n+\n+    cdef void _read_null_mask(self, bint*null_mask,\n+                              libc.stdint.int32_t input_leading_complete_bytes_num,\n+                              libc.stdint.int32_t input_remaining_bits_num):\n+        cdef libc.stdint.int32_t field_pos, i\n+        cdef unsigned char b\n+        field_pos = 0\n+        for _ in range(input_leading_complete_bytes_num):\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(8):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+        if input_remaining_bits_num:\n+            b = self._input_data[self._input_pos]\n+            self._input_pos += 1\n+            for i in range(input_remaining_bits_num):\n+                null_mask[field_pos] = (b & self._null_byte_search_table[i]) > 0\n+                field_pos += 1\n+\n+    cdef void _decode_next_row(self):\n+        cdef libc.stdint.int32_t i\n+        # skip prefix variable int length\n+        while self._input_data[self._input_pos] & 0x80:\n+            self._input_pos += 1\n+        self._input_pos += 1\n+        self._read_null_mask(self._null_mask, self._input_leading_complete_bytes_num,\n+                             self._input_remaining_bits_num)\n+        for i in range(self._input_field_count):\n+            if self._null_mask[i]:\n+                self.row[i] = None\n+            else:\n+                if self._input_coder_type[i] == SIMPLE:\n+                    self.row[i] = self._decode_field_simple(self._input_field_type[i])\n+\n+    cdef object _decode_field_simple(self, TypeName field_type):\n+        cdef libc.stdint.int32_t value, minutes, seconds, hours\n+        cdef libc.stdint.int64_t milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            return self._decode_byte()\n+        elif field_type == SMALLINT:\n+            # smallint\n+            return self._decode_smallint()\n+        elif field_type == INT:\n+            # int\n+            return self._decode_int()\n+        elif field_type == BIGINT:\n+            # bigint\n+            return self._decode_bigint()\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            return not not self._decode_byte()\n+        elif field_type == FLOAT:\n+            # float\n+            return self._decode_float()\n+        elif field_type == DOUBLE:\n+            # double\n+            return self._decode_double()\n+        elif field_type == BINARY:\n+            # bytes\n+            return self._decode_bytes()\n+        elif field_type == CHAR:\n+            # str\n+            return self._decode_bytes().decode(\"utf-8\")\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            return datetime.date.fromordinal(self._decode_int() + 719163)\n+        elif field_type == TIME:\n+            # Time\n+            value = self._decode_int()\n+            seconds = value // 1000\n+            milliseconds = value % 1000\n+            minutes = seconds // 60\n+            seconds %= 60\n+            hours = minutes // 60\n+            minutes %= 60\n+            return datetime.time(hours, minutes, seconds, milliseconds * 1000)\n+\n+    cdef unsigned char _decode_byte(self) except? -1:\n+        self._input_pos += 1\n+        return <unsigned char> self._input_data[self._input_pos - 1]\n+\n+    cdef libc.stdint.int16_t _decode_smallint(self) except? -1:\n+        self._input_pos += 2\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8)\n+\n+    cdef libc.stdint.int32_t _decode_int(self) except? -1:\n+        self._input_pos += 4\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint32_t> <unsigned char> self._input_data[\n+                    self._input_pos - 4] << 24)\n+\n+    cdef libc.stdint.int64_t _decode_bigint(self) except? -1:\n+        self._input_pos += 8\n+        return (<unsigned char> self._input_data[self._input_pos - 1]\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 2] << 8\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 3] << 16\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 4] << 24\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 5] << 32\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 6] << 40\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[self._input_pos - 7] << 48\n+                | <libc.stdint.uint64_t> <unsigned char> self._input_data[\n+                    self._input_pos - 8] << 56)\n+\n+    cdef float _decode_float(self) except? -1:\n+        cdef libc.stdint.int32_t as_long = self._decode_int()\n+        return (<float*> <char*> &as_long)[0]\n+\n+    cdef double _decode_double(self) except? -1:\n+        cdef libc.stdint.int64_t as_long = self._decode_bigint()\n+        return (<double*> <char*> &as_long)[0]\n+\n+    cdef bytes _decode_bytes(self):\n+        cdef libc.stdint.int32_t size = self._decode_int()\n+        self._input_pos += size\n+        return self._input_data[self._input_pos - size: self._input_pos]\n+\n+    cdef void _prepare_encode(self, InputStreamAndFunctionWrapper input_stream_and_function_wrapper,\n+                              OutputStream out_stream):\n+        cdef InputStreamWrapper input_stream_wrapper\n+        # get the data pointer of output_stream\n+        self._output_data = out_stream.data\n+        self._output_pos = out_stream.pos\n+        self._output_buffer_size = out_stream.buffer_size\n+        self._output_row_pos = 0\n+\n+        input_stream_wrapper = input_stream_and_function_wrapper.input_stream_wrapper\n+        # get the data pointer of input_stream\n+        self._input_data = input_stream_wrapper.input_stream.allc\n+        self._input_buffer_size = input_stream_wrapper.input_buffer_size\n+\n+        # get the infos of input coder which will be used to decode data from input_stream\n+        self._input_field_count = input_stream_wrapper.input_field_count\n+        self._input_leading_complete_bytes_num = input_stream_wrapper.input_leading_complete_bytes_num\n+        self._input_remaining_bits_num = input_stream_wrapper.input_remaining_bits_num\n+        self._input_field_type = input_stream_wrapper.input_field_type\n+        self._input_coder_type = input_stream_wrapper.input_coder_type\n+        self._input_field_coders = input_stream_wrapper.input_field_coders\n+        self._null_mask = <bint*> libc.stdlib.malloc(self._input_field_count * sizeof(bint))\n+        self._input_pos = 0\n+\n+        # initial the result row and get the Python user-defined function\n+        self.row = [None for _ in range(self._input_field_count)]\n+        self.func = input_stream_and_function_wrapper.func\n+\n+    cdef void _encode_field_simple(self, TypeName field_type, item):\n+        cdef libc.stdint.int32_t hour, minute, seconds, microsecond, milliseconds\n+        if field_type == TINYINT:\n+            # tinyint\n+            self._encode_byte(item)\n+        elif field_type == SMALLINT:\n+            # smallint\n+            self._encode_smallint(item)\n+        elif field_type == INT:\n+            # int\n+            self._encode_int(item)\n+        elif field_type == BIGINT:\n+            # bigint\n+            self._encode_bigint(item)\n+        elif field_type == BOOLEAN:\n+            # boolean\n+            self._encode_byte(item)\n+        elif field_type == FLOAT:\n+            # float\n+            self._encode_float(item)\n+        elif field_type == DOUBLE:\n+            # double\n+            self._encode_double(item)\n+        elif field_type == BINARY:\n+            # bytes\n+            self._encode_bytes(item)\n+        elif field_type == CHAR:\n+            # str\n+            self._encode_bytes(item.encode('utf-8'))\n+        elif field_type == DATE:\n+            # Date\n+            # EPOCH_ORDINAL = datetime.datetime(1970, 1, 1).toordinal()\n+            # The value of EPOCH_ORDINAL is 719163\n+            self._encode_int(item.toordinal() - 719163)\n+        elif field_type == TIME:\n+            # Time\n+            hour = item.hour\n+            minute = item.minute\n+            seconds = item.second\n+            microsecond = item.microsecond\n+            milliseconds = hour * 3600000 + minute * 60000 + seconds * 1000 + microsecond // 1000\n+            self._encode_int(milliseconds)\n+\n+    # write 0x00 as end message of udtf\n+    cdef void _encode_end_message(self):\n+        if self._output_buffer_size < self._output_pos + 2:\n+            self._output_buffer_size *= 2\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        self._output_data[self._output_pos] = 0x01\n+        self._output_data[self._output_pos + 1] = 0x00\n+        self._output_pos += 2\n+\n+    cdef void _copy_row_buffer_to_output_buffer(self):\n+        cdef size_t size\n+        cdef size_t i\n+        cdef bint is_realloc\n+        cdef char bits\n+        # the length of the variable prefix length will be less than 9 bytes\n+        if self._output_buffer_size < self._output_pos + self._output_row_pos + 9:\n+            self._output_buffer_size += self._output_row_buffer_size + 9\n+            self._output_data = <char*> libc.stdlib.realloc(self._output_data,\n+                                                            self._output_buffer_size)\n+        size = self._output_row_pos\n+        # write variable prefix length\n+        while size:\n+            bits = size & 0x7F\n+            size >>= 7\n+            if size:\n+                bits |= 0x80\n+            self._output_data[self._output_pos] = bits\n+            self._output_pos += 1\n+        if self._output_row_pos < 8:\n+            # This is faster than memcpy when the string is short.\n+            for i in range(self._output_row_pos):\n+                self._output_data[self._output_pos + i] = self._output_row_data[i]\n+        else:\n+            libc.string.memcpy(self._output_data + self._output_pos, self._output_row_data,\n+                               self._output_row_pos)\n+        self._output_pos += self._output_row_pos\n+        self._output_row_pos = 0\n+\n+    cdef void _maybe_flush(self, OutputStream out_stream):\n+        # Currently, it will trigger flushing when the size of buffer reach to 10_000_000\n+        if self._output_pos > 10_000_000:\n+            self._map_output_data_to_output_stream(out_stream)\n+            out_stream.flush()\n+            self._output_pos = 0\n+\n+    cdef void _map_output_data_to_output_stream(self, OutputStream out_stream):", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4Mjc1OA==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408782758", "bodyText": "Rename test_coders_common to test_coders.py and Move the coders for cython to test_fast_coders.py?", "author": "dianfu", "createdAt": "2020-04-15T11:50:31Z", "path": "flink-python/pyflink/fn_execution/tests/test_coders_common.py", "diffHunk": "@@ -36,65 +36,230 @@ def check_coder(self, coder, *values):\n             else:\n                 self.assertEqual(v, coder.decode(coder.encode(v)))\n \n+    def check_cython_coder(self, python_field_coders, cython_field_coders, data):", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4NDM4NQ==", "url": "https://github.com/apache/flink/pull/11718#discussion_r408784385", "bodyText": "Use unittest.skipIf", "author": "dianfu", "createdAt": "2020-04-15T11:53:43Z", "path": "flink-python/pyflink/fn_execution/tests/test_coders_common.py", "diffHunk": "@@ -36,65 +36,230 @@ def check_coder(self, coder, *values):\n             else:\n                 self.assertEqual(v, coder.decode(coder.encode(v)))\n \n+    def check_cython_coder(self, python_field_coders, cython_field_coders, data):\n+        from apache_beam.coders.coder_impl import create_InputStream, create_OutputStream\n+        from pyflink.fn_execution import coder_impl\n+        from pyflink.fn_execution import fast_coder_impl\n+        from pyflink.fn_execution.fast_coder_impl import InputStreamAndFunctionWrapper\n+        py_flatten_row_coder = coder_impl.FlattenRowCoderImpl(python_field_coders)\n+        internal = py_flatten_row_coder.encode(data)\n+        input_stream = create_InputStream(internal)\n+        output_stream = create_OutputStream()\n+        cy_flatten_row_coder = fast_coder_impl.FlattenRowCoderImpl(cython_field_coders)\n+        value = cy_flatten_row_coder.decode_from_stream(input_stream, False)\n+        wrapper_func_input_element = InputStreamAndFunctionWrapper(\n+            lambda v: [v[i] for i in range(len(v))], value)\n+        cy_flatten_row_coder.encode_to_stream(wrapper_func_input_element, output_stream, False)\n+        generator_result = py_flatten_row_coder.decode_from_stream(create_InputStream(\n+            output_stream.get()), False)\n+        result = []\n+        for item in generator_result:\n+            result.append(item)\n+        try:\n+            self.assertEqual(result, data)\n+        except AssertionError:\n+            self.assertEqual(len(result), len(data))\n+            self.assertEqual(len(result[0]), len(data[0]))\n+            for i in range(len(data[0])):\n+                if isinstance(data[0][i], float):\n+                    from pyflink.table.tests.test_udf import float_equal\n+                    assert float_equal(data[0][i], result[0][i], 1e-6)\n+                else:\n+                    self.assertEqual(data[0][i], result[0][i])\n+\n     # decide whether two floats are equal\n     @staticmethod\n     def float_equal(a, b, rel_tol=1e-09, abs_tol=0.0):\n         return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n \n+    def skip_python_test(self):", "originalCommit": "f08d03b3f2416ab3a6493f3a7a2c29c92c0830e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "271588a9f3d3e28a0b6da3c3965d6e717258b35b", "url": "https://github.com/apache/flink/commit/271588a9f3d3e28a0b6da3c3965d6e717258b35b", "message": "[FLINK-17118][python] Support Primitive DataTypes in Cython", "committedDate": "2020-04-16T05:55:36Z", "type": "commit"}, {"oid": "271588a9f3d3e28a0b6da3c3965d6e717258b35b", "url": "https://github.com/apache/flink/commit/271588a9f3d3e28a0b6da3c3965d6e717258b35b", "message": "[FLINK-17118][python] Support Primitive DataTypes in Cython", "committedDate": "2020-04-16T05:55:36Z", "type": "forcePushed"}]}