{"pr_number": 12107, "pr_title": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "pr_createdAt": "2020-05-13T03:37:23Z", "pr_url": "https://github.com/apache/flink/pull/12107", "timeline": [{"oid": "e873c1ae8ee8bf318b5beae2c8030bd9051cb3c2", "url": "https://github.com/apache/flink/commit/e873c1ae8ee8bf318b5beae2c8030bd9051cb3c2", "message": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "committedDate": "2020-05-13T03:37:08Z", "type": "forcePushed"}, {"oid": "387b8c2d181de89398fe0f16c6d1749e5024be40", "url": "https://github.com/apache/flink/commit/387b8c2d181de89398fe0f16c6d1749e5024be40", "message": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "committedDate": "2020-05-13T05:59:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424210750", "bodyText": "Just to clarify: do we expect an exception to be thrown in this case or is it a possible (undeterministic) outcome?\nIf we expect it, then the test needs to be modified.\nIf it\u2019s undeterministic, is there a way to make it deterministic?", "author": "AHeise", "createdAt": "2020-05-13T06:54:39Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannelTest.java", "diffHunk": "@@ -220,24 +223,24 @@ private void testConcurrentReadStateAndProcessAndRelease(boolean isRemote) throw\n \t\t}\n \t}\n \n-\tprivate Callable<Void> readRecoveredStateTask(RecoveredInputChannel inputChannel, ChannelStateReader reader) {\n+\tprivate Callable<Void> readRecoveredStateTask(RecoveredInputChannel inputChannel, ChannelStateReader reader, boolean verifyRelease) {\n \t\treturn () -> {\n \t\t\ttry {\n \t\t\t\tinputChannel.readRecoveredState(reader);\n-\t\t\t} catch (CancelTaskException ex) {\n-\t\t\t\t// within expectation\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tassertTrue(\"The expected exception should only happen in the case of released channel.\", verifyRelease && inputChannel.isReleased());", "originalCommit": "387b8c2d181de89398fe0f16c6d1749e5024be40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxODkwOA==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424218908", "bodyText": "The previous expected CancelTaskException happens inside BufferManager#requestBufferBlocking while reading recovered state by IO thread. In strict way, I think it also makes sense to limit the exception here as before.\nRegarding the concern of deterministic outcome, actually the determined outcome of this test are no buffer leaks and deadlock issues finally, but not for the determined thrown exception case.\nIf we want to strictly control the executions among IO thread and canceler thread, that means before IO thread requesting the floating buffer, then the canceler thread already released the channel to give a determined thrown exception. But it only covers the partial scenarios of the concurrent execution. In practice, these two threads can execute concurrently in any order, e.g. after IO thread already requested the floating buffer, the canceler thread works. So we did not make the precise control of them, just make them execute in random way which is more fitting for the real scenarios and can cover all the possible cases.\nActually we had many similar cases in RemoteInputChannelTest to detect the potential deadlock issues among three threads.", "author": "zhijiangW", "createdAt": "2020-05-13T07:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMzQ3MQ==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424223471", "bodyText": "I'm still concerned that the test is not as specific as it could be.\nCould we assume that an exception needs to be thrown at either place? (there is a second try-catch block) Or could it happen that no exception is thrown at all?\nIf this is non-deterministic, would it make sense to repeatedly execute the test? The test is rather fast on my machine.", "author": "AHeise", "createdAt": "2020-05-13T07:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMTE2OA==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424231168", "bodyText": "I'm still not convinced about this test. It's reimplementing production code in many aspects. For example exception handling (this exception ignoring during cancelation/closing) and threading model from Task/StreamTask, so at any time we modify those, this test has a chance to fail.\nAlso I'm pretty sure there are ITCases testing for that and the logic there is simpler and more stable manner.", "author": "pnowojski", "createdAt": "2020-05-13T07:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1Nzk5NA==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424257994", "bodyText": "Could we assume that an exception needs to be thrown at either place? (there is a second try-catch block) Or could > it happen that no exception is thrown at all?\n\nYeah, I understand your concern. Actually this test covers the following scenarios:\n\n\nFirst: IO thread inserts the buffer into channel queue, Second: canceler thread releases the channel to recycle the queued buffer. Without exception in this case.\n\n\nFirst: Canceler thread releases the channel, Second: IO thread tries to insert the buffer into channel queue. But it would check the released state and then recycle the filled buffer by IO thread. Without exception in this case.\n\n\nFirst: IO thread consumes all the available buffers while reading states and blocks on waiting for buffers. Second: canceler thread releases the channel and awake the IO thread. Then IO thread will check the isReleased state and then throw CancelTaskException.\n\n\nFirst: Canceler thread releases the channel, Second: IO thread requests buffer but does not get available buffer because of released channel, then it will check the isReleased state and throw CancelTaskException. The difference with above is that the IO thread is not awaked by canceler thread.\n\n\nMaybe there are also some other cases besides above. So if we want to get determined results, we need to design different separate tests for fine-grained scenarios, and I am not quite sure whether it is easy to control the logics among different processes. And it might be more fragile future if we change the related processes because we touch the fine-grained logics.\nFrom another aspect, the overall scenario is that while IO thread recovering state, the canceler thread is releasing the channel. As long as we construct this scenario, we do not need to touch the fine-grained logics inside every process, somehow like the ITCase as @pnowojski said above. And finally we only need to guarantee there are no deadlock and buffer leaks in the result and ignores the intermediate results.\n\nIf this is non-deterministic, would it make sense to repeatedly execute the test? The test is rather fast on my machine.\n\nI think it is hard to give a proper loop number to guarantee which action will be executed among these threads, then it might cause more fragile cases. Actually somehow we rely on this non-determined environment to try to cover all the possible cases, as mentioned in above four cases.", "author": "zhijiangW", "createdAt": "2020-05-13T08:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI2NDI1Ng==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424264256", "bodyText": "Okay thank you for the detailed explanation. I know understood the challenges. I'd also second @pnowojski that the tests are probably too fine-grain.", "author": "AHeise", "createdAt": "2020-05-13T08:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3OTc4Ng==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424279786", "bodyText": "I'm still not convinced about this test. It's reimplementing production code in many aspects. For example exception handling (this exception ignoring during cancelation/closing) and threading model from Task/StreamTask, so at any time we modify those, this test has a chance to fail.\n\nI guess the reimplementing production code refers to processRecoveredBufferTask which will consumed the recovered buffers and verify the data. This test actually only focuses on RecoveredInputChannel#readRecoveredState method, so as long as the related interaction processes is not changed, this test is still valid, no matter with how the upper component handles the CancelTaskException (ignore or throw it) .\nIn general the unit tests should avoid touching more components to bring potential fragile if some changes future. From this aspect, maybe the ITCase is more suitable for this scenario as you said. But unit tests still have somehow meanings to work on the respective methods directly, then it might has more chances to cover all the potential cases.", "author": "zhijiangW", "createdAt": "2020-05-13T08:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4MDMzNQ==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424280335", "bodyText": "I'm still not convinced about this test. It's reimplementing production code in many aspects. For example exception handling (this exception ignoring during cancelation/closing) and threading model from Task/StreamTask, so at any time we modify those, this test has a chance to fail.\n\nI guess the reimplementing production code refers to processRecoveredBufferTask which will consumed the recovered buffers and verify the data. This test actually only focuses on RecoveredInputChannel#readRecoveredState method, so as long as the related interaction processes is not changed, this test is still valid, no matter with how the upper component handles the CancelTaskException (ignore or throw it) .\nIn general the unit tests should avoid touching more components to bring potential fragile if some changes future. From this aspect, maybe the ITCase is more suitable for this scenario as you said. But unit tests still have somehow meanings to work on the respective methods directly, then it might has more chances to cover all the potential cases.", "author": "zhijiangW", "createdAt": "2020-05-13T08:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNTA2MQ==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424225061", "bodyText": "It's better to not hide an original exception in case of failure (to speed up understanding why the test is failing). Either throw the original exception, or embed it into the failure message (as cause) etc.", "author": "pnowojski", "createdAt": "2020-05-13T07:24:09Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannelTest.java", "diffHunk": "@@ -252,10 +255,8 @@ private void testConcurrentReadStateAndProcessAndRelease(boolean isRemote) throw\n \t\t\t\t\t\tbuffer.recycleBuffer();\n \t\t\t\t\t\tnumProcessedStates++;\n \t\t\t\t\t}\n-\t\t\t\t} catch (IllegalStateException e) {\n-\t\t\t\t\tif (!e.getMessage().contains(\"Queried for a buffer after channel has been closed\")) {\n-\t\t\t\t\t\tthrow e;\n-\t\t\t\t\t}\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tassertTrue(\"The expected exception should only happen in the case of released channel.\", verifyRelease && inputChannel.isReleased());", "originalCommit": "387b8c2d181de89398fe0f16c6d1749e5024be40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4MTI3MQ==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424281271", "bodyText": "Makes sense to carry the original exception onto the failure messages.", "author": "zhijiangW", "createdAt": "2020-05-13T08:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMjMzNg==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424232336", "bodyText": "As below, it's better not to hide the original exception.", "author": "pnowojski", "createdAt": "2020-05-13T07:37:23Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannelTest.java", "diffHunk": "@@ -220,24 +223,24 @@ private void testConcurrentReadStateAndProcessAndRelease(boolean isRemote) throw\n \t\t}\n \t}\n \n-\tprivate Callable<Void> readRecoveredStateTask(RecoveredInputChannel inputChannel, ChannelStateReader reader) {\n+\tprivate Callable<Void> readRecoveredStateTask(RecoveredInputChannel inputChannel, ChannelStateReader reader, boolean verifyRelease) {\n \t\treturn () -> {\n \t\t\ttry {\n \t\t\t\tinputChannel.readRecoveredState(reader);\n-\t\t\t} catch (CancelTaskException ex) {\n-\t\t\t\t// within expectation\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tassertTrue(\"The expected exception should only happen in the case of released channel.\", verifyRelease && inputChannel.isReleased());", "originalCommit": "387b8c2d181de89398fe0f16c6d1749e5024be40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "26319fb2d3dad1c3e4f652051dfa42189df3a2cb", "url": "https://github.com/apache/flink/commit/26319fb2d3dad1c3e4f652051dfa42189df3a2cb", "message": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "committedDate": "2020-05-13T09:22:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMwOTM2MA==", "url": "https://github.com/apache/flink/pull/12107#discussion_r424309360", "bodyText": "nit: you could keep the cause by throwing new AssertionError(msg, t), which would preserve the stack trace as well.", "author": "pnowojski", "createdAt": "2020-05-13T09:42:44Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannelTest.java", "diffHunk": "@@ -252,10 +255,8 @@ private void testConcurrentReadStateAndProcessAndRelease(boolean isRemote) throw\n \t\t\t\t\t\tbuffer.recycleBuffer();\n \t\t\t\t\t\tnumProcessedStates++;\n \t\t\t\t\t}\n-\t\t\t\t} catch (IllegalStateException e) {\n-\t\t\t\t\tif (!e.getMessage().contains(\"Queried for a buffer after channel has been closed\")) {\n-\t\t\t\t\t\tthrow e;\n-\t\t\t\t\t}\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tassertTrue(\"The released channel is expected, but the actual exception is \" + t.getMessage(), verifyRelease && inputChannel.isReleased());", "originalCommit": "26319fb2d3dad1c3e4f652051dfa42189df3a2cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90311e5d41df4d03184e03e535c865b3859e5efb", "url": "https://github.com/apache/flink/commit/90311e5d41df4d03184e03e535c865b3859e5efb", "message": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "committedDate": "2020-05-13T10:15:07Z", "type": "commit"}, {"oid": "90311e5d41df4d03184e03e535c865b3859e5efb", "url": "https://github.com/apache/flink/commit/90311e5d41df4d03184e03e535c865b3859e5efb", "message": "[FLINK-17640][network][tests] Fix the unstable unit tests in RecoveredInputChannelTest", "committedDate": "2020-05-13T10:15:07Z", "type": "forcePushed"}]}