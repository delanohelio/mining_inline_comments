{"pr_number": 12873, "pr_title": "[FLINK-15366][table-planner] Improve FlinkCalcMergeRule to merge calc nodes better", "pr_createdAt": "2020-07-10T15:21:49Z", "pr_url": "https://github.com/apache/flink/pull/12873", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MjQwNQ==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454852405", "bodyText": "nit: rename to topProjectInputIndices \uff1f", "author": "godfreyhe", "createdAt": "2020-07-15T07:36:59Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MjYzOQ==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454852639", "bodyText": "nit: rename to topFilterInputIndices", "author": "godfreyhe", "createdAt": "2020-07-15T07:37:26Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzA1Ng==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853056", "bodyText": "nit: rename to  bottomProjectList", "author": "godfreyhe", "createdAt": "2020-07-15T07:38:13Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzM4OA==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853388", "bodyText": "nit: put them just one line ?", "author": "godfreyhe", "createdAt": "2020-07-15T07:38:53Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzcwNg==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454853706", "bodyText": "nit: rename rexNode to project", "author": "godfreyhe", "createdAt": "2020-07-15T07:39:31Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODEwMw==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858103", "bodyText": "combine topProjectRexNodesInputs and topFilterRexNodesInputs  into  one list, then this foreach can be removed", "author": "godfreyhe", "createdAt": "2020-07-15T07:47:24Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {\n+        var nonDeterministicRexRefCnt = 0\n+        if (!RexUtil.isDeterministic(rexNode)) {\n+          topProjectRexNodesInputs.foreach(list => list.foreach(\n+            ref => if (ref == index) {\n+              nonDeterministicRexRefCnt += 1\n+            }))\n+          topFilterRexNodesInputs.foreach(", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODI3OA==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858278", "bodyText": "rename list to indices ?", "author": "godfreyhe", "createdAt": "2020-07-15T07:47:46Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n+    // topCalc's project fields and condition field.\n+    val bottomProgram = bottomCalc.getProgram\n+    val topProjectRexNodesInputs = topProgram.getProjectList\n+      .map(r => topProgram.expandLocalRef(r))\n+      .map(r => InputFinder.bits(r).toArray)\n+\n+    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n+        .toArray\n+    } else {\n+      new Array[Int](0)\n+    }\n+\n+    val bottomRexList = bottomProgram.getProjectList\n+      .map(r => bottomProgram.expandLocalRef(r))\n+      .toArray\n+\n+    bottomRexList.zipWithIndex.forall {\n+      case (rexNode: RexNode, index: Int) => {\n+        var nonDeterministicRexRefCnt = 0\n+        if (!RexUtil.isDeterministic(rexNode)) {\n+          topProjectRexNodesInputs.foreach(list => list.foreach(", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1ODU0OQ==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454858549", "bodyText": "extract these logic into another method? and please update the javadoc", "author": "godfreyhe", "createdAt": "2020-07-15T07:48:15Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -60,9 +61,40 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Don't merge Calcs which contain non-deterministic expr\n-    topProgram.getExprList.forall(RexUtil.isDeterministic) &&\n-      bottomCalc.getProgram.getExprList.forall(RexUtil.isDeterministic)\n+    // Each bottomCalc's non-deterministic RexNode should appear at most once in", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MDg2OA==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454860868", "bodyText": "move this common line into setup method", "author": "godfreyhe", "createdAt": "2020-07-15T07:52:30Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "diffHunk": "@@ -82,4 +82,35 @@ class FlinkCalcMergeRuleTest extends TableTestBase {\n     val sqlQuery = \"SELECT a FROM (SELECT a FROM MyTable) t WHERE random_udf(a) > 10\"\n     util.verifyPlan(sqlQuery)\n   }\n+\n+  @Test\n+  def testCalcMergeWithNestedNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MTQwNg==", "url": "https://github.com/apache/flink/pull/12873#discussion_r454861406", "bodyText": "please add a case about: top filter references a bottom non-deterministic project", "author": "godfreyhe", "createdAt": "2020-07-15T07:53:27Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRuleTest.scala", "diffHunk": "@@ -82,4 +82,35 @@ class FlinkCalcMergeRuleTest extends TableTestBase {\n     val sqlQuery = \"SELECT a FROM (SELECT a FROM MyTable) t WHERE random_udf(a) > 10\"\n     util.verifyPlan(sqlQuery)\n   }\n+\n+  @Test\n+  def testCalcMergeWithNestedNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT random_udf(a1) as a2 FROM (SELECT random_udf(a) as\" +\n+      \" a1, b FROM MyTable) t WHERE b > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithTopMultiNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT random_udf(a1) as a2, random_udf(a1) as a3 FROM\" +\n+      \" (SELECT random_udf(a) as a1, b FROM MyTable) t WHERE b > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithBottomMultiNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT a1, b2 FROM\" +\n+      \" (SELECT random_udf(a) as a1, random_udf(b) as b2, c FROM MyTable) t WHERE c > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }\n+\n+  @Test\n+  def testCalcMergeWithoutInnerNonDeterministicExpr(): Unit = {\n+    util.addFunction(\"random_udf\", new NonDeterministicUdf)\n+    val sqlQuery = \"SELECT a, c FROM (SELECT a, random_udf(a) as a1, c FROM MyTable) t WHERE c > 10\"\n+    util.verifyPlan(sqlQuery)\n+  }", "originalCommit": "d348328658445fbc11b8a310f8f0fbd163acf308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24c77b9c54d326b4f6b51a716669df85d6f59a3f", "url": "https://github.com/apache/flink/commit/24c77b9c54d326b4f6b51a716669df85d6f59a3f", "message": "address comments", "committedDate": "2020-07-15T14:25:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMDcyNQ==", "url": "https://github.com/apache/flink/pull/12873#discussion_r456230725", "bodyText": "This line should move out-of forall, otherwise the topProjectInputIndices will contain many topFilterInputIndicess if there is multiple non-deterministic expression in bottom project.", "author": "godfreyhe", "createdAt": "2020-07-17T05:45:55Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -61,36 +61,43 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       return false\n     }\n \n-    // Each bottomCalc's non-deterministic RexNode should appear at most once in\n-    // topCalc's project fields and condition field.\n+    isMergeable(topCalc, bottomCalc)\n+  }\n+\n+  /**\n+   * Return two neighbouring [[Calc]] can merge into one [[Calc]] or not. If the two [[Calc]] can\n+   * merge into one, each non-deterministic [[RexNode]] of bottom [[Calc]] should appear at most\n+   * once in the project list and filter list of top [[Calc]].\n+   */\n+  private def isMergeable(topCalc: Calc, bottomCalc: Calc): Boolean = {\n+    val topProgram = topCalc.getProgram\n     val bottomProgram = bottomCalc.getProgram\n-    val topProjectRexNodesInputs = topProgram.getProjectList\n+    val topProjectInputIndices = topProgram.getProjectList\n       .map(r => topProgram.expandLocalRef(r))\n       .map(r => InputFinder.bits(r).toArray)\n \n-    val topFilterRexNodesInputs = if (topProgram.getCondition != null) {\n-      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition))\n-        .toArray\n+    val topFilterInputIndices = if (topProgram.getCondition != null) {\n+      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition)).toArray\n     } else {\n       new Array[Int](0)\n     }\n \n-    val bottomRexList = bottomProgram.getProjectList\n+    val bottomProjectList = bottomProgram.getProjectList\n       .map(r => bottomProgram.expandLocalRef(r))\n       .toArray\n \n-    bottomRexList.zipWithIndex.forall {\n-      case (rexNode: RexNode, index: Int) => {\n+    bottomProjectList.zipWithIndex.forall {\n+      case (project: RexNode, index: Int) => {\n         var nonDeterministicRexRefCnt = 0\n-        if (!RexUtil.isDeterministic(rexNode)) {\n-          topProjectRexNodesInputs.foreach(list => list.foreach(\n-            ref => if (ref == index) {\n-              nonDeterministicRexRefCnt += 1\n-            }))\n-          topFilterRexNodesInputs.foreach(\n-            ref => if (ref == index) {\n-              nonDeterministicRexRefCnt += 1\n-            })\n+        if (!RexUtil.isDeterministic(project)) {\n+          topProjectInputIndices.add(topFilterInputIndices)", "originalCommit": "24c77b9c54d326b4f6b51a716669df85d6f59a3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMjk3MA==", "url": "https://github.com/apache/flink/pull/12873#discussion_r456232970", "bodyText": "topProjectInputIndices :+ topFilterInputIndices", "author": "godfreyhe", "createdAt": "2020-07-17T05:53:43Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala", "diffHunk": "@@ -86,12 +88,14 @@ class FlinkCalcMergeRule(relBuilderFactory: RelBuilderFactory) extends RelOptRul\n       .map(r => bottomProgram.expandLocalRef(r))\n       .toArray\n \n+    topProjectInputIndices.add(topFilterInputIndices)\n+    val topInputIndices = topProjectInputIndices", "originalCommit": "35a627186bdc24c604ae1d188921d3668c94c16c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "228c4360654f070e4730f60be2c4173134064de0", "url": "https://github.com/apache/flink/commit/228c4360654f070e4730f60be2c4173134064de0", "message": "[FLINK-15366][table-planner-blink] Improve FlinkCalcMergeRule to merge calc nodes better\n\nThis closes #12873", "committedDate": "2020-07-27T12:58:00Z", "type": "forcePushed"}, {"oid": "4b5b9ee889681cf25097c4cf58023c028a72185c", "url": "https://github.com/apache/flink/commit/4b5b9ee889681cf25097c4cf58023c028a72185c", "message": "[FLINK-15366][table-planner] Improve FlinkCalcMergeRule to merge calc nodes better.", "committedDate": "2020-07-27T13:17:44Z", "type": "commit"}, {"oid": "4b5b9ee889681cf25097c4cf58023c028a72185c", "url": "https://github.com/apache/flink/commit/4b5b9ee889681cf25097c4cf58023c028a72185c", "message": "[FLINK-15366][table-planner] Improve FlinkCalcMergeRule to merge calc nodes better.", "committedDate": "2020-07-27T13:17:44Z", "type": "forcePushed"}]}