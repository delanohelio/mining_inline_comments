{"pr_number": 13307, "pr_title": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "pr_createdAt": "2020-09-02T13:54:33Z", "pr_url": "https://github.com/apache/flink/pull/13307", "timeline": [{"oid": "da1db6af426818bc3bd0224c244dd201bd81799a", "url": "https://github.com/apache/flink/commit/da1db6af426818bc3bd0224c244dd201bd81799a", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-09-03T01:57:56Z", "type": "forcePushed"}, {"oid": "b9f1d43f8e46a0c79d2741c4d6061443ef9be599", "url": "https://github.com/apache/flink/commit/b9f1d43f8e46a0c79d2741c4d6061443ef9be599", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-09-05T09:16:55Z", "type": "forcePushed"}, {"oid": "7dc326d54c5ac31c352ac06c35d918f444d9bd40", "url": "https://github.com/apache/flink/commit/7dc326d54c5ac31c352ac06c35d918f444d9bd40", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-18T15:07:00Z", "type": "forcePushed"}, {"oid": "3aae457c54d028a1c526a32e059b0836df8105c7", "url": "https://github.com/apache/flink/commit/3aae457c54d028a1c526a32e059b0836df8105c7", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-18T17:22:29Z", "type": "forcePushed"}, {"oid": "4174635af1c0de52685df1ffb1b2adc869256d18", "url": "https://github.com/apache/flink/commit/4174635af1c0de52685df1ffb1b2adc869256d18", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-19T02:00:20Z", "type": "forcePushed"}, {"oid": "7ad79c6528d529ebd03e87a78f92d79d8cb6d91f", "url": "https://github.com/apache/flink/commit/7ad79c6528d529ebd03e87a78f92d79d8cb6d91f", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-22T15:49:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MzIyOA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511843228", "bodyText": "I would suggest not deprecate this interface for now, as we don't provide equivalent functionality yet.", "author": "wuchong", "createdAt": "2020-10-26T10:03:47Z", "path": "flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/Table.java", "diffHunk": "@@ -168,7 +168,9 @@\n \t *        It takes one single argument, the {@code timeAttribute}, for which it returns\n \t *        matching version of the {@link Table}, from which {@link TemporalTableFunction}\n \t *        was created.\n+\t * @deprecated please temporal DDL to define a temporal table.", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0NTA3Nw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511845077", "bodyText": "Can simplify to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      case None =>\n          \n          \n            \n                        val beforeAfter = beforeAfterOrNone(rightInputModifyKindSet)\n          \n          \n            \n                        this.visit(right, beforeAfter)\n          \n          \n            \n                      case None => this.visit(right, beforeAfterOrNone(rightInputModifyKindSet))", "author": "wuchong", "createdAt": "2020-10-26T10:06:44Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/optimize/program/FlinkChangelogModeInferenceProgram.scala", "diffHunk": "@@ -543,12 +543,16 @@ class FlinkChangelogModeInferenceProgram extends FlinkOptimizeProgram[StreamOpti\n         }\n         val newLeftOption = this.visit(left, leftRequiredTrait)\n \n-        // currently temporal join support changelog stream as the right side\n-        // so it requires beforeAfterOrNone UpdateKind\n         val rightInputModifyKindSet = getModifyKindSet(right)\n-        val beforeAndAfter = beforeAfterOrNone(rightInputModifyKindSet)\n-\n-        val newRightOption = this.visit(right, beforeAndAfter)\n+        // currently temporal join support changelog stream as the right side\n+        // so it supports both ONLY_AFTER and BEFORE_AFTER, but prefer ONLY_AFTER\n+        val onlyAfter = onlyAfterOrNone(rightInputModifyKindSet)\n+        val newRightOption = this.visit(right, onlyAfter) match {\n+          case Some(newRight) => Some(newRight)\n+          case None =>\n+            val beforeAfter = beforeAfterOrNone(rightInputModifyKindSet)\n+            this.visit(right, beforeAfter)", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0ODM3OA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511848378", "bodyText": "It would be better to not mix insertRecord and record(RowKind.INSERT, ...).", "author": "wuchong", "createdAt": "2020-10-26T10:12:17Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperatorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.KeyedTwoInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.types.RowKind;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.record;\n+\n+/**\n+ * Harness tests for {@link TemporalRowTimeJoinOperatorTest}.\n+ */\n+public class TemporalRowTimeJoinOperatorTest extends TemporalTimeJoinOperatorTestBase {\n+\t/**\n+\t * Test rowtime temporal join.\n+\t */\n+\t@Test\n+\tpublic void testRowTimeTemporalJoin() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(new Watermark(1));\n+\t\texpectedOutput.add(new Watermark(2));\n+\t\texpectedOutput.add(insertRecord(3L, \"k1\", \"1a3\", 2L, \"k1\", \"1a2\"));\n+\t\texpectedOutput.add(new Watermark(5));\n+\t\texpectedOutput.add(insertRecord(6L, \"k2\", \"2a3\", 4L, \"k2\", \"2a4\"));\n+\t\texpectedOutput.add(new Watermark(8));\n+\t\texpectedOutput.add(new Watermark(9));\n+\t\texpectedOutput.add(insertRecord(11L, \"k2\", \"5a12\", 10L, \"k2\", \"2a6\"));\n+\t\texpectedOutput.add(new Watermark(13));\n+\n+\t\ttestRowTimeTemporalJoin(false, expectedOutput);\n+\t}\n+\n+\t/**\n+\t * Test rowtime left temporal join.\n+\t */\n+\t@Test\n+\tpublic void testRowTimeLeftTemporalJoin() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(new Watermark(1));\n+\t\texpectedOutput.add(insertRecord(1L, \"k1\", \"1a1\", null, null, null));\n+\t\texpectedOutput.add(new Watermark(2));\n+\t\texpectedOutput.add(insertRecord(1L, \"k1\", \"1a1\", null, null, null));\n+\t\texpectedOutput.add(insertRecord(3L, \"k1\", \"1a3\", 2L, \"k1\", \"1a2\"));\n+\t\texpectedOutput.add(new Watermark(5));\n+\t\texpectedOutput.add(insertRecord(6L, \"k2\", \"2a3\", 4L, \"k2\", \"2a4\"));\n+\t\texpectedOutput.add(new Watermark(8));\n+\t\texpectedOutput.add(insertRecord(9L, \"k2\", \"5a11\", null, null, null));\n+\t\texpectedOutput.add(new Watermark(9));\n+\t\texpectedOutput.add(insertRecord(11L, \"k2\", \"5a12\", 10L, \"k2\", \"2a6\"));\n+\t\texpectedOutput.add(new Watermark(13));\n+\n+\t\ttestRowTimeTemporalJoin(true, expectedOutput);\n+\t}\n+\n+\tprivate void testRowTimeTemporalJoin(boolean isLeftOuterJoin, List<Object> expectedOutput) throws Exception {\n+\t\tTemporalRowTimeJoinOperator joinOperator = new TemporalRowTimeJoinOperator(\n+\t\t\t\trowType,\n+\t\t\t\trowType,\n+\t\t\t\tjoinCondition,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\tisLeftOuterJoin);\n+\t\tKeyedTwoInputStreamOperatorTestHarness<RowData, RowData, RowData, RowData> testHarness = createTestHarness(\n+\t\t\t\tjoinOperator);\n+\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processWatermark1(new Watermark(1));\n+\t\ttestHarness.processWatermark2(new Watermark(1));\n+\n+\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"1a1\"));\n+\t\ttestHarness.processElement2(record(RowKind.INSERT, 2L, \"k1\", \"1a2\"));", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0ODY1MQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511848651", "bodyText": "Convert this class to an abstract class.", "author": "wuchong", "createdAt": "2020-10-26T10:12:47Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalTimeJoinOperatorTestBase.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.table.runtime.util.BinaryRowDataKeySelector;\n+import org.apache.flink.table.runtime.util.RowDataHarnessAssertor;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+\n+/**\n+ * Base test class for TemporalJoinOperator.\n+ */\n+public class TemporalTimeJoinOperatorTestBase {", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NjY3NA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511856674", "bodyText": "Why not use the default 4 parallelism? Can we remove this?", "author": "wuchong", "createdAt": "2020-10-26T10:26:14Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,453 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+\n+import scala.collection.JavaConversions._\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyData = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  @Before\n+  def prepare(): Unit = {\n+    env.setParallelism(2)", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzQyMA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511857420", "bodyText": "The source is insert-only, however the data rowTimeOrderData contains updates.", "author": "wuchong", "createdAt": "2020-10-26T10:27:33Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,453 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+\n+import scala.collection.JavaConversions._\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyData = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  @Before\n+  def prepare(): Unit = {\n+    env.setParallelism(2)\n+\n+    val procTimeOrderDataId = registerData(procTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_proctime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    // register a non-lookup table\n+    val procTimeCurrencyDataId = registerData(procTimeCurrencyData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE changelog_currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE VIEW latest_rates AS\n+         |SELECT\n+         |  currency,\n+         |  currency_no,\n+         |  rate,\n+         |  proctime FROM\n+         |      ( SELECT *, ROW_NUMBER() OVER (PARTITION BY currency, currency_no\n+         |        ORDER BY proctime DESC) AS rowNum\n+         |        FROM currency_proctime) T\n+         | WHERE rowNum = 1\"\"\".stripMargin)\n+\n+    val rowTimeOrderDataId = registerData(rowTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_rowtime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  order_time TIMESTAMP(3),\n+         |  WATERMARK FOR order_time AS order_time\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeOrderDataId'", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODAwMA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511858000", "bodyText": "The source is insert-only, however the data rowTimeCurrencyData contains updates.", "author": "wuchong", "createdAt": "2020-10-26T10:28:32Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,453 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+\n+import scala.collection.JavaConversions._\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyData = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  @Before\n+  def prepare(): Unit = {\n+    env.setParallelism(2)\n+\n+    val procTimeOrderDataId = registerData(procTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_proctime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    // register a non-lookup table\n+    val procTimeCurrencyDataId = registerData(procTimeCurrencyData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE changelog_currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE VIEW latest_rates AS\n+         |SELECT\n+         |  currency,\n+         |  currency_no,\n+         |  rate,\n+         |  proctime FROM\n+         |      ( SELECT *, ROW_NUMBER() OVER (PARTITION BY currency, currency_no\n+         |        ORDER BY proctime DESC) AS rowNum\n+         |        FROM currency_proctime) T\n+         | WHERE rowNum = 1\"\"\".stripMargin)\n+\n+    val rowTimeOrderDataId = registerData(rowTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_rowtime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  order_time TIMESTAMP(3),\n+         |  WATERMARK FOR order_time AS order_time\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    val rowTimeCurrencyDataId = registerData(rowTimeCurrencyData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE versioned_currency_with_single_key (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate  BIGINT,\n+         |  currency_time TIMESTAMP(3),\n+         |  WATERMARK FOR currency_time AS currency_time - interval '10' SECOND,\n+         |  PRIMARY KEY(currency) NOT ENFORCED\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeCurrencyDataId'", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODE0NA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511858144", "bodyText": "ditto.", "author": "wuchong", "createdAt": "2020-10-26T10:28:46Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,453 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+\n+import scala.collection.JavaConversions._\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyData = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  @Before\n+  def prepare(): Unit = {\n+    env.setParallelism(2)\n+\n+    val procTimeOrderDataId = registerData(procTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_proctime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    // register a non-lookup table\n+    val procTimeCurrencyDataId = registerData(procTimeCurrencyData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE changelog_currency_proctime (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate BIGINT,\n+         |  proctime as PROCTIME()\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'bounded' = 'false',\n+         |  'disable-lookup' = 'true',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$procTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE VIEW latest_rates AS\n+         |SELECT\n+         |  currency,\n+         |  currency_no,\n+         |  rate,\n+         |  proctime FROM\n+         |      ( SELECT *, ROW_NUMBER() OVER (PARTITION BY currency, currency_no\n+         |        ORDER BY proctime DESC) AS rowNum\n+         |        FROM currency_proctime) T\n+         | WHERE rowNum = 1\"\"\".stripMargin)\n+\n+    val rowTimeOrderDataId = registerData(rowTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_rowtime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  order_time TIMESTAMP(3),\n+         |  WATERMARK FOR order_time AS order_time\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    val rowTimeCurrencyDataId = registerData(rowTimeCurrencyData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE versioned_currency_with_single_key (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate  BIGINT,\n+         |  currency_time TIMESTAMP(3),\n+         |  WATERMARK FOR currency_time AS currency_time - interval '10' SECOND,\n+         |  PRIMARY KEY(currency) NOT ENFORCED\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE versioned_currency_with_multi_key (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate  BIGINT,\n+         |  currency_time TIMESTAMP(3),\n+         |  WATERMARK FOR currency_time AS currency_time - interval '10' SECOND,\n+         |  PRIMARY KEY(currency, currency_no) NOT ENFORCED\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'data-id' = '$rowTimeCurrencyDataId'", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NTQ0MA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511895440", "bodyText": "Could you add a test that the rowtime in delete message is previous time in insert message?", "author": "wuchong", "createdAt": "2020-10-26T11:36:45Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,453 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n-\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n import org.junit.Assert.assertEquals\n import org.junit._\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+\n+import scala.collection.JavaConversions._\n \n-import java.sql.Timestamp\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n \n-import scala.collection.mutable\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in COLLECTION sink check\n+    changelogRow(\"+U\", toJLong(4), \"RMB\", \"no1\", toJLong(60)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // simply test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyData = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkwMDA3Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511900076", "bodyText": "I don't think we can skip all -U messages here, because the -U message might be useful. The optimizer has already  tried to not send -U to temporal join, if the temporal join still receives -U, that means the -U is necessary. For example, filter after changelog source.\nYou can add a test for temporal join a changelog source with filter, and having a currency whose currency changes from 90 to 110. E.g.\nSELECT *\nFROM orders  AS O\nLEFT JOIN (SELECT * FROM currency WHERE rate > 100)  FOR SYSTEM_TIME AS OF O.rowtime AS C\nON O.currency_id = C.currency_id", "author": "wuchong", "createdAt": "2020-10-26T11:45:38Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * The operator for temporal join (FOR SYSTEM_TIME AS OF o.rowtime) on row time, it has no limitation\n+ * about message types of the left input and right input, this means the operator deals changelog well.\n+ *\n+ * <p>For Event-time temporal join, its probe side is a regular table, its build side is a versioned\n+ * table, the version of versioned table can extract from the build side state. This operator works by\n+ * keeping on the state collection of probe and build records to process on next watermark. The idea\n+ * is that between watermarks we are collecting those elements and once we are sure that there will be\n+ * no updates we emit the correct result and clean up the expired data in state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * we sort all \"old\" values with row time and row kind and then clean up the old values, when clean up\n+ * the \"old\" values, if the latest record of all \"old\" values is retract message which means the version\n+ * end, we clean all \"old\" values, if the the latest record is accumulate message which means the version\n+ * start, we keep the latest one, and clear other \"old\" values.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class TemporalRowTimeJoinOperator\n+\textends BaseTwoInputStreamOperatorWithStateRetention {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final String NEXT_LEFT_INDEX_STATE_NAME = \"next-index\";\n+\tprivate static final String LEFT_STATE_NAME = \"left\";\n+\tprivate static final String RIGHT_STATE_NAME = \"right\";\n+\tprivate static final String REGISTERED_TIMER_STATE_NAME = \"timer\";\n+\tprivate static final String TIMERS_STATE_NAME = \"timers\";\n+\n+\tprivate final boolean isLeftOuterJoin;\n+\tprivate final InternalTypeInfo<RowData> leftType;\n+\tprivate final InternalTypeInfo<RowData> rightType;\n+\tprivate final GeneratedJoinCondition generatedJoinCondition;\n+\tprivate final int leftTimeAttribute;\n+\tprivate final int rightTimeAttribute;\n+\n+\t/**\n+\t * The comparator to get ordered elements of right state.\n+\t */\n+\tprivate final ChangelogOrderComparator rightChangelogOrderComparator;\n+\n+\t/**\n+\t * Incremental index generator for {@link #leftState}'s keys.\n+\t */\n+\tprivate transient ValueState<Long> nextLeftIndex;\n+\n+\t/**\n+\t * Mapping from artificial row index (generated by `nextLeftIndex`) into the left side `Row`.\n+\t * We can not use List to accumulate Rows, because we need efficient deletes of the oldest rows.\n+\t */\n+\tprivate transient MapState<Long, RowData> leftState;\n+\n+\t/**\n+\t * Mapping from timestamp to right side `Row`.\n+\t **/\n+\tprivate transient MapState<RowData, Long> rightState;\n+\n+\tprivate transient ValueState<Long> registeredEventTimer;\n+\tprivate transient TimestampedCollector<RowData> collector;\n+\tprivate transient InternalTimerService<VoidNamespace> timerService;\n+\n+\tprivate transient JoinCondition joinCondition;\n+\tprivate transient JoinedRowData outRow;\n+\tprivate transient GenericRowData rightNullRow;\n+\n+\tpublic TemporalRowTimeJoinOperator(\n+\t\t\tInternalTypeInfo<RowData> leftType,\n+\t\t\tInternalTypeInfo<RowData> rightType,\n+\t\t\tGeneratedJoinCondition generatedJoinCondition,\n+\t\t\tint leftTimeAttribute,\n+\t\t\tint rightTimeAttribute,\n+\t\t\tlong minRetentionTime,\n+\t\t\tlong maxRetentionTime,\n+\t\t\tboolean isLeftOuterJoin) {\n+\t\tsuper(minRetentionTime, maxRetentionTime);\n+\t\tthis.leftType = leftType;\n+\t\tthis.rightType = rightType;\n+\t\tthis.generatedJoinCondition = generatedJoinCondition;\n+\t\tthis.leftTimeAttribute = leftTimeAttribute;\n+\t\tthis.rightTimeAttribute = rightTimeAttribute;\n+\t\tthis.rightChangelogOrderComparator = new ChangelogOrderComparator(rightTimeAttribute);\n+\t\tthis.isLeftOuterJoin = isLeftOuterJoin;\n+\t}\n+\n+\t@Override\n+\tpublic void open() throws Exception {\n+\t\tsuper.open();\n+\t\tjoinCondition = generatedJoinCondition.newInstance(getRuntimeContext().getUserCodeClassLoader());\n+\t\tjoinCondition.setRuntimeContext(getRuntimeContext());\n+\t\tjoinCondition.open(new Configuration());\n+\n+\t\tnextLeftIndex = getRuntimeContext().getState(\n+\t\t\tnew ValueStateDescriptor<>(NEXT_LEFT_INDEX_STATE_NAME, Types.LONG));\n+\t\tleftState = getRuntimeContext().getMapState(\n+\t\t\tnew MapStateDescriptor<>(LEFT_STATE_NAME, Types.LONG, leftType));\n+\t\trightState = getRuntimeContext().getMapState(\n+\t\t\tnew MapStateDescriptor<>(RIGHT_STATE_NAME, rightType, Types.LONG));\n+\t\tregisteredEventTimer = getRuntimeContext().getState(\n+\t\t\tnew ValueStateDescriptor<>(REGISTERED_TIMER_STATE_NAME, Types.LONG));\n+\n+\t\ttimerService = getInternalTimerService(\n+\t\t\tTIMERS_STATE_NAME, VoidNamespaceSerializer.INSTANCE, this);\n+\n+\t\toutRow = new JoinedRowData();\n+\t\trightNullRow = new GenericRowData(rightType.toRowType().getFieldCount());\n+\t\tcollector = new TimestampedCollector<>(output);\n+\t}\n+\n+\t@Override\n+\tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData row = element.getValue();\n+\t\tleftState.put(getNextLeftIndex(), row);\n+\t\tregisterSmallestTimer(getLeftTime(row)); // Timer to emit and clean up the state\n+\n+\t\tregisterProcessingCleanupTimer();\n+\t}\n+\n+\t/**\n+\t * We skip all -U message here, currently -U message is useless in versioned table.\n+\t * case 1: the -U message may use update message's time, for example: rightState = [1(+I), 4(-U), 4(+U)],\n+\t * case 2: the -U message may use insert message's time, for example: rightState = [1(+I), 1(-U), 4(+U)],\n+\t * the valid period of them should be [1, 4) and [4, Long.MaxValue).\n+\t */\n+\t@Override\n+\tpublic void processElement2(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData row = element.getValue();\n+\t\tif (row.getRowKind() == RowKind.UPDATE_BEFORE) {\n+\t\t\treturn;", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzAxNQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511973015", "bodyText": "This can be MapState<Long, RowData> to have better performance as we discussed.", "author": "wuchong", "createdAt": "2020-10-26T13:49:19Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * The operator for temporal join (FOR SYSTEM_TIME AS OF o.rowtime) on row time, it has no limitation\n+ * about message types of the left input and right input, this means the operator deals changelog well.\n+ *\n+ * <p>For Event-time temporal join, its probe side is a regular table, its build side is a versioned\n+ * table, the version of versioned table can extract from the build side state. This operator works by\n+ * keeping on the state collection of probe and build records to process on next watermark. The idea\n+ * is that between watermarks we are collecting those elements and once we are sure that there will be\n+ * no updates we emit the correct result and clean up the expired data in state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * we sort all \"old\" values with row time and row kind and then clean up the old values, when clean up\n+ * the \"old\" values, if the latest record of all \"old\" values is retract message which means the version\n+ * end, we clean all \"old\" values, if the the latest record is accumulate message which means the version\n+ * start, we keep the latest one, and clear other \"old\" values.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class TemporalRowTimeJoinOperator\n+\textends BaseTwoInputStreamOperatorWithStateRetention {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final String NEXT_LEFT_INDEX_STATE_NAME = \"next-index\";\n+\tprivate static final String LEFT_STATE_NAME = \"left\";\n+\tprivate static final String RIGHT_STATE_NAME = \"right\";\n+\tprivate static final String REGISTERED_TIMER_STATE_NAME = \"timer\";\n+\tprivate static final String TIMERS_STATE_NAME = \"timers\";\n+\n+\tprivate final boolean isLeftOuterJoin;\n+\tprivate final InternalTypeInfo<RowData> leftType;\n+\tprivate final InternalTypeInfo<RowData> rightType;\n+\tprivate final GeneratedJoinCondition generatedJoinCondition;\n+\tprivate final int leftTimeAttribute;\n+\tprivate final int rightTimeAttribute;\n+\n+\t/**\n+\t * The comparator to get ordered elements of right state.\n+\t */\n+\tprivate final ChangelogOrderComparator rightChangelogOrderComparator;\n+\n+\t/**\n+\t * Incremental index generator for {@link #leftState}'s keys.\n+\t */\n+\tprivate transient ValueState<Long> nextLeftIndex;\n+\n+\t/**\n+\t * Mapping from artificial row index (generated by `nextLeftIndex`) into the left side `Row`.\n+\t * We can not use List to accumulate Rows, because we need efficient deletes of the oldest rows.\n+\t */\n+\tprivate transient MapState<Long, RowData> leftState;\n+\n+\t/**\n+\t * Mapping from timestamp to right side `Row`.\n+\t **/\n+\tprivate transient MapState<RowData, Long> rightState;", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0edbb09cea1b10a677b91c17b889ec74ef8dfbed", "url": "https://github.com/apache/flink/commit/0edbb09cea1b10a677b91c17b889ec74ef8dfbed", "message": "19078 base on 19077", "committedDate": "2020-10-27T16:46:48Z", "type": "forcePushed"}, {"oid": "20fe41449f841cfbbb155c1f1c842c5d814ca934", "url": "https://github.com/apache/flink/commit/20fe41449f841cfbbb155c1f1c842c5d814ca934", "message": "19078 base on 19077", "committedDate": "2020-10-28T02:25:08Z", "type": "forcePushed"}, {"oid": "85867d4ab920f571c1dcad56fea6a89c3b717b13", "url": "https://github.com/apache/flink/commit/85867d4ab920f571c1dcad56fea6a89c3b717b13", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T03:57:11Z", "type": "forcePushed"}, {"oid": "dee9ebd0a1947e6580064910a0dace6f5e349c52", "url": "https://github.com/apache/flink/commit/dee9ebd0a1947e6580064910a0dace6f5e349c52", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T04:12:51Z", "type": "forcePushed"}, {"oid": "a558cb0fd984dc5f256d7710f67239d0851204b3", "url": "https://github.com/apache/flink/commit/a558cb0fd984dc5f256d7710f67239d0851204b3", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T08:12:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzODUwMg==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513238502", "bodyText": "We don't need this, because default is 4.", "author": "wuchong", "createdAt": "2020-10-28T07:52:03Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,555 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n \n-import org.junit.Assert.assertEquals\n import org.junit._\n+import org.junit.Assert.assertEquals\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n \n-import java.sql.Timestamp\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n \n-import scala.collection.mutable\n+import scala.collection.JavaConversions._\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  val procTimeCurrencyChangelogData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"-U\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+U\",\"RMB\", \"no1\", toJLong(802)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyDataUsingMetaTime = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  val rowTimeCurrencyDataUsingInsertTime = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-15T00:00:00\")))\n+\n+  @Before\n+  def prepare(): Unit = {\n+    env.setParallelism(4)", "originalCommit": "dee9ebd0a1947e6580064910a0dace6f5e349c52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwNDUyNA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513904524", "bodyText": "Remove this?", "author": "wuchong", "createdAt": "2020-10-29T03:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0MTkwMQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513241901", "bodyText": "It is never used? Besides, I think \"InsertTime\" is not very accurate (maybe previous updated time). What about \"BeforeTime\"?", "author": "wuchong", "createdAt": "2020-10-28T07:58:39Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -18,232 +18,555 @@\n \n package org.apache.flink.table.planner.runtime.stream.sql\n \n-import org.apache.flink.api.scala._\n-import org.apache.flink.streaming.api.TimeCharacteristic\n-import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor\n-import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment\n-import org.apache.flink.streaming.api.windowing.time.Time\n-import org.apache.flink.table.api._\n-import org.apache.flink.table.api.bridge.scala._\n+import org.apache.flink.table.api.TableException\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.getRawResults\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n-import org.apache.flink.table.planner.runtime.utils.{StreamingWithStateTestBase, TestingAppendSink}\n-import org.apache.flink.table.planner.utils.TableTestUtil\n-import org.apache.flink.types.Row\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n \n-import org.junit.Assert.assertEquals\n import org.junit._\n+import org.junit.Assert.assertEquals\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n \n-import java.sql.Timestamp\n+import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n \n-import scala.collection.mutable\n+import scala.collection.JavaConversions._\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n+  // test data for Processing-Time temporal table join\n+  val procTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n+    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n+    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)))\n+\n+  val procTimeCurrencyData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  val procTimeCurrencyChangelogData = List(\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n+    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n+    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"-U\",\"RMB\", \"no1\", toJLong(702)),\n+    changelogRow(\"+U\",\"RMB\", \"no1\", toJLong(802)),\n+    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n+    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation\n+    changelogRow(\"+U\", toJLong(5), \"US Dollar\", \"no1\", toJLong(18),\n+      toDateTime(\"2020-08-16T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(6), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-16T00:03:00\")))\n+\n+  val rowTimeCurrencyDataUsingMetaTime = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", toJLong(702),\n+      toDateTime(\"2020-08-15T00:00:00\")),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", toJLong(114),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", toJLong(118),\n+      toDateTime(\"2020-08-16T00:01:00\")),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", toJLong(102),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", toJLong(106),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    changelogRow(\"-D\",\"RMB\", \"no1\", toJLong(708),\n+      toDateTime(\"2020-08-16T00:02:00\")))\n+\n+  val rowTimeCurrencyDataUsingInsertTime = List(", "originalCommit": "dee9ebd0a1947e6580064910a0dace6f5e349c52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NjQyNQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513256425", "bodyText": "I would suggest to add full events, it's weird to have only +U but no -U in a non-upsert source.\nFor event-time temporal join, I think it's safe to retract rows in sink.", "author": "wuchong", "createdAt": "2020-10-28T08:25:42Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -59,10 +64,68 @@ class TemporalJoinITCase(state: StateBackendMode)\n     changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n     changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n \n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12),\n+      toDateTime(\"2020-08-15T00:01:00\")),\n+    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(1),\n+      toDateTime(\"2020-08-15T00:02:00\")),\n+    changelogRow(\"+I\", toJLong(3), \"RMB\", \"no1\", toJLong(40),\n+      toDateTime(\"2020-08-15T00:03:00\")),\n+    changelogRow(\"+I\", toJLong(4), \"Euro\", \"no1\", toJLong(14),\n+      toDateTime(\"2020-08-16T00:02:00\")),\n+    // test left stream could be changelog,\n+    // -U or -D message may retract fail in collection connector sink implementation", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1OTQ0MQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513259441", "bodyText": "I think this is not a good case, because there is no updates in the source that changing from matching condition to not matching. Maybe rate < 115 is better.", "author": "wuchong", "createdAt": "2020-10-28T08:31:00Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -260,6 +390,152 @@ class TemporalJoinITCase(state: StateBackendMode)\n     tEnv.executeSql(sql).await()\n   }\n \n+  @Test\n+  def testEventTimeTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00)\",\n+      \"+I(4,Euro,14,2020-08-16T00:02,118,2020-08-16T00:01)\",\n+      \"+U(5,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeTemporalJoinWithFilter(): Unit = {\n+    tEnv.executeSql(\"CREATE VIEW v1 AS\" +\n+      \" SELECT * FROM versioned_currency_with_single_key WHERE rate > 114\")", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1OTg3MA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513259870", "bodyText": "This table is not using insertion time.", "author": "wuchong", "createdAt": "2020-10-28T08:31:45Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -129,6 +192,73 @@ class TemporalJoinITCase(state: StateBackendMode)\n \n     createSinkTable(\"proctime_default_sink\", None)\n \n+\n+    val rowTimeOrderDataId = registerData(rowTimeOrderData)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE orders_rowtime (\n+         |  order_id BIGINT,\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  amount BIGINT,\n+         |  order_time TIMESTAMP(3),\n+         |  WATERMARK FOR order_time AS order_time\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$rowTimeOrderDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    val rowTimeCurrencyDataId = registerData(rowTimeCurrencyDataUsingMetaTime)\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE versioned_currency_with_single_key (\n+         |  currency STRING,\n+         |  currency_no STRING,\n+         |  rate  BIGINT,\n+         |  currency_time TIMESTAMP(3),\n+         |  WATERMARK FOR currency_time AS currency_time - interval '10' SECOND,\n+         |  PRIMARY KEY(currency) NOT ENFORCED\n+         |) WITH (\n+         |  'connector' = 'values',\n+         |  'changelog-mode' = 'I,UA,UB,D',\n+         |  'data-id' = '$rowTimeCurrencyDataId'\n+         |)\n+         |\"\"\".stripMargin)\n+\n+    tEnv.executeSql(\n+      s\"\"\"\n+         |CREATE TABLE changelog_currency_using_insert_time (", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MjUxMw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513262513", "bodyText": "I think this case doesn't cover the case we want to verify that the deletion in temporal table is a late event which doesn't affect the previous joined RMB order.", "author": "wuchong", "createdAt": "2020-10-28T08:36:22Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -260,6 +390,152 @@ class TemporalJoinITCase(state: StateBackendMode)\n     tEnv.executeSql(sql).await()\n   }\n \n+  @Test\n+  def testEventTimeTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00)\",\n+      \"+I(4,Euro,14,2020-08-16T00:02,118,2020-08-16T00:01)\",\n+      \"+U(5,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeTemporalJoinWithFilter(): Unit = {\n+    tEnv.executeSql(\"CREATE VIEW v1 AS\" +\n+      \" SELECT * FROM versioned_currency_with_single_key WHERE rate > 114\")\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o \" +\n+      \" JOIN v1 FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00)\",\n+      \"+I(4,Euro,14,2020-08-16T00:02,118,2020-08-16T00:01)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def tesEventTimeLeftTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o LEFT JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+    tEnv.executeSql(sql).await()\n+\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00)\",\n+      \"+I(4,Euro,14,2020-08-16T00:02,118,2020-08-16T00:01)\",\n+      \"+I(6,RMB,40,2020-08-16T00:03,null,null)\",\n+      \"+U(5,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def tesEventTimeLeftTemporalJoinChangelogUsingInsertTime(): Unit = {", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MzQ0MA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513263440", "bodyText": "Could you add a test that the join key contains not only the primary key? For example ON o.currency_no = r.currency_no AND o.currency = r.currency.", "author": "wuchong", "createdAt": "2020-10-28T08:37:58Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -260,6 +390,152 @@ class TemporalJoinITCase(state: StateBackendMode)\n     tEnv.executeSql(sql).await()\n   }\n \n+  @Test\n+  def testEventTimeTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4NTgwNA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513285804", "bodyText": "This comment is not correct any more, remove them?", "author": "wuchong", "createdAt": "2020-10-28T09:14:36Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -153,28 +161,30 @@ public void open() throws Exception {\n \n \t\ttimerService = getInternalTimerService(\n \t\t\tTIMERS_STATE_NAME, VoidNamespaceSerializer.INSTANCE, this);\n-\t\tcollector = new TimestampedCollector<>(output);\n+\n \t\toutRow = new JoinedRowData();\n-\t\t// all the output records should be INSERT only,\n-\t\t// because current temporal join only supports INSERT only left stream\n-\t\toutRow.setRowKind(RowKind.INSERT);\n+\t\trightNullRow = new GenericRowData(rightType.toRowType().getFieldCount());\n+\t\tcollector = new TimestampedCollector<>(output);\n \t}\n \n \t@Override\n \tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n \t\tRowData row = element.getValue();\n-\t\tcheckNotRetraction(row);\n-\n \t\tleftState.put(getNextLeftIndex(), row);\n \t\tregisterSmallestTimer(getLeftTime(row)); // Timer to emit and clean up the state\n \n \t\tregisterProcessingCleanupTimer();\n \t}\n \n+\t/**\n+\t * We skip all -U message here, currently -U message is useless in versioned table.\n+\t * case 1: the -U message may use update message's time, for example: rightState = [1(+I), 4(-U), 4(+U)],\n+\t * case 2: the -U message may use insert message's time, for example: rightState = [1(+I), 1(-U), 4(+U)],\n+\t * the valid period of them should be [1, 4) and [4, Long.MaxValue).", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI5MzYxNw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513293617", "bodyText": "I don't think this is a trick...", "author": "wuchong", "createdAt": "2020-10-28T09:26:48Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -236,21 +253,30 @@ private long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n \t\t\t}\n \t\t}\n \n-\t\tcleanupState(timerTimestamp, rightRowsSorted);\n+\t\tcleanupExpiredVersionInState(currentWatermark, rightRowsSorted);\n \t\treturn lastUnprocessedTime;\n \t}\n \n+\tprivate void collectJoinedRow(RowData leftSideRow, RowData rightRow) {\n+\t\toutRow.setRowKind(leftSideRow.getRowKind());\n+\t\toutRow.replace(leftSideRow, rightRow);\n+\t\tcollector.collect(outRow);\n+\t}\n+\n \t/**\n-\t * Removes all right entries older then the watermark, except the latest one. For example with:\n-\t * rightState = [1, 5, 9]\n-\t * and\n-\t * watermark = 6\n-\t * we can not remove \"5\" from rightState, because left elements with rowtime of 7 or 8 could\n-\t * be joined with it later\n+\t * Removes all expired version in the versioned table's state according to current watermark.\n+\t * For example with: rightState = [1(+I), 4(-U), 4(+U), 7(-U), 7(+U), 9(-D), 12(I)],\n+\t *\n+\t * <p>If watermark = 6 we can not remove \"4(+U)\" from rightState because accumulate message means\n+\t * the start of version, the left elements with row time of 5 or 6 could be joined with (+U,4) later.\n+\t *\n+\t * <p>If watermark = 10 we can remove \"9(-D)\" from rightState because retract message means the\n+\t * end of version, a trick is we do not remove it but do not correlate it if it is a retract message.", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513301466", "bodyText": "I think we can't store both 4(-U) and 4(+U) in state, because they have the same map key 4.\nAn improvement here is we don't store the RowData into state for retraction, but just store null. This can be better for performance if the RowData is large. We can use TreeMap<Long, RowData> or List<Tuple2<Long, RowData> to replace the current List<RowData>.", "author": "wuchong", "createdAt": "2020-10-28T09:38:49Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -294,6 +320,13 @@ private int indexOfFirstElementNewerThanTimer(long timerTimestamp, List<RowData>\n \t/**\n \t * Binary search {@code rightRowsSorted} to find the latest right row to join with {@code leftTime}.\n \t * Latest means a right row with largest time that is still smaller or equal to {@code leftTime}.\n+\t * For example with: rightState = [1(+I), 4(-U), 4(+U), 7(-U), 7(+U), 9(-D), 12(I)],", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0Nzc0Mg==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513547742", "bodyText": "I did not get the improvement point, could you explain more ? other comments has addressed", "author": "leonardBang", "createdAt": "2020-10-28T15:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NjUxNw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513556517", "bodyText": "Got your point, maybe this performance improvement is minor because (1) it only saves retraction records storage not all records (2) many retraction records between two watermarks  is not common, So I tend to improve it later if it's very important for performance", "author": "leonardBang", "createdAt": "2020-10-28T15:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwNDYwMA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513304600", "bodyText": "Two UB for the same key k2? Should this be UA?", "author": "wuchong", "createdAt": "2020-10-28T09:43:29Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperatorTest.java", "diffHunk": "@@ -85,31 +101,28 @@ public void testRowTimeTemporalJoin() throws Exception {\n \t\ttestHarness.processWatermark1(new Watermark(2));\n \t\ttestHarness.processWatermark2(new Watermark(2));\n \n-\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"2a1\"));\n-\t\ttestHarness.processElement1(insertRecord(3L, \"k1\", \"2a3\"));\n+\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"1a1\"));\n+\t\ttestHarness.processElement1(insertRecord(3L, \"k1\", \"1a3\"));\n \t\ttestHarness.processElement2(insertRecord(4L, \"k2\", \"2a4\"));\n \n \t\ttestHarness.processWatermark1(new Watermark(5));\n \t\ttestHarness.processWatermark2(new Watermark(5));\n \n-\t\ttestHarness.processElement1(insertRecord(6L, \"k2\", \"5a6\"));\n-\t\ttestHarness.processElement2(insertRecord(8L, \"k2\", \"5a8\"));\n-\t\ttestHarness.processElement1(insertRecord(11L, \"k2\", \"5a11\"));\n-\t\ttestHarness.processElement1(insertRecord(7L, \"k2\", \"5a7\"));\n+\t\ttestHarness.processElement1(insertRecord(6L, \"k2\", \"2a3\"));\n+\t\ttestHarness.processElement2(updateBeforeRecord(7L, \"k2\", \"2a4\"));\n+\t\ttestHarness.processElement2(updateBeforeRecord(7L, \"k2\", \"2a5\"));", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8a62099663b658669488af7f0ecd5087d1e5da6", "url": "https://github.com/apache/flink/commit/f8a62099663b658669488af7f0ecd5087d1e5da6", "message": "address comments", "committedDate": "2020-10-28T15:51:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5MDA4NQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513890085", "bodyText": "Use InternalSerializers.create(returnType) instead, then we don't need to pass in the exeConfig.", "author": "wuchong", "createdAt": "2020-10-29T02:33:56Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -250,18 +251,16 @@ class StreamExecTemporalJoinToCoProcessTranslator private(\n     val minRetentionTime = tableConfig.getMinIdleStateRetentionTime\n     val maxRetentionTime = tableConfig.getMaxIdleStateRetentionTime\n     if (rightRowTimeAttributeInputReference.isDefined) {\n-      if (isTemporalFunctionJoin) {\n-        new LegacyTemporalRowTimeJoinOperator(\n-          InternalTypeInfo.of(leftInputType),\n-          InternalTypeInfo.of(rightInputType),\n-          generatedJoinCondition,\n-          leftTimeAttributeInputReference,\n-          rightRowTimeAttributeInputReference.get,\n-          minRetentionTime,\n-          maxRetentionTime)\n-      } else {\n-        throw new TableException(\"Event-time temporal join operator is not implemented yet.\")\n-      }\n+      new TemporalRowTimeJoinOperator(\n+        InternalTypeInfo.of(leftInputType),\n+        InternalTypeInfo.of(rightInputType),\n+        InternalTypeInfo.of(returnType).createSerializer(exeConfig),", "originalCommit": "9f912a17d777463b856a19b64a03c16adadb8a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwNDQ0NQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513904445", "bodyText": "Would be better to have the same history data, then the result of temporal join would be more predicable.", "author": "wuchong", "createdAt": "2020-10-29T03:03:23Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -19,50 +19,100 @@\n package org.apache.flink.table.planner.runtime.stream.sql\n \n import org.apache.flink.table.api.TableException\n-import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow\n-import org.apache.flink.table.planner.factories.TestValuesTableFactory.registerData\n-import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory\n+import org.apache.flink.table.planner.factories.TestValuesTableFactory.{getRawResults, registerData}\n import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase\n+import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode\n+import org.apache.flink.types.Row\n \n import org.junit._\n+import org.junit.Assert.assertEquals\n import org.junit.runner.RunWith\n import org.junit.runners.Parameterized\n \n-import java.lang.{Long => JLong}\n+import java.time.LocalDateTime\n+import java.time.format.DateTimeParseException\n+\n+import scala.collection.JavaConversions._\n \n @RunWith(classOf[Parameterized])\n class TemporalJoinITCase(state: StateBackendMode)\n   extends StreamingWithStateTestBase(state) {\n \n   // test data for Processing-Time temporal table join\n   val procTimeOrderData = List(\n-    changelogRow(\"+I\", toJLong(1), \"Euro\", \"no1\", toJLong(12)),\n-    changelogRow(\"+I\", toJLong(2), \"US Dollar\", \"no1\", toJLong(14)),\n-    changelogRow(\"+I\", toJLong(3), \"US Dollar\", \"no2\", toJLong(18)),\n-    changelogRow(\"+I\", toJLong(4), \"RMB\", \"no1\", toJLong(40)))\n+    changelogRow(\"+I\", 1L, \"Euro\", \"no1\", 12L),\n+    changelogRow(\"+I\", 2L, \"US Dollar\", \"no1\", 14L),\n+    changelogRow(\"+I\", 3L, \"US Dollar\", \"no2\", 18L),\n+    changelogRow(\"+I\", 4L, \"RMB\", \"no1\", 40L))\n \n   val procTimeCurrencyData = List(\n-    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n-    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n-    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n-    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n-    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n-    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 114L),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", 102L),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", 1L),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", 702L),\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 118L),\n+    changelogRow(\"+I\", \"US Dollar\", \"no2\", 106L))\n \n   val procTimeCurrencyChangelogData = List(\n-    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(114)),\n-    changelogRow(\"+I\",\"US Dollar\", \"no1\", toJLong(102)),\n-    changelogRow(\"+I\",\"Yen\", \"no1\", toJLong(1)),\n-    changelogRow(\"+I\",\"RMB\", \"no1\", toJLong(702)),\n-    changelogRow(\"-U\",\"RMB\", \"no1\", toJLong(702)),\n-    changelogRow(\"+U\",\"RMB\", \"no1\", toJLong(802)),\n-    changelogRow(\"+I\",\"Euro\", \"no1\", toJLong(118)),\n-    changelogRow(\"+I\",\"US Dollar\", \"no2\", toJLong(106)))\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 114L),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", 102L),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", 1L),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", 702L),\n+    changelogRow(\"-U\", \"RMB\", \"no1\", 702L),\n+    changelogRow(\"+U\", \"RMB\", \"no1\", 802L),\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 118L),\n+    changelogRow(\"+I\", \"US Dollar\", \"no2\", 106L))\n+\n+  // test data for Event-Time temporal table join\n+  val rowTimeOrderData = List(\n+    changelogRow(\"+I\", 1L, \"Euro\", \"no1\", 12L, \"2020-08-15T00:01:00\"),\n+    changelogRow(\"+I\", 2L, \"US Dollar\", \"no1\", 1L, \"2020-08-15T00:02:00\"),\n+    changelogRow(\"+I\", 3L, \"RMB\", \"no1\", 40L, \"2020-08-15T00:03:00\"),\n+    changelogRow(\"+I\", 4L, \"Euro\", \"no1\", 14L, \"2020-08-16T00:02:00\"),\n+    changelogRow(\"-U\", 2L, \"US Dollar\", \"no1\", 1L, \"2020-08-16T00:03:00\"),\n+    changelogRow(\"+U\", 2L, \"US Dollar\", \"no1\", 18L, \"2020-08-16T00:03:00\"),\n+    changelogRow(\"+I\", 5L, \"RMB\", \"no1\", 40L, \"2020-08-16T00:03:00\"),\n+    changelogRow(\"+I\", 6L, \"RMB\", \"no1\", 40L, \"2020-08-16T00:04:00\"),\n+    changelogRow(\"-D\", 6L, \"RMB\", \"no1\", 40L, \"2020-08-16T00:04:00\"))\n+\n+  val rowTimeCurrencyDataUsingMetaTime = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 114L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", 102L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", 1L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", 702L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", 114L, \"2020-08-16T00:01:00\"),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", 118L, \"2020-08-16T00:01:00\"),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", 102L, \"2020-08-16T00:02:00\"),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", 106L, \"2020-08-16T00:02:00\"),\n+    changelogRow(\"-D\", \"RMB\", \"no1\", 708L, \"2020-08-16T00:02:00\"))\n+\n+  val rowTimeCurrencyDataUsingUpdateBeforeTime = List(\n+    changelogRow(\"+I\", \"Euro\", \"no1\", 114L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"US Dollar\", \"no1\", 102L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"Yen\", \"no1\", 1L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", 702L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+I\", \"RMB\", \"no1\", 708L, \"2020-08-16T00:00:00\"),\n+    changelogRow(\"-U\", \"Euro\", \"no1\", 114L, \"2020-08-16T00:01:00\"),\n+    changelogRow(\"+U\", \"Euro\",  \"no1\", 118L, \"2020-08-16T00:01:00\"),\n+    changelogRow(\"-U\", \"US Dollar\", \"no1\", 102L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"US Dollar\",  \"no1\", 106L, \"2020-08-16T00:02:00\"),\n+    changelogRow(\"-D\", \"RMB\", \"no1\", 702L, \"2020-08-15T00:00:00\"))\n+\n+  val upsertSourceCurrencyData = List(\n+    changelogRow(\"+U\", \"Euro\", \"no1\", 114L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"US Dollar\", \"no1\", 102L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"Yen\", \"no1\", 1L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"RMB\", \"no1\", 702L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"US Dollar\", \"no1\", 104L, \"2020-08-16T00:00:00\"),\n+    changelogRow(\"-D\", \"RMB\", \"no1\", 702L, \"2020-08-15T00:00:00\"),\n+    changelogRow(\"+U\", \"RMB\", \"no1\", 712L, \"2020-08-16T00:00:00\"))", "originalCommit": "9f912a17d777463b856a19b64a03c16adadb8a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwNDc3Mg==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513904772", "bodyText": "We can store left row data to avoid copy joined result.", "author": "wuchong", "createdAt": "2020-10-29T03:04:07Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,22 +221,32 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// keep the the output records' order same with left input records order\n+\t\tMap<Long, RowData> orderedOutputs = new TreeMap<>();", "originalCommit": "9f912a17d777463b856a19b64a03c16adadb8a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "url": "https://github.com/apache/flink/commit/a45a5a527afc2aae477c89ebf0dc047cc45a201d", "message": "address comments", "committedDate": "2020-10-29T09:19:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNjY2Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514126666", "bodyText": "nit: would be better to declare it as final TreeMap<Long, RowData> orderedLeftRecords to guarantee it must be a TreeMap and not changed.", "author": "wuchong", "createdAt": "2020-10-29T09:43:17Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,45 +217,63 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// the output records's  order should keep same with left input records order\n+\t\tMap<Long, RowData> orderedLeftRecords = new TreeMap<>();", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNzk4Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514127986", "bodyText": "Add a comment that iterator the triggered left records in the ascending order of the sequence key, i.e. the arrival order.", "author": "wuchong", "createdAt": "2020-10-29T09:45:18Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,45 +217,63 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// the output records's  order should keep same with left input records order\n+\t\tMap<Long, RowData> orderedLeftRecords = new TreeMap<>();\n+\n \t\twhile (leftIterator.hasNext()) {\n \t\t\tMap.Entry<Long, RowData> entry = leftIterator.next();\n+\t\t\tLong leftSeq = entry.getKey();\n \t\t\tRowData leftRow = entry.getValue();\n \t\t\tlong leftTime = getLeftTime(leftRow);\n-\n-\t\t\tif (leftTime <= timerTimestamp) {\n-\t\t\t\tOptional<RowData> rightRow = latestRightRowToJoin(rightRowsSorted, leftTime);\n-\t\t\t\tif (rightRow.isPresent()) {\n-\t\t\t\t\tif (joinCondition.apply(leftRow, rightRow.get())) {\n-\t\t\t\t\t\toutRow.replace(leftRow, rightRow.get());\n-\t\t\t\t\t\tcollector.collect(outRow);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (leftTime <= currentWatermark) {\n+\t\t\t\torderedLeftRecords.put(leftSeq, leftRow);\n \t\t\t\tleftIterator.remove();\n \t\t\t} else {\n \t\t\t\tlastUnprocessedTime = Math.min(lastUnprocessedTime, leftTime);\n \t\t\t}\n \t\t}\n \n-\t\tcleanupState(timerTimestamp, rightRowsSorted);\n+\t\torderedLeftRecords.forEach((leftSeq, leftRow) -> {", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMDg1Mw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514130853", "bodyText": "Remove useless imports.", "author": "wuchong", "createdAt": "2020-10-29T09:49:52Z", "path": "flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecTemporalJoin.scala", "diffHunk": "@@ -18,6 +18,7 @@\n \n package org.apache.flink.table.planner.plan.nodes.physical.stream\n \n+import org.apache.flink.api.common.ExecutionConfig", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTE2NA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514149164", "bodyText": "Add a comment // TODO: remove the single parallelism once FLINK-19878 is fixed.", "author": "wuchong", "createdAt": "2020-10-29T10:19:40Z", "path": "flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TemporalJoinITCase.scala", "diffHunk": "@@ -260,6 +393,214 @@ class TemporalJoinITCase(state: StateBackendMode)\n     tEnv.executeSql(sql).await()\n   }\n \n+  @Test\n+  def testEventTimeTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00:01)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00:02)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00:04)\",\n+      \"+I(4,Euro,14,2020-08-16T00:04,118,2020-08-16T00:01)\",\n+      \"-U(2,US Dollar,1,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+U(2,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeTemporalJoinThatJoinkeyContainsPk(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency AND o.currency_no = r.currency_no\"\n+\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00:01)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00:02)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00:04)\",\n+      \"+I(4,Euro,14,2020-08-16T00:04,118,2020-08-16T00:01)\",\n+      \"-U(2,US Dollar,1,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+U(2,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeTemporalJoinWithFilter(): Unit = {\n+    tEnv.executeSql(\"CREATE VIEW v1 AS\" +\n+      \" SELECT * FROM versioned_currency_with_single_key WHERE rate < 115\")\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o \" +\n+      \" JOIN v1 FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+    tEnv.executeSql(sql).await()\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00:01)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00:02)\",\n+      \"-U(2,US Dollar,1,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+U(2,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeLeftTemporalJoin(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o LEFT JOIN versioned_currency_with_single_key \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+    tEnv.executeSql(sql).await()\n+\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,114,2020-08-15T00:00:01)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00:02)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00:04)\",\n+      \"+I(4,Euro,14,2020-08-16T00:04,118,2020-08-16T00:01)\",\n+      \"-U(2,US Dollar,1,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+U(2,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+I(5,RMB,40,2020-08-16T00:03,null,null)\",\n+      \"+I(6,RMB,40,2020-08-16T00:04,null,null)\",\n+      \"-D(6,RMB,40,2020-08-16T00:04,null,null)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeTemporalJoinChangelogUsingBeforeTime(): Unit = {\n+    val sql = \"INSERT INTO rowtime_default_sink \" +\n+      \" SELECT o.order_id, o.currency, o.amount, o.order_time, r.rate, r.currency_time \" +\n+      \" FROM orders_rowtime AS o LEFT JOIN currency_using_update_before_time \" +\n+      \" FOR SYSTEM_TIME AS OF o.order_time as r \" +\n+      \" ON o.currency = r.currency\"\n+    tEnv.executeSql(sql).await()\n+\n+    val rawResult = getRawResults(\"rowtime_default_sink\")\n+    val expected = List(\n+      \"+I(1,Euro,12,2020-08-15T00:01,null,null)\",\n+      \"+I(2,US Dollar,1,2020-08-15T00:02,102,2020-08-15T00:00:02)\",\n+      \"+I(3,RMB,40,2020-08-15T00:03,702,2020-08-15T00:00:04)\",\n+      \"+I(4,Euro,14,2020-08-16T00:04,118,2020-08-16T00:01)\",\n+      \"-U(2,US Dollar,1,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+U(2,US Dollar,18,2020-08-16T00:03,106,2020-08-16T00:02)\",\n+      \"+I(5,RMB,40,2020-08-16T00:03,null,null)\",\n+      \"+I(6,RMB,40,2020-08-16T00:04,null,null)\",\n+      \"-D(6,RMB,40,2020-08-16T00:04,null,null)\")\n+    assertEquals(expected.sorted, rawResult.sorted)\n+  }\n+\n+  @Test\n+  def testEventTimeLeftTemporalJoinUpsertSource(): Unit = {\n+    // Note: The WatermarkAssigner of upsertSource is followed after ChangelogNormalize,\n+    // when the parallelism > 1 and test data doesn't cover all parallelisms, it returns\n+    // Long.MaxValue as final watermark until all parallelism finished.\n+    // This may leads the test failed because the test data doesn't cover every parallelism.", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "896661af5940a86cd9fba9526aaf57a553d388cb", "url": "https://github.com/apache/flink/commit/896661af5940a86cd9fba9526aaf57a553d388cb", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator.", "committedDate": "2020-10-29T11:54:51Z", "type": "commit"}, {"oid": "896661af5940a86cd9fba9526aaf57a553d388cb", "url": "https://github.com/apache/flink/commit/896661af5940a86cd9fba9526aaf57a553d388cb", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator.", "committedDate": "2020-10-29T11:54:51Z", "type": "forcePushed"}]}