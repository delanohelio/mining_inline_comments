{"pr_number": 11098, "pr_title": "[FLINK-16060][task] Implement working StreamMultipleInputProcessor", "pr_createdAt": "2020-02-14T14:18:03Z", "pr_url": "https://github.com/apache/flink/pull/11098", "timeline": [{"oid": "311d3e9843bd601a8de8bee78c2ecd34222d19d6", "url": "https://github.com/apache/flink/commit/311d3e9843bd601a8de8bee78c2ecd34222d19d6", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-15T06:32:34Z", "type": "forcePushed"}, {"oid": "8355093ce1ed0dab9985d9f522f3bcd97c66d016", "url": "https://github.com/apache/flink/commit/8355093ce1ed0dab9985d9f522f3bcd97c66d016", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-15T06:36:13Z", "type": "forcePushed"}, {"oid": "e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "url": "https://github.com/apache/flink/commit/e72b2a38b7ec718b44a14f98897dbaf22f9d0d0d", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-15T06:44:29Z", "type": "forcePushed"}, {"oid": "ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "url": "https://github.com/apache/flink/commit/ce0a2e4c48f33e7826d6f469c54f3ba342c9552d", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-16T09:13:30Z", "type": "forcePushed"}, {"oid": "e9472785fa25680b297986397e3c732875d4ccff", "url": "https://github.com/apache/flink/commit/e9472785fa25680b297986397e3c732875d4ccff", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-16T10:56:15Z", "type": "forcePushed"}, {"oid": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "url": "https://github.com/apache/flink/commit/82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-17T11:59:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTMyMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380549321", "bodyText": "If I understood correctly, there are two use-cases: with stateKeySelectors and without.\nI think it's better to have separate classes for these, or at least document these cases and invariants (on class or field level).", "author": "rkhachatryan", "createdAt": "2020-02-18T09:26:35Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MzQwOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382653408", "bodyText": "I think it might be a good idea to provide both MultipleInputTransformation and MultipleInputKeyedTransformation (I was duplicating pre-existing pattern), with some common base class. Maybe for this PR, I would just provide non keyed version, and in the later one, where I'm planning to add actual support for key selectors and multiple input, I would try to add separate class for handling key selectors.\nThis way, if there will come up any reason why having a single class is actually a better idea, we won't have to revert the changes.", "author": "pnowojski", "createdAt": "2020-02-21T15:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0OTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Mzg4MA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380553880", "bodyText": "Could you please explain the purpose of this method?", "author": "rkhachatryan", "createdAt": "2020-02-18T09:34:15Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -581,6 +611,13 @@ public void setTwoInputStateKey(Integer vertexID, KeySelector<?, ?> keySelector1\n \t\tnode.setStateKeySerializer(keySerializer);\n \t}\n \n+\tpublic void setMultipleInputStateKey(\n+\t\t\tint id,\n+\t\t\tList<KeySelector<?, ?>> stateKeySelectors,\n+\t\t\tTypeSerializer<?> keySerializer) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODMyNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382658325", "bodyText": "I dropped the method as a result of a previous comment", "author": "pnowojski", "createdAt": "2020-02-21T15:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Mzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380557788", "bodyText": "With this signature, it's possible to call without any arguments.\nIf it's not a legal state then it makes sense to check arguments (or better ensure at compile time).\nAlso in other classes, e.g. MinWatermarkGauge.", "author": "rkhachatryan", "createdAt": "2020-02-18T09:41:11Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamNode.java", "diffHunk": "@@ -235,20 +234,16 @@ public void addOutputSelector(OutputSelector<?> outputSelector) {\n \t\tthis.outputSelectors.add(outputSelector);\n \t}\n \n-\tpublic TypeSerializer<?> getTypeSerializerIn1() {\n-\t\treturn typeSerializerIn1;\n+\tpublic void setSerializersIn(TypeSerializer<?> ...typeSerializersIn) {", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NDE1NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383184155", "bodyText": "Empty needed for sources, I guess.", "author": "AHeise", "createdAt": "2020-02-24T10:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5NjA0OQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383396049", "bodyText": "It's not used in the sources. I think indeed the job graph generator could crash if this is empty. Also currently that could happen only with incorrectly constructed/implemented MultipleInputOperator, so I think it's a good idea to just disallow it.", "author": "pnowojski", "createdAt": "2020-02-24T17:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1Nzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1NDMyMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380654321", "bodyText": "nit: extract method (repeated 4 times)?", "author": "rkhachatryan", "createdAt": "2020-02-18T12:56:59Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -330,6 +332,34 @@ public boolean isIterative() {\n \t\t}\n \t}\n \n+\tpublic <OUT> void addMultipleInputOperator(\n+\t\t\tInteger vertexID,\n+\t\t\tString slotSharingGroup,\n+\t\t\t@Nullable String coLocationGroup,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tList<TypeInformation<?>> inTypeInfos,\n+\t\t\tTypeInformation<OUT> outTypeInfo,\n+\t\t\tString operatorName) {\n+\n+\t\tClass<? extends AbstractInvokable> vertexClass = MultipleInputStreamTask.class;\n+\n+\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, vertexClass, operatorFactory, operatorName);\n+\n+\t\tTypeSerializer<OUT> outSerializer = (outTypeInfo != null) && !(outTypeInfo instanceof MissingTypeInfo) ?\n+\t\t\toutTypeInfo.createSerializer(executionConfig) : null;\n+", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1Nzg1Ng==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382657856", "bodyText": "what is repeated 4 times? I see that addMultipleInputOperator  duplicates (once) addCoOperator, but where are other two duplications?\nnever mind, found it.", "author": "pnowojski", "createdAt": "2020-02-21T15:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1NDMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380658811", "bodyText": "Could you please explain:\n\nwhy do we need this check here? there is already one in transform()?\nwhy the check doesn't precede transform() of inputs?", "author": "rkhachatryan", "createdAt": "2020-02-18T13:06:19Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java", "diffHunk": "@@ -735,6 +739,56 @@ public StreamGraph generate() {\n \t\treturn Collections.singleton(transform.getId());\n \t}\n \n+\tprivate <OUT> Collection<Integer> transformMultipleInputTransform(MultipleInputTransformation<OUT> transform) {\n+\t\tList<Collection<Integer>> allInputIds = new ArrayList<>();\n+\n+\t\tfor (Transformation<?> input : transform.getInputs()) {\n+\t\t\tallInputIds.add(transform(input));\n+\t\t}\n+\n+\t\t// the recursive call might have already transformed this\n+\t\tif (alreadyTransformed.containsKey(transform)) {\n+\t\t\treturn alreadyTransformed.get(transform);\n+\t\t}\n+", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MTk0MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383181941", "bodyText": "Should be before transform() of inputs.", "author": "AHeise", "createdAt": "2020-02-24T10:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM5MjE1NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383392154", "bodyText": "I'm not sure. I was mostly copying the logic from transformTwoInputTransform (and also the same pattern is in transformOneInputTransform as well).\nHowever it looks like this might be because of cyclic dependencies.\nDo you think this is a bug in all of those places?", "author": "pnowojski", "createdAt": "2020-02-24T17:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExNTIxNA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384115214", "bodyText": "Or maybe because of mutability of Transformation?\nIn either case, I wouldn't spend time on it because the only impact I see is this confusion.", "author": "rkhachatryan", "createdAt": "2020-02-25T20:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY1ODgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY3ODEwNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380678105", "bodyText": "Why can't we use Transformation#getId here? E.g.\nassertEquals(1, streamGraph.getStreamEdges(transform.getId(), source1.getId()).size());", "author": "rkhachatryan", "createdAt": "2020-02-18T13:42:53Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -312,6 +316,40 @@ public void testOutputTypeConfigurationWithTwoInputTransformation() throws Excep\n \t\tassertEquals(BasicTypeInfo.INT_TYPE_INFO, outputTypeConfigurableOperation.getTypeInformation());\n \t}\n \n+\t@Test\n+\tpublic void testMultipleInputTransformation() throws Exception {\n+\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n+\t\t//TODO: referring to getNewNodeId() is hacky, but I'm not sure if there is a better idea?\n+\t\tint startingNewNodeId = Transformation.getNewNodeId();\n+\n+\t\tDataStream<Integer> source1 = env.fromElements(1, 10);\n+\t\tDataStream<Long> source2 = env.fromElements(2L, 11L);\n+\t\tDataStream<String> source3 = env.fromElements(\"42\", \"44\");\n+\n+\t\tMultipleInputTransformation<String> transform = new MultipleInputTransformation<String>(\n+\t\t\t\"My Operator\",\n+\t\t\tnew MultipleInputOperatorFactory(),\n+\t\t\tBasicTypeInfo.STRING_TYPE_INFO,\n+\t\t\t3);\n+\n+\t\ttransform.addInput(source1.getTransformation());\n+\t\ttransform.addInput(source2.getTransformation());\n+\t\ttransform.addInput(source3.getTransformation());\n+\n+\t\tenv.addOperator(transform);\n+\t\tStreamGraph streamGraph = env.getStreamGraph();\n+\t\tassertEquals(4, streamGraph.getStreamNodes().size());\n+\n+\t\tint id = startingNewNodeId;\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3, id + 4).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 1).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 2).size());\n+\t\tassertEquals(1, streamGraph.getStreamEdges(id + 3).size());\n+\t\tassertEquals(0, streamGraph.getStreamEdges(id + 4).size());", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwMjA0OQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383402049", "bodyText": "I don't know why I haven't figured this out \ud83d\ude13", "author": "pnowojski", "createdAt": "2020-02-24T17:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY3ODEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5MTIyMA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380691220", "bodyText": "Can we improve it with two arrayCopy calls:\nSystem.arraycopy(bufferStorages, 0, copy, 0, skipStorage);\nSystem.arraycopy(bufferStorages, skipStorage + 1, copy, skipStorage, bufferStorages.length - skipStorage - 1);\n\n?\nAlso, variable names don't say much to me (just src, dst and i would be better).", "author": "rkhachatryan", "createdAt": "2020-02-18T14:05:43Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -63,40 +63,57 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \tpublic static CheckpointedInputGate[] createCheckpointedInputGatePair(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tCheckpointingMode checkpointMode,\n-\t\t\tInputGate inputGate1,\n-\t\t\tInputGate inputGate2,\n \t\t\tConfiguration taskManagerConfig,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n-\t\t\tString taskName) {\n+\t\t\tString taskName,\n+\t\t\tInputGate ...inputGates) {\n \n \t\tint pageSize = ConfigurationParserUtils.getPageSize(taskManagerConfig);\n \n-\t\tBufferStorage mainBufferStorage1 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tBufferStorage mainBufferStorage2 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tcheckState(mainBufferStorage1.getMaxBufferedBytes() == mainBufferStorage2.getMaxBufferedBytes());\n+\t\tBufferStorage[] mainBufferStorages = new BufferStorage[inputGates.length];\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tmainBufferStorages[i] = createBufferStorage(\n+\t\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n+\t\t}\n+\n+\t\tBufferStorage[] linkedBufferStorages = new BufferStorage[inputGates.length];\n \n-\t\tBufferStorage linkedBufferStorage1 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n-\t\tBufferStorage linkedBufferStorage2 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tlinkedBufferStorages[i] = new LinkedBufferStorage(\n+\t\t\t\tmainBufferStorages[i],\n+\t\t\t\tmainBufferStorages[i].getMaxBufferedBytes(),\n+\t\t\t\tcopyBufferStoragesExceptOf(i, mainBufferStorages));\n+\t\t}\n \n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tcheckpointMode,\n-\t\t\tinputGate1.getNumberOfInputChannels() + inputGate2.getNumberOfInputChannels(),\n+\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum(),\n \t\t\ttaskName,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n-\t\treturn new CheckpointedInputGate[] {\n-\t\t\tnew CheckpointedInputGate(inputGate1, linkedBufferStorage1, barrierHandler),\n-\t\t\tnew CheckpointedInputGate(inputGate2, linkedBufferStorage2, barrierHandler, inputGate1.getNumberOfInputChannels())\n-\t\t};\n+\t\tCheckpointedInputGate[] checkpointedInputGates = new CheckpointedInputGate[inputGates.length];\n+\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tcheckpointedInputGates[i] = new CheckpointedInputGate(inputGates[i], linkedBufferStorages[i], barrierHandler, channelIndexOffset);\n+\t\t\tchannelIndexOffset += inputGates[i].getNumberOfInputChannels();\n+\t\t}\n+\n+\t\treturn checkpointedInputGates;\n+\t}\n+\n+\tprivate static BufferStorage[] copyBufferStoragesExceptOf(\n+\t\t\tint skipStorage,\n+\t\t\tBufferStorage[] bufferStorages) {\n+\t\tBufferStorage[] copy = new BufferStorage[bufferStorages.length - 1];\n+\t\tint copyTo = 0;\n+\t\tfor (int copyFrom = 0; copyFrom < bufferStorages.length; copyFrom++) {\n+\t\t\tif (copyFrom != skipStorage) {\n+\t\t\t\tcopy[copyTo++] = bufferStorages[copyFrom];\n+\t\t\t}\n+\t\t}\n+\t\treturn copy;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5OTcwOQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380699709", "bodyText": "nit: mark the class with @NotThreadSafe?", "author": "rkhachatryan", "createdAt": "2020-02-18T14:19:37Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/LinkedBufferStorage.java", "diffHunk": "@@ -56,17 +57,27 @@ public boolean isFull() {\n \t@Override\n \tpublic void rollOver() {\n \t\tmainStorage.rollOver();\n-\t\tlinkedStorage.rollOver();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tlinked.rollOver();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic long getPendingBytes() {\n-\t\treturn mainStorage.getPendingBytes() + linkedStorage.getPendingBytes();\n+\t\tlong pendingBytes = mainStorage.getPendingBytes();\n+\t\tfor (BufferStorage linked : linkedStorage) {\n+\t\t\tpendingBytes += linked.getPendingBytes();", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NzI2NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382667265", "bodyText": "Usually we treat most of the classes @NotThreadSafe by default and all/almost all of the classes in this package are not thread safe.", "author": "pnowojski", "createdAt": "2020-02-21T16:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDY5OTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyODM3MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380728371", "bodyText": "I think the whole function can be simplified as:\nprivate int fairSelectFromRightBits(int bits, int next) {\n    for (bits >>= next; bits > 0 && bits % 2 != 1; bits >>= 1, next++) {\n    }\n    return bits > 0 ? next : -1;\n}\n\nRemoving if makes loop more predictable (I understand it's a critical code path, right?)", "author": "rkhachatryan", "createdAt": "2020-02-18T15:03:39Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MDU4OQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382680589", "bodyText": "I'm not sure if this alternative is more readable and I don't think it will be faster (compiler should be able to optimise it anyway AND branch prediction wouldn't work for one or two iterations anyway), but ok.", "author": "pnowojski", "createdAt": "2020-02-21T16:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyODM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyOTk3MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380729971", "bodyText": "Here, we check if the rightmost bit is set, right?\nIn that case, masking would be faster and more readable:\nrightBits & 1 == 1", "author": "rkhachatryan", "createdAt": "2020-02-18T15:06:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTQwOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382681408", "bodyText": "For me % 2 is easier to understand, as % operator is used much more frequently compared to &. And there is zero performance difference between those two (both will be optimised to the same machine code)\nscratch that, & 1 behaves somehow better for negative inputs.", "author": "pnowojski", "createdAt": "2020-02-21T16:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyOTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMDQ1MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380730451", "bodyText": "Should we use >>> instead of >>? (unlikely we hit this situation... but IPv4... :) )\n(same in other places where we shift)", "author": "rkhachatryan", "createdAt": "2020-02-18T15:06:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {\n+\t\t\tif (rightBits % 2 == 1) {\n+\t\t\t\treturn nextReadInputIndex;\n+\t\t\t}\n+\t\t\tnextReadInputIndex++;\n+\t\t\trightBits >>= 1;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5Njc0NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382696744", "bodyText": "Yes. There was also another bug  in this method. If nextReadInputIndex was larger or equal to 32, method would enter endless loop, as bitshifts have undefined behaviour for shifting more than number of bits.", "author": "pnowojski", "createdAt": "2020-02-21T17:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDczMDQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc0MTA1NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380741055", "bodyText": "Do we need special mask for the case when all inputs are selected (-1L)?\nOr how is this case handled?", "author": "rkhachatryan", "createdAt": "2020-02-18T15:22:33Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,8 +101,39 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n-\tprivate static boolean isALLMaskOf2(long inputMask) {\n-\t\treturn (3 & inputMask) == 3;\n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDY2Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382674662", "bodyText": "Good question, I had to double check that. availableInputsMask could only be set to -1 to indicate all 32 inputs are available. I will document that. MultipleInputSelectionHandler is adhering to this contract.", "author": "pnowojski", "createdAt": "2020-02-21T16:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc0MTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380755077", "bodyText": "If this method is only for tests, should we place it into TestStreamTask which extends StreamTask?\nIf not:\n\nshould we re-use it in runMailboxLoop below?\nmake it package-private?", "author": "rkhachatryan", "createdAt": "2020-02-18T15:42:43Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -484,11 +485,15 @@ public final void invoke() throws Exception {\n \t\t}\n \t}\n \n+\tprotected boolean runMailboxStep() throws Exception {\n+\t\treturn mailboxProcessor.runMailboxStep();\n+\t}\n+", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5ODU0NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r382698544", "bodyText": "I don't see an easy way how to do it, as we would have to provide multiple different test classes (one per each production StreamTask subclass?).", "author": "pnowojski", "createdAt": "2020-02-21T17:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5Njc0Mw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383196743", "bodyText": "We could just expose mailboxProcessor to tests and delegate to MailboxProcessor#runMailboxStep in harness.", "author": "AHeise", "createdAt": "2020-02-24T10:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyOTM2Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384129362", "bodyText": "I came up with this weird construction:\npublic class TestStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamTask<OUT, OP> {\n\tprivate final StreamTask<OUT, OP> delegatee;\n\n\tpublic TestStreamTask(StreamTask<OUT, OP> streamTask) {\n\t\tsuper(streamTask.getEnvironment());\n\t\tthis.delegatee = streamTask;\n\t}\n\n\tpublic boolean runMailboxStep() throws Exception {\n\t\treturn delegate.mailboxProcessor.runMailboxStep();\n\t}\n        // init()\n}\n\nThen replace type StreamTask to TestStreamTask and create it as:\nenv -> new TestStreamTask<>(new MultipleInputStreamTask<>(env))\n\n(should be a factory)\nI think this is better than having \"test\" methods in StreamTask.\nExposing mailboxProcessor (via constructor?) is also an option. But IMO less preferable because it exposes more details.", "author": "rkhachatryan", "createdAt": "2020-02-25T21:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzNTUwNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384335505", "bodyText": "I don't see how your proposal should work @rkhachatryan ? After passing to the test harness\nval streamTask = new TestStreamTask<>(new MultipleInputStreamTask<>(env))\n\nevery time test harness would access the streamTask, it would be accessing TestStreamTask, not MultipleInputStreamTask, unless you would override/delegate  all of the methods, which would be an unstable overkill. Test harness would have to access the delegate reference for everything except of runMailboxStep(), which I would say is basically a less convoluted equivalent of having exposed @VisibleForTesting runMailboxStep() method in the production code.\nI think better solution would be to inject, mailbox into the StreamTask, but that would require to create [Source|TwoInput|MultipleInput]StreamTaskBuilder classes (constructors of StreamTask are already messy), and it's also on an overkill for this (imo) small problem. I think I would have done, if not for the fact how much refactoring and clean up I'm already doing here and will be doing more in other places (AbstractStreamOperator :()", "author": "pnowojski", "createdAt": "2020-02-26T08:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1NDYwNA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384354604", "bodyText": "Yes, we would have to delegate all methods.\n(I agree it can be overkill)", "author": "rkhachatryan", "createdAt": "2020-02-26T09:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc1NTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2MTA2Nw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380761067", "bodyText": "Can we instead of null add something like\npublic interface InputSelectable {\n    InputSelectable ALL = () -> InputSelection.ALL;\n\nand then use it in this class?", "author": "rkhachatryan", "createdAt": "2020-02-18T15:50:59Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {\n+\t\tswitch (inputStatus) {\n+\t\t\tcase MORE_AVAILABLE:\n+\t\t\t\tcheckState(checkBitMask(availableInputsMask, inputIndex));\n+\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t\tcase NOTHING_AVAILABLE:\n+\t\t\t\tavailableInputsMask = unsetBitMask(availableInputsMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tcase END_OF_INPUT:\n+\t\t\t\tendOfInputMask = setBitMask(endOfInputMask, inputIndex);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported inputStatus = \" + inputStatus);\n+\t\t}\n+\n+\t\treturn calculateInputStatus();\n+\t}\n+\n+\tpublic InputStatus calculateInputStatus() throws IOException {\n+\t\tif (endOfInputMask == allSelectedMask) {\n+\t\t\treturn InputStatus.END_OF_INPUT;\n+\t\t}\n+\n+\t\tif (isAnyInputAvailable()) {\n+\t\t\treturn InputStatus.MORE_AVAILABLE;\n+\t\t}\n+\t\telse {\n+\t\t\tlong selectedNotFinishedInputMask = inputSelection.getInputMask() & ~(endOfInputMask);\n+\t\t\tif (selectedNotFinishedInputMask == 0) {\n+\t\t\t\tthrow new IOException(\"Can not make a progress: all selected inputs are already finished\");\n+\t\t\t}\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\t}\n+\n+\tvoid nextSelection() {\n+\t\tif (inputSelector == null) {\n+\t\t\tinputSelection = InputSelection.ALL;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTI4MA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383185280", "bodyText": "It would be indeed nicer. However this brings extra overhead of virtualisation, and might mess up with the optimiser for the common path (no  InputSelector), preventing inlining etc. I'm not sure how much does it matter in here though.\nHowever if we wanted to do it, it should also be changed in the two input processor as well, and would require more cautious regression benchmarks. So I would suggest to do it independently.", "author": "pnowojski", "createdAt": "2020-02-24T10:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2MTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2NjI4NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380766284", "bodyText": "Looks like endOfInputMask is always negated.\nShould we reverse the logic then?\nI.e., have nonEndedInputs set to all ones initially, and zeroed on END_OF_INPUT?", "author": "rkhachatryan", "createdAt": "2020-02-18T15:58:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380770621", "bodyText": "I think this method shouldn't mix these responsibilities:\n\nupdate state for the given input\ncalculate the aggregate status\n\n(reportInputStatus could be void and client could additinally call calculateInputStatus )", "author": "rkhachatryan", "createdAt": "2020-02-18T16:04:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.streaming.api.operators.InputSelectable;\n+import org.apache.flink.streaming.api.operators.InputSelection;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This handler is mainly used for selecting the next available input index\n+ * in {@link StreamMultipleInputProcessor}.\n+ */\n+@Internal\n+public class MultipleInputSelectionHandler {\n+\n+\t@Nullable\n+\tprivate final InputSelectable inputSelector;\n+\n+\tprivate InputSelection inputSelection = InputSelection.ALL;\n+\n+\tprivate final long allSelectedMask;\n+\n+\tprivate long availableInputsMask;\n+\n+\tprivate long endOfInputMask;\n+\n+\tpublic MultipleInputSelectionHandler(@Nullable InputSelectable inputSelectable, int inputCount) {\n+\t\tthis.inputSelector = inputSelectable;\n+\t\tthis.allSelectedMask = (1 << inputCount) - 1;\n+\t\tthis.availableInputsMask = allSelectedMask;\n+\t}\n+\n+\tpublic InputStatus reportInputStatus(InputStatus inputStatus, int inputIndex) throws IOException {", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MTMyNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383181327", "bodyText": "I'm not sure. Also as it is now, the hot looping path\n\t\t\tcase MORE_AVAILABLE:\n\t\t\t\tcheckState(checkBitMask(availableInputsMask, inputIndex));\n\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n\nis a bit shorter, this probably doesn't matter much, but I'm not sure in the first place if it makes sense to push the responsibility on a caller, to always call two methods (especially since they are logically inseparable), .", "author": "pnowojski", "createdAt": "2020-02-24T10:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMzIwNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383203205", "bodyText": "I don't see an issue with that. For me this is the transition function of an finite automate.\nnit: reportInputStatus -> updateInputStatus", "author": "AHeise", "createdAt": "2020-02-24T11:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MTQxMA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384161410", "bodyText": "I find the convention of splitting methods to read-only and writing very helpful.\nThis says much less to me:\nreturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n\nthan\ninputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\nreturn inputSelectionHandler.getOverallStatus();\n\n(I don't even have to go into methods to understand what they do).", "author": "rkhachatryan", "createdAt": "2020-02-25T22:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzODIzNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384338237", "bodyText": "Yes and no. Yes, it's a bit easier to understand, but no, as it creates opportunity for code duplication. I think I would change it as you are suggesting if not for that hot looping argument.\nSo I would leave it as it is, with @AHeise 's suggestion to rename to updateStatus?", "author": "pnowojski", "createdAt": "2020-02-26T08:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM2ODkxNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384368915", "bodyText": "I'd choose readability now vs avoiding Opportunity for duplication of 2 lines. And even if we'd have two call sites, I'd prefer to see them more readable.\nHot looping argument seems like premature optimization to me.\nThis is the 2nd or 3rd time this argument is used in this PR without a benchmark for a hot code path (right?). So probably it makes sense to add a benchmark for this and maybe as a follow-up PR. So let's keep the current version or the suggested by @AHeise and hope to improve it later.", "author": "rkhachatryan", "createdAt": "2020-02-26T09:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3MDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380772843", "bodyText": "Do we start effectively with 2?\nThere is lastReadInputIndex + 1 in InputSelection", "author": "rkhachatryan", "createdAt": "2020-02-18T16:08:01Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NjIxNg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383186216", "bodyText": "Hmmm, indeed we do. I've noticed this behaviour when writing a unit test and was wondering where does it come from, but in the end, it made me realise that neither the production code nor the tests should relay on such behaviour, so I think this is just fine.", "author": "pnowojski", "createdAt": "2020-02-24T10:31:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMzkxNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383203915", "bodyText": "Should probably be -1 if we start at 0 as always.", "author": "AHeise", "createdAt": "2020-02-24T11:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NjA4Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380776082", "bodyText": "Should it be i instead of 0?", "author": "rkhachatryan", "createdAt": "2020-02-18T16:12:49Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM1MDU5OQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383350599", "bodyText": "Good catch. Currently this is a dead code (watermarks not yet supported). I think this has a dedicated test in TwoInputStreamTask version, which I wanted to port with a follow up PR adding support for watermarks.", "author": "pnowojski", "createdAt": "2020-02-24T15:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NzYxNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380787617", "bodyText": "Could you please explain why is it not supported?", "author": "rkhachatryan", "createdAt": "2020-02-18T16:30:04Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NzcyMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383187721", "bodyText": "I haven't yet tested it with the input selection and I'm not sure if the isAnyInputAvailable properly supports inputs selection.\nHmm.. it looks like it might be just missing a single if check, but I'm not sure.", "author": "pnowojski", "createdAt": "2020-02-24T10:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NzYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380789462", "bodyText": "The future will never complete if all inputs are finished, won't it?", "author": "rkhachatryan", "createdAt": "2020-02-18T16:32:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\t// to avoid starvation, if the input selection is ALL and availableInputsMask is not ALL,\n+\t\t// always try to check and set the availability of another input\n+\t\tif (inputSelectionHandler.shouldSetAvailableForAnotherInput()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\treturn readingInputIndex;\n+\t}\n+\n+\tprivate void fullCheckAndSetAvailable() {\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tInputProcessor<?> inputProcessor = inputProcessors[i];\n+\t\t\t// TODO: isAvailable() can be a costly operation (checking volatile). If one of\n+\t\t\t// the input is constantly available and another is not, we will be checking this volatile\n+\t\t\t// once per every record. This might be optimized to only check once per processed NetworkBuffer\n+\t\t\tif (inputProcessor.networkInput.isApproximatelyAvailable() || inputProcessor.networkInput.isAvailable()) {\n+\t\t\t\tinputSelectionHandler.setAvailableInput(i);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate CompletableFuture<?> isAnyInputAvailable() {\n+\t\tif (inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\treturn AVAILABLE;\n+\t\t}\n+\t\tfinal CompletableFuture<?> anyInputAvailable = new CompletableFuture<>();\n+\t\tfor (int i = 0; i < inputProcessors.length; i++) {\n+\t\t\tif (!inputSelectionHandler.isInputFinished(i)) {", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNjk1NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383206954", "bodyText": "Would probably be better to use CompletableFuture#any in any case.", "author": "AHeise", "createdAt": "2020-02-24T11:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIzMTIxNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383231215", "bodyText": "Good catch, there should be one more check +/-:\nif (inputSelectionHandler.isAnyInputAvailable() || inputSelectionHandler.areAllInputsFinished()) {\n\treturn AVAILABLE;\n}", "author": "pnowojski", "createdAt": "2020-02-24T12:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczNDk3Nw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383734977", "bodyText": "Would probably be better to use CompletableFuture#any in any case.\n\nI was hoping to do just that, but we can not include all of the futures, so we would have to be constructing new array every time we access CompletableFuture#anyOf(...) - which might be quite often.", "author": "pnowojski", "createdAt": "2020-02-25T08:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTgzNg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r380789836", "bodyText": "nit: extract constant?", "author": "rkhachatryan", "createdAt": "2020-02-18T16:33:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();\n+\t\t}\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn InputStatus.NOTHING_AVAILABLE;\n+\t\t}\n+\n+\t\tlastReadInputIndex = readingInputIndex;\n+\t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tcheckFinished(inputStatus, readingInputIndex);\n+\t\treturn inputSelectionHandler.reportInputStatus(inputStatus, readingInputIndex);\n+\t}\n+\n+\tprivate int selectFirstReadingInputIndex() {\n+\t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n+\t\t// is opened to ensure that any changes about the input selection in its open()\n+\t\t// method take effect.\n+\t\tinputSelectionHandler.nextSelection();\n+\n+\t\tisPrepared = true;\n+\n+\t\treturn selectNextReadingInputIndex();\n+\t}\n+\n+\tprivate void checkFinished(InputStatus status, int inputIndex) throws Exception {\n+\t\tif (status == InputStatus.END_OF_INPUT) {\n+\t\t\toperatorChain.endHeadOperatorInput(getInputId(inputIndex));\n+\t\t\tinputSelectionHandler.nextSelection();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tIOException ex = null;\n+\t\tfor (InputProcessor<?> input : inputProcessors) {\n+\t\t\ttry {\n+\t\t\t\tinput.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tex = ExceptionUtils.firstOrSuppressed(e, ex);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (ex != null) {\n+\t\t\tthrow ex;\n+\t\t}\n+\t}\n+\n+\tprivate int selectNextReadingInputIndex() {\n+\t\tif (!inputSelectionHandler.isAnyInputAvailable()) {\n+\t\t\tfullCheckAndSetAvailable();\n+\t\t}\n+\n+\t\tint readingInputIndex = inputSelectionHandler.selectNextInputIndex(lastReadInputIndex);\n+\t\tif (readingInputIndex == -1) {\n+\t\t\treturn -1;", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2OTk4Nw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383169987", "bodyText": "n-input?", "author": "AHeise", "createdAt": "2020-02-24T10:00:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+\n+/**\n+ * {@link Input} interface used in {@link MultipleInputStreamOperator}.\n+ */\n+public interface Input<IN> {\n+\t/**\n+\t * Processes one element that arrived on the first input of this two-input operator.", "originalCommit": "cc14a078882901405f9531d06eb83bdd45a528fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MjE0MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383172141", "bodyText": "List<Transformation<?>> inputs", "author": "AHeise", "createdAt": "2020-02-24T10:04:44Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();", "originalCommit": "cc14a078882901405f9531d06eb83bdd45a528fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MjE5Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383172192", "bodyText": "List<KeySelector<?, ?>> stateKeySelectors", "author": "AHeise", "createdAt": "2020-02-24T10:04:51Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();", "originalCommit": "cc14a078882901405f9531d06eb83bdd45a528fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MzYwOQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383173609", "bodyText": "Any reason to not use streams here?", "author": "AHeise", "createdAt": "2020-02-24T10:07:42Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/MultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.ChainingStrategy;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This Transformation represents the application of a\n+ * {@link org.apache.flink.streaming.api.operators.MultipleInputStreamOperator}\n+ * to input {@code Transformations}. The result is again only one stream.\n+ *\n+ * @param <OUT> The type of the elements that result from this {@code MultipleInputTransformation}\n+ */\n+@Internal\n+public class MultipleInputTransformation<OUT> extends PhysicalTransformation<OUT> {\n+\n+\tprivate final ArrayList<Transformation<?>> inputs = new ArrayList<>();\n+\n+\tprivate final StreamOperatorFactory<OUT> operatorFactory;\n+\n+\tprivate final ArrayList<KeySelector<?, ?>> stateKeySelectors = new ArrayList<>();\n+\n+\tprivate TypeInformation<?> stateKeyType;\n+\n+\tpublic MultipleInputTransformation(\n+\t\t\tString name,\n+\t\t\tStreamOperatorFactory<OUT> operatorFactory,\n+\t\t\tTypeInformation<OUT> outputType,\n+\t\t\tint parallelism) {\n+\t\tsuper(name, outputType, parallelism);\n+\t\tthis.operatorFactory = operatorFactory;\n+\t}\n+\n+\tpublic List<Transformation<?>> getInputs() {\n+\t\treturn inputs;\n+\t}\n+\n+\t/**\n+\t * Returns the {@code TypeInformation} for the elements from the inputs.\n+\t */\n+\tpublic List<TypeInformation<?>> getInputTypes() {\n+\t\treturn inputs.stream()\n+\t\t\t.map(Transformation::getOutputType)\n+\t\t\t.collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Returns the {@code StreamOperatorFactory} of this Transformation.\n+\t */\n+\tpublic StreamOperatorFactory<OUT> getOperatorFactory() {\n+\t\treturn operatorFactory;\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.isEmpty(),\n+\t\t\t\"Trying to add non-keyed input to keyed transformation.\");\n+\t\tinputs.add(input);\n+\t}\n+\n+\tpublic void addInput(Transformation<?> input, KeySelector<?, ?> keySelector) {\n+\t\tcheckState(\n+\t\t\tstateKeySelectors.size() == inputs.size(),\n+\t\t\t\"Trying to add keyed input to non-keyed transformation\");\n+\t\tinputs.add(input);\n+\t\tstateKeySelectors.add(keySelector);\n+\t}\n+\n+\tpublic List<KeySelector<?, ?>> getStateKeySelectors() {\n+\t\treturn stateKeySelectors;\n+\t}\n+\n+\tpublic void setStateKeyType(TypeInformation<?> stateKeyType) {\n+\t\tthis.stateKeyType = stateKeyType;\n+\t}\n+\n+\tpublic TypeInformation<?> getStateKeyType() {\n+\t\treturn stateKeyType;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<Transformation<?>> getTransitivePredecessors() {\n+\t\tList<Transformation<?>> result = Lists.newArrayList();", "originalCommit": "cc14a078882901405f9531d06eb83bdd45a528fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4MTA1NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383381055", "bodyText": "Bah, I don't like going back and forth between collections and streams. Especially in flatMap. But ok ;)", "author": "pnowojski", "createdAt": "2020-02-24T16:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3MzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3Mzc5NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383173795", "bodyText": "Random change?", "author": "AHeise", "createdAt": "2020-02-24T10:08:06Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/SingleOutputStreamOperator.java", "diffHunk": "@@ -59,7 +59,7 @@\n \n \tprivate boolean wasSplitApplied = false;\n \n-\tprotected SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {\n+\tpublic SingleOutputStreamOperator(StreamExecutionEnvironment environment, Transformation<T> transformation) {", "originalCommit": "cc14a078882901405f9531d06eb83bdd45a528fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM3NzgyNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383377827", "bodyText": "actually not :) This constructor is the only way to actually use the MutlipleInputTransformation. But as this is a @Public class, good that you are rising this issue.\n@aljoscha you might want to voice your opinion about this and the first commit of this PR in general.", "author": "pnowojski", "createdAt": "2020-02-24T16:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3Mzc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383177132", "bodyText": "Not sure what this whole change is about. Better commit message? Why is the new method deprecated already?\nUsually when I read orThrow I except some customizable error; see Optional#orElseThrow(Supplier<X> exceptionSupplier).\nI'd probably just add this methods to the test as\npublic static List<StreamEdge> getNonEmptyStreamEdges(Environment env, int sourceId, int targetId) { ... }\n\nIt just adds convenience for writing test.  @VisibleForTesting should be about giving access to something that is inaccessible.", "author": "AHeise", "createdAt": "2020-02-24T10:14:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -637,19 +638,24 @@ public StreamNode getStreamNode(Integer vertexID) {\n \t\treturn streamNodes.keySet();\n \t}\n \n+\t@VisibleForTesting\n \tpublic List<StreamEdge> getStreamEdges(int sourceId, int targetId) {\n-\n \t\tList<StreamEdge> result = new ArrayList<>();\n \t\tfor (StreamEdge edge : getStreamNode(sourceId).getOutEdges()) {\n \t\t\tif (edge.getTargetId() == targetId) {\n \t\t\t\tresult.add(edge);\n \t\t\t}\n \t\t}\n+\t\treturn result;\n+\t}\n \n+\t@VisibleForTesting\n+\t@Deprecated\n+\tpublic List<StreamEdge> getStreamEdgesOrThrow(int sourceId, int targetId) {", "originalCommit": "33c07ff8c333074b60425360c101ffd1de8e58c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTUwNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383385507", "bodyText": "Keep in mind that this method is only used in the tests, to make some assertions.\nGenerally speaking this old getStreamEdges() with throwing an exception was a bad & confusing design. It should never be like that. If it wasn't supposed to be empty, test should just assert manually content of the actual list, instead of relaying on this method throwing an exception. I tried to use it to actually make an assertion that the list is empty and it exploded in my face with some RuntimeException...\nIf not for the fact that this method is used a lot in the tests and annoyingly, couple percent of those tests are actually relaying on the fact that this method throws, I would just drop it and use getStreamEdges() everywhere properly , but there were too many usages and I gave up...", "author": "pnowojski", "createdAt": "2020-02-24T16:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1ODQ1Nw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383858457", "bodyText": "Like I said, we should move the old behavior into the tests. If we don't do it now, it's probably okay.", "author": "AHeise", "createdAt": "2020-02-25T12:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzOTM1NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384339354", "bodyText": "Yes, we should. As I wrote, the old method shouldn't exists. At least here I renamed it so it is not so confusing :/\nBut I didn't want to spend even more time cleaning up unrelated old code (because I was cleaning up/refactoring already so much).", "author": "pnowojski", "createdAt": "2020-02-26T08:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3NzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODQ2MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383178461", "bodyText": "Start at 1 for backwards compatibility?", "author": "AHeise", "createdAt": "2020-02-24T10:16:52Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -158,12 +158,11 @@ public TimeCharacteristic getTimeCharacteristic() {\n \t\t}\n \t}\n \n-\tpublic void setTypeSerializerIn1(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_1, serializer);\n-\t}\n-\n-\tpublic void setTypeSerializerIn2(TypeSerializer<?> serializer) {\n-\t\tsetTypeSerializer(TYPE_SERIALIZER_IN_2, serializer);\n+\tpublic void setTypeSerializersIn(TypeSerializer<?> ...serializers) {\n+\t\tconfig.setInteger(TYPE_SERIALIZERS_IN_COUNT, serializers.length);\n+\t\tfor (int i = 0; i < serializers.length; i++) {", "originalCommit": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4ODAzNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383388037", "bodyText": "no need for the backwards compatibility - I've double checked that with SDK team.", "author": "pnowojski", "createdAt": "2020-02-24T16:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODgzNQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383178835", "bodyText": "PREFIX would be good enough, see TYPE_SERIALIZER_SIDEOUT_PREFIX.", "author": "AHeise", "createdAt": "2020-02-24T10:17:37Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -73,8 +73,8 @@\n \tprivate static final String ITERATION_ID = \"iterationId\";\n \tprivate static final String OUTPUT_SELECTOR_WRAPPER = \"outputSelectorWrapper\";\n \tprivate static final String BUFFER_TIMEOUT = \"bufferTimeout\";\n-\tprivate static final String TYPE_SERIALIZER_IN_1 = \"typeSerializer_in_1\";\n-\tprivate static final String TYPE_SERIALIZER_IN_2 = \"typeSerializer_in_2\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_COUNT = \"typeSerializer_in_count\";\n+\tprivate static final String TYPE_SERIALIZERS_IN_PATTERN = \"typeSerializer_in_%d\";", "originalCommit": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NzY2Mw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383387663", "bodyText": "but with %d it's a pattern now, not a prefix, so the name fits. Or do you mean to change it to prefix (by dropping the %d part?)? If the latter, I think pattern > prefix.", "author": "pnowojski", "createdAt": "2020-02-24T16:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1ODgzNg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383858836", "bodyText": "String.format is quite slow, but I guess it's okay for setup code.", "author": "AHeise", "createdAt": "2020-02-25T12:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3ODgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE3OTM3Mw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383179373", "bodyText": "handle -1? Would give a weird exception.", "author": "AHeise", "createdAt": "2020-02-24T10:18:36Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamConfig.java", "diffHunk": "@@ -174,19 +173,35 @@ public void setTypeSerializerSideOut(OutputTag<?> outputTag, TypeSerializer<?> s\n \t\tsetTypeSerializer(TYPE_SERIALIZER_SIDEOUT_PREFIX + outputTag.getId(), serializer);\n \t}\n \n+\t@Deprecated\n \tpublic <T> TypeSerializer<T> getTypeSerializerIn1(ClassLoader cl) {\n-\t\ttry {\n-\t\t\treturn InstantiationUtil.readObjectFromConfig(this.config, TYPE_SERIALIZER_IN_1, cl);\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new StreamTaskException(\"Could not instantiate serializer.\", e);\n-\t\t}\n+\t\treturn getTypeSerializerIn(0, cl);\n \t}\n \n+\t@Deprecated\n \tpublic <T> TypeSerializer<T> getTypeSerializerIn2(ClassLoader cl) {\n+\t\treturn getTypeSerializerIn(1, cl);\n+\t}\n+\n+\tpublic TypeSerializer<?>[] getTypeSerializersIn(ClassLoader cl) {\n+\t\tint typeSerializersCount = config.getInteger(TYPE_SERIALIZERS_IN_COUNT, -1);\n+\t\tTypeSerializer<?>[] typeSerializers = new TypeSerializer<?>[typeSerializersCount];", "originalCommit": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MDgyOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383180828", "bodyText": "TypeSerializer[]::new not working?", "author": "AHeise", "createdAt": "2020-02-24T10:21:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraph.java", "diffHunk": "@@ -590,17 +626,30 @@ public void setBufferTimeout(Integer vertexID, long bufferTimeout) {\n \n \tpublic void setSerializers(Integer vertexID, TypeSerializer<?> in1, TypeSerializer<?> in2, TypeSerializer<?> out) {\n \t\tStreamNode vertex = getStreamNode(vertexID);\n-\t\tvertex.setSerializerIn1(in1);\n-\t\tvertex.setSerializerIn2(in2);\n+\t\tvertex.setSerializersIn(in1, in2);\n+\t\tvertex.setSerializerOut(out);\n+\t}\n+\n+\tprivate <OUT> void setSerializers(\n+\t\t\tInteger vertexID,\n+\t\t\tList<TypeInformation<?>> inTypeInfos,\n+\t\t\tTypeSerializer<OUT> out) {\n+\n+\t\tStreamNode vertex = getStreamNode(vertexID);\n+\n+\t\tvertex.setSerializersIn(\n+\t\t\tinTypeInfos.stream()\n+\t\t\t\t.map(typeInfo -> typeInfo.createSerializer(executionConfig))\n+\t\t\t\t.toArray(size -> new TypeSerializer<?>[size]));", "originalCommit": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTcyOQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383185729", "bodyText": "Weird that we need that here... the real factories are still SimpleX? Or can we not add a real factory.", "author": "AHeise", "createdAt": "2020-02-24T10:30:41Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamGraphGeneratorTest.java", "diffHunk": "@@ -633,4 +671,29 @@ protected boolean matchesSafely(ResourceSpec item) {\n \t\t\treturn resources.lessThanOrEqual(item) && item.lessThanOrEqual(resources);\n \t\t}\n \t}\n+\n+\tprivate static class MultipleInputOperatorFactory implements StreamOperatorFactory<String> {", "originalCommit": "e7d81d3232d7f3c6ce98eee507ea80ba3a555528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwMjkwNg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383402906", "bodyText": "This is not using SimpleOperatorFactory, isn't it?", "author": "pnowojski", "createdAt": "2020-02-24T17:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1OTU1OA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383859558", "bodyText": "Good question. There has to be some factory for it.", "author": "AHeise", "createdAt": "2020-02-25T12:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NjIxNA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383186214", "bodyText": "Imho not a hotfix.", "author": "AHeise", "createdAt": "2020-02-24T10:31:37Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -28,7 +28,7 @@\n import org.apache.flink.runtime.util.ConfigurationParserUtils;\n import org.apache.flink.streaming.api.CheckpointingMode;\n \n-import static org.apache.flink.util.Preconditions.checkState;", "originalCommit": "b7ed31dfcf341a632addaf43b3db2a171508aec3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4NzQ1NQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383187455", "bodyText": "nit declare in loop.", "author": "AHeise", "createdAt": "2020-02-24T10:34:01Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -63,40 +63,57 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \tpublic static CheckpointedInputGate[] createCheckpointedInputGatePair(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tCheckpointingMode checkpointMode,\n-\t\t\tInputGate inputGate1,\n-\t\t\tInputGate inputGate2,\n \t\t\tConfiguration taskManagerConfig,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n-\t\t\tString taskName) {\n+\t\t\tString taskName,\n+\t\t\tInputGate ...inputGates) {\n \n \t\tint pageSize = ConfigurationParserUtils.getPageSize(taskManagerConfig);\n \n-\t\tBufferStorage mainBufferStorage1 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tBufferStorage mainBufferStorage2 = createBufferStorage(\n-\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n-\t\tcheckState(mainBufferStorage1.getMaxBufferedBytes() == mainBufferStorage2.getMaxBufferedBytes());\n+\t\tBufferStorage[] mainBufferStorages = new BufferStorage[inputGates.length];\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tmainBufferStorages[i] = createBufferStorage(\n+\t\t\t\tcheckpointMode, pageSize, taskManagerConfig, taskName);\n+\t\t}\n+\n+\t\tBufferStorage[] linkedBufferStorages = new BufferStorage[inputGates.length];\n \n-\t\tBufferStorage linkedBufferStorage1 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n-\t\tBufferStorage linkedBufferStorage2 = new LinkedBufferStorage(\n-\t\t\tmainBufferStorage2,\n-\t\t\tmainBufferStorage1,\n-\t\t\tmainBufferStorage1.getMaxBufferedBytes());\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tlinkedBufferStorages[i] = new LinkedBufferStorage(\n+\t\t\t\tmainBufferStorages[i],\n+\t\t\t\tmainBufferStorages[i].getMaxBufferedBytes(),\n+\t\t\t\tcopyBufferStoragesExceptOf(i, mainBufferStorages));\n+\t\t}\n \n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tcheckpointMode,\n-\t\t\tinputGate1.getNumberOfInputChannels() + inputGate2.getNumberOfInputChannels(),\n+\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum(),\n \t\t\ttaskName,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n-\t\treturn new CheckpointedInputGate[] {\n-\t\t\tnew CheckpointedInputGate(inputGate1, linkedBufferStorage1, barrierHandler),\n-\t\t\tnew CheckpointedInputGate(inputGate2, linkedBufferStorage2, barrierHandler, inputGate1.getNumberOfInputChannels())\n-\t\t};\n+\t\tCheckpointedInputGate[] checkpointedInputGates = new CheckpointedInputGate[inputGates.length];\n+\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tcheckpointedInputGates[i] = new CheckpointedInputGate(inputGates[i], linkedBufferStorages[i], barrierHandler, channelIndexOffset);\n+\t\t\tchannelIndexOffset += inputGates[i].getNumberOfInputChannels();\n+\t\t}\n+\n+\t\treturn checkpointedInputGates;\n+\t}\n+\n+\tprivate static BufferStorage[] copyBufferStoragesExceptOf(\n+\t\t\tint skipStorage,\n+\t\t\tBufferStorage[] bufferStorages) {\n+\t\tBufferStorage[] copy = new BufferStorage[bufferStorages.length - 1];\n+\t\tint copyTo = 0;", "originalCommit": "b7ed31dfcf341a632addaf43b3db2a171508aec3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4OTAwOQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383189009", "bodyText": "Again not a hotfix imho.", "author": "AHeise", "createdAt": "2020-02-24T10:37:02Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/metrics/MinWatermarkGauge.java", "diffHunk": "@@ -20,21 +20,23 @@\n \n import org.apache.flink.metrics.Gauge;", "originalCommit": "85d0c2c8fc103a2268a3b064913d6b3a4e76cfd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5MTcyNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383191727", "bodyText": "any reason why inputMask is long but availableInputsMask is not?", "author": "AHeise", "createdAt": "2020-02-24T10:42:26Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,6 +110,41 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {", "originalCommit": "34ac483978e13949e15a03ebd7523ee3610661da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQwOTM0Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383409342", "bodyText": "I've forgotten about a TODO in the code to investigate it. I think we should be fine by supporting longs. Previously for two input case it was int, as  it was max 2.", "author": "pnowojski", "createdAt": "2020-02-24T17:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5MTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5NDM3OA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383194378", "bodyText": "Since this is very performance critical, we might need to check if we can use the ideas behind Integer#numberOfTrailingZeros to speed things up.", "author": "AHeise", "createdAt": "2020-02-24T10:47:42Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/InputSelection.java", "diffHunk": "@@ -110,6 +110,41 @@ public int fairSelectNextIndexOutOf2(int availableInputsMask, int lastReadInputI\n \t\tthrow new UnsupportedOperationException(\"Only two inputs are supported.\");\n \t}\n \n+\t/**\n+\t * Fairly select one of the available inputs for reading.\n+\t *\n+\t * @param availableInputsMask The mask of all available inputs.\n+\t * @param lastReadInputIndex The index of last read input.\n+\t * @return the index of the input for reading or -1, and -1 indicates no input is selected (\n+\t *         {@code inputMask} is empty or the inputs in {@code inputMask} are unavailable).\n+\t */\n+\tpublic int fairSelectNextIndex(int availableInputsMask, int lastReadInputIndex) {\n+\t\tint selectionMask = (int) inputMask;\n+\t\tint combineMask = availableInputsMask & selectionMask;\n+\n+\t\tif (combineMask == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\tint nextReadInputIndex = fairSelectFromRightBits(combineMask, lastReadInputIndex + 1);\n+\t\tif (nextReadInputIndex >= 0) {\n+\t\t\treturn nextReadInputIndex;\n+\t\t}\n+\t\treturn fairSelectFromRightBits(combineMask, 0);\n+\t}\n+\n+\tprivate int fairSelectFromRightBits(int combineMask, int nextReadInputIndex) {\n+\t\tint rightBits = combineMask >> nextReadInputIndex;\n+\t\twhile (rightBits > 0) {", "originalCommit": "34ac483978e13949e15a03ebd7523ee3610661da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5NTAwOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383195008", "bodyText": "This looks like two test cases to me.", "author": "AHeise", "createdAt": "2020-02-24T10:48:45Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/InputSelectionTest.java", "diffHunk": "@@ -75,6 +75,28 @@ public void testFairSelectNextIndexOutOf2() {\n \t\tassertEquals(-1, InputSelection.SECOND.fairSelectNextIndexOutOf2(0, 1));\n \t}\n \n+\t@Test\n+\tpublic void testFairSelectNextIndex() {\n+\t\tassertEquals(1, InputSelection.ALL.fairSelectNextIndex(7, 0));\n+\t\tassertEquals(2, InputSelection.ALL.fairSelectNextIndex(7, 1));\n+\t\tassertEquals(0, InputSelection.ALL.fairSelectNextIndex(7, 2));\n+\t\tassertEquals(1, InputSelection.ALL.fairSelectNextIndex(7, 0));\n+\n+\t\t// combination of selection and availability is supposed to be 3, 5, 8:\n+\t\tInputSelection selection = new Builder().select(2).select(3).select(4).select(5).select(8).build();", "originalCommit": "34ac483978e13949e15a03ebd7523ee3610661da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5ODUzMQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383198531", "bodyText": "Visible for testing.", "author": "AHeise", "createdAt": "2020-02-24T10:55:43Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java", "diffHunk": "@@ -183,9 +183,20 @@ public void runMailboxLoop() throws Exception {\n \n \t\tfinal MailboxController defaultActionContext = new MailboxController(this);\n \n-\t\twhile (processMail(localMailbox)) {\n+\t\twhile (runMailboxStep(localMailbox, defaultActionContext)) {\n+\t\t}\n+\t}\n+\n+\tpublic boolean runMailboxStep() throws Exception {", "originalCommit": "5b562ca278304274d87807b319e64c6b57d65d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNDY2Ng==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383414666", "bodyText": "I think this could be part of the public api for this class.", "author": "pnowojski", "createdAt": "2020-02-24T17:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5ODUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MDA0NA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383860044", "bodyText": "I don't mind. It's non-public API to begin with.", "author": "AHeise", "createdAt": "2020-02-25T12:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE5ODUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383201040", "bodyText": "I didn't get why we'd need the owner in this commit.", "author": "AHeise", "createdAt": "2020-02-24T11:00:46Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamConfigChainer.java", "diffHunk": "@@ -42,15 +42,17 @@\n /**\n  * Helper class to build StreamConfig for chain of operators.\n  */\n-public class StreamConfigChainer {\n+public class StreamConfigChainer<OWNER> {\n+\tprivate final OWNER owner;", "originalCommit": "5b562ca278304274d87807b319e64c6b57d65d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNTkwNw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383415907", "bodyText": "It's in order to provide a nice builder like API, for nested builder. That after finish() call on setting up the chaining, we  can continue configuring or build the test harness:\n\t\t\tnew MultipleInputStreamTaskTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.addInput(BasicTypeInfo.STRING_TYPE_INFO)\n\t\t\t\t.setupOperatorChain(new DuplicatingOperator())\n\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t.chain(new OneInputStreamTaskTest.DuplicatingOperator(), BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))\n\t\t\t\t.finish()\n\t\t\t\t.setTaskMetricGroup(taskMetricGroup)\n\t\t\t\t.build()\n\nAnd OWNER is template, so that finish() and hence build() would return correct specific type of the test harness (MultipleInput)", "author": "pnowojski", "createdAt": "2020-02-24T17:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MDQwMA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383860400", "bodyText": "Gotcha. StreamConfigChainer is only used as a builder anyway, right?", "author": "AHeise", "createdAt": "2020-02-25T12:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0MDQxMw==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384340413", "bodyText": "Yes, exactly. It is a builder to setup operator chain.", "author": "pnowojski", "createdAt": "2020-02-26T08:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTM4OA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383201388", "bodyText": "Could also be done with prefix.", "author": "AHeise", "createdAt": "2020-02-24T11:01:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java", "diffHunk": "@@ -42,8 +42,11 @@ private MetricNames() {\n \tpublic static final String IO_NUM_BUFFERS_OUT_RATE = IO_NUM_BUFFERS_OUT + SUFFIX_RATE;\n \n \tpublic static final String IO_CURRENT_INPUT_WATERMARK = \"currentInputWatermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_1_WATERMARK = \"currentInput1Watermark\";\n+\t@Deprecated\n \tpublic static final String IO_CURRENT_INPUT_2_WATERMARK = \"currentInput2Watermark\";\n+\tpublic static final String IO_CURRENT_INPUT_WATERMARK_PATERN = \"currentInput%dWatermark\";", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNzMyMg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383417322", "bodyText": "As previously, even if we re ordered it as prefix, patterns carry more information and are more concrete/well defined. For example, if you have prefix, does it mean that there is no suffix or other infix? Pattern mitigates this ambiguity.", "author": "pnowojski", "createdAt": "2020-02-24T17:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwMTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNDg5MQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383204891", "bodyText": "Couldn't we introduce some open/init for this case?", "author": "AHeise", "createdAt": "2020-02-24T11:09:29Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.runtime.io;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.runtime.io.disk.iomanager.IOManager;\n+import org.apache.flink.streaming.api.operators.Input;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;\n+import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;\n+import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;\n+import org.apache.flink.streaming.runtime.tasks.OperatorChain;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Input processor for {@link MultipleInputStreamOperator}.\n+ */\n+@Internal\n+public final class StreamMultipleInputProcessor implements StreamInputProcessor {\n+\n+\tprivate final MultipleInputSelectionHandler inputSelectionHandler;\n+\n+\tprivate final InputProcessor<?>[] inputProcessors;\n+\n+\tprivate final OperatorChain<?, ?> operatorChain;\n+\n+\t/**\n+\t * Stream status for the two inputs. We need to keep track for determining when\n+\t * to forward stream status changes downstream.\n+\t */\n+\tprivate final StreamStatus[] streamStatuses;\n+\n+\tprivate final Counter numRecordsIn;\n+\n+\t/** Always try to read from the first input. */\n+\tprivate int lastReadInputIndex = 1;\n+\n+\tprivate boolean isPrepared;\n+\n+\tpublic StreamMultipleInputProcessor(\n+\t\t\tCheckpointedInputGate[] checkpointedInputGates,\n+\t\t\tTypeSerializer<?>[] inputSerializers,\n+\t\t\tIOManager ioManager,\n+\t\t\tStreamStatusMaintainer streamStatusMaintainer,\n+\t\t\tMultipleInputStreamOperator<?> streamOperator,\n+\t\t\tMultipleInputSelectionHandler inputSelectionHandler,\n+\t\t\tWatermarkGauge[] inputWatermarkGauges,\n+\t\t\tOperatorChain<?, ?> operatorChain,\n+\t\t\tCounter numRecordsIn) {\n+\n+\t\tthis.inputSelectionHandler = checkNotNull(inputSelectionHandler);\n+\n+\t\tList<Input> inputs = streamOperator.getInputs();\n+\t\tint operatorsCount = inputs.size();\n+\n+\t\tthis.inputProcessors = new InputProcessor[operatorsCount];\n+\t\tthis.streamStatuses = new StreamStatus[operatorsCount];\n+\t\tthis.numRecordsIn = numRecordsIn;\n+\n+\t\tfor (int i = 0; i < operatorsCount; i++) {\n+\t\t\tStreamTaskNetworkOutput dataOutput = new StreamTaskNetworkOutput<>(\n+\t\t\t\tinputs.get(i),\n+\t\t\t\tstreamStatusMaintainer,\n+\t\t\t\tinputWatermarkGauges[i],\n+\t\t\t\ti);\n+\n+\t\t\tinputProcessors[i] = new InputProcessor(\n+\t\t\t\tdataOutput,\n+\t\t\t\tnew StreamTaskNetworkInput<>(\n+\t\t\t\t\tcheckpointedInputGates[i],\n+\t\t\t\t\tinputSerializers[i],\n+\t\t\t\t\tioManager,\n+\t\t\t\t\tnew StatusWatermarkValve(checkpointedInputGates[0].getNumberOfInputChannels(), dataOutput),\n+\t\t\t\t\ti));\n+\t\t}\n+\n+\t\tthis.operatorChain = checkNotNull(operatorChain);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<?> getAvailableFuture() {\n+\t\tif (inputSelectionHandler.areAllInputsSelected()) {\n+\t\t\treturn isAnyInputAvailable();\n+\t\t} else {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStatus processInput() throws Exception {\n+\t\tint readingInputIndex;\n+\t\tif (isPrepared) {\n+\t\t\treadingInputIndex = selectNextReadingInputIndex();\n+\t\t} else {\n+\t\t\t// the preparations here are not placed in the constructor because all work in it\n+\t\t\t// must be executed after all operators are opened.\n+\t\t\treadingInputIndex = selectFirstReadingInputIndex();", "originalCommit": "82937c8a0ec226cc90b29ac0f67f9abbb33c9e4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxODQ0Mg==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383418442", "bodyText": "+/- 0 from my side. Complicating the interface of the class vs a tinny implementation hiccup ?", "author": "pnowojski", "createdAt": "2020-02-24T17:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNDg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MTMxOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r383861318", "bodyText": "Leave as is. Ideally we would have fully initialized operators before any processor is used.", "author": "AHeise", "createdAt": "2020-02-25T12:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIwNDg5MQ=="}], "type": "inlineReview"}, {"oid": "ac7b323867f647d50b170c23df6c6052b2c08d61", "url": "https://github.com/apache/flink/commit/ac7b323867f647d50b170c23df6c6052b2c08d61", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-24T17:52:59Z", "type": "forcePushed"}, {"oid": "68393ef701e7b462638a26e89df167fa4a36ec14", "url": "https://github.com/apache/flink/commit/68393ef701e7b462638a26e89df167fa4a36ec14", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-25T08:29:10Z", "type": "forcePushed"}, {"oid": "352eaf94ac42b2428e2f2f90081e7a023136d9fd", "url": "https://github.com/apache/flink/commit/352eaf94ac42b2428e2f2f90081e7a023136d9fd", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-26T08:43:50Z", "type": "forcePushed"}, {"oid": "8e56fa6affa8e58ed6ad9233345c7c5b697de4ea", "url": "https://github.com/apache/flink/commit/8e56fa6affa8e58ed6ad9233345c7c5b697de4ea", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet.", "committedDate": "2020-02-26T14:53:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDM1OQ==", "url": "https://github.com/apache/flink/pull/11098#discussion_r384544359", "bodyText": "@AHeise could you take a look at the first commit once more time? I've reverted the @Public api change.", "author": "pnowojski", "createdAt": "2020-02-26T14:55:29Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/MultipleConnectedStreams.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.datastream;\n+\n+import org.apache.flink.annotation.Experimental;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.transformations.MultipleInputTransformation;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This is a very basic and rough stub for a class connecting multiple input {@link DataStream}s\n+ * into one, using {@link MultipleInputStreamOperator}.\n+ */\n+@Experimental\n+public class MultipleConnectedStreams {", "originalCommit": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMjkxOA==", "url": "https://github.com/apache/flink/pull/11098#discussion_r385112918", "bodyText": "Should be transform. doTransform would be the private implementation.", "author": "AHeise", "createdAt": "2020-02-27T13:05:36Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/MultipleConnectedStreams.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.datastream;\n+\n+import org.apache.flink.annotation.Experimental;\n+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;\n+import org.apache.flink.streaming.api.transformations.MultipleInputTransformation;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This is a very basic and rough stub for a class connecting multiple input {@link DataStream}s\n+ * into one, using {@link MultipleInputStreamOperator}.\n+ */\n+@Experimental\n+public class MultipleConnectedStreams {\n+\n+\tprotected final StreamExecutionEnvironment environment;\n+\n+\tpublic MultipleConnectedStreams(StreamExecutionEnvironment env) {\n+\t\tthis.environment = requireNonNull(env);\n+\t}\n+\n+\tpublic StreamExecutionEnvironment getExecutionEnvironment() {\n+\t\treturn environment;\n+\t}\n+\n+\tpublic <OUT> SingleOutputStreamOperator<OUT> doTransform(MultipleInputTransformation<OUT> transform) {", "originalCommit": "ad0620c7d03c7c38fd4a36bad398d972fd50eea8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "445bb2c0d1e78d34129e36b1372de9a900aef7d1", "url": "https://github.com/apache/flink/commit/445bb2c0d1e78d34129e36b1372de9a900aef7d1", "message": "[FLINK-15688][streaming] Define DataStream API for MultipleInputStreamOperator\n\nThis interface is still not complete - it's missing for example watermark and\nlatency markers support.", "committedDate": "2020-02-27T15:07:02Z", "type": "commit"}, {"oid": "a74317be52485be3ec6b07ab6c648cbf27cc762e", "url": "https://github.com/apache/flink/commit/a74317be52485be3ec6b07ab6c648cbf27cc762e", "message": "[hotfix][test] Rename getStreamEdges to getStreamEdgesOrThrow", "committedDate": "2020-02-27T15:07:02Z", "type": "commit"}, {"oid": "e84b830ceb9ff05b07c955f63145157f5711bb4c", "url": "https://github.com/apache/flink/commit/e84b830ceb9ff05b07c955f63145157f5711bb4c", "message": "[hotfix][streaming] Deduplicate code in StreamGraph", "committedDate": "2020-02-27T15:07:02Z", "type": "commit"}, {"oid": "0585cb5c374c2db5bddf3d54546fcba594c418d3", "url": "https://github.com/apache/flink/commit/0585cb5c374c2db5bddf3d54546fcba594c418d3", "message": "[FLINK-15688][streaming] Add support for MultipleInputStreamOperator in the StreamGraphGenerator", "committedDate": "2020-02-27T15:07:02Z", "type": "commit"}, {"oid": "df071c1e7d71fca6b26a36026c39d4c21361dc63", "url": "https://github.com/apache/flink/commit/df071c1e7d71fca6b26a36026c39d4c21361dc63", "message": "[hotfix][test] Deduplicate code in LinkedBufferStorageTest", "committedDate": "2020-02-27T15:07:02Z", "type": "commit"}, {"oid": "bf72510a524f4f5506ccb70d69e0ce9e08502241", "url": "https://github.com/apache/flink/commit/bf72510a524f4f5506ccb70d69e0ce9e08502241", "message": "[FLINK-16060][checkpointing] Generalize LinkedBufferStorage to support arbitrary number of linked buffer storages", "committedDate": "2020-02-27T15:07:03Z", "type": "commit"}, {"oid": "c477b07a4c393b2a6555b4d60776ffa93aa50f83", "url": "https://github.com/apache/flink/commit/c477b07a4c393b2a6555b4d60776ffa93aa50f83", "message": "[FLINK-16060][metrics] Generalize MinWatermarkGauge to accept an aribtrary number of input gauges", "committedDate": "2020-02-27T15:07:03Z", "type": "commit"}, {"oid": "6f82f13a03c276d59b4f6dca4ee8692d6cb5bc5e", "url": "https://github.com/apache/flink/commit/6f82f13a03c276d59b4f6dca4ee8692d6cb5bc5e", "message": "[hotfix][task] Extract InputSelection.NONE_AVAILABLE constant", "committedDate": "2020-02-27T15:07:03Z", "type": "commit"}, {"oid": "2462b4ef88b2633222ad4ae6ee12c09d5f7725f8", "url": "https://github.com/apache/flink/commit/2462b4ef88b2633222ad4ae6ee12c09d5f7725f8", "message": "[FLINK-16060][task] Implement InputSelection#fairSelectNextIndex\n\nThis is going to be used for runtime support of MultipleInputStreamOperator", "committedDate": "2020-02-27T15:07:03Z", "type": "commit"}, {"oid": "ed5c836b342a54914f77ea922328a7f17318e3dc", "url": "https://github.com/apache/flink/commit/ed5c836b342a54914f77ea922328a7f17318e3dc", "message": "[FLINK-16060][task] Generalize InputSelection#isAllMaskOf2 to multiple inputs", "committedDate": "2020-02-27T15:07:04Z", "type": "commit"}, {"oid": "8dac2a72a8184939f537c52962555971b7ff3097", "url": "https://github.com/apache/flink/commit/8dac2a72a8184939f537c52962555971b7ff3097", "message": "[hotfix][tests] Clean up exception lists of StreamTestSingleInputGate", "committedDate": "2020-02-27T15:07:04Z", "type": "commit"}, {"oid": "1a3c8c731bf1b7b42cefc827dc87473f02b65069", "url": "https://github.com/apache/flink/commit/1a3c8c731bf1b7b42cefc827dc87473f02b65069", "message": "[FLINK-16060][test] Provide a test harness for MultipleInputStreamTask\n\nThis creates new hierarchy of task harnesses that could be used for other tasks as well.", "committedDate": "2020-02-27T15:07:04Z", "type": "commit"}, {"oid": "b85332b20e2765101e28eca8ac45584ab57c77a0", "url": "https://github.com/apache/flink/commit/b85332b20e2765101e28eca8ac45584ab57c77a0", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet", "committedDate": "2020-02-27T15:07:04Z", "type": "commit"}, {"oid": "8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "url": "https://github.com/apache/flink/commit/8e399800ab8aad87f8d3a0f386d4f4eb0c488aad", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet", "committedDate": "2020-02-27T15:04:35Z", "type": "forcePushed"}, {"oid": "b85332b20e2765101e28eca8ac45584ab57c77a0", "url": "https://github.com/apache/flink/commit/b85332b20e2765101e28eca8ac45584ab57c77a0", "message": "[FLINK-16060][task] Implemente working StreamMultipleInputProcessor\n\nThis doesn't fully support input selection, watermarks, latency markers and keyed contextes yet", "committedDate": "2020-02-27T15:07:04Z", "type": "forcePushed"}]}