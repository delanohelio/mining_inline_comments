{"pr_number": 11347, "pr_title": "[FLINK-14971][checkpointing] Make all the non-IO operations in CheckpointCoordinator single-threaded", "pr_createdAt": "2020-03-09T04:05:10Z", "pr_url": "https://github.com/apache/flink/pull/11347", "timeline": [{"oid": "3bac3485e8fa916db3c1ec7dffcf5b80dbaef4de", "url": "https://github.com/apache/flink/commit/3bac3485e8fa916db3c1ec7dffcf5b80dbaef4de", "message": "[FLINK-14971][checkpointing] Remove lock of PendingCheckpoint\n\nSince all non-IO operations are executed in main thread, the lock of\nPendingCheckpoint could be avoided now.", "committedDate": "2020-03-09T06:58:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTIyOA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r390285228", "bodyText": "Shouldn't this commit:\n\n[hotfix] Fix broken DefaultSchedulerTest by satisfying the main thread requirement of CheckpointCoordinator\n\nbe squashed with the preceding one?", "author": "pnowojski", "createdAt": "2020-03-10T12:42:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -588,8 +588,8 @@ private void startTriggeringCheckpoint(\n \t\t\tfinal CompletableFuture<?> coordinatorCheckpointsComplete = pendingCheckpointCompletableFuture\n \t\t\t\t\t.thenComposeAsync((pendingCheckpoint) ->\n \t\t\t\t\t\t\tOperatorCoordinatorCheckpoints.triggerAndAcknowledgeAllCoordinatorCheckpointsWithCompletion(\n-\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, timer),\n-\t\t\t\t\t\t\ttimer);\n+\t\t\t\t\t\t\t\t\tcoordinatorsToCheckpoint, pendingCheckpoint, mainThreadExecutor),", "originalCommit": "74af716850ea4cf7d34cde033e90ab05e6210eba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM4MTc2OQ==", "url": "https://github.com/apache/flink/pull/11347#discussion_r391381769", "bodyText": "Oops, I just realize this commit includes some codes belongs the preceding commit. It's must caused by the conflict resolving. And yes, you are right. This commit could be squashed with the preceding one. I will do the squashing when all comments are addressed.", "author": "ifndef-SleePy", "createdAt": "2020-03-12T03:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg5NDQyMg==", "url": "https://github.com/apache/flink/pull/11347#discussion_r390894422", "bodyText": "I think we are missing some comments why is something being executed on the main thread or io thread executor. For example this chain in CheckpointCoordinator#completePendingCheckpoint:\n\nfinalizeCheckpoint goes first on io executor\nthen finalizeCheckpoint asynchronously goes back to the main thread\nthen completePendingCheckpoint goes again to io executor\nand finally completePendingCheckpoint goes back to main thread executor asynchronously\n\nFirst thing is those missing comments, why something is executed in one executor not the other one. Secondly, does it have to be this back and forth? Could we somehow simplify the code with simpler control flow main thread -> io thread -> main thread?", "author": "pnowojski", "createdAt": "2020-03-11T11:03:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -1018,61 +1019,64 @@ else if (checkpoint != null) {\n \t * <p>Important: This method should only be called in the checkpoint lock scope.\n \t *\n \t * @param pendingCheckpoint to complete\n-\t * @throws CheckpointException if the completion failed\n \t */\n-\tprivate void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {\n-\t\tfinal long checkpointId = pendingCheckpoint.getCheckpointId();\n-\t\tfinal CompletedCheckpoint completedCheckpoint;\n-\n+\tprivate void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) {\n \t\t// As a first step to complete the checkpoint, we register its state with the registry\n \t\tMap<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates();\n \t\tsharedStateRegistry.registerAll(operatorStates.values());\n \n-\t\ttry {\n-\t\t\ttry {\n-\t\t\t\tcompletedCheckpoint = pendingCheckpoint.finalizeCheckpoint();\n-\t\t\t\tfailureManager.handleCheckpointSuccess(pendingCheckpoint.getCheckpointId());\n-\t\t\t}\n-\t\t\tcatch (Exception e1) {\n-\t\t\t\t// abort the current pending checkpoint if we fails to finalize the pending checkpoint.\n-\t\t\t\tif (!pendingCheckpoint.isDiscarded()) {\n-\t\t\t\t\tabortPendingCheckpoint(\n-\t\t\t\t\t\tpendingCheckpoint,\n-\t\t\t\t\t\tnew CheckpointException(\n-\t\t\t\t\t\t\tCheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1));\n+\t\tfinal CompletableFuture<CompletedCheckpoint> completedCheckpointFuture = pendingCheckpoint.finalizeCheckpoint();\n+\t\tcompletedCheckpointFuture.thenApplyAsync((completedCheckpoint) -> {\n+\t\t\tsynchronized (lock) {\n+\t\t\t\tif (shutdown) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\t// the pending checkpoint must be discarded after the finalization\n+\t\t\t\tPreconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null);\n+\t\t\t\ttry {\n+\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completedCheckpoint);\n+\t\t\t\t\treturn completedCheckpoint;\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tcompletedCheckpoint.discardOnFailedStoring();\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tLOG.warn(\"Could not properly discard completed checkpoint {}.\", completedCheckpoint.getCheckpointID(), e);\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new CompletionException(t);\n \t\t\t\t}\n-\n-\t\t\t\tthrow new CheckpointException(\"Could not finalize the pending checkpoint \" + checkpointId + '.',\n-\t\t\t\t\tCheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, e1);\n \t\t\t}\n-\n-\t\t\t// the pending checkpoint must be discarded after the finalization\n-\t\t\tPreconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null);\n-\n-\t\t\ttry {\n-\t\t\t\tcompletedCheckpointStore.addCheckpoint(completedCheckpoint);\n-\t\t\t} catch (Exception exception) {\n-\t\t\t\t// we failed to store the completed checkpoint. Let's clean up\n-\t\t\t\texecutor.execute(new Runnable() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tcompletedCheckpoint.discardOnFailedStoring();\n-\t\t\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\t\t\tLOG.warn(\"Could not properly discard completed checkpoint {}.\", completedCheckpoint.getCheckpointID(), t);\n-\t\t\t\t\t\t}\n+\t\t}, executor)\n+\t\t.whenCompleteAsync((completedCheckpoint, throwable) -> {\n+\t\t\tsynchronized (lock) {\n+\t\t\t\tif (shutdown) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif (throwable != null) {\n+\t\t\t\t\tif (!pendingCheckpoint.isDiscarded()) {\n+\t\t\t\t\t\tabortPendingCheckpoint(\n+\t\t\t\t\t\t\tpendingCheckpoint,\n+\t\t\t\t\t\t\tnew CheckpointException(\n+\t\t\t\t\t\t\t\tCheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, throwable));\n \t\t\t\t\t}\n-\t\t\t\t});\n-\n-\t\t\t\tthrow new CheckpointException(\"Could not complete the pending checkpoint \" + checkpointId + '.',\n-\t\t\t\t\tCheckpointFailureReason.FINALIZE_CHECKPOINT_FAILURE, exception);\n+\t\t\t\t} else {\n+\t\t\t\t\tonCheckpointSuccess(completedCheckpoint);\n+\t\t\t\t}\n \t\t\t}\n-\t\t} finally {\n-\t\t\tpendingCheckpoints.remove(checkpointId);\n+\t\t}, timer);\n+\t}", "originalCommit": "cb87f61668e27f69dc3057691b1cfe997ce2e8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM4MzUwNw==", "url": "https://github.com/apache/flink/pull/11347#discussion_r391383507", "bodyText": "It's indeed a bit complicated. If we combine the meta data persistence and completed checkpoint storing in one operation (in IO thread), the logic here would be much easier to understand.", "author": "ifndef-SleePy", "createdAt": "2020-03-12T03:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg5NDQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5MjIzNA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r391492234", "bodyText": "If we are synchronizing all of the access to the completedCheckpointStore externally, wouldn't it be better to make CompletedCheckpointStore @ThreadSafe and synchronise it inside?", "author": "pnowojski", "createdAt": "2020-03-12T09:25:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -403,7 +403,10 @@ public void shutdown(JobStatus jobStatus) throws Exception {\n \t\t\t// clear queued requests and in-flight checkpoints\n \t\t\tabortPendingAndQueuedCheckpoints(reason);\n \n-\t\t\tcompletedCheckpointStore.shutdown(jobStatus);\n+\t\t\t// there might be a race condition with IO threads on completedCheckpointStore\n+\t\t\tsynchronized (completedCheckpointStore) {", "originalCommit": "a04e4412520adcc0f51cb9ce2b53c8ea70798bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgwMTI3NA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r392801274", "bodyText": "Sounds reasonable.", "author": "ifndef-SleePy", "createdAt": "2020-03-16T06:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5MjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5MzI0Nw==", "url": "https://github.com/apache/flink/pull/11347#discussion_r391493247", "bodyText": "The race condition is between io threads and just the shut down? And previously was it working becase CompletedCheckpointStore access were synchronized on the checkopint coordinator's lock?", "author": "pnowojski", "createdAt": "2020-03-12T09:27:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -403,7 +403,10 @@ public void shutdown(JobStatus jobStatus) throws Exception {\n \t\t\t// clear queued requests and in-flight checkpoints\n \t\t\tabortPendingAndQueuedCheckpoints(reason);\n \n-\t\t\tcompletedCheckpointStore.shutdown(jobStatus);\n+\t\t\t// there might be a race condition with IO threads on completedCheckpointStore", "originalCommit": "a04e4412520adcc0f51cb9ce2b53c8ea70798bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgwMzg4NA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r392803884", "bodyText": "The race condition happens between completedCheckpointStore.shutdown and completedCheckpointStore.addCheckpoint.\n\nAnd previously was it working becase CompletedCheckpointStore access were synchronized on the checkopint coordinator's lock?\n\nYes, exactly.", "author": "ifndef-SleePy", "createdAt": "2020-03-16T06:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5MzI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5NDM2Mw==", "url": "https://github.com/apache/flink/pull/11347#discussion_r391494363", "bodyText": "could there be some side effects on changing order of the operations? Now those lines are executed before inalizedLocationFuture.thenApplyAsync((completed) ... on L343.\nWhat would happen if there is some exception etc?", "author": "pnowojski", "createdAt": "2020-03-12T09:29:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java", "diffHunk": "@@ -311,25 +315,32 @@ public CheckpointException getFailureCause() {\n \t\t\t\ttry (CheckpointMetadataOutputStream out = targetLocation.createMetadataOutputStream()) {\n \t\t\t\t\tCheckpoints.storeCheckpointMetadata(savepoint, out);\n \t\t\t\t\tfinalizedLocation = out.closeAndFinalizeCheckpoint();\n+\t\t\t\t}\n \n+\t\t\t\tCompletedCheckpoint completed = new CompletedCheckpoint(\n+\t\t\t\t\tjobId,\n+\t\t\t\t\tcheckpointId,\n+\t\t\t\t\tcheckpointTimestamp,\n+\t\t\t\t\tSystem.currentTimeMillis(),\n+\t\t\t\t\toperatorStates,\n+\t\t\t\t\tmasterStates,\n+\t\t\t\t\tprops,\n+\t\t\t\t\tfinalizedLocation);\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tcompletedCheckpointStore.addCheckpoint(completed);\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tcompleted.discardOnFailedStoring();", "originalCommit": "12ad91e65dd889754a29efc459cf6beb49f68fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1NjQ0OQ==", "url": "https://github.com/apache/flink/pull/11347#discussion_r392856449", "bodyText": "Good question!\nActually completedCheckpointStore.addCheckpoint should be called before finalizedLocationFuture.thenApplyAsync((completed). The finalizedLocationFuture.thenApplyAsync((completed) does things like completing onCompletionPromise, reporting completed statistics, disposing the pending checkpoint. However if completedCheckpointStore.addCheckpoint fails afterwards, does this checkpoint succeeds? I don't think so. But onCompletionPromise has been completed in this scenario. It's inconsistent here.\nSo the right way here is calling completedCheckpointStore.addCheckpoint first, then completing onCompletionPromise.\nI was planning to do this as a follow-up issue. However since we have decided to combine the finalization and adding into completedCheckpointStore to simplify the operations between IO threads and main thread, I think it's a good opportunity to do this.", "author": "ifndef-SleePy", "createdAt": "2020-03-16T08:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5NDM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTg4Mw==", "url": "https://github.com/apache/flink/pull/11347#discussion_r392859883", "bodyText": "However I do find a problem inspired by this comment, nice job!\nThere might be a cancellation or shutting down during the finalization. It's not well handled yet, I would update the PR later to cover this scenario.", "author": "ifndef-SleePy", "createdAt": "2020-03-16T08:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5NDM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyMDkyOQ==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395020929", "bodyText": "I assume that one (or both) of the tests that you have added in the last commit were failing before fixing the issue?", "author": "pnowojski", "createdAt": "2020-03-19T13:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5NDM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTM2OA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r396315368", "bodyText": "It should be.", "author": "ifndef-SleePy", "createdAt": "2020-03-23T09:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5NDM2Mw=="}], "type": "inlineReview"}, {"oid": "cf8adb3d042bb89172fb45b68b6448713b4045ae", "url": "https://github.com/apache/flink/commit/cf8adb3d042bb89172fb45b68b6448713b4045ae", "message": "[hotfix] Address review comments. Make CompletedCheckpointStore thread-safe to avoid synchronization outside", "committedDate": "2020-03-16T06:25:10Z", "type": "forcePushed"}, {"oid": "655adff5f2d9298b34b167b5a355f4b536613246", "url": "https://github.com/apache/flink/commit/655adff5f2d9298b34b167b5a355f4b536613246", "message": "[hotfix] Handle the concurrent IO operations when finalizing checkpoint", "committedDate": "2020-03-16T19:09:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MzgzNQ==", "url": "https://github.com/apache/flink/pull/11347#discussion_r394983835", "bodyText": "@ThreadSafe\n\non the interface?", "author": "pnowojski", "createdAt": "2020-03-19T12:18:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStore.java", "diffHunk": "@@ -28,6 +28,7 @@\n \n /**\n  * A bounded LIFO-queue of {@link CompletedCheckpoint} instances.\n+ * Note that it might be visited by multiple threads. So implementation should keep it thread-safe.", "originalCommit": "5df0ac43a3fe9ee17620ff6ab07b967e2ba7a16f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwMDQ2NA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395000464", "bodyText": "nit: checkState()?", "author": "pnowojski", "createdAt": "2020-03-19T12:49:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java", "diffHunk": "@@ -304,35 +307,44 @@ public CheckpointException getFailureCause() {\n \t\t\t\t\"Pending checkpoint has not been fully acknowledged yet\"));\n \t\t}\n \n+\t\t// now we stop the canceller before finalization\n+\t\t// it simplifies the concurrent conflict issue here\n+\t\tcancelCanceller();\n+\n \t\t// make sure we fulfill the promise with an exception if something fails\n \t\tfinal CompletableFuture<CompletedCheckpoint> finalizedLocationFuture =\n \t\t\tCompletableFuture.supplyAsync(() -> {\n \t\t\ttry {\n-\t\t\t\t// write out the metadata\n-\t\t\t\tfinal CheckpointMetadata savepoint = new CheckpointMetadata(checkpointId, operatorStates.values(), masterStates);\n-\t\t\t\tfinal CompletedCheckpointStorageLocation finalizedLocation;\n+\t\t\t\tsynchronized (operationLock) {\n+\t\t\t\t\tif (isDiscarded()) {\n+\t\t\t\t\t\tthrow new IllegalStateException(\"The checkpoint has been discarded\");\n+\t\t\t\t\t}", "originalCommit": "655adff5f2d9298b34b167b5a355f4b536613246", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwNDU3NA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395004574", "bodyText": "This is reverting a lock here. The issue is that we were able to make CheckpointCoordinator code that's executed in the mainThreadExecutor lock free, as mainThreadExecutor is single threaded. But we still need lock for IO operations executed in the io executor?", "author": "pnowojski", "createdAt": "2020-03-19T12:56:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java", "diffHunk": "@@ -111,6 +108,14 @@\n \t/** The executor for potentially blocking I/O operations, like state disposal. */\n \tprivate final Executor executor;\n \n+\t/** The executor for non-blocking operations. */\n+\tprivate final Executor mainThreadExecutor;\n+\n+\tprivate final CompletedCheckpointStore completedCheckpointStore;\n+\n+\t/** The lock for avoiding conflict between I/O operations. */\n+\tprivate final Object operationLock = new Object();", "originalCommit": "655adff5f2d9298b34b167b5a355f4b536613246", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTIyOA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395429228", "bodyText": "Yes, there is a small possibility that the CheckpointCoordinator is shut down when a PendingCheckpoint is doing finalization. There could be some concurrent conflicts on operatorStates and targetLocation. It might be not a big deal because it would be shut down anyway. The finalization probably could not finish because the IO executor would be also shut down. However it's not so elegant to leave the concurrent issue to the CheckpointStorageLocation and OperatorState. And it's a bit heavy to make all of these implementations thread-safe to avoid the small possibility issue. So here I think introducing a lock outside is better.", "author": "ifndef-SleePy", "createdAt": "2020-03-20T03:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwNDU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMDcyOA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395010728", "bodyText": "checkState?", "author": "pnowojski", "createdAt": "2020-03-19T13:07:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java", "diffHunk": "@@ -342,6 +354,12 @@ public CheckpointException getFailureCause() {\n \n \t\treturn finalizedLocationFuture.thenApplyAsync((completed) -> {\n \n+\t\t\tif (isDiscarded()) {\n+\t\t\t\t// since canceller has been already cancelled, the coordinator must be shut down\n+\t\t\t\t// all the resources should be released properly when it's shutting down the coordinator\n+\t\t\t\tthrow new IllegalStateException(\"The checkpoint has been discarded\");\n+\t\t\t}", "originalCommit": "655adff5f2d9298b34b167b5a355f4b536613246", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMjY0MA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395012640", "bodyText": "nit: some comments like L173 and L176 I think need to be updated, as there is no \"synchronized\" scope anymore but just single threaded?", "author": "pnowojski", "createdAt": "2020-03-19T13:10:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -91,9 +92,6 @@\n \n \t// ------------------------------------------------------------------------\n \n-\t/** Coordinator-wide lock to safeguard the checkpoint updates. */\n-\tprivate final Object lock = new Object();", "originalCommit": "655adff5f2d9298b34b167b5a355f4b536613246", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyOTQyMg==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395429422", "bodyText": "Sure, nice point!", "author": "ifndef-SleePy", "createdAt": "2020-03-20T03:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzE4Mg==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395017182", "bodyText": "It's not nice that this is not a final field, but I guess this would need large scope of changes, as there is the same issue in ExecutionGraph.\nHowever, why does it have to be @Nullable? ExecutionGraph#jobMasterMainThreadExecutor uses interesting trick with DummyComponentMainThreadExecutor. I'm not sure if doing instanceof checks is better or not, but maybe for the sake of consistency we should do the same here?", "author": "pnowojski", "createdAt": "2020-03-19T13:18:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java", "diffHunk": "@@ -151,6 +149,9 @@\n \t * It must be single-threaded. Eventually it will be replaced by main thread executor. */\n \tprivate final ScheduledExecutor timer;\n \n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor mainThreadExecutor;", "originalCommit": "655adff5f2d9298b34b167b5a355f4b536613246", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzMTA3OA==", "url": "https://github.com/apache/flink/pull/11347#discussion_r395431078", "bodyText": "Yes, it could not be a final variable based on current implementation of ExecutionGraph. I'm just not a fan of the trick of DummyComponentMainThreadExecutor. But I agree with you that it's not a bad idea to provide a consistent way with ExecutionGraph. Let me think of it a bit more. Maybe we could find a better solution.", "author": "ifndef-SleePy", "createdAt": "2020-03-20T04:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTc3Mg==", "url": "https://github.com/apache/flink/pull/11347#discussion_r396319772", "bodyText": "Sadly I didn't find an easy way. It involves too much for this. For now I use the DummyComponentMainThreadExecutor and mark it @Nonnull as you advised. But I think it's worth a separate ticket. I put it on my follow-up list.", "author": "ifndef-SleePy", "createdAt": "2020-03-23T09:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzE4Mg=="}], "type": "inlineReview"}, {"oid": "9f59db6be464318410e6ce165cb599233980b534", "url": "https://github.com/apache/flink/commit/9f59db6be464318410e6ce165cb599233980b534", "message": "[FLINK-14971][checkpointing] Remove lock of PendingCheckpoint and introduce IO lock for PendingCheckpoint\n\nSince all non-IO operations are executed in main thread, the lock of\nPendingCheckpoint could be avoided now.", "committedDate": "2020-03-23T09:11:38Z", "type": "forcePushed"}, {"oid": "9315f13bc6ee115572e95281074b60cb8a173f54", "url": "https://github.com/apache/flink/commit/9315f13bc6ee115572e95281074b60cb8a173f54", "message": "[FLINK-14971][checkpointing] Handle ack/declined message of checkpoint\nin timer thread", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "c859427bde1f1a7ec49626411842a61ccd976f79", "url": "https://github.com/apache/flink/commit/c859427bde1f1a7ec49626411842a61ccd976f79", "message": "[FLINK-14971][checkpointing] Introduce main thread executor in CheckpointCoordinator to execute all non-IO operations instead of the timer thread", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "497950ca0ce1dffc0195a770d4f8f4af6505ab23", "url": "https://github.com/apache/flink/commit/497950ca0ce1dffc0195a770d4f8f4af6505ab23", "message": "[hotfix] Harden ResumeCheckpointManuallyITCase\n\nThe way of detecting external checkpoint is done or not is not strict.\nThe finalization of checkpoint might be interrupted by the cancallation.", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "613934743add149140375d53509a941dec86d10a", "url": "https://github.com/apache/flink/commit/613934743add149140375d53509a941dec86d10a", "message": "[FLINK-14971][checkpointing] Make CompletedCheckpointStore thread-safe to avoid synchronization outside", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "6658babf12c6111ce12ac9a174c12b52234af95a", "url": "https://github.com/apache/flink/commit/6658babf12c6111ce12ac9a174c12b52234af95a", "message": "[FLINK-14971][checkpointing] Remove coordinator-wide lock of CheckpointCoordinator\n\nSince all non-IO operations are executed in main thread, the\ncoordinator-wide lock could be avoided now.", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "c48d0125ddfda31c4d4c9aede97af4e3c818a3d9", "url": "https://github.com/apache/flink/commit/c48d0125ddfda31c4d4c9aede97af4e3c818a3d9", "message": "[FLINK-14971][checkpointing] Remove lock of PendingCheckpoint and introduce IO lock for PendingCheckpoint\n\nSince all non-IO operations are executed in main thread, the lock of\nPendingCheckpoint could be avoided now.", "committedDate": "2020-03-23T09:31:28Z", "type": "commit"}, {"oid": "c48d0125ddfda31c4d4c9aede97af4e3c818a3d9", "url": "https://github.com/apache/flink/commit/c48d0125ddfda31c4d4c9aede97af4e3c818a3d9", "message": "[FLINK-14971][checkpointing] Remove lock of PendingCheckpoint and introduce IO lock for PendingCheckpoint\n\nSince all non-IO operations are executed in main thread, the lock of\nPendingCheckpoint could be avoided now.", "committedDate": "2020-03-23T09:31:28Z", "type": "forcePushed"}]}