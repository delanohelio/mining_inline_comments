{"pr_number": 7014, "pr_title": "Add support for watch collection watch streams", "pr_createdAt": "2020-08-03T08:15:50Z", "pr_url": "https://github.com/realm/realm-java/pull/7014", "timeline": [{"oid": "7f45044fc3c95d5cd92a21517072becf3ab7f110", "url": "https://github.com/realm/realm-java/commit/7f45044fc3c95d5cd92a21517072becf3ab7f110", "message": "Support collection watch synchronously", "committedDate": "2020-07-21T17:09:29Z", "type": "commit"}, {"oid": "fd0efe5b4787c8e8be64a341ad010cb959151184", "url": "https://github.com/realm/realm-java/commit/fd0efe5b4787c8e8be64a341ad010cb959151184", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsWatchStream.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-07-22T10:36:15Z", "type": "commit"}, {"oid": "c32124417cba73e2dfe2dc5025e9b6219fa2947c", "url": "https://github.com/realm/realm-java/commit/c32124417cba73e2dfe2dc5025e9b6219fa2947c", "message": "Update realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-07-22T10:52:58Z", "type": "commit"}, {"oid": "27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "url": "https://github.com/realm/realm-java/commit/27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "message": "Encapsulate access to stream functions\nAsync streams", "committedDate": "2020-07-24T11:20:19Z", "type": "commit"}, {"oid": "6c9b739364ba33d17e602bad0976fd41ad378d36", "url": "https://github.com/realm/realm-java/commit/6c9b739364ba33d17e602bad0976fd41ad378d36", "message": "Clean up", "committedDate": "2020-07-24T15:43:35Z", "type": "commit"}, {"oid": "fdee813124e25e03b57eee816ab5533955ed37cd", "url": "https://github.com/realm/realm-java/commit/fdee813124e25e03b57eee816ab5533955ed37cd", "message": "Introduce ChangeEvent class to handle events", "committedDate": "2020-07-24T18:56:35Z", "type": "commit"}, {"oid": "69d9a2b112ceb635d3146171c9277c5941fd1151", "url": "https://github.com/realm/realm-java/commit/69d9a2b112ceb635d3146171c9277c5941fd1151", "message": "Fix return type", "committedDate": "2020-07-28T07:44:07Z", "type": "commit"}, {"oid": "4becb098783519afbda7aacac8bf1bb76a417d8f", "url": "https://github.com/realm/realm-java/commit/4becb098783519afbda7aacac8bf1bb76a417d8f", "message": "Fix findbugs issues", "committedDate": "2020-07-28T09:02:22Z", "type": "commit"}, {"oid": "e7058c79084f09b256deba911632065d563a9111", "url": "https://github.com/realm/realm-java/commit/e7058c79084f09b256deba911632065d563a9111", "message": "Fix missing switch case", "committedDate": "2020-07-28T09:55:21Z", "type": "commit"}, {"oid": "b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "url": "https://github.com/realm/realm-java/commit/b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "message": "Catch http errors", "committedDate": "2020-07-28T10:42:59Z", "type": "commit"}, {"oid": "d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "url": "https://github.com/realm/realm-java/commit/d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "message": "Use busy wait instead of sleep", "committedDate": "2020-07-29T13:05:10Z", "type": "commit"}, {"oid": "f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "url": "https://github.com/realm/realm-java/commit/f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "message": "Rename events package", "committedDate": "2020-07-29T16:04:42Z", "type": "commit"}, {"oid": "f11fd233b53dda14e503e9ca1462e817a93503f2", "url": "https://github.com/realm/realm-java/commit/f11fd233b53dda14e503e9ca1462e817a93503f2", "message": "Fix class visibility", "committedDate": "2020-07-29T22:53:43Z", "type": "commit"}, {"oid": "b6746aec9188603355419d6259d8ef7e9c877cda", "url": "https://github.com/realm/realm-java/commit/b6746aec9188603355419d6259d8ef7e9c877cda", "message": "Improve documentation", "committedDate": "2020-07-30T08:22:08Z", "type": "commit"}, {"oid": "539d864acee367d2263437022e5cedc727c993d3", "url": "https://github.com/realm/realm-java/commit/539d864acee367d2263437022e5cedc727c993d3", "message": "Improve stream task thread naming", "committedDate": "2020-07-30T08:29:42Z", "type": "commit"}, {"oid": "b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "url": "https://github.com/realm/realm-java/commit/b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "message": "PR fixes", "committedDate": "2020-07-30T09:54:45Z", "type": "commit"}, {"oid": "217deac3ec18633a1ee15970c94cabfa35fcdfa8", "url": "https://github.com/realm/realm-java/commit/217deac3ec18633a1ee15970c94cabfa35fcdfa8", "message": "Fix nullpointer when closing okio buffers, as they are not being thread safe \ud83d\ude14", "committedDate": "2020-07-30T16:53:20Z", "type": "commit"}, {"oid": "30ac85113920d4b244c9702212ffdf8b94ca663f", "url": "https://github.com/realm/realm-java/commit/30ac85113920d4b244c9702212ffdf8b94ca663f", "message": "Clean up", "committedDate": "2020-07-31T11:48:37Z", "type": "commit"}, {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c", "url": "https://github.com/realm/realm-java/commit/f11d988aac149a5f946d3a87e14c57d89a09856c", "message": "Merge branch 'v10' into ct/RJAVA-611", "committedDate": "2020-07-31T13:21:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2OTE4Mw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464869183", "bodyText": "Is it really needed to do all of this advanced locking inside this method to test the behavior? I would think that just having called the sync method first would be enough?", "author": "cmelchior", "createdAt": "2020-08-04T07:57:10Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAwMDY4NQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465000685", "bodyText": "If we just call the sync method first we could ran into a race condition were the async function starts before the sync.\nThis mechanism guarantees that the execution is done in the right order.", "author": "clementetb", "createdAt": "2020-08-04T12:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2OTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2OTU3OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464869578", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "cmelchior", "createdAt": "2020-08-04T07:57:49Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()\n+                            asyncLoadedCondition.await()\n+\n+                            lock.unlock()\n+\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            thread {\n+                task.next\n+                looperThread.testComplete()\n+            }\n+\n+            syncLoadedCondition.await()\n+            lock.unlock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                if (result.isSuccess) {\n+                    fail()\n+                } else {\n+                    assertEquals(io.realm.mongodb.ErrorCode.RUNTIME_EXCEPTION, result.error.errorCode)\n+                }\n+\n+                asyncLoadedCondition.signal()\n+                lock.unlock()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                asyncLoadedCondition.signal()\n+                syncLoadedCondition.await()\n+\n+                lock.unlock()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            asyncLoadedCondition.await()\n+\n+            val exception = kotlin.test.assertFailsWith<RuntimeException> {\n+                task.next\n+            }\n+\n+            assertEquals(\"Resource already open\", exception.message)\n+\n+            syncLoadedCondition.signal()\n+            lock.unlock()\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+}", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MjYzNw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464872637", "bodyText": "Why the -1 ?", "author": "cmelchior", "createdAt": "2020-08-04T08:03:20Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAwNDMwOA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465004308", "bodyText": "Because the actual document contains an _id field, while the expected doesn't.\nI am adding a comment to explain it.", "author": "clementetb", "createdAt": "2020-08-04T12:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NDMzMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464874331", "bodyText": "Question: Do we think there is use cases for exposing a public method for this, either as a callback or some kind of wait method (waitUntilReady/waitForOpen/<cannotThinkOfAGoodName>)?", "author": "cmelchior", "createdAt": "2020-08-04T08:06:28Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                        assertNull(changeEvent.fullDocument)\n+                    }\n+\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMjY5OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465022698", "bodyText": "I cannot think on a case that would be useful. Whenever we request for a new event, no matter if sync or async, it will internally wait til open.", "author": "clementetb", "createdAt": "2020-08-04T12:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMjkwMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464902901", "bodyText": "Isn't there a race condition here? Shouldn't this thread wait for a lock we release after calling watcher.cancel() ?", "author": "cmelchior", "createdAt": "2020-08-04T08:55:28Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +885,386 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        assertEquals(expected.keys.size, actual.keys.size - 1)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                    }\n+\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                        assertNull(changeEvent.fullDocument)\n+                    }\n+\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(insertedDocument).get()\n+\n+                val filter = Document(\"watch\", \"1\")\n+                this.updateOne(filter, updatedDocument).get()\n+                this.deleteOne(filter).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamDocumentsFilterSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val type1 = Document(\"type\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val type2 = Document(\"type\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val filter = Document(\"fullDocument.type\", \"1\")\n+                val watcher = this.watchWithFilter(filter)\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                    }\n+\n+                    watcher.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(type2).get()\n+                this.insertOne(type1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamBsonDocumentFilterSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val type1 = Document(\"type\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val type2 = Document(\"type\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val filter = BsonDocument(\"fullDocument.type\", BsonString(\"1\"))\n+                val watcher = this.watchWithFilter(filter)\n+\n+                thread {\n+                    watcher.next.let { changeEvent ->\n+                        assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                    }\n+\n+                    watcher.cancel()\n+                    looperThread.testComplete()\n+\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(type2).get()\n+                this.insertOne(type1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamObjectIdsSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val doc1 = Document(\"document\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc2 = Document(\"document\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc1Id = this.insertOne(doc1).get()\n+                val doc2Id = this.insertOne(doc2).get()\n+\n+                val watcherObjectId = this.watch(doc1Id.insertedId.asObjectId().value)\n+\n+                thread {\n+                    watcherObjectId.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                    }\n+                    watcherObjectId.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcherObjectId.isOpen) {\n+                }\n+\n+                doc1.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                doc2.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                val filter1 = Document(\"_id\", doc1Id.insertedId)\n+                val filter2 = Document(\"_id\", doc2Id.insertedId)\n+\n+                this.updateOne(filter2, doc2).get()\n+                this.updateOne(filter1, doc1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamIdsSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val doc1 = Document(\"document\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc2 = Document(\"document\", \"2\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val doc1Id = this.insertOne(doc1).get()\n+                val doc2Id = this.insertOne(doc2).get()\n+\n+                val watcherBsonValue = this.watch(doc1Id.insertedId)\n+\n+                thread {\n+                    watcherBsonValue.next.let { changeEvent ->\n+                        assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                        assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                    }\n+\n+                    watcherBsonValue.cancel()\n+                    looperThread.testComplete()\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcherBsonValue.isOpen) {\n+                }\n+\n+                doc1.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                doc2.apply {\n+                    this[\"num\"] = 2\n+                }\n+\n+                val filter1 = Document(\"_id\", doc1Id.insertedId)\n+                val filter2 = Document(\"_id\", doc2Id.insertedId)\n+\n+                this.updateOne(filter2, doc2).get()\n+                this.updateOne(filter1, doc1).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamAsynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val insertedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 1\n+                        }\n+\n+                val updatedDocument = Document(\"watch\", \"1\")\n+                        .apply {\n+                            this[\"num\"] = 2\n+                        }\n+\n+\n+                val watcher = this.watch()\n+\n+                var eventCount = 0\n+                watcher.getAsync { it ->\n+                    if (it.isSuccess) {\n+                        it.get().let { changeEvent ->\n+                            when (eventCount) {\n+                                0 -> {\n+                                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                                    assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                                }\n+                                1 -> {\n+                                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                                    assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                                }\n+                                2 -> {\n+                                    assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                                    assertNull(changeEvent.fullDocument)\n+\n+                                    watcher.cancel()\n+                                }\n+                            }\n+                        }\n+\n+                        eventCount++\n+                    } else {\n+                        when (it.error.errorCode) {\n+                            ErrorCode.NETWORK_IO_EXCEPTION -> looperThread.testComplete()\n+                            else -> fail()\n+                        }\n+                        looperThread.testComplete()\n+                    }\n+                }\n+\n+                // Busy wait till watcher is ready to receive updates.\n+                // It syncs the event producer thread (current thread) with\n+                // the event consumer thread.\n+                while (!watcher.isOpen) {\n+                }\n+\n+                this.insertOne(insertedDocument).get()\n+\n+                val filter = Document(\"watch\", \"1\")\n+                this.updateOne(filter, updatedDocument).get()\n+                this.deleteOne(filter).get()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamCancelSynchronous() {\n+        looperThread.runBlocking {\n+            with(getCollectionInternal()) {\n+                val watcher = this.watch()\n+\n+                thread {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyNjA0Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465026047", "bodyText": "I don't see it \ud83d\ude2f! We are testing what happens when we cancel a watcher once it has been started:\n\nCreate watcher\nOn a new thread: Get next event\nWait for the watcher to initialize\nCancel the watcher (this will force the getNextEvent function to throw an exception)", "author": "clementetb", "createdAt": "2020-08-04T12:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMjkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTQxMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464911412", "bodyText": "We shouldn't look this up on every request. If you make it static it only happens once", "author": "cmelchior", "createdAt": "2020-08-04T09:10:18Z", "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -241,3 +242,60 @@ JNIEXPORT void JNICALL Java_io_realm_mongodb_App_nativeSwitchUser(JNIEnv* env,\n     CATCH_STD()\n }\n \n+JNIEXPORT jobject JNICALL Java_io_realm_mongodb_App_nativeMakeStreamingRequest(JNIEnv* env,\n+                                                                  jclass,\n+                                                                  jlong j_app_ptr,\n+                                                                  jlong j_user_ptr,\n+                                                                  jstring j_function_name,\n+                                                                  jstring j_bson_args,\n+                                                                  jstring j_service_name)\n+{\n+    try {\n+        auto app = *reinterpret_cast<std::shared_ptr<App>*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+\n+        JStringAccessor function_name(env, j_function_name);\n+        JStringAccessor service_name(env, j_service_name);\n+\n+        bson::BsonArray filter(JniBsonProtocol::parse_checked(env, j_bson_args, Bson::Type::Array, \"BSON filter must be an Array\"));\n+\n+        const Request &request = app->make_streaming_request(user, function_name, filter,\n+                                                             std::string(service_name));\n+\n+        jstring j_method;\n+\n+        switch (request.method){\n+            case HttpMethod::get:\n+                j_method = env->NewStringUTF(\"get\");\n+                break;\n+            case HttpMethod::post:\n+                j_method = env->NewStringUTF(\"post\");\n+                break;\n+            case HttpMethod::patch:\n+                j_method = env->NewStringUTF(\"patch\");\n+                break;\n+            case HttpMethod::put:\n+                j_method = env->NewStringUTF(\"put\");\n+                break;\n+            case HttpMethod::del:\n+                j_method = env->NewStringUTF(\"del\");\n+                break;\n+        }\n+\n+        jstring j_url = env->NewStringUTF(request.url.c_str());\n+        jobject j_headers = JniUtils::to_hashmap(env, request.headers);\n+        jstring j_body = env->NewStringUTF(request.body.c_str());\n+\n+        jclass request_class = env->FindClass(\"io/realm/internal/objectstore/OsJavaNetworkTransport$Request\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMTY0Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464911647", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:10:43Z", "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -241,3 +242,60 @@ JNIEXPORT void JNICALL Java_io_realm_mongodb_App_nativeSwitchUser(JNIEnv* env,\n     CATCH_STD()\n }\n \n+JNIEXPORT jobject JNICALL Java_io_realm_mongodb_App_nativeMakeStreamingRequest(JNIEnv* env,\n+                                                                  jclass,\n+                                                                  jlong j_app_ptr,\n+                                                                  jlong j_user_ptr,\n+                                                                  jstring j_function_name,\n+                                                                  jstring j_bson_args,\n+                                                                  jstring j_service_name)\n+{\n+    try {\n+        auto app = *reinterpret_cast<std::shared_ptr<App>*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+\n+        JStringAccessor function_name(env, j_function_name);\n+        JStringAccessor service_name(env, j_service_name);\n+\n+        bson::BsonArray filter(JniBsonProtocol::parse_checked(env, j_bson_args, Bson::Type::Array, \"BSON filter must be an Array\"));\n+\n+        const Request &request = app->make_streaming_request(user, function_name, filter,\n+                                                             std::string(service_name));\n+\n+        jstring j_method;\n+\n+        switch (request.method){\n+            case HttpMethod::get:\n+                j_method = env->NewStringUTF(\"get\");\n+                break;\n+            case HttpMethod::post:\n+                j_method = env->NewStringUTF(\"post\");\n+                break;\n+            case HttpMethod::patch:\n+                j_method = env->NewStringUTF(\"patch\");\n+                break;\n+            case HttpMethod::put:\n+                j_method = env->NewStringUTF(\"put\");\n+                break;\n+            case HttpMethod::del:\n+                j_method = env->NewStringUTF(\"del\");\n+                break;\n+        }\n+\n+        jstring j_url = env->NewStringUTF(request.url.c_str());\n+        jobject j_headers = JniUtils::to_hashmap(env, request.headers);\n+        jstring j_body = env->NewStringUTF(request.body.c_str());\n+\n+        jclass request_class = env->FindClass(\"io/realm/internal/objectstore/OsJavaNetworkTransport$Request\");\n+        jmethodID request_constructor = env->GetMethodID(request_class, \"<init>\",\"(Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;)V\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzE4Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913186", "bodyText": "Same as above. Looking up classes is expensive so should be minimized. If a class is used in multiple places we try to pre-load them all in java_class_global_def.hpp. Otherwise making the field static will make sure it is only initialized once.", "author": "cmelchior", "createdAt": "2020-08-04T09:13:30Z", "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzUyOQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913529", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:14:05Z", "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");\n+    jmethodID hash_map_constructor = env->GetMethodID(hash_map_class, \"<init>\", \"(I)V\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzU4Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913587", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:14:11Z", "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp", "diffHunk": "@@ -65,3 +66,26 @@ void JniUtils::keep_global_ref(JavaGlobalRefByMove& ref)\n     s_instance->m_global_refs.push_back(std::move(ref));\n }\n \n+jobject JniUtils::to_hashmap(JNIEnv* env, std::map<std::string, std::string> map)\n+{\n+    jclass hash_map_class= env->FindClass(\"java/util/HashMap\");\n+    jmethodID hash_map_constructor = env->GetMethodID(hash_map_class, \"<init>\", \"(I)V\");\n+    jobject hash_map = env->NewObject(hash_map_class, hash_map_constructor, (jint) map.size());\n+    jmethodID hasMapPut = env->GetMethodID(hash_map_class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMzkxMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464913911", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Transforms a string map into a string hashmap\n          \n          \n            \n                // Transforms a string map into a Java String HashMap", "author": "cmelchior", "createdAt": "2020-08-04T09:14:41Z", "path": "realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp", "diffHunk": "@@ -46,6 +47,8 @@ class JniUtils {\n     static void detach_current_thread();\n     // Keep the given global reference until JNI_OnUnload is called.\n     static void keep_global_ref(JavaGlobalRefByMove& ref);\n+    // Transforms a string map into a string hashmap", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjU4Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464916582", "bodyText": "With this implementation, you can still change between Async/Sync execution. I don't know if this was intended?\nE.g ... this would work:\nwatcher.getNext()\nwatcher.getAsync()\n\nIf intended, it should probably be named getNextAsync()? Alternatively, we set a mode boolean when calling either getNext/getAsync() and throw if the wrong get method is called. So you choose a mode when calling the first get method. Thoughts?", "author": "cmelchior", "createdAt": "2020-08-04T09:19:01Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamTaskImpl.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamTaskImpl<T> implements RealmEventStreamTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private final ReentrantLock lock;\n+\n+    public RealmEventStreamTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.lock = new ReentrantLock();\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    synchronized EventStream<T> getEventStream() throws IOException {\n+        if (eventStream == null) {\n+            eventStream = executor.run();\n+        }\n+\n+        return this.eventStream;\n+    }\n+\n+    @Override\n+    public BaseChangeEvent<T> getNext() throws IOException {\n+        if (lock.tryLock()) {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDA0Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464924042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "cmelchior", "createdAt": "2020-08-04T09:32:02Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import junit.framework.Assert.fail\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.util.concurrent.locks.ReentrantLock\n+import kotlin.concurrent.thread\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun syncExclusiveAccess() {\n+        // Validates that we cannot access asynchronously if we are already\n+        // accessing the stream synchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            lock.lock()\n+\n+                            syncLoadedCondition.signal()\n+                            asyncLoadedCondition.await()\n+\n+                            lock.unlock()\n+\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            thread {\n+                task.next\n+                looperThread.testComplete()\n+            }\n+\n+            syncLoadedCondition.await()\n+            lock.unlock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                if (result.isSuccess) {\n+                    fail()\n+                } else {\n+                    assertEquals(io.realm.mongodb.ErrorCode.RUNTIME_EXCEPTION, result.error.errorCode)\n+                }\n+\n+                asyncLoadedCondition.signal()\n+                lock.unlock()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        looperThread.runBlocking {\n+            val lock = ReentrantLock()\n+\n+            val syncLoadedCondition = lock.newCondition()\n+            val asyncLoadedCondition = lock.newCondition()\n+\n+            val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+                override fun run(): EventStream<String> {\n+                    return object : EventStream<String> {\n+                        var opened: Boolean = true\n+\n+                        override fun getNextEvent(): BaseChangeEvent<String>? {\n+                            return null\n+                        }\n+\n+                        override fun close() {\n+                            opened = false\n+                        }\n+\n+                        override fun isOpen(): Boolean {\n+                            return opened\n+                        }\n+                    }\n+                }\n+            })\n+\n+            lock.lock()\n+\n+            task.getAsync { result ->\n+                lock.lock()\n+\n+                asyncLoadedCondition.signal()\n+                syncLoadedCondition.await()\n+\n+                lock.unlock()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            asyncLoadedCondition.await()\n+\n+            val exception = kotlin.test.assertFailsWith<RuntimeException> {\n+                task.next\n+            }\n+\n+            assertEquals(\"Resource already open\", exception.message)\n+\n+            syncLoadedCondition.signal()\n+            lock.unlock()\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+}", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464924915", "bodyText": "There are a lot of magic constants here. Is there a spec or something we can refer to for the source of truth for these?", "author": "cmelchior", "createdAt": "2020-08-04T09:33:33Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NTM4NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474465384", "bodyText": "This hasn't been addressed.", "author": "cmelchior", "createdAt": "2020-08-21T07:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3MDAxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474570016", "bodyText": "Added a link to the realm change events spec:\nhttps://docs.mongodb.com/realm/triggers/database-triggers/index.html#database-change-events", "author": "clementetb", "createdAt": "2020-08-21T09:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjkyNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464926924", "bodyText": "Can we forward the underlying http exception message instead? Sometimes the server sends useful information there. \"Http error code considered fatal\" doesn't really provide anything useful.", "author": "cmelchior", "createdAt": "2020-08-04T09:37:04Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -31,47 +34,82 @@ public OkHttpNetworkTransport(@Nullable HttpLogObfuscator httpLogObfuscator) {\n         this.httpLogObfuscator = httpLogObfuscator;\n     }\n \n+    private okhttp3.Request makeRequest(String method, String url, Map<String, String> headers, String body){\n+        okhttp3.Request.Builder builder = new okhttp3.Request.Builder().url(url);\n+        switch (method) {\n+            case \"get\":\n+                builder.get();\n+                break;\n+            case \"delete\":\n+                builder.delete(RequestBody.create(JSON, body));\n+                break;\n+            case \"patch\":\n+                builder.patch(RequestBody.create(JSON, body));\n+                break;\n+            case \"post\":\n+                builder.post(RequestBody.create(JSON, body));\n+                break;\n+            case \"put\":\n+                builder.put(RequestBody.create(JSON, body));\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown method type: \" + method);\n+        }\n+\n+        for (Map.Entry<String, String> entry : headers.entrySet()) {\n+            builder.addHeader(entry.getKey(), entry.getValue());\n+        }\n+\n+        return builder.build();\n+    }\n+\n     @Override\n     public Response sendRequest(String method, String url, long timeoutMs, Map<String, String> headers, String body) {\n         try {\n             OkHttpClient client = getClient(timeoutMs);\n+\n             okhttp3.Response response = null;\n             try {\n-                Request.Builder builder = new Request.Builder().url(url);\n-                switch(method) {\n-                    case \"get\": builder.get(); break;\n-                    case \"delete\": builder.delete(RequestBody.create(JSON, body)); break;\n-                    case \"patch\": builder.patch(RequestBody.create(JSON, body)); break;\n-                    case \"post\": builder.post(RequestBody.create(JSON, body)); break;\n-                    case \"put\": builder.put(RequestBody.create(JSON, body)); break;\n-                    default: throw new IllegalArgumentException(\"Unknown method type: \"+ method);\n-                }\n+                okhttp3.Request request = makeRequest(method, url, headers, body);\n \n-                for (Map.Entry<String, String> entry : headers.entrySet()) {\n-                    builder.addHeader(entry.getKey(), entry.getValue());\n-                }\n-                Call call = client.newCall(builder.build());\n+                Call call = client.newCall(request);\n                 response = call.execute();\n                 ResponseBody responseBody = response.body();\n                 String result = \"\";\n                 if (responseBody != null) {\n                     result = responseBody.string();\n                 }\n-                return Response.httpResponse(response.code(), parseHeaders(response.headers()), result);\n+                return OkHttpResponse.httpResponse(response.code(), parseHeaders(response.headers()), result);\n             } catch (IOException ex) {\n-                return Response.ioError(ex.toString());\n+                return OkHttpResponse.ioError(ex.toString());\n             } catch (Exception ex) {\n-                return Response.unknownError(ex.toString());\n+                return OkHttpResponse.unknownError(ex.toString());\n             } finally {\n                 if (response != null) {\n                     response.close();\n                 }\n             }\n         } catch (Exception e) {\n-            return Response.unknownError(e.toString());\n+            return OkHttpResponse.unknownError(e.toString());\n         }\n     }\n \n+    @Override\n+    public Response sendStreamingRequest(Request request) throws IOException, AppException {\n+        OkHttpClient client = getStreamClient();\n+\n+        okhttp3.Request okRequest = makeRequest(request.getMethod(), request.getUrl(), request.getHeaders(), request.getBody());\n+\n+        Call call = client.newCall(okRequest);\n+        okhttp3.Response response = call.execute();\n+\n+        if((response.code() >= 300) || ((response.code() < 200) && (response.code() != 0))) {\n+            throw new AppException(ErrorCode.fromNativeError(ErrorCode.Type.HTTP, response.code()), \"http error code considered fatal\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNTkyMw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474615923", "bodyText": "I was following the pattern in app_utils.hpp.", "author": "clementetb", "createdAt": "2020-08-21T10:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNzgxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464927816", "bodyText": "It feels a bit awkward and duplicates meaning to have this class named OkHttpResponse since it is already wrapped inside OkHttpNetworkTransport, so it becomes OkHttpNetworkTransport.OkHttpResponse ... OkHttpNetworkTransport.Response seems more readable.", "author": "cmelchior", "createdAt": "2020-08-04T09:38:34Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -90,14 +128,87 @@ private synchronized OkHttpClient getClient(long timeoutMs) {\n         return client;\n     }\n \n+    private synchronized OkHttpClient getStreamClient() {\n+        if (streamClient == null) {\n+            streamClient = new OkHttpClient.Builder()\n+                    .readTimeout(0, TimeUnit.MILLISECONDS)\n+                    .followRedirects(true)\n+                    .addInterceptor(new LoggingInterceptor(httpLogObfuscator))\n+                    .build();\n+        }\n+\n+        return streamClient;\n+    }\n+\n     // Parse Headers output from OKHttp to the format expected by ObjectStore\n     private Map<String, String> parseHeaders(Headers headers) {\n-        HashMap<String, String> osHeaders = new HashMap<>(headers.size()/2);\n+        HashMap<String, String> osHeaders = new HashMap<>(headers.size() / 2);\n         for (String key : headers.names()) {\n             osHeaders.put(key, headers.get(key));\n         }\n         return osHeaders;\n     }\n \n+    public static class OkHttpResponse extends OsJavaNetworkTransport.Response {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNjcxNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474616714", "bodyText": "much better!", "author": "clementetb", "createdAt": "2020-08-21T10:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTM4Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464931386", "bodyText": "Not 100% sure why this is in the App class even when package protected? It feels a bit out of place?", "author": "cmelchior", "createdAt": "2020-08-04T09:44:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/App.java", "diffHunk": "@@ -511,16 +514,34 @@ public AppConfiguration getConfiguration() {\n     }\n \n     /**\n-     * Exposed for testing.\n+     * Creates a request for a streaming function\n      *\n+     * @param user         that requests the execution\n+     * @param functionName name of the function\n+     * @param bsonArgs     function arguments as a {@link BsonArray}\n+     * @param serviceName  service that will handle the function\n+     * @return {@link io.realm.internal.objectstore.OsJavaNetworkTransport.Request}\n+     */\n+    OsJavaNetworkTransport.Request makeStreamingRequest(User user,", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMTkyNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465031926", "bodyText": "I placed makeStreamingRequest there because it is an actual method of the obj-store app class. I thought it was the right pattern to reflect native methods on Java.", "author": "clementetb", "createdAt": "2020-08-04T13:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMjkwOA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464932908", "bodyText": "Having this being public makes it part of the public API, which is probably a mistake?", "author": "cmelchior", "createdAt": "2020-08-04T09:47:26Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/StreamNetworkTransportImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import org.bson.BsonArray;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.network.StreamNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+public class StreamNetworkTransportImpl extends StreamNetworkTransport {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzU0NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933544", "bodyText": "These should probably be wrapped in <a href ... tags to render correctly?", "author": "cmelchior", "createdAt": "2020-08-04T09:48:36Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDgwMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465150801", "bodyText": "Yes, it needs the  tag!", "author": "clementetb", "createdAt": "2020-08-04T15:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzYxMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933612", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:48:43Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzY2OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933669", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:48:51Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf9653563af30491ecdeacc1ce04663c627916ac", "url": "https://github.com/realm/realm-java/commit/bf9653563af30491ecdeacc1ce04663c627916ac", "message": "Implement PR requests", "committedDate": "2020-08-10T17:00:57Z", "type": "commit"}, {"oid": "825c53fb171aff79a15bbcbcc5b712d7717df56a", "url": "https://github.com/realm/realm-java/commit/825c53fb171aff79a15bbcbcc5b712d7717df56a", "message": "Remove any stream internal functionality from the public API", "committedDate": "2020-08-11T10:26:56Z", "type": "commit"}, {"oid": "00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "url": "https://github.com/realm/realm-java/commit/00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "message": "Update changelog", "committedDate": "2020-08-11T11:23:52Z", "type": "commit"}, {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "url": "https://github.com/realm/realm-java/commit/159bcadff210c5d0cc68440e2d5cee9d563173a6", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-11T19:39:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NDU1OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469044559", "bodyText": "Unused import?", "author": "rorbech", "createdAt": "2020-08-12T06:56:42Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/UserTests.kt", "diffHunk": "@@ -13,15 +13,16 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.realm\n+package io.realm.mongodb\n \n import androidx.test.ext.junit.runners.AndroidJUnit4\n import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.*\n import io.realm.admin.ServerAdmin\n-import io.realm.mongodb.*\n import io.realm.mongodb.auth.ApiKeyAuth\n import io.realm.mongodb.auth.UserApiKey\n import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonArray", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMzI5MA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469133290", "bodyText": "I have set imports auto clean on now", "author": "clementetb", "createdAt": "2020-08-12T09:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NDU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NzUwNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469047504", "bodyText": "Unused include?", "author": "rorbech", "createdAt": "2020-08-12T07:03:24Z", "path": "realm/realm-library/src/main/cpp/io_realm_mongodb_App.cpp", "diffHunk": "@@ -24,6 +24,7 @@\n #include <binding_callback_thread_observer.hpp>\n #include <sync/app.hpp>\n #include <sync/sync_manager.hpp>\n+#include <jni_util/bson_util.hpp>", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjg3MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469132871", "bodyText": "How did you noticed?", "author": "clementetb", "createdAt": "2020-08-12T09:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDg4Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469134882", "bodyText": "It just seemed like there were no changes that used it, so thought it was left over from intermediate changes. But might be required somewhere.", "author": "rorbech", "createdAt": "2020-08-12T09:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MDY5NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469050694", "bodyText": "Maybe just Unknown key: %s", "author": "rorbech", "createdAt": "2020-08-12T07:10:21Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {\n+        if (!map.containsKey(key)) {\n+            throw new IllegalStateException(\n+                    String.format(\"expected %s to be present\", key));", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDMxMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469134310", "bodyText": "I copied the code directly from stitch and didnt realize the phrasing", "author": "clementetb", "createdAt": "2020-08-12T09:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTQ1Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051457", "bodyText": "Funny phrasing.", "author": "rorbech", "createdAt": "2020-08-12T07:11:55Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTYwOQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051609", "bodyText": "Does not match exception thrown.", "author": "rorbech", "createdAt": "2020-08-12T07:12:12Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzgwMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469053800", "bodyText": "Following naming from other check functions would give an immediate impression that this is actually throwing an exception if key is not present.", "author": "rorbech", "createdAt": "2020-08-12T07:16:36Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMzk4NQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474523985", "bodyText": "Great! Much better", "author": "clementetb", "createdAt": "2020-08-21T08:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY0Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469057647", "bodyText": "Is this semantically correct?", "author": "rorbech", "createdAt": "2020-08-12T07:24:08Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmResultTaskImpl.java", "diffHunk": "@@ -122,6 +122,7 @@ private void postError(RealmNotifier handler,\n             public void run() {\n                 if (!isCancelled) {\n                     callback.onResult(App.Result.withError(error));\n+                    isCancelled = true;", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMjk1Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474532957", "bodyText": "No. I forgot to remove it.", "author": "clementetb", "createdAt": "2020-08-21T08:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTA2OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469059068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return the serialized document.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @return the serialized document.", "author": "rorbech", "createdAt": "2020-08-12T07:27:01Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469060091", "bodyText": "Use local variables for something that is retrieved multiple times.", "author": "rorbech", "createdAt": "2020-08-12T07:28:58Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NDc1Mw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474464753", "bodyText": "This hasn't been addressed", "author": "cmelchior", "createdAt": "2020-08-21T07:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MTMxNQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469061315", "bodyText": "Maybe considering a specific stream related error code when protocol is not met in ErrorCodes.java instead of propagating the InvalidStateException?", "author": "rorbech", "createdAt": "2020-08-12T07:31:16Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NTY3OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474555679", "bodyText": "much better \ud83d\udc4c\ud83d\udc4c", "author": "clementetb", "createdAt": "2020-08-21T09:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTgwNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065806", "bodyText": "Only taking CRUD operations into account. Are the invalidate events not to be considered at our level?", "author": "rorbech", "createdAt": "2020-08-12T07:39:48Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NzQyNw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474557427", "bodyText": "They are not: https://docs.mongodb.com/realm/triggers/database-triggers/index.html", "author": "clementetb", "createdAt": "2020-08-21T09:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTkzMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065932", "bodyText": "Same as above", "author": "rorbech", "createdAt": "2020-08-12T07:39:58Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {\n+        switch (type) {\n+            case \"insert\":\n+                return INSERT;\n+            case \"delete\":\n+                return DELETE;\n+            case \"replace\":\n+                return REPLACE;\n+            case \"update\":\n+                return UPDATE;\n+            default:\n+                return UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Converts this operation to the remote string representation of the operation as\n+     * represented in a {@link ChangeEvent} from a remote cluster.\n+     *\n+     * @return the remote representation of the update operation.\n+     */\n+    private String toRemote(OperationType operationType) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2OTY4MA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469069680", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Fetch the next event from a given stream\n          \n          \n            \n                 * Fetch the next event from a given stream.", "author": "rorbech", "createdAt": "2020-08-12T07:46:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectserver;\n+\n+import java.io.IOException;\n+\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public interface EventStream<T> {\n+    /**\n+     * Fetch the next event from a given stream", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3MjQyMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469072422", "bodyText": "Maybe we should consider using the codec registry to allow automatic conversion from all sorts of arguments. This could also collapse the method with the below. See the Functions.callFunction implementation for details.", "author": "rorbech", "createdAt": "2020-08-12T07:51:54Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -525,34 +550,93 @@ protected ResultT mapSuccess(Object result) {\n         }\n     }\n \n+    private EventStream<DocumentT> watchInternal(int type, @Nullable BsonArray ids, @Nullable BsonDocument matchFilter) throws IOException {\n+        BsonArray args = new BsonArray();\n+        BsonDocument watchArgs = new BsonDocument(\"database\", new BsonString(namespace.getDatabaseName()));\n+        args.add(watchArgs);\n+\n+        watchArgs.put(\"collection\", new BsonString(namespace.getCollectionName()));\n+\n+        switch (type) {\n+            case WATCH:\n+                break;\n+            case WATCH_IDS:\n+                watchArgs.put(\"ids\", ids);\n+                break;\n+            case WATCH_WITH_FILTER:\n+                watchArgs.put(\"filter\", matchFilter);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid watch type: \" + type);\n+        }\n+\n+        OsJavaNetworkTransport.Request request = streamNetworkTransport.makeStreamingRequest(\"watch\", args, serviceName);\n+        OsJavaNetworkTransport.Response response = streamNetworkTransport.sendRequest(request);\n+\n+        return new NetworkEventStream<>(response, codecRegistry, documentClass);\n+    }\n+\n+    public EventStream<DocumentT> watch() throws IOException {\n+        return watchInternal(WATCH, null, null);\n+    }\n+\n+    public EventStream<DocumentT> watch(final BsonValue... ids) throws IOException {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469075568", "bodyText": "Seems a bit general!?", "author": "rorbech", "createdAt": "2020-08-12T07:57:35Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/ErrorCode.java", "diffHunk": "@@ -47,6 +47,8 @@\n     BSON_CODEC_NOT_FOUND(Type.JAVA, 1100),\n     BSON_ENCODING(Type.JAVA, 1101),\n     BSON_DECODING(Type.JAVA, 1102),\n+    // Java errors\n+    RUNTIME_EXCEPTION(Type.JAVA, 1200),", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NTE1Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469145152", "bodyText": "It helps to catch generic errors as in RealmEventStreamAsyncTaskImpl.java", "author": "clementetb", "createdAt": "2020-08-12T09:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MTY1Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469151656", "bodyText": "As suggested elsewhere it would might be an idea to segment it to indicate a stream protocol error or similar, to make it a bit clearer to reason about", "author": "rorbech", "createdAt": "2020-08-12T10:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3Njc1MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469076751", "bodyText": "Maybe use codec registry to allow automatic argument conversion as in Functions.callFunction. Would allow collapsing this with the below method.", "author": "rorbech", "createdAt": "2020-08-12T07:59:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzU2Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469077562", "bodyText": "Same as previous with automatic argument conversion.", "author": "rorbech", "createdAt": "2020-08-12T08:01:18Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(BsonDocument matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection asynchronously. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync() {\n+        return new RealmEventStreamAsyncTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamAsyncTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection asynchronously.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync(final BsonValue... ids) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NjcxMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469086710", "bodyText": "We should probably guard this catching all non IOExceptions too and emit them as some other error to prevents accidential crashes.", "author": "rorbech", "createdAt": "2020-08-12T08:18:30Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));\n+                        }\n+                    } catch (IOException exception) {\n+                        callback.onResult(App.Result.withError(new AppException(ErrorCode.NETWORK_IO_EXCEPTION, exception)));\n+                    }\n+                }", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469088856", "bodyText": "@cmelchior Do we have a convention about logging and swallowing user exceptions? Seen it somewhere, but maybe it is preferable that users gets the attention?", "author": "rorbech", "createdAt": "2020-08-12T08:22:09Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NDc4Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469144787", "bodyText": "I found this one:\nRealmLog.error(exception);\nWhat is the log policy, shall we log all errors? For example, shall we log the IOExceptions in RealmEventStreamAsyncTaskImpl.java too?", "author": "clementetb", "createdAt": "2020-08-12T09:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NjAxMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469156011", "bodyText": "Normally we try to surface crashes to users instead of catching them. There is one noticeable, namely callbacks called from JNI and run in Java.\nIf there is a Java exception inside those, they don't necessarily crash the JNI code, that only happens if it touches JNIEnv, and then the stack trace you get can look really strange. So for those cases, we do attempt to catch all Java exceptions and either convert them to something that JNI understands or log them and attempt to stop the event flow as quickly as possible. But is very tricky and I wouldn't be surprised if we forgot to do that in some places.", "author": "cmelchior", "createdAt": "2020-08-12T10:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NjYxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469156616", "bodyText": "But for the App Request API, we do have a way to roundtrip errors, so in that case we shouldn't log them, since an AppException is thrown as quickly as possible.", "author": "cmelchior", "createdAt": "2020-08-12T10:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMTgyNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r471521826", "bodyText": "I wasn't using the exception generated by the watch stream. The error handling has makes more sense now that I have included support for such exceptions.", "author": "clementetb", "createdAt": "2020-08-17T14:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}], "type": "inlineReview"}, {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "url": "https://github.com/realm/realm-java/commit/35d396751a2ffcb93bf926d79c6b54b53454ff6b", "message": "Implements PR CR and fixes merge issues", "committedDate": "2020-08-12T10:03:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODY4Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r470638686", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        doc1.apply {\n          \n          \n            \n                            this[\"num\"] = 2\n          \n          \n            \n                        }\n          \n          \n            \n                        doc1[\"num\"] = 2", "author": "rorbech", "createdAt": "2020-08-14T13:55:35Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +882,392 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {\n+        // Accounts for the missing _id field in the expected document\n+        assertTrue {\n+            actual.remove(\"_id\") != null\n+        }\n+\n+        assertEquals(expected.keys.size, actual.keys.size)\n+\n+        for (key in expected.keys) {\n+            assertTrue(actual.keys.contains(key))\n+            assertEquals(expected[key], actual[key])\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamSynchronous() {\n+        with(getCollectionInternal()) {\n+            val insertedDocument = Document(\"watch\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val updatedDocument = Document(\"watch\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 2\n+                    }\n+\n+\n+            val watcher = this.watch()\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertDocumentEquals(insertedDocument, changeEvent.fullDocument!!)\n+                }\n+\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                    assertDocumentEquals(updatedDocument, changeEvent.fullDocument!!)\n+                }\n+\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.DELETE, changeEvent.operationType)\n+                    assertNull(changeEvent.fullDocument)\n+                }\n+\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(insertedDocument).get()\n+\n+            val filter = Document(\"watch\", \"1\")\n+            this.updateOne(filter, updatedDocument).get()\n+            this.deleteOne(filter).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamDocumentsFilterSynchronous() {\n+        with(getCollectionInternal()) {\n+            val type1 = Document(\"type\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val type2 = Document(\"type\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val filter = Document(\"fullDocument.type\", \"1\")\n+            val watcher = this.watchWithFilter(filter)\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                }\n+\n+                watcher.cancel()\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(type2).get()\n+            this.insertOne(type1).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamBsonDocumentFilterSynchronous() {\n+        with(getCollectionInternal()) {\n+            val type1 = Document(\"type\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val type2 = Document(\"type\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val filter = BsonDocument(\"fullDocument.type\", BsonString(\"1\"))\n+            val watcher = this.watchWithFilter(filter)\n+\n+            val condition = looperThread.runDetached {\n+                watcher.next.let { changeEvent ->\n+                    assertEquals(OperationType.INSERT, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"type\"])\n+                }\n+\n+                watcher.cancel()\n+                looperThread.testComplete()\n+\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcher.isOpen) {\n+            }\n+\n+            this.insertOne(type2).get()\n+            this.insertOne(type1).get()\n+\n+            condition?.await()\n+        }\n+    }\n+\n+    @Test\n+    fun watchStreamObjectIdsSynchronous() {\n+        with(getCollectionInternal()) {\n+            val doc1 = Document(\"document\", \"1\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val doc2 = Document(\"document\", \"2\")\n+                    .apply {\n+                        this[\"num\"] = 1\n+                    }\n+\n+            val doc1Id = this.insertOne(doc1).get()\n+            val doc2Id = this.insertOne(doc2).get()\n+\n+            val watcherObjectId = this.watch(doc1Id.insertedId.asObjectId().value)\n+\n+            val condition = looperThread.runDetached {\n+                watcherObjectId.next.let { changeEvent ->\n+                    assertEquals(OperationType.REPLACE, changeEvent.operationType)\n+                    assertEquals(\"1\", changeEvent.fullDocument!![\"document\"])\n+                }\n+                watcherObjectId.cancel()\n+\n+                looperThread.testComplete()\n+            }\n+\n+            // Busy wait till watcher is ready to receive updates.\n+            // It syncs the event producer thread (current thread) with\n+            // the event consumer thread.\n+            while (!watcherObjectId.isOpen) {\n+            }\n+\n+            doc1.apply {\n+                this[\"num\"] = 2\n+            }", "originalCommit": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4NTA3Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r471285072", "bodyText": "This code follows the MongoClientTest style on how to modify documents, see for example findOneAndDelete_withProjectionAndSort\nShall we modify the rest of the test cases?", "author": "clementetb", "createdAt": "2020-08-17T07:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY0MDI3OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r470640279", "bodyText": "Multiple sequential calls to watchStream.getState(). If it is not changing in between then use a local variable.", "author": "rorbech", "createdAt": "2020-08-14T13:58:16Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/NetworkEventStream.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.realm.internal.events;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.internal.objectstore.OsWatchStream;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class NetworkEventStream<T> implements EventStream<T> {\n+    private final OsJavaNetworkTransport.Response response;\n+    private final OsWatchStream<T> watchStream;\n+    private final CodecRegistry codecRegistry;\n+    private final Class<T> documentClass;\n+\n+    public NetworkEventStream(OsJavaNetworkTransport.Response response, CodecRegistry codecRegistry, Class<T> documentClass) {\n+        this.response = response;\n+        this.watchStream = new OsWatchStream<>(codecRegistry);\n+        this.codecRegistry = codecRegistry;\n+        this.documentClass = documentClass;\n+    }\n+\n+    /**\n+     * Fetch the next event from a given stream\n+     *\n+     * @return the next event\n+     * @throws IOException any io exception that could occur\n+     */\n+    @Override\n+    public BaseChangeEvent<T> getNextEvent() throws IOException {\n+        String line;\n+\n+        while ((((line = response.readBodyLine())) != null)) {\n+            watchStream.feedLine(line);\n+\n+            if (watchStream.getState().equals(OsWatchStream.HAVE_EVENT))", "originalCommit": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "url": "https://github.com/realm/realm-java/commit/1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "message": "Implement PR changes\nBetter error handling\nAutomatic argument conversion", "committedDate": "2020-08-17T14:28:56Z", "type": "commit"}, {"oid": "94ff30d870892a57b434794f30d42d621bccbe88", "url": "https://github.com/realm/realm-java/commit/94ff30d870892a57b434794f30d42d621bccbe88", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-17T14:30:43Z", "type": "commit"}, {"oid": "703c55ef368348544436843b24aad0c382cb501b", "url": "https://github.com/realm/realm-java/commit/703c55ef368348544436843b24aad0c382cb501b", "message": "Split App class following the object store pattern (#7038)", "committedDate": "2020-08-18T13:19:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3NzkxNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r472777914", "bodyText": "This needs to go into the 10.0.7 section instead", "author": "rorbech", "createdAt": "2020-08-19T06:57:01Z", "path": "CHANGELOG.md", "diffHunk": "@@ -13,6 +13,7 @@ The old Realm Cloud legacy APIs have undergone significant refactoring. The new\n * RealmLists can now be marked final. (Issue [#6892](https://github.com/realm/realm-java/issues/6892))\n * It is now possible to create embedded objects using [DynamicRealm]s. (Issue [#6982](https://github.com/realm/realm-java/pull/6982))\n * Added extra validation and more meaningful error messages when creating embedded objects pointing to the wrong parent property. (See issue above)\n+* Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "originalCommit": "703c55ef368348544436843b24aad0c382cb501b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDg0MA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r472910840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                fun assertDocumentEquals(expected: Document, actual: Document) {\n          \n          \n            \n                private fun assertDocumentEquals(expected: Document, actual: Document) {", "author": "edualonso", "createdAt": "2020-08-19T09:59:52Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt", "diffHunk": "@@ -876,6 +882,391 @@ class MongoClientTest {\n         }\n     }\n \n+    fun assertDocumentEquals(expected: Document, actual: Document) {", "originalCommit": "703c55ef368348544436843b24aad0c382cb501b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "148da00538fe087a0ec5fa003fde0ac9fcfc792a", "url": "https://github.com/realm/realm-java/commit/148da00538fe087a0ec5fa003fde0ac9fcfc792a", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-08-20T08:59:51Z", "type": "commit"}, {"oid": "d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "url": "https://github.com/realm/realm-java/commit/d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-20T19:35:11Z", "type": "commit"}, {"oid": "ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "url": "https://github.com/realm/realm-java/commit/ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "message": "Update changelog in the right build version", "committedDate": "2020-08-20T19:39:23Z", "type": "commit"}, {"oid": "3ff3de792890950b38dc52a029aa696026a34144", "url": "https://github.com/realm/realm-java/commit/3ff3de792890950b38dc52a029aa696026a34144", "message": "Add missing space", "committedDate": "2020-08-20T19:46:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0Njk0MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474446941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))\n          \n          \n            \n            * Support for watching MongoCollection change streams (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "author": "cmelchior", "createdAt": "2020-08-21T07:00:51Z", "path": "CHANGELOG.md", "diffHunk": "@@ -1,3 +1,25 @@\n+## 10.0.0-BETA.7 (YYYY-MM-DD)\n+\n+We no longer support Realm Cloud (legacy), but instead the new MongoDB Realm Cloud. MongoDB Realm is a serverless platform that enables developers to quickly build applications without having to set up server infrastructure. MongoDB Realm is built on top of MongoDB Atlas, automatically integrating the connection to your database.\n+\n+The old Realm Cloud legacy APIs have undergone significant refactoring. The new APIs are all located in the `io.realm.mongodb` package with `io.realm.mongodb.App` as the entry point.\n+\n+### Breaking Changes \n+* None\n+\n+### Enhancements\n+* Add support for watching change streams to MongoCollection (Issue [#6912](https://github.com/realm/realm-java/issues/6912))", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NzUyNQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474447525", "bodyText": "Nice \ud83d\udcaf", "author": "cmelchior", "createdAt": "2020-08-21T07:01:39Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/rule/BlockingLooperThread.kt", "diffHunk": "@@ -88,7 +89,14 @@ class BlockingLooperThread {\n      * Runs the test on a Looper thread\n      */\n     fun runBlocking(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit) {\n-        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate()\n+        RunInLooperThreadStatement(threadName, emulateMainThread, test).evaluate(false)\n+    }\n+\n+    /**\n+     * Runs the test on a Looper thread. Returns an object that can be used to wait for the test to complete\n+     */\n+    fun runDetached(threadName: String = \"TestLooperThread\", emulateMainThread: Boolean = false, test: () -> Unit): Condition? {", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2MDA3OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474460078", "bodyText": "But why is the return value Condition?. It always returns the condition and it would clean up some ? used in the test code.", "author": "cmelchior", "createdAt": "2020-08-21T07:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NzUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYyMTkwMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474621900", "bodyText": "It is because runDetached and runBlocking shared the same functions. I have split them in two different function sets, improves readability and forces return non null values for runDetached.", "author": "clementetb", "createdAt": "2020-08-21T10:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2MDI2OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474460268", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "cmelchior", "createdAt": "2020-08-21T07:18:08Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.internal.objectserver.EventStream\n+import io.realm.mongodb.mongo.events.BaseChangeEvent\n+import io.realm.rule.BlockingLooperThread\n+import junit.framework.Assert.assertEquals\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+import kotlin.test.assertFailsWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmStreamTaskImplTest {\n+    private val looperThread = BlockingLooperThread()\n+\n+    @Test\n+    fun asyncExclusiveAccess() {\n+        // Validates that we cannot access synchronously if we are already\n+        // accessing the stream asynchronously.\n+\n+        val task = RealmEventStreamAsyncTaskImpl(\"test\", object : RealmEventStreamAsyncTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = true\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        task.get { }\n+\n+        assertFailsWith<IllegalStateException> {\n+            task.get { }\n+        }\n+    }\n+\n+    @Test\n+    fun openClose() {\n+        val task = RealmEventStreamTaskImpl(\"test\", object : RealmEventStreamTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.next\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+\n+    @Test\n+    fun openCloseAsync() {\n+        val task = RealmEventStreamAsyncTaskImpl(\"test\", object : RealmEventStreamAsyncTaskImpl.Executor<String>() {\n+            override fun run(): EventStream<String> {\n+                return object : EventStream<String> {\n+                    var opened: Boolean = false\n+\n+                    override fun getNextEvent(): BaseChangeEvent<String>? {\n+                        opened = true\n+                        return null\n+                    }\n+\n+                    override fun close() {\n+                        opened = false\n+                    }\n+\n+                    override fun isOpen(): Boolean {\n+                        return opened\n+                    }\n+                }\n+            }\n+        })\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        looperThread.runBlocking {\n+            task.get {\n+                looperThread.testComplete()\n+            }\n+        }\n+\n+        assertEquals(true, task.isOpen)\n+        assertEquals(false, task.isCancelled)\n+\n+        task.cancel()\n+\n+        assertEquals(false, task.isOpen)\n+        assertEquals(true, task.isCancelled)\n+    }\n+}", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjIwNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476204", "bodyText": "This is no longer true?", "author": "cmelchior", "createdAt": "2020-08-21T07:37:38Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamTask.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import java.io.IOException;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjQwMw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476403", "bodyText": "This is no longer true", "author": "cmelchior", "createdAt": "2020-08-21T07:37:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamAsyncTask.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamAsyncTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1ODU5OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474558598", "bodyText": "Forgot to update those descriptions", "author": "clementetb", "createdAt": "2020-08-21T09:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjQwMw=="}], "type": "inlineReview"}, {"oid": "e588e87354b6db11ad619b7451af3cbc4f74e952", "url": "https://github.com/realm/realm-java/commit/e588e87354b6db11ad619b7451af3cbc4f74e952", "message": "Update CHANGELOG.md\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>", "committedDate": "2020-08-21T07:59:59Z", "type": "commit"}, {"oid": "87f162f38888966c576b5549e99db4f2ec083053", "url": "https://github.com/realm/realm-java/commit/87f162f38888966c576b5549e99db4f2ec083053", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>", "committedDate": "2020-08-21T08:14:11Z", "type": "commit"}, {"oid": "59f515355258b32c7a8a32df6c49840d8895251a", "url": "https://github.com/realm/realm-java/commit/59f515355258b32c7a8a32df6c49840d8895251a", "message": "Transform keyPresent function into a check", "committedDate": "2020-08-21T08:38:44Z", "type": "commit"}, {"oid": "7065f993f684b5285aa2320a180aa9200fe43307", "url": "https://github.com/realm/realm-java/commit/7065f993f684b5285aa2320a180aa9200fe43307", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>", "committedDate": "2020-08-21T08:43:17Z", "type": "commit"}, {"oid": "9e1f8d3c055ba88c29f813b922639dbc2f646d94", "url": "https://github.com/realm/realm-java/commit/9e1f8d3c055ba88c29f813b922639dbc2f646d94", "message": "Change eventstream tasks description", "committedDate": "2020-08-21T08:45:40Z", "type": "commit"}, {"oid": "10a511c15ac0d092015aef80a5ba4c1066c70779", "url": "https://github.com/realm/realm-java/commit/10a511c15ac0d092015aef80a5ba4c1066c70779", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>", "committedDate": "2020-08-21T08:51:40Z", "type": "commit"}, {"oid": "8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "url": "https://github.com/realm/realm-java/commit/8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "message": "Merge branch 'ct/watch-event-streams' of ssh://github.com/realm/realm-java into ct/watch-event-streams", "committedDate": "2020-08-21T09:06:36Z", "type": "commit"}, {"oid": "0f76b662e588dc0e6b289858ac224f758f5417b3", "url": "https://github.com/realm/realm-java/commit/0f76b662e588dc0e6b289858ac224f758f5417b3", "message": "Claus PR change requests", "committedDate": "2020-08-21T09:10:07Z", "type": "commit"}, {"oid": "3d02f9240afff6c616cfd5bb4d78450033c8a510", "url": "https://github.com/realm/realm-java/commit/3d02f9240afff6c616cfd5bb4d78450033c8a510", "message": "Added link to realm change events spec", "committedDate": "2020-08-21T09:22:54Z", "type": "commit"}, {"oid": "5da5ccc8a213a13fdd39f366310a724071d43368", "url": "https://github.com/realm/realm-java/commit/5da5ccc8a213a13fdd39f366310a724071d43368", "message": "BlockingLooperThread runDetached returns non null values", "committedDate": "2020-08-21T10:16:33Z", "type": "commit"}, {"oid": "7570829040b4600e4ad44e81ce71e2e9a30efa54", "url": "https://github.com/realm/realm-java/commit/7570829040b4600e4ad44e81ce71e2e9a30efa54", "message": "Use static class and method references", "committedDate": "2020-08-21T10:24:28Z", "type": "commit"}, {"oid": "b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "url": "https://github.com/realm/realm-java/commit/b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "message": "Better comment", "committedDate": "2020-08-21T10:27:04Z", "type": "commit"}, {"oid": "319483675412a252c3c931c7ff0604296a0ab7f3", "url": "https://github.com/realm/realm-java/commit/319483675412a252c3c931c7ff0604296a0ab7f3", "message": "Return response message on http stream error", "committedDate": "2020-08-21T10:42:16Z", "type": "commit"}, {"oid": "f3a956e0a663def9edfff370610831bb4137d26e", "url": "https://github.com/realm/realm-java/commit/f3a956e0a663def9edfff370610831bb4137d26e", "message": "Rename OkHttpNetworkTransport response", "committedDate": "2020-08-21T10:43:21Z", "type": "commit"}, {"oid": "b6430333b18f478eefd60b7a6e0a3a9edc81de60", "url": "https://github.com/realm/realm-java/commit/b6430333b18f478eefd60b7a6e0a3a9edc81de60", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-25T08:54:37Z", "type": "commit"}]}