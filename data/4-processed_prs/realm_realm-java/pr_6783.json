{"pr_number": 6783, "pr_title": "Add support for EmailPasswordAuthProvider", "pr_createdAt": "2020-03-24T10:03:21Z", "pr_url": "https://github.com/realm/realm-java/pull/6783", "timeline": [{"oid": "a5106591261d27897ab2977c3ab0db5cd8bd07f2", "url": "https://github.com/realm/realm-java/commit/a5106591261d27897ab2977c3ab0db5cd8bd07f2", "message": "Initial implementation of EmailPasswordAuthProvider", "committedDate": "2020-03-24T09:58:46Z", "type": "commit"}, {"oid": "84055a428669d6d1dc6de39a4255e592c4f01484", "url": "https://github.com/realm/realm-java/commit/84055a428669d6d1dc6de39a4255e592c4f01484", "message": "Add more EmailPasswordAuthProviderTests", "committedDate": "2020-03-24T22:06:41Z", "type": "commit"}, {"oid": "53cd14446f890ab2a13d368ffe01026682a87f4f", "url": "https://github.com/realm/realm-java/commit/53cd14446f890ab2a13d368ffe01026682a87f4f", "message": "Cleanup. Finish remaining tests", "committedDate": "2020-03-25T09:22:43Z", "type": "commit"}, {"oid": "18ecd6b5d4eed7b8cb242973a99733c316b3d7d2", "url": "https://github.com/realm/realm-java/commit/18ecd6b5d4eed7b8cb242973a99733c316b3d7d2", "message": "More cleanup", "committedDate": "2020-03-25T09:39:08Z", "type": "commit"}, {"oid": "35047fc5e88be5e190cf681afc68ca53fd92a528", "url": "https://github.com/realm/realm-java/commit/35047fc5e88be5e190cf681afc68ca53fd92a528", "message": "Add missing javadoc", "committedDate": "2020-03-25T22:18:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxNzU1NA==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399317554", "bodyText": "can we add FIXME to use the admin API in the future to do this validation?", "author": "nhachicha", "createdAt": "2020-03-27T14:46:20Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        app.emailPasswordAuthProvider.registerUser(email, password)\n+        val user = app.login(RealmCredentials.emailPassword(email, password))\n+        assertEquals(RealmUser.State.ACTIVE, user.state)\n+    }\n+\n+    @Test\n+    fun registerUserAsync() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        looperThread.runBlocking {\n+            app.emailPasswordAuthProvider.registerUserAsync(email, password, object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    val user2 = app.login(RealmCredentials.emailPassword(email, password))\n+                    assertEquals(RealmUser.State.ACTIVE, user2.state)\n+                    looperThread.testComplete()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    fail(error.toString())\n+                }\n+            })\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        try {\n+            provider.registerUser(\"invalid-email\", \"1234\")\n+            fail()\n+        } catch (ex: ObjectServerError) {\n+            assertEquals(ErrorCode.BAD_REQUEST, ex.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun registerUserAsync_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(\"invalid-email\", \"1234\", object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    fail()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    assertEquals(ErrorCode.BAD_REQUEST, error.errorCode)\n+                    looperThread.testComplete()\n+                }\n+            })\n+        }\n+\n+    }\n+\n+    @Test\n+    fun registerUser_invalidArgumentsThrows() {\n+        val provider: EmailPasswordAuthProvider = app.emailPasswordAuthProvider\n+        testNullArg { provider.registerUser(TestHelper.getNullString(), \"123456\") }\n+        testNullArg { provider.registerUser(\"foo@bar.baz\", TestHelper.getNullString()) }\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(TestHelper.getNullString(), \"123456\", checkNullArgCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.registerUserAsync(\"foo@bar.baz\", TestHelper.getNullString(), checkNullArgCallback)\n+        }\n+    }\n+\n+    @Ignore(\"Find a way to automate this\")\n+    @Test\n+    fun confirmUser() {\n+        TODO(\"Figure out how to manually test this\")\n+    }\n+\n+    @Ignore(\"Find a way to automate this\")\n+    @Test\n+    fun confirmUserAsync() {\n+        TODO(\"Figure out how to manually test this\")\n+    }\n+\n+    @Test\n+    fun confirmUser_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        try {\n+            provider.confirmUser(\"invalid-token\", \"invalid-token-id\")\n+            fail()\n+        } catch (ex: ObjectServerError) {\n+            assertEquals(ErrorCode.BAD_REQUEST, ex.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun confirmUserAsync_invalidServerArgsThrows() {\n+        val provider = app.emailPasswordAuthProvider\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(\"invalid-email\", \"1234\", object: RealmApp.Callback<Void> {\n+                override fun onSuccess(t: Void) {\n+                    fail()\n+                }\n+\n+                override fun onError(error: ObjectServerError) {\n+                    assertEquals(ErrorCode.BAD_REQUEST, error.errorCode)\n+                    looperThread.testComplete()\n+                }\n+            })\n+        }\n+    }\n+\n+    @Test\n+    fun confirmUser_invalidArgumentsThrows() {\n+        val provider: EmailPasswordAuthProvider = app.emailPasswordAuthProvider\n+        testNullArg { provider.confirmUser(TestHelper.getNullString(), \"token-id\") }\n+        testNullArg { provider.confirmUser(\"token\", TestHelper.getNullString()) }\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(TestHelper.getNullString(), \"token-id\", checkNullArgCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.confirmUserAsync(\"token\", TestHelper.getNullString(), checkNullArgCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun resendConfirmationEmail() {\n+        // We only test that the server successfully accepts the request. We have no way of knowing", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ5OTI5NQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399499295", "bodyText": "I don't think it is possible to verify this using the Admin API. We might be able to use a custom SMTP server, but it is very unclear to me how much work that is. But I'll add a FIXME here about it.", "author": "cmelchior", "createdAt": "2020-03-27T19:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxNzU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMzY2OQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399323669", "bodyText": "do you need to call deletePendingUser for each registerUser ?", "author": "nhachicha", "createdAt": "2020-03-27T14:54:33Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun registerUser() {\n+        val email = TestHelper.getRandomEmail()\n+        val password = \"password1234\"\n+        app.emailPasswordAuthProvider.registerUser(email, password)", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMDEwMg==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399500102", "bodyText": "No, pending users and registered users are two different things. Right now I automatically delete all registered users in app.close(). There was an undocumented API for doing the same for pending users, so I'll add that to app.close() as well.", "author": "cmelchior", "createdAt": "2020-03-27T19:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzMjIzMQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399432231", "bodyText": "This can be refactored to be used with all types of expected exception.\ninline fun <reified T : Exception> expectException(method: () -> Unit) {\n        try {\n            method()\n            fail()\n        } catch (ignore: Throwable) {\n            if (ignore !is T) {\n                throw ignore\n            }\n        }\n    }\n\n//\nexpectException<IllegalArgumentException> { provider.registerUser(TestHelper.getNullString(), \"123456\") }", "author": "nhachicha", "createdAt": "2020-03-27T17:36:33Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/EmailPasswordAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.junit.After\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.fail\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.lang.IllegalStateException\n+\n+@RunWith(AndroidJUnit4::class)\n+class EmailPasswordAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullArgCallback\n+            = object : RealmApp.Callback<Void> {\n+        override fun onSuccess(t: Void) {\n+            fail()\n+        }\n+\n+        override fun onError(error: ObjectServerError) {\n+            assertEquals(ErrorCode.UNKNOWN, error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        REGISTER_USER,\n+        CONFIRM_USER,\n+        RESEND_CONFIRMATION_EMAIL,\n+        SEND_RESET_PASSWORD_EMAIL,\n+        CALL_RESET_PASSWORD_FUNCTION,\n+        RESET_PASSWORD\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMDE5OA==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399500198", "bodyText": "Nice \ud83c\udf89", "author": "cmelchior", "createdAt": "2020-03-27T19:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzMjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1NjU5NA==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399456594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This only works if users in the Realm Application are configured to be automatically be confirmed.\n          \n          \n            \n             * This only works if users in the Realm Application are configured to be automatically confirmed.", "author": "nhachicha", "createdAt": "2020-03-27T18:18:24Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppExt.kt", "diffHunk": "@@ -13,3 +11,12 @@ fun RealmApp.close() {\n     SyncManager.reset()\n     BaseRealm.applicationContext = null // Required for Realm.init() to work\n }\n+\n+/**\n+ * Helper function for quickly logging in test users.\n+ * This only works if users in the Realm Application are configured to be automatically be confirmed.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3MjQ1OQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399472459", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * for logging into an Realm Application.\n          \n          \n            \n                 * for login into a Realm Application.", "author": "nhachicha", "createdAt": "2020-03-27T18:47:47Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3MzExOQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399473119", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param password the password to associated with the email. The password must be between\n          \n          \n            \n                 * @param password the password to associate with the email. The password must be between", "author": "nhachicha", "createdAt": "2020-03-27T18:48:57Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NjEzMQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399476131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * happen on the same thread as this this method is called on.\n          \n          \n            \n                 * happen on the same thread as this method is called on.", "author": "nhachicha", "createdAt": "2020-03-27T18:54:44Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NzU0Ng==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399477546", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * happen on the same thread as this this method is called on.\n          \n          \n            \n                 * happen on the same thread as this method is called on.", "author": "nhachicha", "createdAt": "2020-03-27T18:57:31Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3ODQ1OQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399478459", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * always happen on the same thread as this this method is called on.\n          \n          \n            \n                 * always happen on the same thread as this method is called on.", "author": "nhachicha", "createdAt": "2020-03-27T18:59:15Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3ODg4Nw==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399478887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * always happen on the same thread as this this method is called on.\n          \n          \n            \n                 * always happen on the same thread as this method is called on.", "author": "nhachicha", "createdAt": "2020-03-27T18:59:59Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3OTUzMQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399479531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param args any additional arguments provided to to the reset function. All arguments must\n          \n          \n            \n                 * @param args any additional arguments provided to the reset function. All arguments must", "author": "nhachicha", "createdAt": "2020-03-27T19:01:18Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous sending the reset password email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                sendResetPasswordEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must\n+     * be able to be converted to JSON compatible values using {@code toString()}.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void callResetPasswordFunction(String email, String newPassword, Object... args) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(newPassword, \"newPassword\");\n+        JSONArray array = new JSONArray();\n+        for (Object arg : args) {\n+            array.put((arg != null) ? arg.toString() : null);\n+        }\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CALL_RESET_PASSWORD_FUNCTION,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, newPassword, array.toString());\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3OTY3Ng==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399479676", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param args any additional arguments provided to to the reset function. All arguments must\n          \n          \n            \n                 * @param args any additional arguments provided to the reset function. All arguments must", "author": "nhachicha", "createdAt": "2020-03-27T19:01:37Z", "path": "realm/realm-library/src/objectServer/java/io/realm/EmailPasswordAuthProvider.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.json.JSONArray;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * Class encapsulating functionality provided when {@link RealmUser}'s are logged in through the\n+ * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+ */\n+public class EmailPasswordAuthProvider {\n+\n+    private static final int TYPE_REGISTER_USER = 1;\n+    private static final int TYPE_CONFIRM_USER = 2;\n+    private static final int TYPE_RESEND_CONFIRMATION_EMAIL = 3;\n+    private static final int TYPE_SEND_RESET_PASSWORD_EMAIL = 4;\n+    private static final int TYPE_CALL_RESET_PASSWORD_FUNCTION = 5;\n+    private static final int TYPE_RESET_PASSWORD = 6;\n+\n+    private final RealmApp app;\n+\n+    /**\n+     * Creates an authentication provider exposing functionality to using an email and password\n+     * for logging into an Realm Application.\n+     */\n+    public EmailPasswordAuthProvider(RealmApp app) {\n+        this.app = app;\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     *\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public void registerUser(String email, String password) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        Util.checkEmpty(password, \"password\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_REGISTER_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email, password);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Registers a new user with the given email and password.\n+     *\n+     * @param email the email to register with. This will be the username used during log in.\n+     * @param password the password to associated with the email. The password must be between\n+     * 6 and 128 characters long.\n+     * @param callback callback when registration has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     *\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     * @throws ObjectServerError if the server failed to register the user.\n+     */\n+    public RealmAsyncTask registerUserAsync(String email, String password, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous registration of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                registerUser(email, password);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void confirmUser(String token, String tokenId) throws ObjectServerError {\n+        Util.checkEmpty(token, \"token\");\n+        Util.checkEmpty(tokenId, \"tokenId\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_CONFIRM_USER,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                token, tokenId);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Confirms a user with the given token and token id.\n+     *\n+     * @param token the confirmation token.\n+     * @param tokenId the id of the confirmation token.\n+     * @param callback callback when confirmation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask confirmUserAsync(String token, String tokenId, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous confirmation of a user is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                confirmUser(token, tokenId);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void resendConfirmationEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_RESEND_CONFIRMATION_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Resend the confirmation for a user to the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when resending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask resendConfirmationEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous resending the confirmation email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                resendConfirmationEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public void sendResetPasswordEmail(String email) throws ObjectServerError {\n+        Util.checkEmpty(email, \"email\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_SEND_RESET_PASSWORD_EMAIL,\n+                app.nativePtr,\n+                new RealmApp.OsJNIVoidResultCallback(error),\n+                email);\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Sends a user a password reset email for the given email.\n+     *\n+     * @param email the email of the user.\n+     * @param callback callback when sending the email has completed or failed. The callback will\n+     * always happen on the same thread as this this method is called on.\n+     * @throws ObjectServerError if the server failed to confirm the user.\n+     */\n+    public RealmAsyncTask sendResetPasswordEmailAsync(String email, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous sending the reset password email is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                sendResetPasswordEmail(email);\n+                return RealmApp.VOID_INSTANCE;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Call the reset password function configured to the\n+     * {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} provider.\n+     *\n+     * @param email the email of the user.\n+     * @param newPassword the new password of the user.\n+     * @param args any additional arguments provided to to the reset function. All arguments must", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ4MDU3OQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399480579", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * logging in using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.\n          \n          \n            \n                 * login using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.", "author": "nhachicha", "createdAt": "2020-03-27T19:03:28Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -225,15 +228,25 @@ public RealmAsyncTask logOutAsync(Callback<RealmUser> callback) {\n          return logOutAsync(user, callback);\n      }\n \n+    /**\n+     * Returns a wrapper for interacting with functionality related to users either being created or\n+     * logging in using the {@link RealmCredentials.IdentityProvider#EMAIL_PASSWORD} identity provider.", "originalCommit": "35047fc5e88be5e190cf681afc68ca53fd92a528", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "269787c3e7287d37f571208d5e3735e80ebe6e3d", "url": "https://github.com/realm/realm-java/commit/269787c3e7287d37f571208d5e3735e80ebe6e3d", "message": "Apply suggestions from code review\n\nCo-Authored-By: Nabil Hachicha <nh@realm.io>", "committedDate": "2020-03-27T22:17:30Z", "type": "commit"}, {"oid": "d4d9a1ebe40e40108a5f87090dc020b28979c40c", "url": "https://github.com/realm/realm-java/commit/d4d9a1ebe40e40108a5f87090dc020b28979c40c", "message": "Generic exception check. Also automatically delete all pending users.", "committedDate": "2020-03-27T23:14:16Z", "type": "commit"}, {"oid": "11c7cc975a01d86ab7f9145b5adb093c41b3b588", "url": "https://github.com/realm/realm-java/commit/11c7cc975a01d86ab7f9145b5adb093c41b3b588", "message": "Introduce Result class instead of letting Callback having multiple methods", "committedDate": "2020-03-29T10:22:32Z", "type": "commit"}, {"oid": "d706ff934c05808c95512915b71c8ed7715d99f7", "url": "https://github.com/realm/realm-java/commit/d706ff934c05808c95512915b71c8ed7715d99f7", "message": "Remove Void instance hack", "committedDate": "2020-03-29T11:21:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMjg5NA==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399812894", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Returns the response in case the request as a success.\n          \n          \n            \n                     * Returns the response in case the request was a success.", "author": "nhachicha", "createdAt": "2020-03-29T15:26:52Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -448,30 +448,106 @@ private void postSuccess(final T result) {\n                 handler.post(new Runnable() {\n                     @Override\n                     public void run() {\n-                        callback.onSuccess(result);\n+                        callback.onResult(Result.withResult(result));\n                     }\n                 });\n             }\n         }\n     }\n \n-    // Work-around for Kotlin not playing nice with the Void type and nullability annotations.\n-    // See https://github.com/realm/realm-java/pull/6783/ for more context.\n-    static final Void VOID_INSTANCE;\n-    static {\n-        Constructor<Void> constructor;\n-        Void v = null;\n-        try {\n-            constructor = Void.class.getDeclaredConstructor();\n-            constructor.setAccessible(true);\n-            v = constructor.newInstance();\n-        } catch (Exception e) {\n-            // Do nothing\n-            // Something is fundamentally broken if this fails and any Kotlin API using callbacks\n-            // with Void will throw a runtime exception (as Kotlin expects the value to be non-null).\n-            // For now, let this happen as any API using Java will still continue to work.\n+    /**\n+     * Result class representing the result of an async request from this app towards MongoDB Realm.\n+     *\n+     * @param <T> Type returned if the request was a success.\n+     * @see Callback\n+     */\n+    public static class Result<T> {\n+        private T result;\n+        private ObjectServerError error;\n+\n+        private Result(@Nullable T result, @Nullable ObjectServerError exception) {\n+            this.result = result;\n+            this.error = exception;\n+        }\n+\n+        /**\n+         * Creates a successful request result with no return value.\n+         */\n+        public static <T> Result<T> success() {\n+            return new Result(null, null);\n+        }\n+\n+        /**\n+         * Creates a successful request result with a return value.\n+         *\n+         * @param result the result value.\n+         */\n+        public static <T> Result<T> withResult(T result) {\n+            return new Result<>(result, null);\n+        }\n+\n+        /**\n+         * Creates a failed request result. The request failed for some reason, either because there\n+         * was a network error or the Realm Object Server returned an error.\n+         *\n+         * @param exception error that occurred.\n+         */\n+        public static <T> Result<T> withError(ObjectServerError exception) {\n+            return new Result<>(null, exception);\n+        }\n+\n+        /**\n+         * Returns whether or not request was successful\n+         *\n+         * @return {@code true} if the request was a success, {@code false} if not.\n+         */\n+        public boolean isSuccess() {\n+            return error == null;\n+        }\n+\n+        /**\n+         * Returns the response in case the request as a success.", "originalCommit": "d706ff934c05808c95512915b71c8ed7715d99f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzMyMg==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399813322", "bodyText": "You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...", "author": "nhachicha", "createdAt": "2020-03-29T15:30:02Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -448,30 +448,106 @@ private void postSuccess(final T result) {\n                 handler.post(new Runnable() {\n                     @Override\n                     public void run() {\n-                        callback.onSuccess(result);\n+                        callback.onResult(Result.withResult(result));", "originalCommit": "d706ff934c05808c95512915b71c8ed7715d99f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzg4Mg==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399813882", "bodyText": "True. I actually didn't think of it, but in this case Results.withResult(null) is actually equal to Results.success(). The Result class will end up the correct state either way. Is it worth adding the null check here?", "author": "cmelchior", "createdAt": "2020-03-29T15:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgyOTcxOQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399829719", "bodyText": "I think it does make sense if the implementation was in Kotlin, since withResult will not accept nullable values. We can annotate it though in Java with Nullable", "author": "nhachicha", "createdAt": "2020-03-29T17:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzMTMzNQ==", "url": "https://github.com/realm/realm-java/pull/6783#discussion_r399831335", "bodyText": "Fair point. I'll change it", "author": "cmelchior", "createdAt": "2020-03-29T17:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzMyMg=="}], "type": "inlineReview"}, {"oid": "ecebe1cb9d8d2e7dbff22043008ec0c7c43fcd38", "url": "https://github.com/realm/realm-java/commit/ecebe1cb9d8d2e7dbff22043008ec0c7c43fcd38", "message": "Increase readability", "committedDate": "2020-03-29T17:57:56Z", "type": "commit"}, {"oid": "54586044c0114cf5cbde690013893bea26a29500", "url": "https://github.com/realm/realm-java/commit/54586044c0114cf5cbde690013893bea26a29500", "message": "Update realm/realm-library/src/objectServer/java/io/realm/RealmApp.java\n\nCo-Authored-By: Nabil Hachicha <nh@realm.io>", "committedDate": "2020-03-29T17:58:44Z", "type": "commit"}]}