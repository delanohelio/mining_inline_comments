{"pr_number": 7191, "pr_title": "Added FlowFactory interface and default implementation for coroutines flows", "pr_createdAt": "2020-11-10T13:11:53Z", "pr_url": "https://github.com/realm/realm-java/pull/7191", "timeline": [{"oid": "973d43725d3bc2a8bd053892ddab0ff2856daa12", "url": "https://github.com/realm/realm-java/commit/973d43725d3bc2a8bd053892ddab0ff2856daa12", "message": "Prepare next dev iteration", "committedDate": "2020-10-15T11:57:14Z", "type": "commit"}, {"oid": "69a044b05ee93656f0fb7e2f8a0c9e32ae4b50e2", "url": "https://github.com/realm/realm-java/commit/69a044b05ee93656f0fb7e2f8a0c9e32ae4b50e2", "message": "Add Decimal128 and ObjectId to Javadoc on supported types (#7183)", "committedDate": "2020-11-05T10:06:07Z", "type": "commit"}, {"oid": "ac2d4540df081d03854b66be7f06875bef651d61", "url": "https://github.com/realm/realm-java/commit/ac2d4540df081d03854b66be7f06875bef651d61", "message": "Merge branch 'releases'\n\n# Conflicts:\n#\tversion.txt", "committedDate": "2020-11-06T11:19:35Z", "type": "commit"}, {"oid": "a2557b6349e0eea4cc8ee43cee5d56d0d03e40ed", "url": "https://github.com/realm/realm-java/commit/a2557b6349e0eea4cc8ee43cee5d56d0d03e40ed", "message": "First steps towards having a coroutines factory", "committedDate": "2020-11-06T15:06:24Z", "type": "commit"}, {"oid": "e0728b79fbe65f3e83d0e95061099bf8c4ab7628", "url": "https://github.com/realm/realm-java/commit/e0728b79fbe65f3e83d0e95061099bf8c4ab7628", "message": "Hid Kotlin dependencies from artifact, only for compile time", "committedDate": "2020-11-06T16:31:02Z", "type": "commit"}, {"oid": "c7156b30f2257e3b81757e2d992f9aba73d0504a", "url": "https://github.com/realm/realm-java/commit/c7156b30f2257e3b81757e2d992f9aba73d0504a", "message": "Added dependencies for testing, added missing toFlow methods and tests for config and syncconfig", "committedDate": "2020-11-09T11:40:33Z", "type": "commit"}, {"oid": "4efc7147d3e2b4ca6092aa7f0dccda6101dca10f", "url": "https://github.com/realm/realm-java/commit/4efc7147d3e2b4ca6092aa7f0dccda6101dca10f", "message": "Corrected signatures", "committedDate": "2020-11-09T11:56:12Z", "type": "commit"}, {"oid": "aa67c34f1321f582208df616dc040a435caddae2", "url": "https://github.com/realm/realm-java/commit/aa67c34f1321f582208df616dc040a435caddae2", "message": "Added missing realm instance flow methods to factory and tests", "committedDate": "2020-11-09T15:46:40Z", "type": "commit"}, {"oid": "dbfd23d50809a755686da6df3d222eb8a88f6e1b", "url": "https://github.com/realm/realm-java/commit/dbfd23d50809a755686da6df3d222eb8a88f6e1b", "message": "Made realm property in RealmResults and RealmList public so that it can be accessed from extension functions (the existing getRealm method cannot be used for DynamicRealms so that would break the API), added missing flow methods for dynamic realms and tests, and added docs and beta annotations to factory methods", "committedDate": "2020-11-10T12:47:52Z", "type": "commit"}, {"oid": "29d15d070c602e4083386cf9e0270048caabd9bd", "url": "https://github.com/realm/realm-java/commit/29d15d070c602e4083386cf9e0270048caabd9bd", "message": "Added missing documentation and renamed builder method to flowFactory instead", "committedDate": "2020-11-10T13:11:24Z", "type": "commit"}, {"oid": "e14d72296c6f6c2aadcc2423efaa2b0e8cfb226c", "url": "https://github.com/realm/realm-java/commit/e14d72296c6f6c2aadcc2423efaa2b0e8cfb226c", "message": "Added support for Flows with no results when using findFirst", "committedDate": "2020-11-11T10:21:10Z", "type": "commit"}, {"oid": "29abccae77f9f0e37f278080bfbf791a73448051", "url": "https://github.com/realm/realm-java/commit/29abccae77f9f0e37f278080bfbf791a73448051", "message": "Added exclusion of Kotlin files for javadoc generation", "committedDate": "2020-11-11T10:31:24Z", "type": "commit"}, {"oid": "65feabb11ab4021d80d44a32ab19988c2f639e3d", "url": "https://github.com/realm/realm-java/commit/65feabb11ab4021d80d44a32ab19988c2f639e3d", "message": "Added test for null object to flow", "committedDate": "2020-11-11T13:34:03Z", "type": "commit"}, {"oid": "fc71055cd4eba2099b340784927ecac540c00e73", "url": "https://github.com/realm/realm-java/commit/fc71055cd4eba2099b340784927ecac540c00e73", "message": "Added missing collect to trigger thread violation", "committedDate": "2020-11-11T14:06:16Z", "type": "commit"}, {"oid": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "url": "https://github.com/realm/realm-java/commit/481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "message": "Fixed test factories", "committedDate": "2020-11-11T14:32:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NzkyNA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r521857924", "bodyText": "Missing license header", "author": "cmelchior", "createdAt": "2020-11-12T06:00:44Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/DynamicRealmExtensions.kt", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.realm.kotlin", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMTczMg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522711732", "bodyText": "Can this ever be null here?", "author": "cmelchior", "createdAt": "2020-11-13T07:11:22Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc2NzY3MA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522767670", "bodyText": "Yes, when calling findFirst().toflow(). We got feedback from a user and decided to add this here #7165", "author": "edualonso", "createdAt": "2020-11-13T08:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMTczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxMzQ5MA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522713490", "bodyText": "Maybe add a comment about unmanaged objects only being emitted once?", "author": "cmelchior", "createdAt": "2020-11-13T07:13:19Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNTIzOQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522715239", "bodyText": "After thinking a bit about this,  I think we should introduce this method as well. IMO the one just returning the RealmResults are far easier to consume, this one is slightly annoying as you have to unpack things everytime, but it still has a lot of uses.", "author": "cmelchior", "createdAt": "2020-11-13T07:15:21Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmResultsExtensions.kt", "diffHunk": "@@ -63,38 +57,17 @@ import kotlinx.coroutines.flow.flowOf\n  */\n @Beta\n fun <T : RealmModel> RealmResults<T>.toFlow(): Flow<RealmResults<T>> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(this)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow {\n-        val results = this@toFlow\n-\n-        // Do nothing if the results are invalid\n-        if (!results.isValid) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n-            offer(listenerResults.freeze())\n-        }\n-\n-        results.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze())\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                results.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n+    @Suppress(\"INACCESSIBLE_TYPE\")\n+    return when (val realmInstance = baseRealm) {\n+        is Realm -> realmInstance.configuration.flowFactory?.from(baseRealm as Realm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        is DynamicRealm -> realmInstance.configuration.flowFactory?.from(baseRealm as DynamicRealm, this)\n+                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+        else -> throw IllegalStateException(\"Wrong type of Realm.\")\n     }\n }\n+\n+// TODO figure out if we want to do this as a separate method or merge both in one that delivers changesets and results", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNjczMA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522716730", "bodyText": "I would probably just delete this comment.", "author": "cmelchior", "createdAt": "2020-11-13T07:16:53Z", "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -208,8 +208,14 @@ repositories {\n \n dependencies {\n \n+    // Hidden from deliverable", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMTgxMw==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522721813", "bodyText": "Missing test for what happens if you try to assign null to the factory. I assume we want to throw an IllegalArgumentException?", "author": "cmelchior", "createdAt": "2020-11-13T07:22:16Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,68 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void coroutinesFactory_defaultNotNull() {", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722245", "bodyText": "Same, missing test for what happens if you assign null", "author": "cmelchior", "createdAt": "2020-11-13T07:22:47Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncConfigurationTests.kt", "diffHunk": "@@ -424,4 +431,57 @@ class SyncConfigurationTests {\n                 .build()\n         assertTrue(configuration.isAllowWritesOnUiThread)\n     }\n+\n+    @Test\n+    fun coroutinesFactory_defaultNonNull() {\n+        val configuration = SyncConfiguration.Builder(createTestUser(app), DEFAULT_PARTITION)\n+                .build()\n+        assertNotNull(configuration.flowFactory)\n+    }\n+\n+    @Test\n+    fun coroutinesFactory() {", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2MTQ3OA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522861478", "bodyText": "This is a Kotlin class, so non-nullability is enforced after adding @Nonnull to the Java method.", "author": "edualonso", "createdAt": "2020-11-13T10:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2Mjk3Ng==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522862976", "bodyText": "No, it doesn't prevent that when calling it from Java. At best you get a warning which can be missed or ignored.", "author": "cmelchior", "createdAt": "2020-11-13T10:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMjkzNA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522722934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "author": "cmelchior", "createdAt": "2020-11-13T07:23:32Z", "path": "realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java", "diffHunk": "@@ -25,7 +25,13 @@\n     private static final String NOT_SUPPORTED_MESSAGE = \"This method is not supported by 'RealmResults' or\" +\n             \" 'OrderedRealmCollectionSnapshot'.\";\n \n-    final BaseRealm realm;\n+    /**\n+     * The {@link BaseRealm} instance in which this collection resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyMzk3MA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522723970", "bodyText": "Missing Javadoc", "author": "cmelchior", "createdAt": "2020-11-13T07:24:39Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522724370", "bodyText": "We should guard against this in the builder so it can never be null here.", "author": "cmelchior", "createdAt": "2020-11-13T07:25:06Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -267,6 +272,18 @@ public RxObservableFactory getRxFactory() {\n         return rxObservableFactory;\n     }\n \n+    /**\n+     * FIXME\n+     * @return\n+     */\n+    @Nullable\n+    public FlowFactory getFlowFactory() {\n+        if (flowFactory == null) {", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0ODkyOA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522848928", "bodyText": "Is this not the same case as with the Rx factory? It will be null if it isn't present in the classpath. By the way, I have just added a utility method for checking whether Flows are present or not.", "author": "edualonso", "createdAt": "2020-11-13T10:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzgwMA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522857800", "bodyText": "Oh, I see what you mean. Sure, I will mark the parameter as @Nonnull (for Kotlin's sake) and throw an exception in case we still receive null in Java - and will add the same guard for the Rx factory because it seems we are missing it too.", "author": "edualonso", "createdAt": "2020-11-13T10:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNjQ5Ng==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522726496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Warning: we discourage using this property directly from your code.\n          \n          \n            \n                 * Warning: This field is only exposed for internal usage, and should not be used.", "author": "cmelchior", "createdAt": "2020-11-13T07:27:13Z", "path": "realm/realm-library/src/main/java/io/realm/RealmList.java", "diffHunk": "@@ -73,7 +73,14 @@\n \n     // Always null if RealmList is unmanaged, always non-null if managed.\n     private final ManagedListOperator<E> osListOperator;\n-    protected final BaseRealm realm;\n+\n+    /**\n+     * The {@link BaseRealm} instance in which this list resides.\n+     * <p>\n+     * Warning: we discourage using this property directly from your code.", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522729623", "bodyText": "I think we might want to add the changeSetsFrom methods already now to this interface. Even if we don't expose them in this PR, it will prevent a later breaking change?\nBut then again, the interface is marked Beta.\nThoughts?", "author": "cmelchior", "createdAt": "2020-11-13T07:30:41Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/FlowFactory.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmObject;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory interface for creating Kotlin {@link Flow}s for Realm classes.\n+ */\n+@Beta\n+public interface FlowFactory {", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NTExMw==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522855113", "bodyText": "I will have a look at the current implementation for Rx. I will get back to you once I have a better idea about whether it's doable right away or not.", "author": "edualonso", "createdAt": "2020-11-13T10:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzMzkxMA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r524033910", "bodyText": "I've added the implementation for all changeset methods and tests for them. I have left all the factory methods markes as \"beta\".", "author": "edualonso", "createdAt": "2020-11-16T09:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyOTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMTg0NQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522731845", "bodyText": "Flow\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Flow factory used by Realm by default.\n          \n          \n            \n             * Factory class used to create coroutine Flows. This class is used by default unless overridden in {@link RealmConfiguration.Builder#flowFactory(FlowFactory)}.", "author": "cmelchior", "createdAt": "2020-11-13T07:33:03Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522732506", "bodyText": "What actually happens in our Javadoc? Is this class even listed there? If not, that is a problem, that might prevent us from implementing this in Kotlin. \ud83e\udd14", "author": "cmelchior", "createdAt": "2020-11-13T07:33:47Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Flow factory used by Realm by default.", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MzM2OA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522853368", "bodyText": "I had to add an exception to exclude Kotlin files from being javadoc'ed in the build.gradle script since the mere existence of this class was causing the javadoc task to fail. I think it is totally ignored at the moment. But it is a valid concern. I don't think javadoc can ever document Kotlin classes, it can only be done with dokka, but then I'm not sure how to glue the two outputs together...", "author": "edualonso", "createdAt": "2020-11-13T10:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg4NDQxNA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522884414", "bodyText": "It seems it might be possible to generate the javadoc using dokka instead: https://blog.jetbrains.com/kotlin/2020/08/dokka-preview-based-on-kotlin-1-4-0-rc/", "author": "edualonso", "createdAt": "2020-11-13T11:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5MjYzMQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522892631", "bodyText": "I am unsure about being able to write this class in Java. The file containing the ProducerScope.awaitClose extension function doesn't have the @file:JvmName that would make it visible from Java, and so far it seems impossible to call it using a ProducerScope instance from java \ud83d\ude1e", "author": "edualonso", "createdAt": "2020-11-13T11:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk3NjIwMA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522976200", "bodyText": "Will add an internal Kotlin class that will be called from a Java class that implements the flow interface. This way we will not have issues with javadoc.", "author": "edualonso", "createdAt": "2020-11-13T14:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczMjUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734462", "bodyText": "We should guard against null here.", "author": "cmelchior", "createdAt": "2020-11-13T07:36:02Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -793,6 +799,17 @@ public Builder rxFactory(RxObservableFactory factory) {\n             return this;\n         }\n \n+        /**\n+         * Sets the {@link FlowFactory} used to create coroutines Flows from Realm objects.\n+         * The default factory is {@link RealmFlowFactory}.\n+         *\n+         * @param factory factory to use.\n+         */\n+        public Builder flowFactory(FlowFactory factory) {\n+            flowFactory = factory;", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MzUwNw==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522853507", "bodyText": "See #7191 (comment)", "author": "edualonso", "createdAt": "2020-11-13T10:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzkzMw==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522857933", "bodyText": "Got it - #7191 (comment)", "author": "edualonso", "createdAt": "2020-11-13T10:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDg4Ng==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522734886", "bodyText": "We seem to be missing tests for this?", "author": "cmelchior", "createdAt": "2020-11-13T07:36:30Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmObjectExtensions.kt", "diffHunk": "@@ -56,94 +54,25 @@ import kotlinx.coroutines.flow.flowOf\n  * @return Kotlin [Flow] on which calls to `onEach` or `collect` can be made.\n  */\n @Beta\n-fun <T : RealmModel> T.toFlow(): Flow<T> {\n-    val obj = this\n-    return if (obj is RealmObjectProxy) {\n-        val proxy = obj as RealmObjectProxy\n-        val realm = proxy.`realmGet$proxyState`().`realm$realm`\n-\n-        when (realm) {\n-            is Realm -> flowFromRealm<T>(realm, obj)\n-            is DynamicRealm -> {\n-                val dynamicObject = obj as DynamicRealmObject\n-                flowFromDynamicRealm(realm, dynamicObject) as Flow<T>\n-            }\n-            else -> throw UnsupportedOperationException(\"${realm.javaClass} does not support RxJava. See https://realm.io/docs/java/latest/#rxjava for more details.\")\n-        }\n-    } else {\n-        return flowOf(this)\n-    }\n-}\n-\n-private fun <T : RealmModel> flowFromRealm(realm: Realm, obj: T): Flow<T> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (realm.isFrozen) {\n-        return flowOf(obj)\n-    }\n-\n-    val config = realm.configuration\n-\n-    return callbackFlow<T> {\n-        // Do nothing if the object is invalid\n-        if (!obj.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<T> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        obj.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(obj))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                obj.removeChangeListener(listener)\n-                flowRealm.close()\n-            }\n-        }\n-    }\n-}\n-\n-private fun flowFromDynamicRealm(\n-        dynamicRealm: DynamicRealm,\n-        dynamicObject: DynamicRealmObject\n-): Flow<DynamicRealmObject> {\n-    // Return \"as is\" if frozen, there will be no listening for changes\n-    if (dynamicRealm.isFrozen) {\n-        return flowOf(dynamicObject)\n-    }\n-\n-    val config = dynamicRealm.configuration\n-\n-    return callbackFlow<DynamicRealmObject> {\n-        // Do nothing if the object is invalid\n-        if (!dynamicObject.isValid()) {\n-            return@callbackFlow\n-        }\n-\n-        // Get instance to ensure the Realm is open for as long as we are listening\n-        val flowRealm = Realm.getInstance(config)\n-        val listener = RealmChangeListener<DynamicRealmObject> { listenerObj ->\n-            offer(listenerObj.freeze())\n-        }\n-\n-        dynamicObject.addChangeListener(listener)\n-\n-        // Emit current (frozen) value\n-        offer(freeze(dynamicObject))\n-\n-        awaitClose {\n-            // Remove listener and cleanup\n-            if (!flowRealm.isClosed) {\n-                dynamicObject.removeChangeListener(listener)\n-                flowRealm.close()\n+fun <T : RealmModel> T?.toFlow(): Flow<T?> {\n+    // Return flow with object or null flow if this function is called on null\n+    return this?.let { obj ->\n+        if (obj is RealmObjectProxy) {\n+            val proxy = obj as RealmObjectProxy\n+\n+            @Suppress(\"INACCESSIBLE_TYPE\")\n+            when (val realm = proxy.`realmGet$proxyState`().`realm$realm`) {\n+                is Realm -> realm.configuration.flowFactory?.from<T>(realm, obj)\n+                        ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")\n+                is DynamicRealm ->\n+                    (obj as DynamicRealmObject).let { dynamicRealmObject ->\n+                        (realm.configuration.flowFactory?.from(realm, dynamicRealmObject)\n+                                ?: throw IllegalStateException(\"Missing flow factory in Realm configuration.\")) as Flow<T?>\n+                    }\n+                else -> throw UnsupportedOperationException(\"${realm.javaClass} is not supported as a candidate for 'toFlow'. Only subclasses of RealmModel/RealmObject can be used.\")\n             }\n+        } else {\n+            return flowOf(this)\n         }\n-    }\n+    } ?: flowOf(null)", "originalCommit": "481a0bdd4fdb8a7fae6d7f71f7bc8ae6eb75fd8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NDAyMA==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522854020", "bodyText": "No, it is here CoroutinesTests.realmObject_toFlow_nullObjectEmitsNullFlow.", "author": "edualonso", "createdAt": "2020-11-13T10:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjczNDg4Ng=="}], "type": "inlineReview"}, {"oid": "fe9fd64231c1aeb639f8b83311003eb2ce856868", "url": "https://github.com/realm/realm-java/commit/fe9fd64231c1aeb639f8b83311003eb2ce856868", "message": "Added check for null rx and flow factories in config builder, added check for flows present in classpath, added missing null factory checks, added missing docs and cleaned up a bit", "committedDate": "2020-11-13T11:05:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzc3MQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903771", "bodyText": "Remember to awaitClose {}. And maybe also add a test for that path.\nAccording to #7180.", "author": "rorbech", "createdAt": "2020-11-13T11:53:44Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "originalCommit": "fe9fd64231c1aeb639f8b83311003eb2ce856868", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMTgzOQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522931839", "bodyText": "Completely forgot about these \ud83e\udd26", "author": "edualonso", "createdAt": "2020-11-13T12:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkwMzkwMg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r522903902", "bodyText": "Same.", "author": "rorbech", "createdAt": "2020-11-13T11:54:03Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.kt", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines\n+\n+import io.realm.*\n+import io.realm.annotations.Beta\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import kotlinx.coroutines.flow.flowOf\n+\n+/**\n+ * Factory class used to create coroutine [Flow]s.\n+ *\n+ * This class is used by default unless overridden in [RealmConfiguration.Builder.flowFactory].\n+ */\n+@Beta\n+class RealmFlowFactory(\n+        private val returnFrozenObjects: Boolean = true\n+) : FlowFactory {\n+\n+    @Beta\n+    override fun from(realm: Realm): Flow<Realm> {\n+        if (realm.isFrozen) {\n+            return flowOf(realm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = Realm.getInstance(realm.configuration)\n+            val listener = RealmChangeListener<Realm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(realm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun from(dynamicRealm: DynamicRealm): Flow<DynamicRealm> {\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(dynamicRealm)\n+        }\n+\n+        return callbackFlow {\n+            val flowRealm = DynamicRealm.getInstance(dynamicRealm.configuration)\n+            val listener = RealmChangeListener<DynamicRealm> { listenerRealm ->\n+                if (returnFrozenObjects) {\n+                    offer(dynamicRealm.freeze())\n+                } else {\n+                    offer(listenerRealm)\n+                }\n+            }\n+\n+            flowRealm.addChangeListener(listener)\n+\n+            if (returnFrozenObjects) {\n+                offer(flowRealm.freeze())\n+            } else {\n+                offer(flowRealm)\n+            }\n+\n+            awaitClose {\n+                flowRealm.removeChangeListener(listener)\n+                flowRealm.close()\n+            }\n+        }\n+    }\n+\n+    @Beta\n+    override fun <T> from(realm: Realm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (realm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = realm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow\n+            }\n+\n+            // Get instance to ensure the Realm is open for as long as we are listening\n+            val flowRealm = Realm.getInstance(config)\n+            val listener = RealmChangeListener<RealmResults<T>> { listenerResults ->\n+                if (returnFrozenObjects) {\n+                    offer(listenerResults.freeze())\n+                } else {\n+                    offer(listenerResults)\n+                }\n+            }\n+\n+            results.addChangeListener(listener)\n+\n+            // Emit current value\n+            if (returnFrozenObjects) {\n+                offer(results.freeze())\n+            } else {\n+                offer(results)\n+            }\n+\n+            awaitClose {\n+                // Remove listener and cleanup\n+                if (!flowRealm.isClosed) {\n+                    results.removeChangeListener(listener)\n+                    flowRealm.close()\n+                }\n+            }\n+        }\n+    }\n+\n+    override fun <T> from(dynamicRealm: DynamicRealm, results: RealmResults<T>): Flow<RealmResults<T>> {\n+        // Return \"as is\" if frozen, there will be no listening for changes\n+        if (dynamicRealm.isFrozen) {\n+            return flowOf(results)\n+        }\n+\n+        val config = dynamicRealm.configuration\n+\n+        return callbackFlow {\n+            // Do nothing if the results are invalid\n+            if (!results.isValid) {\n+                return@callbackFlow", "originalCommit": "fe9fd64231c1aeb639f8b83311003eb2ce856868", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3064a573189ba45f4b115deb1ab8b5685d947226", "url": "https://github.com/realm/realm-java/commit/3064a573189ba45f4b115deb1ab8b5685d947226", "message": "Created internal factory in Kotlin and left the default implementation in Java to avoid issues with javadoc, plus added invalid object tests", "committedDate": "2020-11-13T13:56:38Z", "type": "commit"}, {"oid": "be61d91aa2f10f031f2cb8c62b4b3b542e94515d", "url": "https://github.com/realm/realm-java/commit/be61d91aa2f10f031f2cb8c62b4b3b542e94515d", "message": "Removed conceptually-wrong test, it passed before due not having added the awaitClose to the callbackFlow blocks when invalid results/objects are detected (which was the case, as the realm instance had been closed right before starting collection of the flow for the second time)", "committedDate": "2020-11-13T14:13:34Z", "type": "commit"}, {"oid": "39dc648bda9f102501af7d90375f4f4f7fc8a133", "url": "https://github.com/realm/realm-java/commit/39dc648bda9f102501af7d90375f4f4f7fc8a133", "message": "Added changeset methods and tests", "committedDate": "2020-11-13T15:47:24Z", "type": "commit"}, {"oid": "462a04b17c2803f9e8ab4cb77029b82b80aaed7b", "url": "https://github.com/realm/realm-java/commit/462a04b17c2803f9e8ab4cb77029b82b80aaed7b", "message": "Added final missing tests plus renamed two wrongly-named ones", "committedDate": "2020-11-16T09:38:39Z", "type": "commit"}, {"oid": "cdb3c5ba35b14601f56d299d7f6309819e033de4", "url": "https://github.com/realm/realm-java/commit/cdb3c5ba35b14601f56d299d7f6309819e033de4", "message": "Added missing methods in test factory", "committedDate": "2020-11-16T10:33:45Z", "type": "commit"}, {"oid": "e525c24b41d67adcc47cf58c9a6e48562dbda75d", "url": "https://github.com/realm/realm-java/commit/e525c24b41d67adcc47cf58c9a6e48562dbda75d", "message": "Added missing methods in test factory", "committedDate": "2020-11-16T11:31:26Z", "type": "commit"}, {"oid": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "url": "https://github.com/realm/realm-java/commit/7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "message": "Changed check for a closed realm instead of invalid object since findFirstAsync always returns \"invalid object\" right away, so we can't use isValid", "committedDate": "2020-11-16T21:14:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNzY1Mg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525007652", "bodyText": "Why is there a nullability check here when not for DynamicRealm?", "author": "cmelchior", "createdAt": "2020-11-17T09:30:47Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -96,6 +98,18 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n     return this.createEmbeddedObject(T::class.java, parentObject, parentProperty)\n }\n \n+/**\n+ * Creates a [Flow] for a [Realm]. It should emit the initial state of the Realm when subscribed to and\n+ * on each subsequent update of the Realm.\n+ *\n+ * @return Kotlin [Flow] that emit all updates to the Realm.\n+ */\n+@Beta\n+fun Realm.toflow(): Flow<Realm> {\n+    return configuration.flowFactory?.from(this)", "originalCommit": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMDA0Mg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525010042", "bodyText": "Normally we would do this to prevent accidental bugs to trigger the wrong failure:\nprivate RealmConfiguration.Builder builder =  configFactory.createConfigurationBuilder()\ntry {\n  builder.rxFactory(null)\n} catch (IllegalArgumentException e {\n  //...\n}", "author": "cmelchior", "createdAt": "2020-11-17T09:34:23Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java", "diffHunk": "@@ -796,6 +801,120 @@ public void rxFactory() {\n         assertFalse(configuration2.getRxFactory() == dummyFactory);\n     }\n \n+    @Test\n+    public void rxFactory_nullThrows() {\n+        try {\n+            configFactory.createConfigurationBuilder()", "originalCommit": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMjExNQ==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525012115", "bodyText": "The argument about frozen should also be exposed as a public constructor for this class, as people cannot otherwise customize it.", "author": "cmelchior", "createdAt": "2020-11-17T09:37:20Z", "path": "realm/realm-library/src/main/java/io/realm/coroutines/RealmFlowFactory.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.coroutines;\n+\n+import javax.annotation.Nonnull;\n+\n+import io.realm.DynamicRealm;\n+import io.realm.DynamicRealmObject;\n+import io.realm.Realm;\n+import io.realm.RealmList;\n+import io.realm.RealmModel;\n+import io.realm.RealmResults;\n+import io.realm.annotations.Beta;\n+import io.realm.internal.coroutines.InternalFlowFactory;\n+import io.realm.rx.CollectionChange;\n+import io.realm.rx.ObjectChange;\n+import kotlinx.coroutines.flow.Flow;\n+\n+/**\n+ * Factory class used to create coroutine {@link Flow}s.\n+ *\n+ * This class is used by default unless overridden in {@link io.realm.RealmConfiguration.Builder#flowFactory(FlowFactory}.\n+ */\n+@Beta\n+public class RealmFlowFactory implements FlowFactory {\n+\n+    private final InternalFlowFactory factory = new InternalFlowFactory(true);", "originalCommit": "7d59993e4dac2cb4e3a5bdd94c9f3b0c3bd8d8eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxNzgxNg==", "url": "https://github.com/realm/realm-java/pull/7191#discussion_r525017816", "bodyText": "That's true, I missed this one.", "author": "edualonso", "createdAt": "2020-11-17T09:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxMjExNQ=="}], "type": "inlineReview"}, {"oid": "da5f7d9684c139b3ba3d5b63662440c1743aaae7", "url": "https://github.com/realm/realm-java/commit/da5f7d9684c139b3ba3d5b63662440c1743aaae7", "message": "Cleanup", "committedDate": "2020-11-17T09:48:51Z", "type": "commit"}, {"oid": "0d0881d3ec4044d6be0ee912842b1eb6ef987cba", "url": "https://github.com/realm/realm-java/commit/0d0881d3ec4044d6be0ee912842b1eb6ef987cba", "message": "Added returnFrozenObjects parameter to factory constructor, added missing documentation and cleanup", "committedDate": "2020-11-17T10:07:18Z", "type": "commit"}, {"oid": "985779d31d5c6609ce9deb5c92f188967c4654c1", "url": "https://github.com/realm/realm-java/commit/985779d31d5c6609ce9deb5c92f188967c4654c1", "message": "Merge branch 'releases' into el/coroutines-factory", "committedDate": "2020-11-17T10:14:25Z", "type": "commit"}, {"oid": "0b313c854d7a88b73e95719b290d6d75beac6db9", "url": "https://github.com/realm/realm-java/commit/0b313c854d7a88b73e95719b290d6d75beac6db9", "message": "Updated changelog", "committedDate": "2020-11-17T10:14:37Z", "type": "commit"}]}