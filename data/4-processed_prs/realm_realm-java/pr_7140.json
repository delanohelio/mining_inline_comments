{"pr_number": 7140, "pr_title": "Fix flaky test: executeTransactionAwait", "pr_createdAt": "2020-10-02T09:14:41Z", "pr_url": "https://github.com/realm/realm-java/pull/7140", "timeline": [{"oid": "6225d019487e7b2c96a5f4f41c1cfb513401cfbe", "url": "https://github.com/realm/realm-java/commit/6225d019487e7b2c96a5f4f41c1cfb513401cfbe", "message": "Made executeTransactionAwait cooperative (although it won't cancel the transaction itself), fixed test so that it blocks until the coroutine job is cancelled, added two more tests with heavy transactions that explore cooperation for cancellation, added and fixed some documentation", "committedDate": "2020-10-02T09:10:03Z", "type": "commit"}, {"oid": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "url": "https://github.com/realm/realm-java/commit/92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "message": "Removed unused import", "committedDate": "2020-10-02T09:13:30Z", "type": "commit"}, {"oid": "415085112b2fb300ba008d463a376ddf119cb1d2", "url": "https://github.com/realm/realm-java/commit/415085112b2fb300ba008d463a376ddf119cb1d2", "message": "Improved clarification on cooperation in executeTransactionAwait method documentation", "committedDate": "2020-10-02T09:43:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMzMxNg==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498723316", "bodyText": "I see a Realm.close() in the setUp but there is no tearDown step, couldn't it leave an open instance after the last test execution?", "author": "clementetb", "createdAt": "2020-10-02T09:47:41Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -28,19 +27,14 @@ class CoroutineTests {\n     private lateinit var configuration: RealmConfiguration\n     private lateinit var testDispatcher: TestCoroutineDispatcher\n     private lateinit var testScope: TestCoroutineScope\n-    private lateinit var realm: Realm\n \n     @Before\n     fun setUp() {\n         testDispatcher = TestCoroutineDispatcher()\n         testScope = TestCoroutineScope(testDispatcher)\n         configuration = configFactory.createConfiguration()\n-        realm = Realm.getInstance(configuration)\n-    }\n \n-    @After\n-    fun tearDown() {", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMDA4Ng==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498730086", "bodyText": "No. I don't really need to use a global realm instance for these tests. Now instead I use Kotlin's use scope function, which receives the instance of the object you're calling it on (which has to be a Closeable) and calls close() automatically at the end of the closure.", "author": "edualonso", "createdAt": "2020-10-02T10:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMTQ5Ng==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498721496", "bodyText": "This doesn't actually do anything. Realm.getInstance() will increment the reference count and then close it again. But any other underlying Realms will not be closed.", "author": "cmelchior", "createdAt": "2020-10-02T09:43:57Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -28,19 +27,14 @@ class CoroutineTests {\n     private lateinit var configuration: RealmConfiguration\n     private lateinit var testDispatcher: TestCoroutineDispatcher\n     private lateinit var testScope: TestCoroutineScope\n-    private lateinit var realm: Realm\n \n     @Before\n     fun setUp() {\n         testDispatcher = TestCoroutineDispatcher()\n         testScope = TestCoroutineScope(testDispatcher)\n         configuration = configFactory.createConfiguration()\n-        realm = Realm.getInstance(configuration)\n-    }\n \n-    @After\n-    fun tearDown() {\n-        realm.close()\n+        Realm.getInstance(configuration).close()", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyODkzMg==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498728932", "bodyText": "I had to do this because I'm using a dynamic realm in one of the tests, so I would have a schema error if I don't have it.", "author": "edualonso", "createdAt": "2020-10-02T09:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMTQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyOTE1Mw==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498729153", "bodyText": "OK, you're right this is probably something else. I will remove it.", "author": "edualonso", "createdAt": "2020-10-02T10:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNDEwNw==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498724107", "bodyText": "Maybe wrap the underlying block in use instead of manually closing, because close will not be called if the awaitOrFails throws", "author": "cmelchior", "createdAt": "2020-10-02T09:49:17Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -134,6 +130,7 @@ class CoroutineTests {\n         val countDownLatch = CountDownLatch(1)\n \n         // Get results from the test thread\n+        val realm = Realm.getInstance(configuration)", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNDg3NA==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498724874", "bodyText": "Ah, nice. Didn't know this was possible \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-10-02T09:50:55Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -475,17 +473,90 @@ class CoroutineTests {\n         }\n \n         val countDownLatch = CountDownLatch(1)\n-        val otherMainScope = CoroutineScope(Dispatchers.Main)\n-        otherMainScope.launch {\n-            // Wait for 50 ms and cancel scope so that not all planned 10 elements are inserted\n+        CoroutineScope(Dispatchers.Main).launch {\n+            // Wait for 50 ms and cancel job so that not all planned 10 elements are inserted\n             delay(50)\n-            mainScope.cancel(\"Cancelling\")\n+            job.cancelAndJoin()\n+\n+            assertNotEquals(upperBound.toLong(), realmInstance!!.where<SimpleClass>().count())\n+\n+            realmInstance!!.close()\n+\n+            countDownLatch.countDown()\n+            this.cancel()\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait_cancelCoroutineWithHeavyCooperativeTransaction() {\n+        val upperBound = 10000\n+        var realmInstance: Realm? = null\n+\n+        val job = CoroutineScope(Dispatchers.Main).launch {\n+            realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance!!.executeTransactionAwait { transactionRealm ->\n+                for (i in 1..upperBound) {\n+                    // The coroutine itself will not cancel the transaction, but we can make it cooperative ourselves\n+                    if (isActive) {", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNzY5Mw==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498727693", "bodyText": "This delay feels a bit dangerous. 50ms is a long time and the first job might already have completed here?", "author": "cmelchior", "createdAt": "2020-10-02T09:56:55Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -475,17 +473,90 @@ class CoroutineTests {\n         }\n \n         val countDownLatch = CountDownLatch(1)\n-        val otherMainScope = CoroutineScope(Dispatchers.Main)\n-        otherMainScope.launch {\n-            // Wait for 50 ms and cancel scope so that not all planned 10 elements are inserted\n+        CoroutineScope(Dispatchers.Main).launch {\n+            // Wait for 50 ms and cancel job so that not all planned 10 elements are inserted\n             delay(50)\n-            mainScope.cancel(\"Cancelling\")\n+            job.cancelAndJoin()\n+\n+            assertNotEquals(upperBound.toLong(), realmInstance!!.where<SimpleClass>().count())\n+\n+            realmInstance!!.close()\n+\n+            countDownLatch.countDown()\n+            this.cancel()\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait_cancelCoroutineWithHeavyCooperativeTransaction() {\n+        val upperBound = 10000\n+        var realmInstance: Realm? = null\n+\n+        val job = CoroutineScope(Dispatchers.Main).launch {\n+            realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance!!.executeTransactionAwait { transactionRealm ->\n+                for (i in 1..upperBound) {\n+                    // The coroutine itself will not cancel the transaction, but we can make it cooperative ourselves\n+                    if (isActive) {\n+                        val simpleObject = SimpleClass().apply { name = \"simpleName $i\" }\n+                        transactionRealm.insert(simpleObject)\n+                    }\n+                }\n+            }\n+        }\n \n+        val countDownLatch = CountDownLatch(1)\n+        CoroutineScope(Dispatchers.Main).launch {\n+            // Wait for 50 ms and cancel job\n+            delay(10)\n+            job.cancelAndJoin()\n+\n+            // The coroutine won't finish until the transaction is completely done\n+            // but not all elements will have been inserted since the transaction is cooperative\n             assertNotEquals(upperBound.toLong(), realmInstance!!.where<SimpleClass>().count())\n \n             realmInstance!!.close()\n+\n             countDownLatch.countDown()\n-            otherMainScope.cancel()\n+            this.cancel()\n+        }\n+\n+        TestHelper.awaitOrFail(countDownLatch)\n+    }\n+\n+    @Test\n+    fun executeTransactionAwait_cancelCoroutineWithHeavyNonCooperativeTransaction() {\n+        val upperBound = 10000\n+        var realmInstance: Realm? = null\n+\n+        val job = CoroutineScope(Dispatchers.Main).launch {\n+            realmInstance = Realm.getInstance(configuration)\n+\n+            realmInstance!!.executeTransactionAwait { transactionRealm ->\n+                for (i in 1..upperBound) {\n+                    val simpleObject = SimpleClass().apply { name = \"simpleName $i\" }\n+                    transactionRealm.insert(simpleObject)\n+                }\n+            }\n+        }\n+\n+        val countDownLatch = CountDownLatch(1)\n+        CoroutineScope(Dispatchers.Main).launch {\n+            // Wait for 50 ms and cancel job\n+            delay(50)", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMDgxOA==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498730818", "bodyText": "True. I wrote 50ms because I had another delay of 10ms in the loop of transactions in the original test, which was enough. I will lower it.", "author": "edualonso", "createdAt": "2020-10-02T10:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNzY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNzg1NA==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498727854", "bodyText": "Maybe wrap with use to preven leakage if the test fails.", "author": "cmelchior", "createdAt": "2020-10-02T09:57:17Z", "path": "realm/kotlin-extensions/src/androidTest/kotlin/io/realm/CoroutineTests.kt", "diffHunk": "@@ -495,20 +566,26 @@ class CoroutineTests {\n     fun executeTransactionAwait_throwsDueToThreadViolation() {\n         // Just to prevent the test to end prematurely\n         val countDownLatch = CountDownLatch(1)\n+        val realm = Realm.getInstance(configuration)", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyODA3Ng==", "url": "https://github.com/realm/realm-java/pull/7140#discussion_r498728076", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * realmInstance.executeTransactionAwait { transactionRealm ->\n          \n          \n            \n             * realm.executeTransactionAwait { transactionRealm ->", "author": "cmelchior", "createdAt": "2020-10-02T09:57:45Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -97,6 +99,21 @@ inline fun <reified T : RealmModel> Realm.createEmbeddedObject(parentObject: Rea\n /**\n  * Suspend version of [Realm.executeTransaction] to use within coroutines.\n  *\n+ * Canceling the scope or job in which this function is executed does not cancel the transaction itself. If you want to ensure\n+ * your transaction is cooperative, you have to check for the value of [CoroutineScope.isActive] while running the transaction:\n+ *\n+ * ```\n+ * // insert 100 objects\n+ * realmInstance.executeTransactionAwait { transactionRealm ->", "originalCommit": "92cd01e6949bd371b3b717ccb6ff5d6bd16ae7ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d289e005f899ce27f5c352d0bbabbbb64e152f2", "url": "https://github.com/realm/realm-java/commit/3d289e005f899ce27f5c352d0bbabbbb64e152f2", "message": "Removed conceptually wrong test as it cannot be guaranteed that the coroutine is not cancelled before running the transaction. Improved documentation in that regard too.", "committedDate": "2020-10-02T11:09:28Z", "type": "commit"}]}