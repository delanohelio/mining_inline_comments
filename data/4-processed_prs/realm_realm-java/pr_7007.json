{"pr_number": 7007, "pr_title": "Add tests for syncing embedded objects", "pr_createdAt": "2020-07-27T20:48:35Z", "pr_url": "https://github.com/realm/realm-java/pull/7007", "timeline": [{"oid": "0026b1844580047a14c176caf378f987059904ba", "url": "https://github.com/realm/realm-java/commit/0026b1844580047a14c176caf378f987059904ba", "message": "wip", "committedDate": "2020-07-23T14:49:43Z", "type": "commit"}, {"oid": "88dbf726f4b83c3737d3774c5c170c035515972d", "url": "https://github.com/realm/realm-java/commit/88dbf726f4b83c3737d3774c5c170c035515972d", "message": "Seems we can't set children to managed parents when using sync. In addition, sync doesn't allow calls to *OrUpdate to update a constant parent with a different child", "committedDate": "2020-07-26T22:17:29Z", "type": "commit"}, {"oid": "20b35d87bbd1b448d272041b7999d83e5a0774c7", "url": "https://github.com/realm/realm-java/commit/20b35d87bbd1b448d272041b7999d83e5a0774c7", "message": "Fixed broken test", "committedDate": "2020-07-29T09:16:10Z", "type": "commit"}, {"oid": "6318bafc94b7143bfae04d593df612f1e407aba3", "url": "https://github.com/realm/realm-java/commit/6318bafc94b7143bfae04d593df612f1e407aba3", "message": "Merge branch 'v10' into el/embedded-objects-sync", "committedDate": "2020-08-03T09:59:08Z", "type": "commit"}, {"oid": "7af323f5dddb0f28b7e4f37ce3a6e60b7eccd6e5", "url": "https://github.com/realm/realm-java/commit/7af323f5dddb0f28b7e4f37ce3a6e60b7eccd6e5", "message": "Added ignore to failing test due to server error", "committedDate": "2020-08-04T09:02:03Z", "type": "commit"}, {"oid": "babf0ef5793aaed0a493e5a227835dcf83640307", "url": "https://github.com/realm/realm-java/commit/babf0ef5793aaed0a493e5a227835dcf83640307", "message": "Merge branch 'v10' into el/embedded-objects-sync\n\n# Conflicts:\n#\trealm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "committedDate": "2020-08-07T09:28:22Z", "type": "commit"}, {"oid": "79cef318e87830aae00666dc0dee0065b74ee42a", "url": "https://github.com/realm/realm-java/commit/79cef318e87830aae00666dc0dee0065b74ee42a", "message": "Added test for embedded tree structures but ignored due to existing bug server-side", "committedDate": "2020-08-07T11:18:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NjA3Nw==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466996077", "bodyText": "Is this always true? Wouldn't the sync potentially already have fetched stuff.", "author": "rorbech", "createdAt": "2020-08-07T12:01:40Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())", "originalCommit": "79cef318e87830aae00666dc0dee0065b74ee42a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NjY3MQ==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467076671", "bodyText": "I thought of adding this because I was debugging something else a number of times and I found it curious that the local realm never had any objects at this point. I guess in all fairness that the synchronisation process could just be slow, so making this assumption might not be correct. I will delete it.", "author": "edualonso", "createdAt": "2020-08-07T14:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5ODQ0Nw==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466998447", "bodyText": "Maybe also verify that the children are actually embedded in the parent.", "author": "rorbech", "createdAt": "2020-08-07T12:06:18Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)", "originalCommit": "79cef318e87830aae00666dc0dee0065b74ee42a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5OTk2MA==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r466999960", "bodyText": "I would prefer explicit naming to avoid confusion.", "author": "rorbech", "createdAt": "2020-08-07T12:09:22Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)", "originalCommit": "79cef318e87830aae00666dc0dee0065b74ee42a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwMTI2Ng==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467001266", "bodyText": "Do we have a reference to the issue?", "author": "rorbech", "createdAt": "2020-08-07T12:11:55Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/sync/SyncedRealmTests.kt", "diffHunk": "@@ -232,6 +239,222 @@ class SyncedRealmTests {\n         }\n     }\n \n+    @Test\n+    fun embeddedObject_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                realm.createObject<EmbeddedSimpleParent>(primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    // FIXME: remove ignore when sync issue fixed\n+    @Test\n+    @Ignore(\"ignored until https://jira.mongodb.org/browse/REALMC-6541 is fixed\")\n+    fun embeddedObject_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+\n+        Realm.getInstance(config1).use { realm ->\n+            assertTrue(realm.isEmpty)\n+\n+            realm.executeTransaction {\n+                val parent = EmbeddedSimpleParent(primaryKeyValue)\n+\n+//                parent.child = EmbeddedSimpleChild()\n+                val managedParent = it.copyToRealmOrUpdate(parent)\n+                // FIXME: instantiating the child in managedParent yields this from sync:\n+                //  \"MongoDB error: Updating the path 'child.childID' would create a conflict at 'child'\"\n+                managedParent.child = EmbeddedSimpleChild() // Will copy the object to Realm\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(1, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleParent>()\n+            assertEquals(1, parentResults.count())\n+            val parent = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parent._id)\n+            assertEquals(parent._id, parent.child!!.parent._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(EmbeddedSimpleListParent::class.java, primaryKeyValue).let { parent ->\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                    realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, \"children\")\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(5, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+        }\n+    }\n+\n+    @Test\n+    fun embeddedObject_realmList_copyUnmanaged_roundTrip() {\n+        val user1: User = createNewUser()\n+        val config1: SyncConfiguration = createDefaultConfig(user1, partitionValue)\n+        val primaryKeyValue = UUID.randomUUID().toString()\n+        Realm.getInstance(config1).use { realm ->\n+            realm.executeTransaction {\n+                EmbeddedSimpleListParent(primaryKeyValue).apply {\n+                    children = RealmList(EmbeddedSimpleChild(\"child1\"), EmbeddedSimpleChild(\"child2\"))\n+                    it.insert(this)\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+\n+            assertEquals(1, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        }\n+\n+        val user2: User = createNewUser()\n+        val config2: SyncConfiguration = createDefaultConfig(user2, partitionValue)\n+        Realm.getInstance(config2).use { realm ->\n+            assertEquals(0, realm.where<EmbeddedSimpleListParent>().count())\n+            assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+\n+            realm.syncSession.downloadAllServerChanges(1, TimeUnit.SECONDS).let {\n+                if (!it) fail()\n+            }\n+            realm.refresh()\n+\n+            val childResults = realm.where<EmbeddedSimpleChild>()\n+            assertEquals(2, childResults.count())\n+            val parentResults = realm.where<EmbeddedSimpleListParent>()\n+            assertEquals(1, parentResults.count())\n+            val parentFromResults = parentResults.findFirst()!!\n+            assertEquals(primaryKeyValue, parentFromResults._id)\n+            assertEquals(\"child1\", childResults.findAll()[0]!!.childId)\n+            assertEquals(\"child2\", childResults.findAll()[1]!!.childId)\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"Enable when a bug server-side is fixed\")", "originalCommit": "79cef318e87830aae00666dc0dee0065b74ee42a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwNjE1Ng==", "url": "https://github.com/realm/realm-java/pull/7007#discussion_r467006156", "bodyText": "I've just got feedback from Nikola, I'll update when creating a ticket for them \ud83d\udc4d", "author": "edualonso", "createdAt": "2020-08-07T12:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAwMTI2Ng=="}], "type": "inlineReview"}, {"oid": "a95ba2d2d3d8fb009b16c8b3e8bcc06cddc614fb", "url": "https://github.com/realm/realm-java/commit/a95ba2d2d3d8fb009b16c8b3e8bcc06cddc614fb", "message": "Removed tree-structure classes from remote config schema until https://jira.mongodb.org/projects/HELP/queues/issue/HELP-17759 is fixed", "committedDate": "2020-08-07T14:30:49Z", "type": "commit"}]}