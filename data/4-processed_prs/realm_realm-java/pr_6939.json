{"pr_number": 6939, "pr_title": "Migrate and reenable sync realm integration test ", "pr_createdAt": "2020-06-10T14:39:58Z", "pr_url": "https://github.com/realm/realm-java/pull/6939", "timeline": [{"oid": "87308e5a76e091d67fc2afd2be50a05076bb310b", "url": "https://github.com/realm/realm-java/commit/87308e5a76e091d67fc2afd2be50a05076bb310b", "message": "Move SyncedRealmIntegrationTests to Kotlin source set", "committedDate": "2020-06-09T09:18:53Z", "type": "commit"}, {"oid": "592ca9e3bf6c4592c3b1e43c4ed2630c0ebe1b14", "url": "https://github.com/realm/realm-java/commit/592ca9e3bf6c4592c3b1e43c4ed2630c0ebe1b14", "message": "Automatic conversion of SyncedRealmIntegrationTests to Kotlin", "committedDate": "2020-06-09T09:20:28Z", "type": "commit"}, {"oid": "6c4cbebf004ba9f6d8fbd2f8ff409e434aa73871", "url": "https://github.com/realm/realm-java/commit/6c4cbebf004ba9f6d8fbd2f8ff409e434aa73871", "message": "Update to new Sync implementation and Kotlin", "committedDate": "2020-06-10T14:30:11Z", "type": "commit"}, {"oid": "e8de581890b1a233e6703b4539f4711f629e76c2", "url": "https://github.com/realm/realm-java/commit/e8de581890b1a233e6703b4539f4711f629e76c2", "message": "Merge branch 'v10' into cr/sync-integration-test-realm", "committedDate": "2020-06-24T07:10:57Z", "type": "commit"}, {"oid": "185bb0adfc106ee36feb8be7a75c04d145922fe2", "url": "https://github.com/realm/realm-java/commit/185bb0adfc106ee36feb8be7a75c04d145922fe2", "message": "Merge branch 'v10' into cr/sync-integration-test-realm", "committedDate": "2020-06-30T07:18:11Z", "type": "commit"}, {"oid": "0b7ca9a048ebbab34aca9cd14b265ba28b60c136", "url": "https://github.com/realm/realm-java/commit/0b7ca9a048ebbab34aca9cd14b265ba28b60c136", "message": "Clean up", "committedDate": "2020-06-30T07:21:41Z", "type": "commit"}, {"oid": "d98e193a4ef840b09b38a80e36c9aa8bb5a1a2e3", "url": "https://github.com/realm/realm-java/commit/d98e193a4ef840b09b38a80e36c9aa8bb5a1a2e3", "message": "Merge branch 'v10' into cr/sync-integration-test-realm", "committedDate": "2020-08-04T11:33:29Z", "type": "commit"}, {"oid": "edba5df6d179e03470ae3561d695ba2771e93abf", "url": "https://github.com/realm/realm-java/commit/edba5df6d179e03470ae3561d695ba2771e93abf", "message": "Enable readOnly in read only test", "committedDate": "2020-08-07T13:18:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MTEwMQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478461101", "bodyText": "Just delete this test", "author": "cmelchior", "createdAt": "2020-08-27T14:27:23Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/AppConfigurationTests.kt", "diffHunk": "@@ -297,4 +309,61 @@ class AppConfigurationTests {\n                     assertEquals(defaultHttpLogObfuscator, it.httpLogObfuscator)\n                 }\n     }\n+    // Check that custom headers and auth header renames are correctly used for HTTP requests\n+    // performed from Java.\n+    @Test\n+    fun javaRequestCustomHeaders() {\n+        var app: App? = null\n+        try {\n+            looperThread.runBlocking {\n+                app = TestApp(builder = { builder ->\n+                    builder.addCustomRequestHeader(CUSTOM_HEADER_NAME, CUSTOM_HEADER_VALUE)\n+                    builder.authorizationHeaderName(AUTH_HEADER_NAME)\n+                })\n+                runJavaRequestCustomHeadersTest(app!!)\n+            }\n+        } finally {\n+            app?.close()\n+        }\n+    }\n+\n+    // FIXME Seems to be outdated...cannot find an option for setting headers for a specific host", "originalCommit": "edba5df6d179e03470ae3561d695ba2771e93abf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478462578", "bodyText": "Hmm, I think I saw something about this being fixed. Try talking to @RedBeard0531", "author": "cmelchior", "createdAt": "2020-08-27T14:29:15Z", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been", "originalCommit": "edba5df6d179e03470ae3561d695ba2771e93abf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMTExNQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480921115", "bodyText": "The old issue #5416 is still open. I have tried incorporating the shutdown_and_wait from realm/realm-object-store#1055 but had various issue around it. In some of the other tests referring to #5416 I was not able to get hold of the session and other places like here it did not work out. Reapplied a workaround from another test by retried to close if it fails.", "author": "rorbech", "createdAt": "2020-09-01T07:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4MzQzNA==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480983434", "bodyText": "Maybe related to some internal notification triggering to early due to realm/realm-object-store#1054", "author": "rorbech", "createdAt": "2020-09-01T09:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MzEzNQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478463135", "bodyText": "Yes", "author": "cmelchior", "createdAt": "2020-08-27T14:29:58Z", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case", "originalCommit": "edba5df6d179e03470ae3561d695ba2771e93abf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NDE5OQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478464199", "bodyText": "Great, we should probably still keep the test as a kind of smoke test.", "author": "cmelchior", "createdAt": "2020-08-27T14:31:21Z", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense", "originalCommit": "edba5df6d179e03470ae3561d695ba2771e93abf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTE5OA==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r478465198", "bodyText": "We cannot test this in dev mode, since the server will just create the schema.\nMaybe if we have a model class with a specific property that has a different type on the the client than on the server.\nWe can add this class as part of the server setup?", "author": "cmelchior", "createdAt": "2020-08-27T14:32:42Z", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import android.util.Log\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.SyncDog\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.log.RealmLogger\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.util.assertFailsWithErrorCode\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import java.util.concurrent.CountDownLatch\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicBoolean\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        // FIXME Is this sufficient to test \"loginLogoutResumeSynching\"-case\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null\n+                assertFailsWith<DownloadingRealmInterruptedException> {\n+                    Thread.currentThread().interrupt()\n+                    Realm.getInstance(config).close()\n+                }\n+                // FIXME Seems like the file is actually created before interrupted. Is this check\n+                //  correct?\n+                 assertFalse(File(config.getPath()).exists())\n+                // FIXME This can throw IllegalStateException as the realm is maybe not closed\n+                //  properly due to https://github.com/realm/realm-java/issues/5416\n+                Realm.deleteRealm(config)\n+            })\n+            t.start()\n+            t.join()\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    // FIXME This does not throw anymore as described in issue. But do the test still make sense\n+    //  with new sync?\n+    //@Ignore(\"See https://github.com/realm/realm-java/issues/5373\")\n+    fun waitForInitialData_resilientInCaseOfRetriesAsync() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .waitForInitialRemoteData()\n+                .build()\n+        val randomizer = Random()\n+        for (i in 0..9) {\n+            val task = Realm.getInstanceAsync(config, object : Realm.Callback() {\n+                override fun onSuccess(realm: Realm) { fail() }\n+                override fun onError(exception: Throwable) { fail(exception.toString()) }\n+            })\n+            SystemClock.sleep(randomizer.nextInt(5).toLong())\n+            task.cancel()\n+        }\n+        // Leave some time for the async callbacks to actually get through\n+        looperThread.postRunnableDelayed(\n+                Runnable { looperThread.testComplete() },\n+                1000\n+        )\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData_readOnlyTrue() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should\n+        // download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        Realm.getInstance(configNew).use { realm ->\n+            assertEquals(10, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        user.logOut()\n+    }\n+\n+    @Test\n+    // FIXME\n+    @Ignore(\"Not really sure how to do this test with new sync\")\n+    fun waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {\n+        val configNew: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .readOnly()\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        assertFalse(configNew.testRealmExists())\n+        assertFailsWith<RealmMigrationNeededException> {\n+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the\n+            // schema.\n+            // FIXME Does not throw. How to test schema migration with new sync when server is in dev mode", "originalCommit": "edba5df6d179e03470ae3561d695ba2771e93abf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE2NTA2MQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r480165061", "bodyText": "Seems to work if the class is just not known on the server, so introduce a class for this purpose.", "author": "rorbech", "createdAt": "2020-08-31T14:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTE5OA=="}], "type": "inlineReview"}, {"oid": "be2056b5810d52d16ddeca1d50e46c3ba07b493b", "url": "https://github.com/realm/realm-java/commit/be2056b5810d52d16ddeca1d50e46c3ba07b493b", "message": "Merge branch 'v10' into cr/sync-integration-test-realm", "committedDate": "2020-08-31T09:01:01Z", "type": "commit"}, {"oid": "88c0427df19e0686901a2f996530afc2f6ea820a", "url": "https://github.com/realm/realm-java/commit/88c0427df19e0686901a2f996530afc2f6ea820a", "message": "Add missing imports after merge", "committedDate": "2020-08-31T14:08:21Z", "type": "commit"}, {"oid": "a33af43300576882ed2345227b9eafa31eb665db", "url": "https://github.com/realm/realm-java/commit/a33af43300576882ed2345227b9eafa31eb665db", "message": "Fix ignored SyncedRealmIntegrationTests", "committedDate": "2020-08-31T14:13:06Z", "type": "commit"}, {"oid": "807b8fe084ae2715c471c20e27151a76285b5e53", "url": "https://github.com/realm/realm-java/commit/807b8fe084ae2715c471c20e27151a76285b5e53", "message": "Fix ignored SyncSessionTests", "committedDate": "2020-08-31T21:40:35Z", "type": "commit"}, {"oid": "68c99ba1e44b67136a2e0ddf80409054c79d2a34", "url": "https://github.com/realm/realm-java/commit/68c99ba1e44b67136a2e0ddf80409054c79d2a34", "message": "Expose OS sync session's shutdown_and_wait for test", "committedDate": "2020-08-31T22:16:39Z", "type": "commit"}, {"oid": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "url": "https://github.com/realm/realm-java/commit/d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "message": "Ignored flaky waitForInitialData_resilientInCaseOfRetries test", "committedDate": "2020-09-01T06:55:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482906742", "bodyText": "Shouldn't we wait for the transaction to complete to call this?", "author": "clementetb", "createdAt": "2020-09-03T11:28:51Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ProgressListenerTests.kt", "diffHunk": "@@ -290,6 +300,83 @@ class ProgressListenerTests {\n         }\n     }\n \n+    @Test\n+    @Ignore(\"FIXME: Flacky: Tracked by https://github.com/realm/realm-java/issues/6976\")\n+    fun progressListenersWorkWhenUsingWaitForInitialRemoteData() = looperThread.runBlocking {\n+        val username = UUID.randomUUID().toString()\n+        val password = \"password\"\n+        var user: User = app.registerUserAndLogin(username, password)\n+\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()", "originalCommit": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyNjk2OQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r484526969", "bodyText": "The transaction are synchronous. ??", "author": "rorbech", "createdAt": "2020-09-07T17:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUzNzY1OQ==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r484537659", "bodyText": "Yes, they are \ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f", "author": "clementetb", "createdAt": "2020-09-07T18:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxODc3Mw==", "url": "https://github.com/realm/realm-java/pull/6939#discussion_r482918773", "bodyText": "Exceptions and assertions on a custom thread will crash the test app. It will stop the test process and will not yield any results.\nCheck using BlockingLooperThread.runDetached", "author": "clementetb", "createdAt": "2020-09-03T11:51:47Z", "path": "realm/realm-library/src/syncIntegrationTest/kotlin/io/realm/SyncedRealmIntegrationTests.kt", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import android.os.SystemClock\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.DefaultSyncSchema\n+import io.realm.entities.StringOnly\n+import io.realm.entities.SyncSchemeMigration\n+import io.realm.entities.SyncStringOnly\n+import io.realm.exceptions.DownloadingRealmInterruptedException\n+import io.realm.exceptions.RealmMigrationNeededException\n+import io.realm.internal.OsRealmConfig\n+import io.realm.kotlin.syncSession\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.mongodb.*\n+import io.realm.mongodb.sync.*\n+import io.realm.objectserver.utils.Constants\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonObjectId\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.Ignore\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.io.File\n+import java.util.*\n+import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+\n+private const val SECRET_PASSWORD = \"123456\"\n+\n+/**\n+ * Catch all class for tests that not naturally fit anywhere else.\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmIntegrationTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var app: App\n+    private lateinit var user: User\n+    private lateinit var syncConfiguration: SyncConfiguration\n+\n+    private val configurationFactory: TestSyncConfigurationFactory = TestSyncConfigurationFactory()\n+\n+    @Before\n+    fun setup() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        RealmLog.setLevel(LogLevel.ALL)\n+        app = TestApp()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        syncConfiguration = configurationFactory\n+                // TODO We generate new partition value for each test to avoid overlaps in data. We\n+                //  could make test booting with a cleaner state by somehow flushing data between\n+                //  tests.\n+                .createSyncConfigurationBuilder(user, BsonObjectId(ObjectId()))\n+                .modules(DefaultSyncSchema())\n+                .build()\n+    }\n+\n+    @After\n+    fun teardown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    @Test\n+    fun loginLogoutResumeSyncing() = looperThread.runBlocking {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction {\n+                realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo\"\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+            user.logOut()\n+        }\n+        try {\n+            assertTrue(Realm.deleteRealm(config))\n+        } catch (e: IllegalStateException) {\n+            // TODO: We don't have a way to ensure that the Realm instance on client thread has been\n+            //  closed for now https://github.com/realm/realm-java/issues/5416\n+            if (e.message!!.contains(\"It's not allowed to delete the file\")) {\n+                // retry after 1 second\n+                SystemClock.sleep(1000)\n+                assertTrue(Realm.deleteRealm(config))\n+            }\n+        }\n+\n+        user = app.login(Credentials.emailPassword(user.email, SECRET_PASSWORD))\n+        val config2: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .build()\n+        Realm.getInstance(config2).use { realm ->\n+            realm.syncSession.downloadAllServerChanges()\n+            realm.refresh()\n+            assertEquals(1, realm.where(SyncStringOnly::class.java).count())\n+        }\n+        looperThread.testComplete()\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    fun waitForInitialRemoteData_mainThreadThrows() {\n+        val user: User = SyncTestUtils.createTestUser(app)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        assertFailsWith<java.lang.IllegalStateException> {\n+            Realm.getInstance(config).close()\n+        }\n+    }\n+\n+    @Test\n+    fun waitForInitialRemoteData() {\n+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)\n+        val configOld: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .testSessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)\n+                .build()\n+        Realm.getInstance(configOld).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo$i\"\n+                }\n+            }\n+            realm.syncSession.uploadAllLocalChanges()\n+        }\n+        user.logOut()\n+\n+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with\n+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).\n+        // Use different user to trigger different path\n+        val user2 = app.registerUserAndLogin(TestHelper.getRandomEmail(), SECRET_PASSWORD)\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user2, user.id)\n+                .testSchema(SyncStringOnly::class.java)\n+                .waitForInitialRemoteData()\n+                .build()\n+        Realm.getInstance(config).use { realm ->\n+            realm.executeTransaction { realm ->\n+                for (i in 0..9) {\n+                    realm.createObject(SyncStringOnly::class.java, ObjectId()).chars = \"Foo 1$i\"\n+                }\n+            }\n+            assertEquals(20, realm.where(SyncStringOnly::class.java).count())\n+        }\n+    }\n+\n+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that\n+    // We cannot do much better since we cannot control the order of events internally in Realm which would be\n+    // needed to correctly test all error paths.\n+    @Test\n+    @Ignore(\"Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw \" +\n+            \" https://github.com/realm/realm-java/issues/5416\")\n+    fun waitForInitialData_resilientInCaseOfRetries() {\n+        val config: SyncConfiguration = configurationFactory.createSyncConfigurationBuilder(user, user.id)\n+                .waitForInitialRemoteData()\n+                .build()\n+        for (i in 0..9) {\n+            val t = Thread(Runnable {\n+                var realm: Realm? = null", "originalCommit": "d6a05d4557fd3ff71fea08e6acca384fbf9382e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b677dccd86503c682f938f93178bbfc04526b033", "url": "https://github.com/realm/realm-java/commit/b677dccd86503c682f938f93178bbfc04526b033", "message": "Avoid native threads in SyncedRealmIntegrationTests", "committedDate": "2020-09-08T06:50:08Z", "type": "commit"}, {"oid": "697482ad5ad7aaad6fbb0cf45a359fde05b8df41", "url": "https://github.com/realm/realm-java/commit/697482ad5ad7aaad6fbb0cf45a359fde05b8df41", "message": "Include previously ignored test", "committedDate": "2020-09-08T06:53:28Z", "type": "commit"}, {"oid": "898168f8bfcc8713cf1eb7d687b023ddebae110c", "url": "https://github.com/realm/realm-java/commit/898168f8bfcc8713cf1eb7d687b023ddebae110c", "message": "Remove irrelevant FIXME", "committedDate": "2020-09-08T06:57:53Z", "type": "commit"}, {"oid": "2ea96d961fcc0a60b8a2290cce52d8cee20bd941", "url": "https://github.com/realm/realm-java/commit/2ea96d961fcc0a60b8a2290cce52d8cee20bd941", "message": "Reignoring flaky SyncedRealmIntegrationTest", "committedDate": "2020-09-08T08:26:55Z", "type": "commit"}, {"oid": "9bebf5221a05051304d45e1b2a67e76decf23153", "url": "https://github.com/realm/realm-java/commit/9bebf5221a05051304d45e1b2a67e76decf23153", "message": "Merge branch 'v10' into cr/sync-integration-test-realm", "committedDate": "2020-09-15T08:18:28Z", "type": "commit"}, {"oid": "dc0e72032739020a2adc6f1c1f21b4c9af2685a1", "url": "https://github.com/realm/realm-java/commit/dc0e72032739020a2adc6f1c1f21b4c9af2685a1", "message": "Fix after merge", "committedDate": "2020-09-15T10:33:42Z", "type": "commit"}]}