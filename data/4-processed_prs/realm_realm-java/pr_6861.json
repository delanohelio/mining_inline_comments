{"pr_number": 6861, "pr_title": "Migrate and reenable SyncedRealmMigrationTests", "pr_createdAt": "2020-05-15T16:23:23Z", "pr_url": "https://github.com/realm/realm-java/pull/6861", "timeline": [{"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "url": "https://github.com/realm/realm-java/commit/ec59608977043ec9a0fb92532f5426edfcc65ab7", "message": "Migrate and reenable SyncedRealmMigrationTests", "committedDate": "2020-05-15T16:21:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426412451", "bodyText": "I think this Rule can largely be replaced with assertFailsWith ?", "author": "cmelchior", "createdAt": "2020-05-18T07:13:55Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()", "originalCommit": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMDc1OQ==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426530759", "bodyText": "Yes, I have it stashed somewhere as my unit tests of the implementation failed as it was not possible to assertFailsWith on an AssertError. I will give it another try if you also see the potential.", "author": "rorbech", "createdAt": "2020-05-18T10:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDE2MQ==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074161", "bodyText": "Added a assertFailsWithMessage<T>(Matcher<in String?>, () -> Unit) in KotlinTestUtils", "author": "rorbech", "createdAt": "2020-05-19T07:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMjQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzg2MQ==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426413861", "bodyText": "Does this needs to be a MutableList? Any reason not to just use val list = listOf(expectedObjectSchema) ?", "author": "cmelchior", "createdAt": "2020-05-18T07:17:04Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()", "originalCommit": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDI4Mw==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074283", "bodyText": "No. Updated", "author": "rorbech", "createdAt": "2020-05-19T07:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxMzg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426414718", "bodyText": "Instead of the ExpectedException rule, perhaps we should create our own variant of assetFailsWith that takes the expected error string, so you can do something like\nassertFailsWith<IllegalStateException)(\"The following changes cannot be made in additive-only schema mode:\") {\n  Realm.getInstance(config)\n}", "author": "cmelchior", "createdAt": "2020-05-18T07:19:02Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.IndexedFields\n+import io.realm.entities.PrimaryKeyAsString\n+import io.realm.entities.StringOnly\n+import io.realm.internal.OsObjectSchemaInfo\n+import io.realm.internal.OsRealmConfig\n+import io.realm.internal.OsSchemaInfo\n+import io.realm.internal.OsSharedRealm\n+import org.hamcrest.CoreMatchers\n+import org.junit.*\n+import org.junit.rules.ExpectedException\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Testing methods around migrations for Realms using a [SyncConfiguration].\n+ */\n+@RunWith(AndroidJUnit4::class)\n+class SyncedRealmMigrationTests {\n+\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val thrown = ExpectedException.none()\n+\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun migrateRealm_syncConfigurationThrows() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app)).build()\n+        assertFailsWith<IllegalArgumentException> {\n+            Realm.migrateRealm(config)\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added\n+    // automatically.\n+    @Test\n+    fun addField_worksWithMigrationError() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with missing fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className) // Create empty class\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            assertTrue(realm.schema[className]!!.hasField(StringOnly.FIELD_CHARS)) // Field has been added\n+        }\n+    }\n+\n+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.\n+    // The underlying field should not be deleted, just hidden.\n+    @Test\n+    fun missingFields_hiddenSilently() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(StringOnly::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with too many fields)\n+        val className = StringOnly::class.java.simpleName\n+        DynamicRealm.getInstance(config).use { dynamicRealm ->\n+            val schema = dynamicRealm.schema\n+            dynamicRealm.executeTransaction {\n+                schema.create(className)\n+                        .addField(StringOnly.FIELD_CHARS, String::class.java)\n+                        .addField(\"newField\", String::class.java)\n+                // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an\n+                // error branch. That is not a real case.\n+                dynamicRealm.version = 0\n+            }\n+        }\n+\n+        // Open typed Realm, which will validate the schema\n+        Realm.getInstance(config).use { realm ->\n+            val stringOnlySchema = realm.schema[className]!!\n+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS))\n+            assertTrue(stringOnlySchema.hasField(\"newField\"))\n+            assertEquals(2, stringOnlySchema.fieldNames.size.toLong())\n+        }\n+    }\n+\n+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key\n+    @Test\n+    fun breakingSchemaChange_throws() {\n+        val config = configFactory.createSyncConfigurationBuilder(createTestUser(app))\n+                .schema(PrimaryKeyAsString::class.java)\n+                .build()\n+\n+        // Setup initial Realm schema (with a different primary key)\n+        val expectedObjectSchema = OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)\n+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)\n+                .build()\n+        val list: MutableList<OsObjectSchemaInfo> = ArrayList()\n+        list.add(expectedObjectSchema)\n+        val schemaInfo = OsSchemaInfo(list)\n+        val configBuilder = OsRealmConfig.Builder(config).schemaInfo(schemaInfo)\n+        OsSharedRealm.getInstance(configBuilder, OsSharedRealm.VersionID.LIVE).close()\n+        thrown.expectMessage(\n+                CoreMatchers.containsString(\"The following changes cannot be made in additive-only schema mode:\"))\n+        thrown.expect(IllegalStateException::class.java)\n+        Realm.getInstance(config)", "originalCommit": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzMTIwNg==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r426531206", "bodyText": "Yep, see details on ealier comment.", "author": "rorbech", "createdAt": "2020-05-18T10:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3NDg1Mg==", "url": "https://github.com/realm/realm-java/pull/6861#discussion_r427074852", "bodyText": "Using the previously mentioned assertFailsWithMessage: https://github.com/realm/realm-java/pull/6861/files#diff-c94fbae13da3fa85fe77b8c175bbe010R134", "author": "rorbech", "createdAt": "2020-05-19T07:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxNDcxOA=="}], "type": "inlineReview"}, {"oid": "13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "url": "https://github.com/realm/realm-java/commit/13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "message": "Review comments updates", "committedDate": "2020-05-18T20:20:58Z", "type": "commit"}, {"oid": "0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "url": "https://github.com/realm/realm-java/commit/0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "message": "Merge branch 'v10' into cr/sync-test-migration-syncedrealmmigration", "committedDate": "2020-05-18T20:21:29Z", "type": "commit"}, {"oid": "93b3c09550cc3e9bb88238e3664a5b155cd2c58d", "url": "https://github.com/realm/realm-java/commit/93b3c09550cc3e9bb88238e3664a5b155cd2c58d", "message": "Merge branch 'v10' into cr/sync-test-migration-syncedrealmmigration", "committedDate": "2020-05-25T11:58:47Z", "type": "commit"}]}