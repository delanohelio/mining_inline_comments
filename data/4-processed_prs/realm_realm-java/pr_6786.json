{"pr_number": 6786, "pr_title": "Add support for ApiKeyAuthProvider", "pr_createdAt": "2020-03-27T08:43:16Z", "pr_url": "https://github.com/realm/realm-java/pull/6786", "timeline": [{"oid": "392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "url": "https://github.com/realm/realm-java/commit/392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "message": "Add support for ApiKeyAuthProvider", "committedDate": "2020-03-27T08:37:08Z", "type": "commit"}, {"oid": "5137c16ae8e151b471790a14a4c499ddc902904c", "url": "https://github.com/realm/realm-java/commit/5137c16ae8e151b471790a14a4c499ddc902904c", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/main/cpp/CMakeLists.txt\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmApp.java\n#\trealm/realm-library/src/testUtils/java/io/realm/TestHelper.java", "committedDate": "2020-03-29T21:50:41Z", "type": "commit"}, {"oid": "59a0cd0c111216375910a78209da24f4a34b5007", "url": "https://github.com/realm/realm-java/commit/59a0cd0c111216375910a78209da24f4a34b5007", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmUser.java", "committedDate": "2020-04-01T08:03:48Z", "type": "commit"}, {"oid": "2a3951c9c135046ed066e64f8adcc136b67c4b42", "url": "https://github.com/realm/realm-java/commit/2a3951c9c135046ed066e64f8adcc136b67c4b42", "message": "Cleanup", "committedDate": "2020-04-01T11:27:41Z", "type": "commit"}, {"oid": "0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "url": "https://github.com/realm/realm-java/commit/0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "message": "Bump minSdk for kotlin-extensions", "committedDate": "2020-04-01T11:31:31Z", "type": "commit"}, {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "url": "https://github.com/realm/realm-java/commit/4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "message": "Set minSdk for examples", "committedDate": "2020-04-01T11:48:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4MzMyOQ==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402183329", "bodyText": "It can be", "author": "edualonso", "createdAt": "2020-04-02T09:40:33Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDgxMA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184810", "bodyText": "Not sure I understand The keys value. Do you mean the value of the key?", "author": "edualonso", "createdAt": "2020-04-02T09:42:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDkxNw==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184917", "bodyText": "Same as above.", "author": "edualonso", "createdAt": "2020-04-02T09:43:06Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTIwOA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185208", "bodyText": "It can be", "author": "edualonso", "createdAt": "2020-04-02T09:43:31Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTM5OA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185398", "bodyText": "this this", "author": "edualonso", "createdAt": "2020-04-02T09:43:52Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "url": "https://github.com/realm/realm-java/commit/4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "message": "Doc updates", "committedDate": "2020-04-02T12:54:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTY1NQ==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402405655", "bodyText": "is the order of keys guarantee/stable ?", "author": "nhachicha", "createdAt": "2020-04-02T15:29:58Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/ApiKeyAuthProviderTests.kt", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.annotation.UiThreadTest\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.log.LogLevel\n+import io.realm.log.RealmLog\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.types.ObjectId\n+import org.junit.After\n+import org.junit.Assert.*\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class ApiKeyAuthProviderTests {\n+\n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+    private lateinit var admin: ServerAdmin\n+    private lateinit var user: RealmUser\n+    private lateinit var provider: ApiKeyAuthProvider\n+\n+    // Callback use to verify that an Illegal Argument was thrown from async methods\n+    private val checkNullInVoidCallback = RealmApp.Callback<Void> { result ->\n+        if (result.isSuccess) {\n+            fail()\n+        } else {\n+            assertEquals(ErrorCode.UNKNOWN, result.error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    private val checkNullInApiKeyCallback = RealmApp.Callback<RealmUserApiKey> { result ->\n+        if (result.isSuccess) {\n+            fail()\n+        } else {\n+            assertEquals(ErrorCode.UNKNOWN, result.error.errorCode)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    // Methods exposed by the EmailPasswordAuthProvider\n+    enum class Method {\n+        CREATE,\n+        FETCH_SINGLE,\n+        FETCH_ALL,\n+        DELETE,\n+        ENABLE,\n+        DISABLE\n+    }\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        RealmLog.setLevel(LogLevel.DEBUG)\n+        admin = ServerAdmin()\n+        user = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        provider = app.apiKeyAuthProvider\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close()\n+        admin.deleteAllUsers()\n+        RealmLog.setLevel(LogLevel.WARN)\n+    }\n+\n+    inline fun testNullArg(method: () -> Unit) {\n+        try {\n+            method()\n+            fail()\n+        } catch (ignore: IllegalArgumentException) {\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKey() {\n+        val key: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        assertEquals(\"my-key\", key.name)\n+        assertNotNull(\"my-key\", key.value)\n+        assertNotNull(\"my-key\", key.id)\n+        assertTrue(\"my-key\", key.isEnabled)\n+    }\n+\n+    @Test\n+    fun createApiKey_invalidServerArgsThrows() {\n+        try {\n+            provider.createApiKey(\"%s\")\n+            fail()\n+        } catch (e: ObjectServerError) {\n+            assertEquals(ErrorCode.INVALID_PARAMETER, e.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKey_invalidArgumentThrows() {\n+        testNullArg { provider.createApiKey(TestHelper.getNull()) }\n+        testNullArg { provider.createApiKey(\"\") }\n+        looperThread.runBlocking {\n+            provider.createApiKeyAsync(TestHelper.getNull(), checkNullInApiKeyCallback)\n+        }\n+        looperThread.runBlocking {\n+            provider.createApiKeyAsync(\"\", checkNullInApiKeyCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKeyAsync() = looperThread.runBlocking {\n+        provider.createApiKeyAsync(\"my-key\") { result ->\n+            val key = result.orThrow\n+            assertEquals(\"my-key\", key.name)\n+            assertNotNull(\"my-key\", key.value)\n+            assertNotNull(\"my-key\", key.id)\n+            assertTrue(\"my-key\", key.isEnabled)\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun createApiKeyAsync_invalidServerArgsThrows() = looperThread.runBlocking {\n+        provider.createApiKeyAsync(\"%s\") { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else {\n+                assertEquals(ErrorCode.INVALID_PARAMETER, result.error.errorCode)\n+                looperThread.testComplete()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKey() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        val key2: RealmUserApiKey = provider.fetchApiKey(key1.id)\n+\n+        assertEquals(key1.id, key2.id)\n+        assertEquals(key1.name, key2.name)\n+        assertNull(key2.value)\n+        assertEquals(key1.isEnabled, key2.isEnabled)\n+    }\n+\n+    @Test\n+    fun fetchApiKey_nonExistingKey() {\n+        try {\n+            provider.fetchApiKey(ObjectId())\n+            fail()\n+        } catch (e: ObjectServerError) {\n+            assertEquals(ErrorCode.API_KEY_NOT_FOUND, e.errorCode)\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKey_invalidArgumentThrows() {\n+        testNullArg { provider.fetchApiKey(TestHelper.getNull()) }\n+        looperThread.runBlocking {\n+            provider.fetchApiKeyAsync(TestHelper.getNull(), checkNullInApiKeyCallback)\n+        }\n+    }\n+\n+    @Test\n+    fun fetchApiKeyAsync() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        looperThread.runBlocking {\n+            provider.fetchApiKeyAsync(key1.id) { result ->\n+                val key2 = result.orThrow\n+                assertEquals(key1.id, key2.id)\n+                assertEquals(key1.name, key2.name)\n+                assertNull(key2.value)\n+                assertEquals(key1.isEnabled, key2.isEnabled)\n+                looperThread.testComplete()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun fetchAllApiKeys() {\n+        val key1: RealmUserApiKey = provider.createApiKey(\"my-key\")\n+        val key2: RealmUserApiKey = provider.createApiKey(\"other-key\")\n+        val allKeys: List<RealmUserApiKey> = provider.fetchAllApiKeys()", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5NjYzMw==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402796633", "bodyText": "That is up to the server, so I don't think we can depend on it. I have rewritten the test to take this into account.", "author": "cmelchior", "createdAt": "2020-04-03T07:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMjE4OA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402422188", "bodyText": "is the provider considered disabled when the user logs out?", "author": "nhachicha", "createdAt": "2020-04-02T15:52:59Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppTests.kt", "diffHunk": "@@ -267,4 +267,22 @@ class RealmAppTests {\n         } catch (ignore: IllegalStateException) {\n         }\n     }\n+\n+    @Test\n+    fun getApiKeyAuthProvider() {\n+        val user1: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider1: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+        val user2: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider2: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+\n+        assertNotEquals(provider1, provider2)\n+        user2.logOut()", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5NzcxNQ==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402797715", "bodyText": "Yes, the provider only works with a logged in user", "author": "cmelchior", "createdAt": "2020-04-03T07:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyNTAzOA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402425038", "bodyText": "This is confusing to me, apiKeyAuthProvider should be related to (an API of) RealmUser ... why it is exposed via the RealmApp ?", "author": "nhachicha", "createdAt": "2020-04-02T15:56:42Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppTests.kt", "diffHunk": "@@ -267,4 +267,22 @@ class RealmAppTests {\n         } catch (ignore: IllegalStateException) {\n         }\n     }\n+\n+    @Test\n+    fun getApiKeyAuthProvider() {\n+        val user1: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider1: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+        val user2: RealmUser = app.registerUserAndLogin(TestHelper.getRandomEmail(), \"123456\")\n+        val provider2: ApiKeyAuthProvider = app.apiKeyAuthProvider\n+\n+        assertNotEquals(provider1, provider2)\n+        user2.logOut()\n+        assertEquals(provider1, app.apiKeyAuthProvider)\n+        user1.logOut()\n+        try {\n+            app.apiKeyAuthProvider", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4NjU3NA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402786574", "bodyText": "I agree. The API is currently pulling in two directions. One where things are on RealmUser and the other where it is on RealmApp.\nI'll discuss this with the other teams so we can come to an agreement. E.g. logOut and getDefaultConfiguration() are currently on RealmUser.\nI think we need to either make the RealmApp behave like a \"user\"  with all the methods and then RealmUser is just a wrapper around meta data or let RealmUser contain all of the methods like in the old Realm API.\nIs it okay to merge as is and then do a discussion/cleanup later?", "author": "cmelchior", "createdAt": "2020-04-03T07:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyNTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5NjQ2Mg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402996462", "bodyText": "sure, let's revisit this later", "author": "nhachicha", "createdAt": "2020-04-03T13:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyNTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzMDcyNg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402430726", "bodyText": "The \"java/lang/Object\" jclass is already looked up in java_class_global_def.hpp,  add definition of\ninline static const jni_util::JavaClass& java_lang_object()\n    {\n        return instance()->m_java_lang_object;\n    }\nand use it here", "author": "nhachicha", "createdAt": "2020-04-02T16:04:46Z", "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzMjk2MA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402432960", "bodyText": "name is required not the key?", "author": "nhachicha", "createdAt": "2020-04-02T16:07:52Z", "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4NTI5Mg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402785292", "bodyText": "name is a description made by the user. The key is considered a secret, so it is only returned the first time you create the ApiKey. Just like e.g. GitHub hides the key after you created it.", "author": "cmelchior", "createdAt": "2020-04-03T07:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzMjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQzNTY2Mg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402435662", "bodyText": "use java_lang_object()", "author": "nhachicha", "createdAt": "2020-04-02T16:11:52Z", "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));\n+    env->SetObjectArrayElement(arr, 3, JavaClassGlobalDef::new_boolean(env, key.disabled));\n+    return arr;\n+}\n+\n+// Shared mapper function for mapping UserApiKey to Java Object[]\n+static std::function<jobject(JNIEnv*, App::UserAPIKey)> single_key_mapper = [](JNIEnv* env, App::UserAPIKey key) {\n+    return map_key(env, key);\n+};\n+\n+// Shared mapper function for mapping Vector<UserApiKey> to Java Object[][]\n+static std::function<jobject(JNIEnv*, std::vector<App::UserAPIKey>)> multi_key_mapper = [](JNIEnv* env, std::vector<App::UserAPIKey> keys) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(keys.size()), env->FindClass(\"java/lang/Object\"), NULL);", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MzI1NQ==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402443255", "bodyText": "Is there a length/format requirement of the name we should check for upfront?", "author": "nhachicha", "createdAt": "2020-04-02T16:23:06Z", "path": "realm/realm-library/src/main/cpp/io_realm_ApiKeyAuthProvider.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include \"io_realm_ApiKeyAuthProvider.h\"\n+\n+#include \"java_network_transport.hpp\"\n+#include \"util.hpp\"\n+#include \"jni_util/java_method.hpp\"\n+#include \"jni_util/jni_utils.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n+\n+#include <realm/util/optional.hpp>\n+#include <sync/app.hpp>\n+\n+using namespace realm;\n+using namespace realm::app;\n+using namespace realm::jni_util;\n+using namespace realm::_impl;\n+\n+static jobjectArray map_key(JNIEnv* env, App::UserAPIKey& key)\n+{\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(4, env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return API key.\");\n+        return NULL;\n+    }\n+    std::string api_key_id = key.id.to_string();\n+    env->SetObjectArrayElement(arr, 0, to_jstring(env, api_key_id));\n+    env->SetObjectArrayElement(arr, 1, (key.key) ? to_jstring(env, key.key) : NULL);\n+    env->SetObjectArrayElement(arr, 2, to_jstring(env, key.name));\n+    env->SetObjectArrayElement(arr, 3, JavaClassGlobalDef::new_boolean(env, key.disabled));\n+    return arr;\n+}\n+\n+// Shared mapper function for mapping UserApiKey to Java Object[]\n+static std::function<jobject(JNIEnv*, App::UserAPIKey)> single_key_mapper = [](JNIEnv* env, App::UserAPIKey key) {\n+    return map_key(env, key);\n+};\n+\n+// Shared mapper function for mapping Vector<UserApiKey> to Java Object[][]\n+static std::function<jobject(JNIEnv*, std::vector<App::UserAPIKey>)> multi_key_mapper = [](JNIEnv* env, std::vector<App::UserAPIKey> keys) {\n+    jobjectArray arr = (jobjectArray)env->NewObjectArray(static_cast<jsize>(keys.size()), env->FindClass(\"java/lang/Object\"), NULL);\n+    if (arr == NULL) {\n+        ThrowException(env, OutOfMemory, \"Could not allocate memory to return list of API keys.\");\n+        return arr;\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        env->SetObjectArrayElement(arr, i, map_key(env, keys[i]));\n+    }\n+    return arr;\n+};\n+\n+JNIEXPORT void JNICALL Java_io_realm_ApiKeyAuthProvider_nativeCallFunction(JNIEnv* env,\n+                                                                           jclass,\n+                                                                           jint j_function_type,\n+                                                                           jlong j_app_ptr,\n+                                                                           jlong j_user_ptr,\n+                                                                           jstring j_arg,\n+                                                                           jobject j_callback)\n+{\n+    try {\n+        App* app = reinterpret_cast<App*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+        auto client = app->provider_client<App::UserAPIKeyProviderClient>();\n+        switch(j_function_type) {\n+            case io_realm_ApiKeyAuthProvider_TYPE_CREATE: {\n+                JStringAccessor name(env, j_arg);\n+                auto callback = JavaNetworkTransport::create_result_callback(env, j_callback, single_key_mapper);\n+                client.create_api_key(name, user, callback);", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NzI2OA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402857268", "bodyText": "None that I know of.", "author": "cmelchior", "createdAt": "2020-04-03T08:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0NjA4OA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402446088", "bodyText": "add\ninline static const jni_util::JavaClass& java_lang_object()\n    {\n        return instance()->m_java_lang_object;\n    }\nto be used", "author": "nhachicha", "createdAt": "2020-04-02T16:27:33Z", "path": "realm/realm-library/src/main/cpp/java_class_global_def.hpp", "diffHunk": "@@ -61,6 +62,7 @@ class JavaClassGlobalDef {\n     jni_util::JavaClass m_java_util_date;\n     jni_util::JavaClass m_java_lang_string;\n     jni_util::JavaClass m_java_lang_boolean;\n+    jni_util::JavaClass m_java_lang_object;", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2ODY2Mg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402668662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was fetched or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:19:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTI3Mw==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402669273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the keys were fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the keys were fetched or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:22:12Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDQ3MA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402670470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was deleted or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was deleted or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:26:31Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTYyMA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402671620", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was enabled or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was enabled or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:30:26Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask deleteApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous deleting an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                deleteApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @throws ObjectServer if the server failed to disable the API key.\n+     */\n+    public void disableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DISABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @param callback callback used when the the key was disabled or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask disableApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous disabling an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                disableApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @throws ObjectServer if the server failed to enable the API key.\n+     */\n+    public void enableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_ENABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @param callback callback used when the the key was enabled or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b941b1817dfe13a62a13f30155f0d14291467789", "url": "https://github.com/realm/realm-java/commit/b941b1817dfe13a62a13f30155f0d14291467789", "message": "PR feedback", "committedDate": "2020-04-03T08:57:17Z", "type": "commit"}, {"oid": "e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "url": "https://github.com/realm/realm-java/commit/e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "message": "Missed using global def", "committedDate": "2020-04-03T08:59:31Z", "type": "commit"}]}