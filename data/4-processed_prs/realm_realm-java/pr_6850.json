{"pr_number": 6850, "pr_title": "Migrating schema tests for sync", "pr_createdAt": "2020-05-13T10:42:50Z", "pr_url": "https://github.com/realm/realm-java/pull/6850", "timeline": [{"oid": "3d479d4e6574995d501133341b1caa2325d37ccb", "url": "https://github.com/realm/realm-java/commit/3d479d4e6574995d501133341b1caa2325d37ccb", "message": "Move SchemaTests to kotlin source set", "committedDate": "2020-05-13T09:03:20Z", "type": "commit"}, {"oid": "fae69e4a3cc4dda8a9b3cd25ee347521557fefbb", "url": "https://github.com/realm/realm-java/commit/fae69e4a3cc4dda8a9b3cd25ee347521557fefbb", "message": "Auto convert SchemaTests to Kotlin", "committedDate": "2020-05-13T09:04:14Z", "type": "commit"}, {"oid": "22306a28d3449f6f99e95b0105c8eb524e03197d", "url": "https://github.com/realm/realm-java/commit/22306a28d3449f6f99e95b0105c8eb524e03197d", "message": "Update tests to Kotlin", "committedDate": "2020-05-13T10:36:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4NzQwNA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424387404", "bodyText": "In other test cases we used private lateinit var app instead. It does require an rather awkard check in tearDown but all other callsites will look \"nicer\"", "author": "cmelchior", "createdAt": "2020-05-13T12:12:06Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4NzcxNQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424387715", "bodyText": "It should be safe to let this be a lateinit so we can loose the null assertions everywhere.", "author": "cmelchior", "createdAt": "2020-05-13T12:12:42Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424388881", "bodyText": "Normally we closed any Realms in the tearDown method instead of using try-with-resources. I do realize that it is a lot easier to express in Kotlin, but unless we decide to change it everywhere I think we should stick to the same pattern in this class. Thoughts?", "author": "cmelchior", "createdAt": "2020-05-13T12:14:45Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNjAxNw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424426017", "bodyText": "The reason was just to get a feeling whether it was nicer/better/etc., and to get some insight for future API decisions. There are certainly also cases which favor explicit try-finally way of doing it, maybe even this specific case, as we need to access it after its closed.\nOtherwise I think use would be the right way to go for inlining getInstance with the block that uses it. I would not deem it necessary to change everywhere just for changing it. But I can reapply the conventional pattern if you find it better to stick to one pattern.", "author": "rorbech", "createdAt": "2020-05-13T13:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMDgwOA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424430808", "bodyText": "True, it is being accessed after being closed in this test. I actually missed that \ud83d\udc4d. In that case, using realm.use { } is probably the most appropriate here.\nGenerally, we have closed Realm instances in tearDown so you didn't have to remember it for every single test, but this class might be a little different\nBut is there a reason you didn't use realm.use here: https://github.com/realm/realm-java/pull/6850/files#diff-a8a31a8a737fec196f4a54bda8e2c9aeR61 ?", "author": "cmelchior", "createdAt": "2020-05-13T13:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzOTA3MA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424439070", "bodyText": "Yes, I stopped applying it after I realized that we should maybe discuss the approach.\nI guess use is exactly solving the problem of not forgetting it as it is automatically closed when leaving the block. To handle it in tearDown we would then need to have it as a property with late init, etc.\nThe motivation for use in this test, was explicitly that we honoured the contract of closing it if people actually uses use.", "author": "rorbech", "createdAt": "2020-05-13T13:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MzE0OA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424443148", "bodyText": "Yeah, In java it was a bit easier, because you could just have a null-check in tearDown... Checking if the lateinit var is initialized feels a bit like a hack.\nI suspect this is a case where we need to experiment a little to see what makes sense and then we probably need a roundtable discussion to settle on something.\nBut for now, this is fine \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-05-13T13:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwMDk2NQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424600965", "bodyText": "I ended up applying the use pattern throughout the file, as some of the old tests were not always calling realm.close() on exceptions which caused the overall execution to fail. We can then use it as input for discussions and revert if needed.", "author": "rorbech", "createdAt": "2020-05-13T17:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4OTA2MA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424389060", "bodyText": "Assert could be a static import here and in the rest of the class. This is most likely an artifact of the automatic Kotlin code conversion. We use static method imports in all other test classes.", "author": "cmelchior", "createdAt": "2020-05-13T12:15:03Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MDE4MA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424390180", "bodyText": "We only allow \"Additive\" changes for Synced Realms, because if you remove a class on the server you will break all existing clients that are not aware of this, and due to how apps are distributed, this is impossible to control.\nWe had thoughts of adding controls to the server so only clients from a specific version were allowed to connect, but until we add something like that destructive schema changes are not allowed.", "author": "cmelchior", "createdAt": "2020-05-13T12:17:04Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))\n+        val stringOnly = realm.createObject(StringOnly::class.java)\n+        stringOnly.chars = \"TEST\"\n+        realm.commitTransaction()\n+        Assert.assertEquals(1, realm.where(StringOnly::class.java).count())\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_removeClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MDU2NQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424390565", "bodyText": "Yes, this should be UnsupportedOperation instead. Looks like a mistake here and we should fix it, but it is a breaking change, so will require a note in the CHANGELOG.md", "author": "cmelchior", "createdAt": "2020-05-13T12:17:43Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))\n+        val stringOnly = realm.createObject(StringOnly::class.java)\n+        stringOnly.chars = \"TEST\"\n+        realm.commitTransaction()\n+        Assert.assertEquals(1, realm.where(StringOnly::class.java).count())\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_removeClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+        //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+        assertFailsWith<java.lang.IllegalArgumentException> {", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwMjM0MA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424602340", "bodyText": "They should now be aligned. I have also added test cases for the other destructive  updates that could throw exceptions for this reason.", "author": "rorbech", "createdAt": "2020-05-13T17:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MDU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MTI1OA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424391258", "bodyText": "Same as above.", "author": "cmelchior", "createdAt": "2020-05-13T12:18:54Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))\n+        val stringOnly = realm.createObject(StringOnly::class.java)\n+        stringOnly.chars = \"TEST\"\n+        realm.commitTransaction()\n+        Assert.assertEquals(1, realm.where(StringOnly::class.java).count())\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_removeClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+        //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+        assertFailsWith<java.lang.IllegalArgumentException> {\n+            realm.schema.remove(className)\n+        }\n+        realm.cancelTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"Dogplace\"\n+        realm.beginTransaction()\n+        realm.schema.create(\"Dogplace\")\n+        realm.commitTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_renameClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        DynamicRealm.getInstance(config!!).use { realm ->\n+            val existingClass = \"StringOnly\"\n+            val newClass = \"Dogplace\"\n+            realm.beginTransaction()\n+            assertFailsWith<java.lang.IllegalArgumentException> {", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MjE2NQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424392165", "bodyText": "In other tests, we have done val objectSchema = realm.schema[className]!!. This triggers the assertion closer to where the error is instead of the first time the schema is being used. So it makes the error more clear IMO\nYou also avoid having to use !! in all the places the objectSchema is accessed. E.g. the test below checks 3 times for this.", "author": "cmelchior", "createdAt": "2020-05-13T12:20:20Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))\n+        val stringOnly = realm.createObject(StringOnly::class.java)\n+        stringOnly.chars = \"TEST\"\n+        realm.commitTransaction()\n+        Assert.assertEquals(1, realm.where(StringOnly::class.java).count())\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_removeClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+        //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+        assertFailsWith<java.lang.IllegalArgumentException> {\n+            realm.schema.remove(className)\n+        }\n+        realm.cancelTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"Dogplace\"\n+        realm.beginTransaction()\n+        realm.schema.create(\"Dogplace\")\n+        realm.commitTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_renameClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        DynamicRealm.getInstance(config!!).use { realm ->\n+            val existingClass = \"StringOnly\"\n+            val newClass = \"Dogplace\"\n+            realm.beginTransaction()\n+            assertFailsWith<java.lang.IllegalArgumentException> {\n+                // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+                //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+                realm.schema.rename(existingClass, newClass)\n+            }\n+            Assert.assertFalse(realm.schema.contains(newClass))\n+            realm.cancelTransaction()\n+            Assert.assertTrue(realm.schema.contains(existingClass))\n+            Assert.assertFalse(realm.schema.contains(newClass))\n+        }\n+    }\n+\n+    @Test\n+    fun disallow_removeField() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        val fieldName = \"chars\"\n+        val objectSchema = realm.schema[className]\n+        Assert.assertNotNull(objectSchema)\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> {\n+            // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+            //  Shouldn't this be UnsupportedOperation to be consistent with ex. addPrimaryKey, etc.\n+            objectSchema.removeField(fieldName)\n+        }\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.cancelTransaction()\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val className = \"StringOnly\"\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val objectSchema = realm.schema[className]\n+        Assert.assertNotNull(objectSchema)\n+        realm.beginTransaction()\n+        objectSchema!!.addField(\"foo\", String::class.java)", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MzE3OA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424393178", "bodyText": "Yes, this is correct. Primary keys cannot be changed when using sync. They had good reasons, but I cannot remember them right now.", "author": "cmelchior", "createdAt": "2020-05-13T12:22:04Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.runner.RunWith\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    private var config: SyncConfiguration? = null\n+    private var app: TestRealmApp? = null\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app!!)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (app != null) {\n+            app!!.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        Assert.assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        val realm = Realm.getInstance(config!!)\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(\"StringOnly\"))\n+        val stringOnly = realm.createObject(StringOnly::class.java)\n+        stringOnly.chars = \"TEST\"\n+        realm.commitTransaction()\n+        Assert.assertEquals(1, realm.where(StringOnly::class.java).count())\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_removeClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        realm.beginTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+        //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+        assertFailsWith<java.lang.IllegalArgumentException> {\n+            realm.schema.remove(className)\n+        }\n+        realm.cancelTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"Dogplace\"\n+        realm.beginTransaction()\n+        realm.schema.create(\"Dogplace\")\n+        realm.commitTransaction()\n+        Assert.assertTrue(realm.schema.contains(className))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun disallow_renameClass() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        DynamicRealm.getInstance(config!!).use { realm ->\n+            val existingClass = \"StringOnly\"\n+            val newClass = \"Dogplace\"\n+            realm.beginTransaction()\n+            assertFailsWith<java.lang.IllegalArgumentException> {\n+                // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+                //  Shouldn't this be UnsupportedOperation to be consistent with ex. addField, etc.\n+                realm.schema.rename(existingClass, newClass)\n+            }\n+            Assert.assertFalse(realm.schema.contains(newClass))\n+            realm.cancelTransaction()\n+            Assert.assertTrue(realm.schema.contains(existingClass))\n+            Assert.assertFalse(realm.schema.contains(newClass))\n+        }\n+    }\n+\n+    @Test\n+    fun disallow_removeField() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val className = \"StringOnly\"\n+        val fieldName = \"chars\"\n+        val objectSchema = realm.schema[className]\n+        Assert.assertNotNull(objectSchema)\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> {\n+            // FIXME Why? We cannot update a sync schema \"destructively\"? -> Update Doc\n+            //  Shouldn't this be UnsupportedOperation to be consistent with ex. addPrimaryKey, etc.\n+            objectSchema.removeField(fieldName)\n+        }\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.cancelTransaction()\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val className = \"StringOnly\"\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val objectSchema = realm.schema[className]\n+        Assert.assertNotNull(objectSchema)\n+        realm.beginTransaction()\n+        objectSchema!!.addField(\"foo\", String::class.java)\n+        Assert.assertTrue(objectSchema.hasField(\"foo\"))\n+        realm.commitTransaction()\n+        Assert.assertTrue(objectSchema.hasField(\"foo\"))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun addPrimaryKey_notAllowed() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val className = \"StringOnly\"\n+        val fieldName = \"chars\"\n+        val realm = DynamicRealm.getInstance(config!!)\n+        val objectSchema = realm.schema[className]\n+        Assert.assertNotNull(objectSchema)\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.beginTransaction()\n+        assertFailsWith<java.lang.UnsupportedOperationException> {\n+            objectSchema.addPrimaryKey(fieldName)\n+        }\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.cancelTransaction()\n+        Assert.assertTrue(objectSchema!!.hasField(fieldName))\n+        realm.close()\n+    }\n+\n+    @Test\n+    fun addField_withPrimaryKeyModifier_notAllowed() {\n+        // Init schema\n+        Realm.getInstance(config!!).close()\n+        val className = \"StringOnly\"\n+\n+        DynamicRealm.getInstance(config!!).use {realm ->\n+            realm.beginTransaction()\n+            val objectSchema = realm.schema[className]\n+            Assert.assertNotNull(objectSchema)\n+            // FIXME Is this in sync with expectations? Seems to be due to immutable scheme but test", "originalCommit": "22306a28d3449f6f99e95b0105c8eb524e03197d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9038ce0f8911b8da1693a8cd7afadabb8c00881b", "url": "https://github.com/realm/realm-java/commit/9038ce0f8911b8da1693a8cd7afadabb8c00881b", "message": "Late initing common test variables", "committedDate": "2020-05-13T12:54:18Z", "type": "commit"}, {"oid": "24bfc4007e03ea427d96cb8cbeaf1551b7a653a2", "url": "https://github.com/realm/realm-java/commit/24bfc4007e03ea427d96cb8cbeaf1551b7a653a2", "message": "Align exceptions on destructive updates of schema of synced realms", "committedDate": "2020-05-13T17:00:22Z", "type": "commit"}, {"oid": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "url": "https://github.com/realm/realm-java/commit/86af421b38b99f0559e91c25c648eec4dcff2c0d", "message": "Align `use` pattern across all SchemeTests", "committedDate": "2020-05-13T17:04:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTU2OA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424651568", "bodyText": "3 things:\n\nThis doesn't sound right. MutableRealmSchema is used by local Dynamic Realms, Local typed and Synced Realms (both Dynamic and normal) use ImmutableRealmSchema.\nMutableRealmSchema/ImmutableRealmSchema is hidden from the public API's. Users do now \"know\" of these classes. They only know of RealmSchema and RealmObjectSchema\nUsing / as seperator between class and method looks a bit weird. Normally we have used Class.Method() in the past`", "author": "cmelchior", "createdAt": "2020-05-13T18:38:51Z", "path": "CHANGELOG.md", "diffHunk": "@@ -3,6 +3,7 @@\n ### Breaking Changes\n * Removed all references and API's releated to permissions. These are now managed through MongoDB Realm. Read more [here](XXX).\n * Removed Query Based Sync API's and Subscriptions. These API's are not initially supported by MongoDB Realm. They will be re-introduced in a future release. `SyncConfiguration.partionKey()` has been added as a replacement. Read more [here](XXX).  \n+* Destructive updates of a schema of a synced Realm will now consistently throw an `UnsupportedOperationException` instead of some methods throwing `IllegalArgumentException`. The affected methods are `RealmSchema/MutableRealmSchema.{remove,rename}` and `RealmObjectSchema/MutableRealmObjectSchema.{setClassName,removeField,renameField,removeIndex,removePrimaryKey,addPrimaryKey,addField}` ", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNDQ1Ng==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424734456", "bodyText": "I tried to clean up. Remove the immutable/mutable classes and named all the methods explicitly.", "author": "rorbech", "createdAt": "2020-05-13T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MjIzMA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424652230", "bodyText": "Nitpick. You could use realm.executeTransaction { } here. I think we started using this in most places since it is the best practise method (since it automatically cancels in case of exceptions).", "author": "cmelchior", "createdAt": "2020-05-13T18:39:59Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MzA3MQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424653071", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        realm.schema.create(\"Dogplace\")\n          \n          \n            \n                        realm.schema.create(className)", "author": "cmelchior", "createdAt": "2020-05-13T18:41:17Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MzE4Mw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424653183", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        val objectSchema = realm.schema[className]\n          \n          \n            \n                        val objectSchema = realm.schema[className]!!", "author": "cmelchior", "createdAt": "2020-05-13T18:41:28Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MzI3OA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424653278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        objectSchema!!.addField(\"foo\", String::class.java)\n          \n          \n            \n                        objectSchema.addField(\"foo\", String::class.java)", "author": "cmelchior", "createdAt": "2020-05-13T18:41:38Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MzM4OQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424653389", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        val objectSchema = realm.schema[className]\n          \n          \n            \n                        val objectSchema = realm.schema[className]!!", "author": "cmelchior", "createdAt": "2020-05-13T18:41:50Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+            realm.commitTransaction()\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+        }\n+    }\n+\n+    // Special column \"__OID\" should be hidden from users.\n+    @Test\n+    fun fieldNames_stableIdColumnShouldBeHidden() {\n+        val className = \"StringOnly\"\n+        Realm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MzQ4NA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424653484", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        val names = objectSchema!!.fieldNames\n          \n          \n            \n                        val names = objectSchema.fieldNames", "author": "cmelchior", "createdAt": "2020-05-13T18:41:59Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+            realm.commitTransaction()\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+        }\n+    }\n+\n+    // Special column \"__OID\" should be hidden from users.\n+    @Test\n+    fun fieldNames_stableIdColumnShouldBeHidden() {\n+        val className = \"StringOnly\"\n+        Realm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            val names = objectSchema!!.fieldNames", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NDY0Mw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424654643", "bodyText": "Note, that the schema classes used by Realm/DynamicRealm are different, so these tests actually only test DynamicRealms. It is still valuable but would rename the test to disallowDestructiveUpdateOfSyncedDynamicRealm", "author": "cmelchior", "createdAt": "2020-05-13T18:43:55Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+            realm.commitTransaction()\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+        }\n+    }\n+\n+    // Special column \"__OID\" should be hidden from users.\n+    @Test\n+    fun fieldNames_stableIdColumnShouldBeHidden() {\n+        val className = \"StringOnly\"\n+        Realm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            val names = objectSchema!!.fieldNames\n+            assertEquals(1, names.size)\n+            assertEquals(StringOnly.FIELD_CHARS, names.iterator().next())\n+        }\n+    }\n+\n+    enum class DestructiveSchemaOperation {\n+        REMOVE_CLASS,\n+        RENAME_CLASS,\n+        SET_CLASS_NAME,\n+        REMOVE_FIELD,\n+        RENAME_FIELD,\n+        REMOVE_INDEX,\n+        REMOVE_PRIMARY_KEY,\n+        ADD_PRIMARY_KEY,\n+        ADD_FIELD_PRIMARY_KEY,\n+    }\n+\n+    @Test\n+    fun disallowDestructiveUpdateOfSyncedRealm() {", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMzE2MQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424733161", "bodyText": "Ok", "author": "rorbech", "createdAt": "2020-05-13T21:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NDY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTMzOA==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424655338", "bodyText": "Normally we have a default case that always fail, to ensure that the test will fail if we add more enums and forget to update tests.", "author": "cmelchior", "createdAt": "2020-05-13T18:45:04Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+            realm.commitTransaction()\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+        }\n+    }\n+\n+    // Special column \"__OID\" should be hidden from users.\n+    @Test\n+    fun fieldNames_stableIdColumnShouldBeHidden() {\n+        val className = \"StringOnly\"\n+        Realm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            val names = objectSchema!!.fieldNames\n+            assertEquals(1, names.size)\n+            assertEquals(StringOnly.FIELD_CHARS, names.iterator().next())\n+        }\n+    }\n+\n+    enum class DestructiveSchemaOperation {\n+        REMOVE_CLASS,\n+        RENAME_CLASS,\n+        SET_CLASS_NAME,\n+        REMOVE_FIELD,\n+        RENAME_FIELD,\n+        REMOVE_INDEX,\n+        REMOVE_PRIMARY_KEY,\n+        ADD_PRIMARY_KEY,\n+        ADD_FIELD_PRIMARY_KEY,\n+    }\n+\n+    @Test\n+    fun disallowDestructiveUpdateOfSyncedRealm() {\n+        for (operation in DestructiveSchemaOperation.values()) {\n+            // Init schema\n+            Realm.getInstance(config).close()\n+            val className = \"StringOnly\"\n+            val newClassName = \"Dogplace\"\n+            val fieldName = \"chars\"\n+            val newFieldName = \"newchars\"\n+\n+            DynamicRealm.getInstance(config).use { realm ->\n+                assertTrue(realm.schema.contains(className))\n+                val objectSchema = realm.schema[className]!!\n+                assertNotNull(objectSchema)\n+                assertTrue(objectSchema.hasField(fieldName))\n+\n+                realm.beginTransaction()\n+                errorCollector.assertFailsWith<UnsupportedOperationException> {\n+                    when (operation) {", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTk3Mw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424655973", "bodyText": "Is this something we should as a general extension method? Perhaps move to KotlinTestUtils in that case then", "author": "cmelchior", "createdAt": "2020-05-13T18:46:10Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SchemaTests.kt", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2016 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.SyncTestUtils.Companion.createTestUser\n+import io.realm.entities.StringOnly\n+import junit.framework.Assert.*\n+import junit.framework.TestCase\n+import org.junit.*\n+import org.junit.rules.ErrorCollector\n+import org.junit.runner.RunWith\n+import java.lang.Exception\n+import java.lang.UnsupportedOperationException\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n+\n+@RunWith(AndroidJUnit4::class)\n+class SchemaTests {\n+    @get:Rule\n+    val configFactory = TestSyncConfigurationFactory()\n+\n+    @get:Rule\n+    val errorCollector = ErrorCollector()\n+\n+    private lateinit var config: SyncConfiguration\n+    private lateinit var app: TestRealmApp\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        val user = createTestUser(app)\n+        config = configFactory.createSyncConfigurationBuilder(user).build()\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::app.isInitialized) {\n+            app.close()\n+        }\n+    }\n+\n+    @Test\n+    fun instance() {\n+        val realm = Realm.getInstance(config)\n+        realm.use {\n+            TestCase.assertFalse(realm.isClosed)\n+        }\n+        assertTrue(realm.isClosed)\n+    }\n+\n+    @Test\n+    fun createObject() {\n+        Realm.getInstance(config).use { realm ->\n+            realm.beginTransaction()\n+            assertTrue(realm.schema.contains(\"StringOnly\"))\n+            val stringOnly = realm.createObject(StringOnly::class.java)\n+            stringOnly.chars = \"TEST\"\n+            realm.commitTransaction()\n+            assertEquals(1, realm.where(StringOnly::class.java).count())\n+        }\n+    }\n+\n+    @Test\n+    fun allow_createClass() {\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val className = \"Dogplace\"\n+            realm.beginTransaction()\n+            realm.schema.create(\"Dogplace\")\n+            realm.commitTransaction()\n+            assertTrue(realm.schema.contains(className))\n+        }\n+    }\n+\n+    @Test\n+    fun allow_addField() {\n+        // Init schema\n+        Realm.getInstance(config).close()\n+        val className = \"StringOnly\"\n+        DynamicRealm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            realm.beginTransaction()\n+            objectSchema!!.addField(\"foo\", String::class.java)\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+            realm.commitTransaction()\n+            assertTrue(objectSchema.hasField(\"foo\"))\n+        }\n+    }\n+\n+    // Special column \"__OID\" should be hidden from users.\n+    @Test\n+    fun fieldNames_stableIdColumnShouldBeHidden() {\n+        val className = \"StringOnly\"\n+        Realm.getInstance(config).use { realm ->\n+            val objectSchema = realm.schema[className]\n+            assertNotNull(objectSchema)\n+            val names = objectSchema!!.fieldNames\n+            assertEquals(1, names.size)\n+            assertEquals(StringOnly.FIELD_CHARS, names.iterator().next())\n+        }\n+    }\n+\n+    enum class DestructiveSchemaOperation {\n+        REMOVE_CLASS,\n+        RENAME_CLASS,\n+        SET_CLASS_NAME,\n+        REMOVE_FIELD,\n+        RENAME_FIELD,\n+        REMOVE_INDEX,\n+        REMOVE_PRIMARY_KEY,\n+        ADD_PRIMARY_KEY,\n+        ADD_FIELD_PRIMARY_KEY,\n+    }\n+\n+    @Test\n+    fun disallowDestructiveUpdateOfSyncedRealm() {\n+        for (operation in DestructiveSchemaOperation.values()) {\n+            // Init schema\n+            Realm.getInstance(config).close()\n+            val className = \"StringOnly\"\n+            val newClassName = \"Dogplace\"\n+            val fieldName = \"chars\"\n+            val newFieldName = \"newchars\"\n+\n+            DynamicRealm.getInstance(config).use { realm ->\n+                assertTrue(realm.schema.contains(className))\n+                val objectSchema = realm.schema[className]!!\n+                assertNotNull(objectSchema)\n+                assertTrue(objectSchema.hasField(fieldName))\n+\n+                realm.beginTransaction()\n+                errorCollector.assertFailsWith<UnsupportedOperationException> {\n+                    when (operation) {\n+                        DestructiveSchemaOperation.REMOVE_CLASS ->\n+                            realm.schema.remove(className)\n+                        DestructiveSchemaOperation.RENAME_CLASS ->\n+                            realm.schema.rename(className, newClassName)\n+                        DestructiveSchemaOperation.SET_CLASS_NAME ->\n+                            objectSchema.setClassName(newClassName)\n+                        DestructiveSchemaOperation.REMOVE_FIELD ->\n+                            objectSchema.removeField(fieldName)\n+                        DestructiveSchemaOperation.RENAME_FIELD ->\n+                            objectSchema.renameField(fieldName, newFieldName)\n+                        DestructiveSchemaOperation.REMOVE_INDEX ->\n+                            objectSchema.removeIndex(fieldName)\n+                        DestructiveSchemaOperation.REMOVE_PRIMARY_KEY ->\n+                            objectSchema.removePrimaryKey()\n+                        DestructiveSchemaOperation.ADD_PRIMARY_KEY ->\n+                            objectSchema.addPrimaryKey(fieldName)\n+                        DestructiveSchemaOperation.ADD_FIELD_PRIMARY_KEY -> {\n+                            objectSchema.addField(newFieldName, String::class.java, FieldAttribute.PRIMARY_KEY)\n+                        }\n+                    }\n+                }\n+                // Verify that operation is actually not performed in the transaction\n+                assertTrue(realm.schema.contains(className))\n+                assertFalse(realm.schema.contains(newClassName))\n+                assertTrue(objectSchema.hasField(fieldName))\n+                realm.cancelTransaction()\n+\n+                // Verify that operation is actually not performed after cancelling\n+                assertTrue(realm.schema.contains(className))\n+                assertFalse(realm.schema.contains(newClassName))\n+                assertTrue(objectSchema.hasField(fieldName))\n+                assertFalse(objectSchema.hasField(newFieldName))\n+                assertNotNull(objectSchema)\n+            }\n+        }\n+    }\n+\n+}\n+\n+inline fun <reified T> ErrorCollector.assertFailsWith(block : () -> Unit){", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMzM3Nw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424733377", "bodyText": "Moved to KotlinTestUtils", "author": "rorbech", "createdAt": "2020-05-13T21:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MjMxNw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424662317", "bodyText": "Not entirely sure why we are using the word immutable here, since I don't think it is a concept we have introduced to users. We are referring to normal typed Realms (those you get from Realm.getInstance), but I suspect this isn't the PR to fix this in.", "author": "cmelchior", "createdAt": "2020-05-13T18:56:44Z", "path": "realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java", "diffHunk": "@@ -119,7 +119,7 @@ public String getClassName() {\n      * @param className the new name for this class.\n      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56\n      * characters.\n-     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.\n+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable or from a synced Realm.", "originalCommit": "86af421b38b99f0559e91c25c648eec4dcff2c0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MDg1Mw==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424740853", "bodyText": "Maybe it would be worth having different public types for the two types of schemas. All update methods of the normal typed Realms' schema just throws UnsupportedOperationException and you only get an updatable scheme from the DynamicRealm (if I have gotten it right).", "author": "rorbech", "createdAt": "2020-05-13T21:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDY4MQ==", "url": "https://github.com/realm/realm-java/pull/6850#discussion_r424744681", "bodyText": "Yes, it might be worth thinking about \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-05-13T21:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MjMxNw=="}], "type": "inlineReview"}, {"oid": "62b68828fda1faeee07d7b9889f5c317d7efda82", "url": "https://github.com/realm/realm-java/commit/62b68828fda1faeee07d7b9889f5c317d7efda82", "message": "Reuse variable in favor of duplicate string\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>", "committedDate": "2020-05-13T19:27:12Z", "type": "commit"}, {"oid": "0524b7cd16dd7a7e0aac0e0ef770912c20c55c7b", "url": "https://github.com/realm/realm-java/commit/0524b7cd16dd7a7e0aac0e0ef770912c20c55c7b", "message": "CHANGELOG Updates", "committedDate": "2020-05-13T20:03:38Z", "type": "commit"}, {"oid": "c227ba4c5dc155e0abadf9093f883de005bf53a9", "url": "https://github.com/realm/realm-java/commit/c227ba4c5dc155e0abadf9093f883de005bf53a9", "message": "Move ErrorCollector.assertWithFailure to existing util class", "committedDate": "2020-05-13T20:04:50Z", "type": "commit"}, {"oid": "54c9b58464f800fcab5217b4c0715b4438574a14", "url": "https://github.com/realm/realm-java/commit/54c9b58464f800fcab5217b4c0715b4438574a14", "message": "Use executeTransaction and other minor fixes", "committedDate": "2020-05-13T20:05:56Z", "type": "commit"}, {"oid": "242dd7fd9335d5aeeccb4f22bf5691598fa635d4", "url": "https://github.com/realm/realm-java/commit/242dd7fd9335d5aeeccb4f22bf5691598fa635d4", "message": "Merge commit '62b68828fda1faeee07d7b9889f5c317d7efda82' into cr/sync-test-migration-schema", "committedDate": "2020-05-13T21:05:31Z", "type": "commit"}]}