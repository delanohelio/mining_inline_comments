{"pr_number": 6730, "pr_title": "Add support for Embedded Objects", "pr_createdAt": "2020-01-29T22:34:04Z", "pr_url": "https://github.com/realm/realm-java/pull/6730", "timeline": [{"oid": "e531ba67c1de6a9372fef603619ec50ec2b6392c", "url": "https://github.com/realm/realm-java/commit/e531ba67c1de6a9372fef603619ec50ec2b6392c", "message": "Added preliminary annotation processor support", "committedDate": "2020-01-29T21:53:49Z", "type": "commit"}, {"oid": "fa85cd20de821b2d1873aee1d9fcc6b4c0f1aad4", "url": "https://github.com/realm/realm-java/commit/fa85cd20de821b2d1873aee1d9fcc6b4c0f1aad4", "message": "Add support for embedded classes on the Java side of schema generation", "committedDate": "2020-01-30T08:40:51Z", "type": "commit"}, {"oid": "6ec468323939e8b3eb91952c038d0f319fc31200", "url": "https://github.com/realm/realm-java/commit/6ec468323939e8b3eb91952c038d0f319fc31200", "message": "Add missing check for illegal use of single parent reference", "committedDate": "2020-01-30T12:22:15Z", "type": "commit"}, {"oid": "a5f2ce65f55a74fbf7da4c9fad9bc4ec1c8301da", "url": "https://github.com/realm/realm-java/commit/a5f2ce65f55a74fbf7da4c9fad9bc4ec1c8301da", "message": "Add preliminary public API's for queries and RealmObjectSchema", "committedDate": "2020-01-30T13:25:12Z", "type": "commit"}, {"oid": "b543110d5ef0d8dd469675fade2dd4cfb0ae3877", "url": "https://github.com/realm/realm-java/commit/b543110d5ef0d8dd469675fade2dd4cfb0ae3877", "message": "Add isEmbedded to mediators", "committedDate": "2020-01-30T22:51:32Z", "type": "commit"}, {"oid": "827ee786a6793d804617ecc0e6f19d2001d9a6b5", "url": "https://github.com/realm/realm-java/commit/827ee786a6793d804617ecc0e6f19d2001d9a6b5", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md", "committedDate": "2020-02-25T09:05:32Z", "type": "commit"}, {"oid": "fd0745da3d799a76fc5ea5b3ac98af20882afae7", "url": "https://github.com/realm/realm-java/commit/fd0745da3d799a76fc5ea5b3ac98af20882afae7", "message": "Merge branch 'v10' into cm/embedded-objects", "committedDate": "2020-02-28T14:09:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTczOTgxNg==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r385739816", "bodyText": "the the", "author": "Zhuinden", "createdAt": "2020-02-28T14:56:18Z", "path": "CHANGELOG.md", "diffHunk": "@@ -5,7 +5,7 @@\n * Removed Query Based Sync API's and Subscriptions. These API's are not initially supported by MongoDB Realm. They will be re-introduced in a future release. `SyncConfiguration.partionKey()` has been added as a replacement. Read more [here](XXX).  \n \n ### Enhancements\n-* None.\n+* Added support for \"Embedded Objects\". They are enabled using `@RealmClass(embedded = true)`. An embedded object must have exactly one parent object linking to it and it will be deleted when the the parent is. Embedded objects can also be the parent of other embedded classes. Read more [here](https://realm.io/docs/java/latest/#embedded-objects). (Issue [#6713](https://github.com/realm/realm-java/issues/6713))  ", "originalCommit": "fd0745da3d799a76fc5ea5b3ac98af20882afae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDExMg==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r385740112", "bodyText": "That's already there 3 lines above I think?", "author": "Zhuinden", "createdAt": "2020-02-28T14:56:51Z", "path": "CHANGELOG.md", "diffHunk": "@@ -43,7 +43,7 @@ NOTE: This version bumps the Realm file format to version 10. It is not possible\n * `RealmResults.asJSON()` is no longer `@Beta`.\n * Storing large binary blobs in Realm files no longer forces the file to be at least 8x the size of the largest blob.\n * Reduce the size of transaction logs stored inside the Realm file, reducing file size growth from large transactions.\n-* Added support for \"Embedded Objects\". They are enabled using `@RealmClass(embedded = true)`. An embedded object must have exactly one parent object linking to it and it will be deleted when the the parent is. Embedded objects can also be the parent of other embedded classes. Read more [here](https://realm.io/docs/java/latest/#embedded-objects). (Issue [#6713](https://github.com/realm/realm-java/issues/6713))  \n+* `RealmResults.asJSON()` is no longer `@Beta`", "originalCommit": "fd0745da3d799a76fc5ea5b3ac98af20882afae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc0NQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r385740745", "bodyText": "Yup, there are some merge mistakes that needs to be cleaned up", "author": "cmelchior", "createdAt": "2020-02-28T14:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDExMg=="}], "type": "inlineReview"}, {"oid": "283aff9768a7fdc3eccc5da8f2ce82aaf5eacc66", "url": "https://github.com/realm/realm-java/commit/283aff9768a7fdc3eccc5da8f2ce82aaf5eacc66", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\trealm/build.gradle", "committedDate": "2020-03-08T21:08:00Z", "type": "commit"}, {"oid": "94f6b8023898f52cc4f168bc7b98190ba3a2f819", "url": "https://github.com/realm/realm-java/commit/94f6b8023898f52cc4f168bc7b98190ba3a2f819", "message": "Adding test stubs", "committedDate": "2020-03-08T21:10:23Z", "type": "commit"}, {"oid": "2c096f01ce7e57ecef25178d755d560e69268600", "url": "https://github.com/realm/realm-java/commit/2c096f01ce7e57ecef25178d755d560e69268600", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md\n#\trealm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java\n#\trealm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java", "committedDate": "2020-05-06T12:42:19Z", "type": "commit"}, {"oid": "232fbb0e6852f0330be0b66636a368bf1c7f3c99", "url": "https://github.com/realm/realm-java/commit/232fbb0e6852f0330be0b66636a368bf1c7f3c99", "message": "Make test compile and convert to Kotlin", "committedDate": "2020-05-06T14:28:11Z", "type": "commit"}, {"oid": "747a210247161bf8e799ada0c7ac09d63134335c", "url": "https://github.com/realm/realm-java/commit/747a210247161bf8e799ada0c7ac09d63134335c", "message": "Move test classes to Kotlin", "committedDate": "2020-05-06T14:43:38Z", "type": "commit"}, {"oid": "320b8a4436cedf9b9befdce740d1fa0bd5dca451", "url": "https://github.com/realm/realm-java/commit/320b8a4436cedf9b9befdce740d1fa0bd5dca451", "message": "Add Javadoc. Add first copyToRealm test", "committedDate": "2020-05-08T05:56:14Z", "type": "commit"}, {"oid": "2365d770d7f827f51418edf351a0d6319f55943a", "url": "https://github.com/realm/realm-java/commit/2365d770d7f827f51418edf351a0d6319f55943a", "message": "Added support for CopyToRealm and ObjectSchema", "committedDate": "2020-05-18T16:07:29Z", "type": "commit"}, {"oid": "8a6c0daa800c8ea927db8a55dfb34b5fc9251b0e", "url": "https://github.com/realm/realm-java/commit/8a6c0daa800c8ea927db8a55dfb34b5fc9251b0e", "message": "Ad support for embedded objects in typed RealmLists.", "committedDate": "2020-05-26T07:00:50Z", "type": "commit"}, {"oid": "88d0a75a645fab5aa4961615064e217f2419fa4a", "url": "https://github.com/realm/realm-java/commit/88d0a75a645fab5aa4961615064e217f2419fa4a", "message": "Update annotation processor tests", "committedDate": "2020-05-26T09:02:47Z", "type": "commit"}, {"oid": "bfca1a62a626ade9a72769936fa9496ca4668a72", "url": "https://github.com/realm/realm-java/commit/bfca1a62a626ade9a72769936fa9496ca4668a72", "message": "Merge branch 'v10' into cm/embedded-objects\n\n# Conflicts:\n#\tCHANGELOG.md\n#\trealm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java", "committedDate": "2020-05-26T09:44:45Z", "type": "commit"}, {"oid": "a548cb8f7027e10d72b45331e1f415b867c85da1", "url": "https://github.com/realm/realm-java/commit/a548cb8f7027e10d72b45331e1f415b867c85da1", "message": "Fix Findbugs", "committedDate": "2020-05-26T10:39:23Z", "type": "commit"}, {"oid": "71f46522d5b2cd5a9e22944bf1ba6880fa50f300", "url": "https://github.com/realm/realm-java/commit/71f46522d5b2cd5a9e22944bf1ba6880fa50f300", "message": "Cleanup", "committedDate": "2020-05-26T12:23:21Z", "type": "commit"}, {"oid": "de129fc4106d870ca5a7e184d7b62e025d91b48d", "url": "https://github.com/realm/realm-java/commit/de129fc4106d870ca5a7e184d7b62e025d91b48d", "message": "Fix faulty cache during copyToRealm. Better autogenerated code.", "committedDate": "2020-05-27T14:09:11Z", "type": "commit"}, {"oid": "efd62ae0b94d70c4b750cbf883ceaa3221eda373", "url": "https://github.com/realm/realm-java/commit/efd62ae0b94d70c4b750cbf883ceaa3221eda373", "message": "Fix Java 7 support", "committedDate": "2020-05-27T17:12:34Z", "type": "commit"}, {"oid": "52d2e569482cba011c9aace3a439724a4849a83a", "url": "https://github.com/realm/realm-java/commit/52d2e569482cba011c9aace3a439724a4849a83a", "message": "Add support for insert/insertOrUpdate", "committedDate": "2020-05-28T11:15:31Z", "type": "commit"}, {"oid": "88bb423d6b56d0970383f8c19ea560f43b8ab58d", "url": "https://github.com/realm/realm-java/commit/88bb423d6b56d0970383f8c19ea560f43b8ab58d", "message": "Add missing methods", "committedDate": "2020-05-28T12:30:58Z", "type": "commit"}, {"oid": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "url": "https://github.com/realm/realm-java/commit/fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "message": "Fix ObjectServerTest", "committedDate": "2020-05-28T13:24:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NTUxNA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432295514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This method should only be used to created objects of types marked as embedded.\n          \n          \n            \n             * This method should only be used to create objects of types marked as embedded.", "author": "rorbech", "createdAt": "2020-05-29T07:10:01Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -74,6 +74,23 @@ inline fun <reified T : RealmModel> Realm.createObject(primaryKeyValue: Any?): T\n     return this.createObject(T::class.java, primaryKeyValue)\n }\n \n+/**\n+ * Instantiates and adds a new embedded object to the Realm.\n+ * <p>\n+ * This method should only be used to created objects of types marked as embedded.", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NjMwNA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432296304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @param parentObject The parent object which should a reference to the embedded object. If the parent property is a list\n          \n          \n            \n             * @param parentObject The parent object which should hold a reference to the embedded object. If the parent property is a list", "author": "rorbech", "createdAt": "2020-05-29T07:12:00Z", "path": "realm/kotlin-extensions/src/main/kotlin/io/realm/kotlin/RealmExtensions.kt", "diffHunk": "@@ -74,6 +74,23 @@ inline fun <reified T : RealmModel> Realm.createObject(primaryKeyValue: Any?): T\n     return this.createObject(T::class.java, primaryKeyValue)\n }\n \n+/**\n+ * Instantiates and adds a new embedded object to the Realm.\n+ * <p>\n+ * This method should only be used to created objects of types marked as embedded.\n+ *\n+ * @param T the Class of the object to create. It must be marked with {@code \\@RealmClass(embedded = true)}.\n+ * @param parentObject The parent object which should a reference to the embedded object. If the parent property is a list", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDIyMA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432300220", "bodyText": "Maybe explicit for testing purpose, but otherwise you could just use default value to skip the two explicit constructors\nopen class EmbeddedSimpleChild(var id: String = UUID.randomUUID().toString())\nHere and in other test classes", "author": "rorbech", "createdAt": "2020-05-29T07:21:04Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedSimpleChild.kt", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+import io.realm.annotations.LinkingObjects\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+/**\n+ * The embedded object part of a simple object graph. This object can have two parents\n+ * [EmbeddedSimpleParent] and [EmbeddedSimpleListParent].\n+ */\n+@RealmClass(embedded = true)\n+open class EmbeddedSimpleChild : RealmObject {", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTY5Mw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433661693", "bodyText": "Totally the same I was thinking about too \ud83d\udc4d", "author": "edualonso", "createdAt": "2020-06-02T07:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5Njg4Mw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433896883", "bodyText": "Good point. I changed it here and for all the other classes.", "author": "cmelchior", "createdAt": "2020-06-02T13:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTEwOA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432955108", "bodyText": "The documentation of Backlink should probably be updated to reflect that it does not have to be a RealmResult for embedded objects if the parent is always of the same type.", "author": "rorbech", "createdAt": "2020-05-31T14:56:10Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -74,7 +74,7 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n     /**\n      * The fully-qualified name of the class to which the backlinks, from `targetField`, point.\n      */\n-    val sourceClass: QualifiedClassName? = Utils.getRealmResultsType(backlinkField)\n+    val sourceClass: QualifiedClassName? = if (Utils.isRealmResults(backlinkField)) Utils.getRealmResultsType(backlinkField) else Utils.getModelClassQualifiedName(backlinkField)", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTI1MQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432955251", "bodyText": "Sounds like this is flipped compared to the implementation.", "author": "rorbech", "createdAt": "2020-05-31T14:57:39Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -83,6 +83,11 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n      */\n     val sourceField: String? = backlinkField.getAnnotation(LinkingObjects::class.java)?.value\n \n+    /**\n+     * {@code true} if the parent link should be modeled as a single link instead of as a RealmResults.", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1OTE1OQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432959159", "bodyText": "Seems like this pattern of commenting on exception, switching and emitting exceptions is used quite some times. Maybe abstract it into a reusable method.", "author": "rorbech", "createdAt": "2020-05-31T15:44:14Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -292,33 +315,52 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n+            if (embeddedClass.contains(false)) {\n                 emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n                 emitStatement(\"RealmModel object = null\")\n                 emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n                 beginControlFlow(\"if (iterator.hasNext())\")\n-                    emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                    emitStatement(\"object = iterator.next()\")\n-                    emitSingleLineComment(\"This cast is correct because obj is either\")\n-                    emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                    emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                    emitEmptyLine()\n+                emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                emitStatement(\"object = iterator.next()\")\n+                emitSingleLineComment(\"This cast is correct because obj is either\")", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MTIwNw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432961207", "bodyText": "Newline at end of file", "author": "rorbech", "createdAt": "2020-05-31T16:10:12Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/SyncedRealmMigrationTests.kt", "diffHunk": "@@ -278,4 +278,4 @@ class SyncedRealmMigrationTests {\n             BaseRealm.applicationContext = null\n         }\n     }\n-}\n+}", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MTUzMA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432961530", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-05-31T16:13:40Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -153,9 +155,9 @@ private Realm(RealmCache cache, OsSharedRealm.VersionID version) {\n         schema = new ImmutableRealmSchema(this,\n                 new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));\n         // FIXME: This is to work around the different behaviour between the read only Realms in the Object Store and\n-        // in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object\n-        // Store and realm-cocoa. In that case, any query based on the missing schema should just return an empty\n-        // results. Fix this together with https://github.com/realm/realm-java/issues/2953\n+        //  in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MjMwNQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432962305", "bodyText": "I assume that this also just works out of the box with obfuscation, due to looking up the field names in some meta data, right?", "author": "rorbech", "createdAt": "2020-05-31T16:22:59Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1006,9 +1012,63 @@ private Scanner getFullStringScanner(InputStream in) {\n      */\n     public <E extends RealmModel> E createObject(Class<E> clazz, @Nullable Object primaryKeyValue) {\n         checkIfValid();\n+        RealmProxyMediator mediator = configuration.getSchemaMediator();\n+        if (mediator.isEmbedded(clazz)) {\n+            throw new IllegalArgumentException(\"This class is marked embedded. Use `createEmbeddedObject(class, parent, property)` instead:  \" + mediator.getSimpleClassName(clazz));\n+        }\n         return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String>emptyList());\n     }\n \n+    /**\n+     * Instantiates and adds a new embedded object to the Realm.\n+     * <p>\n+     * This method should only be used to created objects of types marked as embedded.\n+     *\n+     * @param clazz the Class of the object to create. It must be marked with {@code \\@RealmClass(embedded = true)}.\n+     * @param parent The parent object which should a reference to the embedded object. If the parent property is a list\n+     * the embedded object will be added to the end of that list.\n+     * @param parentProperty the property in the parent class which holds the reference.\n+     * @return the newly created embedded object.\n+     * @throws IllegalArgumentException if {@code clazz} is not an embedded class or if the property\n+     * in the parent class cannot hold objects of the appropriate type.\n+     * @see RealmClass#embedded()\n+     */\n+    public <E extends RealmModel> E createEmbeddedObject(Class<E> clazz, RealmModel parentObject, String parentProperty) {", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5ODI4NA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433898284", "bodyText": "Yes", "author": "cmelchior", "createdAt": "2020-06-02T14:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2MjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MjU3OA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432972578", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * \n          \n          \n            \n                 * <p>", "author": "rorbech", "createdAt": "2020-05-31T18:37:04Z", "path": "realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java", "diffHunk": "@@ -403,12 +404,28 @@ private void addEmptyList(long columnKey) {\n \n     /**\n      * Updates any existing object if it exists, otherwise creates a new one.\n+     * ", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MjU5Nw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432972597", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 * <P>", "author": "rorbech", "createdAt": "2020-05-31T18:37:20Z", "path": "realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java", "diffHunk": "@@ -403,12 +404,28 @@ private void addEmptyList(long columnKey) {\n \n     /**\n      * Updates any existing object if it exists, otherwise creates a new one.\n+     * \n+     * Updating an existing object requires that the primary key is defined as one of the fields.\n      *", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDc2NQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432974765", "bodyText": "New line at end of file", "author": "rorbech", "createdAt": "2020-05-31T19:05:07Z", "path": "realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp", "diffHunk": "@@ -389,3 +389,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateNewObjectWit\n     CATCH_STD()\n     return 0;\n }\n+\n+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateEmbeddedObject(\n+    JNIEnv* env, jclass, jlong j_parent_table_ptr, jlong j_parent_object_key, jlong j_parent_column_key)\n+{\n+    try {\n+        TableRef table = TBL_REF(j_parent_table_ptr);\n+        ObjKey obj_key(static_cast<int64_t>(j_parent_object_key));\n+        Obj parent_obj = table->get_object(obj_key);\n+        ColKey col_key(static_cast<int64_t>(j_parent_column_key));\n+        Obj child_obj;\n+        if (table->get_column_type(col_key) == type_Link) {\n+            child_obj = parent_obj.create_and_set_linked_object(col_key);\n+        } else {\n+            LnkLstPtr list = parent_obj.get_linklist_ptr(col_key);\n+            child_obj = list->create_and_insert_linked_object(list->size());\n+        }\n+        return to_jlong_or_not_found(child_obj.get_key());\n+    }\n+    CATCH_STD()\n+    return 0;\n+}", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3ODc2Ng==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432978766", "bodyText": "Wouldn't there be a way to not have to generate all these _ unsupported_ methods. Maybe somehow checking it in the mediator before dispatching to this class?", "author": "rorbech", "createdAt": "2020-05-31T19:56:34Z", "path": "realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java", "diffHunk": "@@ -384,6 +384,10 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob\n         return unmanagedObject;\n     }\n \n+    public static void updateEmbeddedObject(Realm realm, some.test.Simple unmanagedObject, some.test.Simple managedObject, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2Mjk3OA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434062978", "bodyText": "Yes, I moved the conditional to the mediator, so these are no longer being generated at all.", "author": "cmelchior", "createdAt": "2020-06-02T17:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3ODc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDQxOA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432980418", "bodyText": "Maybe it would also make sense to have output for a mediator with embedded objects too? Not hard to verify that the processor generates right code for isEmbedded - but for completion. And if you could eliminate the always throwing updateEmbeddedObject for non-embedded classes it would start being nice to have to for reasoning about the output instead of the processor.", "author": "rorbech", "createdAt": "2020-05-31T20:18:27Z", "path": "realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java", "diffHunk": "@@ -206,4 +206,25 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects\n         throw getMissingProxyClassException(clazz);\n     }\n \n+    @Override", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MDg5MQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432980891", "bodyText": "Sometimes test fail in weird ways if they fail to assert, so maybe stick to realm.executeTransaction{} just for certainty.", "author": "rorbech", "createdAt": "2020-05-31T20:24:42Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTE5NA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n          \n          \n            \n                    managedParent.child = EmbeddedSimpleChild(\"child\") // Will copy the object to Realm", "author": "rorbech", "createdAt": "2020-05-31T20:27:49Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTI4Mg==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981282", "bodyText": "Magic value. Maybe just add in class.", "author": "rorbech", "createdAt": "2020-05-31T20:29:00Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        assertTrue(managedParent.child!!.isValid)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyManaged() {\n+        // Checks that setting a link to a managed embedded object will automatically copy it unlike\n+        // normal objects that allow multiple parents. Note: This behavior is a bit controversial\n+        // and was subject to a lot of discussion during API design. The problem is that making\n+        // the behavior explicit will result in an extremely annoying API. We need to carefully\n+        // monitor if people understand how this behaves.\n+        realm.beginTransaction()\n+        val managedParent1: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent1\"))\n+        val managedParent2: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent2\"))\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent1.child = EmbeddedSimpleChild(\"child\")\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent2.child = managedParent1.child // Will copy the embedded object\n+        assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        assertNotEquals(managedParent1.child, managedParent2.child)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willCopyUnderConstruction() {\n+        realm.beginTransaction()\n+        val unmanagedObj = EmbeddedWithConstructorArgs()\n+        val managedObj = realm.copyToRealm(unmanagedObj)\n+        assertEquals(\"innerChild\", managedObj.child!!.id)", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTU0OQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                fun copyToRealmOrUpdate_throws() {\n          \n          \n            \n                fun copyToRealmOrUpdate_noParentThrows() {", "author": "rorbech", "createdAt": "2020-05-31T20:31:27Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore\n+    fun dynamicRealm_createEmbeddedObject() {\n+        TODO(\"Placeholder for all tests for DynamicRealm.createEmbeddedObject()\")\n+    }\n+\n+\n+    @Test\n+    fun settingParentFieldDeletesChild() {\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        parent.child = EmbeddedSimpleChild(\"child\")\n+\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+        val managedChild: EmbeddedSimpleChild = managedParent.child!!\n+        managedParent.child = null // Will delete the embedded object\n+        assertFalse(managedChild.isValid)\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyUnmanaged() {\n+        // Checks that adding an unmanaged embedded object to a property will automatically copy it.\n+        realm.beginTransaction()\n+        val parent = EmbeddedSimpleParent(\"parent\")\n+        val managedParent: EmbeddedSimpleParent = realm.copyToRealm(parent)\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent.child = EmbeddedSimpleChild(\"child\") // Wil copy the object to Realm\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        assertTrue(managedParent.child!!.isValid)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willAutomaticallyCopyManaged() {\n+        // Checks that setting a link to a managed embedded object will automatically copy it unlike\n+        // normal objects that allow multiple parents. Note: This behavior is a bit controversial\n+        // and was subject to a lot of discussion during API design. The problem is that making\n+        // the behavior explicit will result in an extremely annoying API. We need to carefully\n+        // monitor if people understand how this behaves.\n+        realm.beginTransaction()\n+        val managedParent1: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent1\"))\n+        val managedParent2: EmbeddedSimpleParent = realm.copyToRealm(EmbeddedSimpleParent(\"parent2\"))\n+\n+        assertEquals(0, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent1.child = EmbeddedSimpleChild(\"child\")\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        managedParent2.child = managedParent1.child // Will copy the embedded object\n+        assertEquals(2, realm.where<EmbeddedSimpleChild>().count())\n+        assertNotEquals(managedParent1.child, managedParent2.child)\n+    }\n+\n+    @Test\n+    fun objectAccessor_willCopyUnderConstruction() {\n+        realm.beginTransaction()\n+        val unmanagedObj = EmbeddedWithConstructorArgs()\n+        val managedObj = realm.copyToRealm(unmanagedObj)\n+        assertEquals(\"innerChild\", managedObj.child!!.id)\n+    }\n+\n+    @Test\n+    fun realmList_add_willAutomaticallyCopy() {\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        assertTrue(parent.children.add(EmbeddedSimpleChild(\"child\")))\n+        val child = parent.children.first()!!\n+        assertTrue(child.isValid)\n+        assertEquals(\"child\", child.id)\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun realmList_addIndex_willAutomaticallyCopy() {\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        parent.children.add(EmbeddedSimpleChild(\"secondChild\"))\n+        parent.children.add(0, EmbeddedSimpleChild(\"firstChild\"))\n+        val child = parent.children.first()!!\n+        assertTrue(child.isValid)\n+        assertEquals(\"firstChild\", child.id)\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun realmList_set_willAutomaticallyCopy() {\n+        // Checks that adding an unmanaged embedded object to a list will automatically make\n+        // it managed\n+        realm.beginTransaction()\n+        val parent = realm.copyToRealm(EmbeddedSimpleListParent(\"parent\"))\n+        assertTrue(parent.children.add(EmbeddedSimpleChild(\"child\")))\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+        parent.children[0] = EmbeddedSimpleChild(\"OtherChild\")\n+        assertEquals(\"OtherChild\", parent.children.first()!!.id)\n+        assertEquals(1, realm.where<EmbeddedSimpleChild>().count())\n+\n+        // FIXME: How to handle DynamicRealmObject :(\n+    }\n+\n+    @Test\n+    fun copyToRealm_noParentThrows() {\n+        realm.executeTransaction {\n+            assertFailsWith<IllegalArgumentException> {\n+                realm.copyToRealm(EmbeddedSimpleChild(\"child\"))\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun copyToRealmOrUpdate_throws() {", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4MTc0OQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432981749", "bodyText": "Add reason to ignore as it is easier to inspect in reports", "author": "rorbech", "createdAt": "2020-05-31T20:34:07Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import androidx.test.platform.app.InstrumentationRegistry\n+import io.realm.entities.*\n+import io.realm.entities.embedded.*\n+import io.realm.kotlin.addChangeListener\n+import io.realm.kotlin.createEmbeddedObject\n+import io.realm.kotlin.createObject\n+import io.realm.kotlin.where\n+import io.realm.rule.BlockingLooperThread\n+import io.realm.rule.TestRealmConfigurationFactory\n+import org.junit.*\n+import org.junit.Assert.*\n+import org.junit.runner.RunWith\n+import java.util.*\n+import kotlin.test.assertFailsWith\n+\n+/**\n+ * Class testing the Embedded Objects feature.\n+ */\n+// FIXME: Move all of these tests out from here. We try to tests by Class, not Feature.\n+@RunWith(AndroidJUnit4::class)\n+class EmbeddedObjectsTest {\n+\n+    @get:Rule\n+    val configFactory = TestRealmConfigurationFactory()\n+\n+    private val looperThread = BlockingLooperThread()\n+\n+    private lateinit var realmConfig: RealmConfiguration\n+    private lateinit var realm: Realm\n+\n+    @Before\n+    fun setUp() {\n+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n+        realmConfig = configFactory.createConfiguration()\n+        realm = Realm.getInstance(realmConfig)\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        if (this::realm.isInitialized) {\n+            realm.close()\n+        }\n+    }\n+\n+    @Test\n+    fun createObject_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>() }\n+    }\n+\n+    @Test\n+    fun createObjectWithPrimaryKey_throwsForEmbeddedClasses() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createObject<EmbeddedSimpleChild>(\"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nullArgsThrows() {\n+        realm.beginTransaction()\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, TestHelper.getNull(), \"foo\") }\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject(EmbeddedSimpleChild::class.java, parent, TestHelper.getNull()) }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_nonExistingParentPropertyNameThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"foo\") }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_wrongParentPropertyTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        // TODO: Smoke-test for wrong type. Figure out how to test all unsupported types.\n+        assertFailsWith<IllegalArgumentException> { realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"id\") }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyObjectTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"child\")\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"FIXME\")\n+    fun createEmbeddedObject_wrongParentPropertyListTypeThrows() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(\"parent\")\n+\n+        assertFailsWith<IllegalArgumentException> {\n+            // Embedded object is not of the type the parent object links to.\n+            realm.createEmbeddedObject<EmbeddedTreeLeaf>(parent, \"children\")\n+        }\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleSingleChild() {\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleParent>(\"parent\")\n+        val child = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"child\");\n+        assertEquals(child.parent, parent)\n+    }\n+\n+    @Test\n+    fun createEmbeddedObject_simpleChildList() {\n+        // Using createEmbeddedObject() with a parent list, will append the object to the end\n+        // of the list\n+        realm.beginTransaction()\n+        val parent = realm.createObject<EmbeddedSimpleListParent>(UUID.randomUUID().toString())\n+        val child1 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        val child2 = realm.createEmbeddedObject<EmbeddedSimpleChild>(parent, \"children\")\n+        assertEquals(2, parent.children.size.toLong())\n+        assertEquals(child1, parent.children.first()!!)\n+        assertEquals(child2, parent.children.last()!!)\n+    }\n+\n+    @Test\n+    @Ignore", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4Mjg0OA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r432982848", "bodyText": "Maybe also add the generated proxy for the EmbeddedClass for reference.", "author": "rorbech", "createdAt": "2020-05-31T20:48:33Z", "path": "realm/realm-annotations-processor/src/test/resources/io/realm/some_test_EmbeddedClassSimpleParentRealmProxy.java", "diffHunk": "@@ -0,0 +1,871 @@\n+package io.realm;", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMjYxNw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433512617", "bodyText": "Doesn't really make a lot of sense to use a backing property if backlinkField is immutable.", "author": "edualonso", "createdAt": "2020-06-01T21:58:18Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt", "diffHunk": "@@ -83,6 +83,11 @@ class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement)\n      */\n     val sourceField: String? = backlinkField.getAnnotation(LinkingObjects::class.java)?.value\n \n+    /**\n+     * {@code true} if the parent link should be modeled as a single link instead of as a RealmResults.\n+     */\n+    val exposeAsRealmResults: Boolean = Utils.isRealmResults(backlinkField)\n+\n     val targetFieldType: String\n         get() = backlinkField.asType().toString()", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzOTc3NA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433839774", "bodyText": "backlinkField is also a val from the constructor.", "author": "cmelchior", "createdAt": "2020-06-02T12:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMjYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0OTE2Nw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433849167", "bodyText": "I think creating a backing property with get is a superfluous here. The value won't change given that backlingField is a val, so there is no need to compute backlinkField.asType().toString() every time we access targetFieldType. It could be done without the get().", "author": "edualonso", "createdAt": "2020-06-02T12:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMjYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTk2Ng==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433915966", "bodyText": "Good point, might assign the value directly \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-06-02T14:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMjYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433521759", "bodyText": "There seems to be a lot immutable data coming out of classType. I'm wondering if we could somehow avoid using vars for things like this and rely on initialisation for assigning values instead. It feels like we are adding state to this class unnecessarily. Another example from this class is the contains* booleans.", "author": "edualonso", "createdAt": "2020-06-01T22:24:20Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.kt", "diffHunk": "@@ -128,12 +128,13 @@ class ClassMetaData(env: ProcessingEnvironment, typeMirrors: TypeMirrors, privat\n             return type != \"io.realm.DynamicRealmObject\" && !type.endsWith(\".RealmObject\") && !type.endsWith(\"RealmProxy\")\n         }\n \n+    var embedded: Boolean = false", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0MzAzOQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433843039", "bodyText": "This is probably an architectural problem. Right now ClassMetaData is responsible for both parsing AND storing state. It would probably help if we could separate this a bit. The issue is that there is a lot of state and it is interdependent, so not sure how much it would help if we split it. We would still need to track a lot of intermediate state somewhere.", "author": "cmelchior", "createdAt": "2020-06-02T12:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDkwNA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433854904", "bodyText": "It feels like it could escalate quickly if these changes are done here and now. I don't think it's super urgent so we can push it for a later time. I'm very wary when it comes to using mutable properties in Kotlin nonetheless. If not managed correctly they become a timebomb.", "author": "edualonso", "createdAt": "2020-06-02T12:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODIwNQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433918205", "bodyText": "If you look at the rest of this class there are tons of var as well. That doesn't mean your point is invalid, but I wonder how you would handle the case of gathering ~10+ variables across 100's of line of code before you send them to a constructor?", "author": "cmelchior", "createdAt": "2020-06-02T14:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NDg4NA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433964884", "bodyText": "I can see e.g. internalClassName is a latent var. It takes its value from realmClassAnnotation or moduleClassNameFormatter (it's a bit more cumbersome to reason in case the value comes from the latter, but still, it's the same rationale as it could be passed via constructor/a builder from where the class metadata is created in RealmProcessor). In turn, the local realmClassAnnotation variable is immutable and takes its value from classType which comes from the constructor as immutable too. All these things considered, there is no excuse to make internalClassName a mutable property.\nIt is true that you might end up having a gazillion properties in your constructor, to which I would strongly object too. You could use a builder to handle that, but that adds a ton of boilerplate. I think the best solution is to encapsulate all these immutable properties behind a data structure/class. This way you would at least keep the clutter away from ClassMetaData and those properties will be easily accessible via vals with backing properties from ClassMetaData, e.g.\nclass ClassMetaData(private val myMetadaContainer: MetaDataContainer) {\n   private val internalClassName: String\n      get() = myMetadaContainer.internalClassName\n\nI don't think there's a silver bullet here in any case but makes the solution more robust IMO.", "author": "edualonso", "createdAt": "2020-06-02T15:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0NzE5Nw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434047197", "bodyText": "I have no doubt there are things we can do to improve this class. You mentioned some of them, but I would rather not do it in this PR since it is too big already. I created #6891 to track it.", "author": "cmelchior", "createdAt": "2020-06-02T17:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1ODQwNg==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434158406", "bodyText": "I agree, seems too much for the scope of this PR.", "author": "edualonso", "createdAt": "2020-06-02T20:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNjcyMg==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433526722", "bodyText": "Nitpick: whenever it makes sense, and as long as the function doesn't rely on optional values for overloading (and even in that case, I favour not using defaults, but that is my personal taste), I would put the lambda as the last parameter. Then you could extract it from within the parameter list for a more elegant look IMO:\n                emitMediatorSwitch(writer, false) {\n                   // blahblahblah...\n                }", "author": "edualonso", "createdAt": "2020-06-01T22:39:31Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -292,33 +315,52 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n+            if (embeddedClass.contains(false)) {\n                 emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n                 emitStatement(\"RealmModel object = null\")\n                 emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n                 beginControlFlow(\"if (iterator.hasNext())\")\n-                    emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                    emitStatement(\"object = iterator.next()\")\n-                    emitSingleLineComment(\"This cast is correct because obj is either\")\n-                    emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                    emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                    emitEmptyLine()\n+                emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                emitStatement(\"object = iterator.next()\")\n+                emitSingleLineComment(\"This cast is correct because obj is either\")\n+                emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n+                emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n+                emitEmptyLine()\n \n-                    emitMediatorSwitch({ i: Int ->\n+                emitMediatorSwitch({ i: Int ->", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxOTUzMQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433919531", "bodyText": "Good point. This is probably just an artifact of this being ported from Java more or less directly", "author": "cmelchior", "createdAt": "2020-06-02T14:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNjcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNzExNA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433527114", "bodyText": "Same as above. I can see it's used in a number of places here too.", "author": "edualonso", "createdAt": "2020-06-01T22:40:46Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -329,29 +371,41 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     EnumSet.of(Modifier.PUBLIC),\n                     \"Realm\", \"realm\", \"Collection<? extends RealmModel>\", \"objects\")\n \n-                emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n-                emitStatement(\"RealmModel object = null\")\n-                emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n+                if (embeddedClass.contains(false)) {\n+                    emitStatement(\"Iterator<? extends RealmModel> iterator = objects.iterator()\")\n+                    emitStatement(\"RealmModel object = null\")\n+                    emitStatement(\"Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())\")\n \n-                beginControlFlow(\"if (iterator.hasNext())\")\n-                        .emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n-                        .emitStatement(\"object = iterator.next()\")\n-                        .emitSingleLineComment(\"This cast is correct because obj is either\")\n-                        .emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n-                        .emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n-                        .emitEmptyLine()\n+                    beginControlFlow(\"if (iterator.hasNext())\")\n+                            .emitSingleLineComment(\" access the first element to figure out the clazz for the routing below\")\n+                            .emitStatement(\"object = iterator.next()\")\n+                            .emitSingleLineComment(\"This cast is correct because obj is either\")\n+                            .emitSingleLineComment(\"generated by RealmProxy or the original type extending directly from RealmObject\")\n+                            .emitStatement(\"@SuppressWarnings(\\\"unchecked\\\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())\")\n+                            .emitEmptyLine()\n \n                     emitMediatorSwitch({ i: Int ->", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNzIyMA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433927220", "bodyText": "Yes, I converted all of them", "author": "cmelchior", "createdAt": "2020-06-02T14:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzNzE0OA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433537148", "bodyText": "This feels wrong. Remove secondary constructors, make this property a val and move to the primary constructor with its default value.\nSame for some of the other files below.", "author": "edualonso", "createdAt": "2020-06-01T23:13:56Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedCircularChild.kt", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+/**\n+ * Embedded object that point to itself. Note, this is only allowed in the schema. The actual\n+ * objects are not allowed to have circular references.\n+ */\n+@RealmClass(embedded = true)\n+open class EmbeddedCircularChild : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+\n+    var id = UUID.randomUUID().toString()", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTE1Ng==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433539156", "bodyText": "I know it's a test, but avoid var unless you're updating the value of children with a different list instance - remember you can still add elements to the list even if its property is immutable.", "author": "edualonso", "createdAt": "2020-06-01T23:21:33Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedSimpleListParent.kt", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmList\n+import io.realm.RealmObject\n+import io.realm.annotations.PrimaryKey\n+\n+// Top-level object describing a simple embedded objects structure consisting of only a\n+// list of embedded objects.\n+open class EmbeddedSimpleListParent : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+\n+    @PrimaryKey\n+    var id: String? = null\n+    var children: RealmList<EmbeddedSimpleChild> = RealmList()", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDE2OA==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434050168", "bodyText": "We don't support final fields in the annotation processor. Probably mostly an oversight which is a lot more annoying in Kotlin. I created #6892. I suspect it would be a fairly trivial fix.", "author": "cmelchior", "createdAt": "2020-06-02T17:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1NzU1Mw==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434157553", "bodyText": "Good to know, I had no idea.", "author": "edualonso", "createdAt": "2020-06-02T20:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MDgwNQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433540805", "bodyText": "Does it make sense to have an individual leafNode while having a leafNodeList? Also, no var for the lists.", "author": "edualonso", "createdAt": "2020-06-01T23:27:23Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedTreeNode.kt", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmList\n+import io.realm.RealmObject\n+import io.realm.annotations.RealmClass\n+import java.util.*\n+\n+// Middle-level node in a object-graph that is three-shaped, i.e. no circular references.\n+// The tree depth can be described as:\n+// - 1 TreeParent\n+// - 1 or more TreeNode's. I.e. a TreeNode can be the child of another TreeNode.\n+// - 1 or more TreeLeaf objects. TreeLeaf objects are always at the bottom of tree.\n+@RealmClass(embedded = true)\n+open class EmbeddedTreeNode : RealmObject {\n+    constructor() {}\n+    constructor(id: String) : super() {\n+        this.id = id\n+    }\n+    var id = UUID.randomUUID().toString()\n+    var middleNode: EmbeddedTreeNode? = null\n+    var leafNode: EmbeddedTreeLeaf? = null\n+    var middleNodeList: RealmList<EmbeddedTreeNode> = RealmList()\n+    var leafNodeList: RealmList<EmbeddedTreeLeaf> = RealmList()", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDU5Ng==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434050596", "bodyText": "I have both because it is different code paths in the generated code. I agree from a modeling perspective it looks weird.\nFor the var see above.", "author": "cmelchior", "createdAt": "2020-06-02T17:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1NzM1Ng==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r434157356", "bodyText": "Got it \ud83d\udc4d", "author": "edualonso", "createdAt": "2020-06-02T20:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MTMwNQ==", "url": "https://github.com/realm/realm-java/pull/6730#discussion_r433541305", "bodyText": "You can possibly do what Claus and I suggested above here too.", "author": "edualonso", "createdAt": "2020-06-01T23:29:00Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/entities/embedded/EmbeddedWithConstructorArgs.kt", "diffHunk": "@@ -0,0 +1,11 @@\n+package io.realm.entities.embedded\n+\n+import io.realm.RealmObject\n+\n+open class EmbeddedWithConstructorArgs : RealmObject() {", "originalCommit": "fa80edbd0e7cd8be5e346b535835fef9dd4a2191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8d2662d1a520f342e05f07fdcc89ab6cdffe03e0", "url": "https://github.com/realm/realm-java/commit/8d2662d1a520f342e05f07fdcc89ab6cdffe03e0", "message": "Merge branch 'v10' into cm/embedded-objects", "committedDate": "2020-06-02T10:36:41Z", "type": "commit"}, {"oid": "8c600a7642b2517aefd5d532c510e1d900dba807", "url": "https://github.com/realm/realm-java/commit/8c600a7642b2517aefd5d532c510e1d900dba807", "message": "Apply suggestions from code review\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>", "committedDate": "2020-06-02T12:08:22Z", "type": "commit"}, {"oid": "a4d06b38e3a809edb1f31892d5c00a7e514fbab2", "url": "https://github.com/realm/realm-java/commit/a4d06b38e3a809edb1f31892d5c00a7e514fbab2", "message": "PR feedback", "committedDate": "2020-06-02T18:37:45Z", "type": "commit"}, {"oid": "264867f3aec5ee9fea75dd41e90440d1dda1e180", "url": "https://github.com/realm/realm-java/commit/264867f3aec5ee9fea75dd41e90440d1dda1e180", "message": "Merge branch 'cm/embedded-objects' of https://github.com/realm/realm-java into cm/embedded-objects", "committedDate": "2020-06-02T18:37:57Z", "type": "commit"}, {"oid": "de5ac9f325ee99a153c5392cbc12079c16a455d5", "url": "https://github.com/realm/realm-java/commit/de5ac9f325ee99a153c5392cbc12079c16a455d5", "message": "Fix test", "committedDate": "2020-06-02T19:31:42Z", "type": "commit"}, {"oid": "0efd5fb1b2a8ceda24e54fe78140d0dd0548e14c", "url": "https://github.com/realm/realm-java/commit/0efd5fb1b2a8ceda24e54fe78140d0dd0548e14c", "message": "Add missing impl", "committedDate": "2020-06-02T19:57:10Z", "type": "commit"}, {"oid": "217f1d30c7a29cbd334431257957a847b695e2fd", "url": "https://github.com/realm/realm-java/commit/217f1d30c7a29cbd334431257957a847b695e2fd", "message": "Fix list tests", "committedDate": "2020-06-03T07:56:01Z", "type": "commit"}]}