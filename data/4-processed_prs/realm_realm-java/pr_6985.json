{"pr_number": 6985, "pr_title": "Add support for string based JSON import of embedded objects", "pr_createdAt": "2020-07-02T15:01:30Z", "pr_url": "https://github.com/realm/realm-java/pull/6985", "timeline": [{"oid": "09b58c46b194343fecd34b64afb1f402e2b11f58", "url": "https://github.com/realm/realm-java/commit/09b58c46b194343fecd34b64afb1f402e2b11f58", "message": "Add support for json import of embedded objects", "committedDate": "2020-07-02T14:57:32Z", "type": "commit"}, {"oid": "1e5c68e2432385bc1d73003a89f27d7db89c7039", "url": "https://github.com/realm/realm-java/commit/1e5c68e2432385bc1d73003a89f27d7db89c7039", "message": "Add support for json import of list of embedded objects", "committedDate": "2020-07-02T19:40:35Z", "type": "commit"}, {"oid": "52299681ed25ba0423f8dd1cea9436adad6ac25c", "url": "https://github.com/realm/realm-java/commit/52299681ed25ba0423f8dd1cea9436adad6ac25c", "message": "Update expected processor test output", "committedDate": "2020-07-02T20:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449248392", "bodyText": "@cmelchior Any particular reason for this to be the interface type?\nAdding the embedded objects require a RealmModel parent. Currently the fillers just use a hardcoded obj reference, but could of course just add both the interface and implementation typed variables as arguments  to the fillers where needed.", "author": "rorbech", "createdAt": "2020-07-02T20:23:26Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt", "diffHunk": "@@ -2066,107 +2066,126 @@ class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvi\n     @Throws(IOException::class)\n     private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {\n         writer.apply {\n+            val embedded = metadata.embedded\n             emitAnnotation(\"SuppressWarnings\", \"\\\"cast\\\"\")\n-            beginMethod(qualifiedJavaClassName,\"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n-            val modelOrListCount = countModelOrListFields(metadata.fields)\n-            if (modelOrListCount == 0) {\n-                emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+            if (!embedded) {\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             } else {\n-                emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n+                beginMethod(qualifiedJavaClassName, \"createOrUpdateUsingJsonObject\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList(\"Realm\", \"realm\", \"RealmModel\", \"parent\", \"String\", \"parentProperty\", \"JSONObject\", \"json\", \"boolean\", \"update\"), listOf(\"JSONException\"))\n             }\n-\n-            if (!metadata.hasPrimaryKey()) {\n-                buildExcludeFieldsList(writer, metadata.fields)\n-                emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n-            } else {\n-                var pkType = \"Long\"\n-                var jsonAccessorMethodSuffix = \"Long\"\n-                var findFirstCast = \"\"\n-                if (Utils.isString(metadata.primaryKey)) {\n-                    pkType = \"String\"\n-                    jsonAccessorMethodSuffix=  \"String\"\n-                } else if (Utils.isObjectId(metadata.primaryKey)) {\n-                    pkType = \"ObjectId\"\n-                    findFirstCast = \"(org.bson.types.ObjectId)\"\n-                    jsonAccessorMethodSuffix = \"\"\n+                val modelOrListCount = countModelOrListFields(metadata.fields)\n+                if (modelOrListCount == 0) {\n+                    emitStatement(\"final List<String> excludeFields = Collections.<String> emptyList()\")\n+                } else {\n+                    emitStatement(\"final List<String> excludeFields = new ArrayList<String>(%1\\$d)\", modelOrListCount)\n                 }\n-                emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n-                beginControlFlow(\"if (update)\")\n-                    emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n-                    emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n-                    emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n-                    emitStatement(\"long objKey = Table.NO_MATCH\")\n-                    if (metadata.isNullable(metadata.primaryKey!!)) {\n-                        beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n-                        nextControlFlow(\"else\")\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+\n+                if (!metadata.hasPrimaryKey()) {\n+                    buildExcludeFieldsList(writer, metadata.fields)\n+                    if (!embedded) {\n+                        emitStatement(\"%s obj = realm.createObjectInternal(%s.class, true, excludeFields)\", qualifiedJavaClassName, qualifiedJavaClassName)\n                     } else {\n-                        beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n-                            emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n-                        endControlFlow()\n+                        emitStatement(\"%s obj = realm.createEmbeddedObject(%s.class, parent, parentProperty)\", qualifiedJavaClassName, qualifiedJavaClassName)\n+                    }\n+                } else {\n+                    var pkType = \"Long\"\n+                    var jsonAccessorMethodSuffix = \"Long\"\n+                    var findFirstCast = \"\"\n+                    if (Utils.isString(metadata.primaryKey)) {\n+                        pkType = \"String\"\n+                        jsonAccessorMethodSuffix=  \"String\"\n+                    } else if (Utils.isObjectId(metadata.primaryKey)) {\n+                        pkType = \"ObjectId\"\n+                        findFirstCast = \"(org.bson.types.ObjectId)\"\n+                        jsonAccessorMethodSuffix = \"\"\n                     }\n-                    beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n-                        emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n-                        beginControlFlow(\"try\")\n-                            emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n-                            emitStatement(\"obj = new %s()\", generatedClassName)\n-                        nextControlFlow(\"finally\")\n-                            emitStatement(\"objectContext.clear()\")\n+                    emitStatement(\"%s obj = null\", qualifiedJavaClassName)\n+                    beginControlFlow(\"if (update)\")\n+                        emitStatement(\"Table table = realm.getTable(%s.class)\", qualifiedJavaClassName)\n+                        emitStatement(\"%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)\", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)\n+                        emitStatement(\"long pkColumnKey = %s\", fieldColKeyVariableReference(metadata.primaryKey))\n+                        emitStatement(\"long objKey = Table.NO_MATCH\")\n+                        if (metadata.isNullable(metadata.primaryKey!!)) {\n+                            beginControlFlow(\"if (json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirstNull(pkColumnKey)\")\n+                            nextControlFlow(\"else\")\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        } else {\n+                            beginControlFlow(\"if (!json.isNull(\\\"%s\\\"))\", metadata.primaryKey!!.simpleName)\n+                                emitStatement(\"objKey = table.findFirst%s(pkColumnKey, %sjson.get%s(\\\"%s\\\"))\", pkType, findFirstCast, jsonAccessorMethodSuffix, metadata.primaryKey!!.simpleName)\n+                            endControlFlow()\n+                        }\n+                        beginControlFlow(\"if (objKey != Table.NO_MATCH)\")\n+                            emitStatement(\"final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()\")\n+                            beginControlFlow(\"try\")\n+                                emitStatement(\"objectContext.set(realm, table.getUncheckedRow(objKey), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())\", qualifiedJavaClassName)\n+                                emitStatement(\"obj = new %s()\", generatedClassName)\n+                            nextControlFlow(\"finally\")\n+                                emitStatement(\"objectContext.clear()\")\n+                            endControlFlow()\n                         endControlFlow()\n                     endControlFlow()\n-                endControlFlow()\n \n-                beginControlFlow(\"if (obj == null)\")\n-                    buildExcludeFieldsList(writer, metadata.fields)\n-                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n-                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n-                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n-                endControlFlow()\n-            }\n-            emitEmptyLine()\n-            emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)\n-            for (field in metadata.fields) {\n-                val fieldName = field.simpleName.toString()\n-                val qualifiedFieldType = QualifiedClassName(field.asType().toString())\n-                if (metadata.isPrimaryKey(field)) {\n-                    continue  // Primary key has already been set when adding new row or finding the existing row.\n+                    beginControlFlow(\"if (obj == null)\")\n+                        buildExcludeFieldsList(writer, metadata.fields)\n+                        val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())\n+                        val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()\n+                        RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)\n+                    endControlFlow()\n                 }\n-                when {\n-                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            (field.asType() as DeclaredType).typeArguments[0].toString(),\n-                            Utils.getProxyClassSimpleName(field),\n-                            writer)\n-                    Utils.isRealmValueList(field) -> emitStatement(\"ProxyUtils.setRealmListWithJsonObject(objProxy.%1\\$s(), json, \\\"%2\\$s\\\")\", metadata.getInternalGetter(fieldName), fieldName)\n-                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalGetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n-                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(\n-                            \"objProxy\",\n-                            metadata.getInternalSetter(fieldName),\n-                            fieldName,\n-                            qualifiedFieldType,\n-                            writer)\n+                emitEmptyLine()\n+                emitStatement(\"final %1\\$s objProxy = (%1\\$s) obj\", interfaceName)", "originalCommit": "52299681ed25ba0423f8dd1cea9436adad6ac25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwODA2MA==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449408060", "bodyText": "I'm a bit unsure, but I believe it is in order to reference the future generated getters and setters in the model class", "author": "cmelchior", "createdAt": "2020-07-03T06:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMjIzMw==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449502233", "bodyText": "Yes, I guess we now need both the proxy and the actual object (RealmModel)", "author": "rorbech", "createdAt": "2020-07-03T10:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUwMjg0MA==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449502840", "bodyText": "The proxy is always a subclass of the realm model, so you can do unsafe casts if needed. We do that in a few places.", "author": "cmelchior", "createdAt": "2020-07-03T10:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzNzM2Ng==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449637366", "bodyText": "Did the unsafe cast instead, as I think it will cause less confusion than juggling differently typed references to the same object.", "author": "rorbech", "createdAt": "2020-07-03T15:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0ODM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNTY5OQ==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449405699", "bodyText": "I don't think we should completely remove this placeholder as it also covers the other json variants, but the name and description could have been more clear about that.", "author": "cmelchior", "createdAt": "2020-07-03T06:47:57Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -437,9 +436,53 @@ class EmbeddedObjectsTest {\n     }\n \n     @Test\n-    @Ignore(\"Add in another PR\")\n-    fun createObjectFromJson() {", "originalCommit": "52299681ed25ba0423f8dd1cea9436adad6ac25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUyMzYyMg==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449523622", "bodyText": "Added another separate ignored test for the stream-based API", "author": "rorbech", "createdAt": "2020-07-03T11:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNTY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNjA4Mg==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449406082", "bodyText": "You are using !! in other places?", "author": "cmelchior", "createdAt": "2020-07-03T06:49:04Z", "path": "realm/realm-library/src/androidTest/kotlin/io/realm/EmbeddedObjectsTest.kt", "diffHunk": "@@ -437,9 +436,53 @@ class EmbeddedObjectsTest {\n     }\n \n     @Test\n-    @Ignore(\"Add in another PR\")\n-    fun createObjectFromJson() {\n-        TODO(\"Placeholder for all tests regarding importing from JSON\")\n+    fun createEmbeddedObjectFromJson() {\n+        realm.executeTransaction { realm ->\n+            realm.createObjectFromJson(EmbeddedCircularParent::class.java, \"\"\"\n+                        { \n+                            \"id\": \"uuid\", \n+                            \"singleChild\": { \n+                                \"id\" : \"childId\", \n+                                \"singleChild\" : { \n+                                    \"id\": \"embeddedChildId\" \n+                                }\n+                            }\n+                        }\n+                \"\"\")\n+        }\n+        val circularParent = realm.where(EmbeddedCircularParent::class.java).findFirst()!!\n+        assertEquals(\"childId\", circularParent.singleChild?.id)", "originalCommit": "52299681ed25ba0423f8dd1cea9436adad6ac25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQzMDczNA==", "url": "https://github.com/realm/realm-java/pull/6985#discussion_r449430734", "bodyText": "Would Importing embedded classes from JSON without a parent is now allowed be more clear? orphaned feels like it had a parent once, which it didn't in this case.", "author": "cmelchior", "createdAt": "2020-07-03T07:47:28Z", "path": "realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt", "diffHunk": "@@ -423,7 +423,11 @@ class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingE\n                     Arrays.asList(\"JSONException\")\n             )\n                 emitMediatorShortCircuitSwitch(writer, emitStatement = { i: Int ->\n-                    emitStatement(\"return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))\", qualifiedProxyClasses[i])\n+                    if (!embeddedClass[i]) {\n+                        emitStatement(\"return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))\", qualifiedProxyClasses[i])\n+                    } else {\n+                        emitStatement(\"throw new IllegalArgumentException(\\\"Cannot import orphaned embedded class from json\\\")\")", "originalCommit": "52299681ed25ba0423f8dd1cea9436adad6ac25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d50a15258e5c14221ee4c945960699cb716e2fc2", "url": "https://github.com/realm/realm-java/commit/d50a15258e5c14221ee4c945960699cb716e2fc2", "message": "Updates addressing code review comments", "committedDate": "2020-07-03T10:09:29Z", "type": "commit"}, {"oid": "8eab906a173dd941e75a02acc1a7105c4589e7a6", "url": "https://github.com/realm/realm-java/commit/8eab906a173dd941e75a02acc1a7105c4589e7a6", "message": "Add sample output for embedded class proxy", "committedDate": "2020-07-03T10:25:54Z", "type": "commit"}, {"oid": "d95c9d72383f2c89e6d3e7350f7e87e87375843c", "url": "https://github.com/realm/realm-java/commit/d95c9d72383f2c89e6d3e7350f7e87e87375843c", "message": "Merge branch 'v10' into cr/embedded-object-json-import", "committedDate": "2020-07-03T13:53:51Z", "type": "commit"}, {"oid": "c0083385ba325ca9cbf947cac1653e66082bfd7f", "url": "https://github.com/realm/realm-java/commit/c0083385ba325ca9cbf947cac1653e66082bfd7f", "message": "Merge branch 'v10' into cr/embedded-object-json-import", "committedDate": "2020-07-03T14:00:41Z", "type": "commit"}, {"oid": "f3d1c6d12f0646b1ef7b8bb45fe8b4902e5698b1", "url": "https://github.com/realm/realm-java/commit/f3d1c6d12f0646b1ef7b8bb45fe8b4902e5698b1", "message": "Use unsafe cast instead of multiple references to parent object", "committedDate": "2020-07-03T14:14:17Z", "type": "commit"}, {"oid": "9c47621a54d76fa58da31997723105cd95dc4486", "url": "https://github.com/realm/realm-java/commit/9c47621a54d76fa58da31997723105cd95dc4486", "message": "Update CHANGELOG", "committedDate": "2020-07-03T14:21:51Z", "type": "commit"}]}