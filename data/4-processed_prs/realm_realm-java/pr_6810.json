{"pr_number": 6810, "pr_title": "Add support for Realm Functions", "pr_createdAt": "2020-04-22T15:00:23Z", "pr_url": "https://github.com/realm/realm-java/pull/6810", "timeline": [{"oid": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "url": "https://github.com/realm/realm-java/commit/6ff4df5e231e97908c3ae976bd9f44607d1190e7", "message": "Initial Stitch Functions API\n\nFirst draft on an API for Functions and BSON type conversions and serialization.", "committedDate": "2020-04-22T14:43:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTIxNg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413349216", "bodyText": "Nothing wrong with adding JVM tests, but I'm not 100% sure our Jenkins setup actually runs them?", "author": "cmelchior", "createdAt": "2020-04-22T21:34:23Z", "path": "realm/realm-library/build.gradle", "diffHunk": "@@ -97,6 +97,9 @@ android {\n     }\n \n     sourceSets {\n+        testObjectServer {", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMjUyMQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414532521", "bodyText": "Seems to be executed by ./gradlew check (at least locally), but test results were not picked up. Added that to Jenkinsfile. Will try to inspect CI artifacts.", "author": "rorbech", "createdAt": "2020-04-24T12:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTU2OA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413349568", "bodyText": "Suggested change", "author": "cmelchior", "createdAt": "2020-04-22T21:35:07Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionTests.kt", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonInt32\n+import org.bson.BsonValue\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmFunctionTests {\n+    \n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+\n+    private lateinit var anonUser: RealmUser\n+    private lateinit var admin: ServerAdmin\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        admin = ServerAdmin()\n+        anonUser = app.login(RealmCredentials.anonymous())\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close() \n+    }\n+\n+    @Test\n+    fun test_basic() = looperThread.runBlocking {\n+        val functions = anonUser.functions\n+        val result1a: BsonValue = functions.callFunction(\"sum\", BsonInt32(32))\n+        val result1b: BsonInt32? = functions.callFunctionTyped(\"sum\", BsonInt32::class.java, 32)\n+        val result1d: Integer = functions.callFunctionNativeTyped(\"sum\", Integer::class.java, 32)\n+        val result1e: Int = functions.callFunctionNativeTyped(\"sum\", Integer::class.java, 32).toInt()\n+        val result1f: String = functions.callFunctionNativeTyped(\"sum\", String::class.java, \"Realm\")\n+        // Does not compile as intended\n+        // val result1g: BsonString = functions.callFunctionBson(\"sum\", BsonInt32::class.java, BsonInt32(32))\n+\n+        val result2: RealmAsyncTask = functions.callFunctionAsync(\n+                \"sum\",\n+                RealmApp.Callback<BsonValue> {result ->\n+                    println(\"function: \"  + result.get())\n+                    looperThread.testComplete()\n+                },\n+                BsonInt32(32)\n+        )\n+    }\n+\n+\n+    \n+}\n+", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzMzYyMQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414533621", "bodyText": "Tried configuring AS to ensure proper line feed at end of file.", "author": "rorbech", "createdAt": "2020-04-24T12:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0OTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MTkwNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413351904", "bodyText": "Right now there is only one test in this class, so not relevant yet, but maybe later. In other classes, we usually define an enum with all cases the tests should support. That way, if we need to add or remove a type from the tests, we know which tests to modify. See e.g. https://github.com/realm/realm-java/blob/master/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java#L368", "author": "cmelchior", "createdAt": "2020-04-22T21:39:28Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionTests.kt", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.rule.BlockingLooperThread\n+import org.bson.BsonInt32\n+import org.bson.BsonValue\n+import org.junit.After\n+import org.junit.Before\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+\n+@RunWith(AndroidJUnit4::class)\n+class RealmFunctionTests {\n+    \n+    private val looperThread = BlockingLooperThread()\n+    private lateinit var app: TestRealmApp\n+\n+    private lateinit var anonUser: RealmUser\n+    private lateinit var admin: ServerAdmin\n+\n+    @Before\n+    fun setUp() {\n+        app = TestRealmApp()\n+        admin = ServerAdmin()\n+        anonUser = app.login(RealmCredentials.anonymous())\n+    }\n+\n+    @After\n+    fun tearDown() {\n+        app.close() \n+    }\n+\n+    @Test\n+    fun test_basic() = looperThread.runBlocking {\n+        val functions = anonUser.functions\n+        val result1a: BsonValue = functions.callFunction(\"sum\", BsonInt32(32))", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxOTQwNw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423519407", "bodyText": "Tried to follow the principle. I guess it should be combined with https://junit.org/junit4/javadoc/4.12/org/junit/rules/ErrorCollector.html to collect all error across enum values and report at the end.", "author": "rorbech", "createdAt": "2020-05-12T07:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY5NA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423525694", "bodyText": "Ah, we never used that one. We just let the test fail after the first error, but actually sounds like a good idea. But doesn't have to be part of this PR.", "author": "cmelchior", "createdAt": "2020-05-12T07:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MTA3Mw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423541073", "bodyText": "No, somehow also breaks initialization of the Androidx runner, so I will be for some other time. Seems like there is a fix for the BSON parser already, so everything should hopefully pass after upgrading.", "author": "rorbech", "createdAt": "2020-05-12T08:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTQ1NQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413361455", "bodyText": "Shouldn't these just be private?", "author": "cmelchior", "createdAt": "2020-04-22T21:58:15Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -15,5 +15,107 @@\n  */\n package io.realm;\n \n-class RealmFunctions {\n+import org.bson.BsonDocument;\n+import org.bson.BsonElement;\n+import org.bson.BsonValue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.util.BsonConverter;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB functions.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+public class RealmFunctions {\n+\n+    /**\n+     * Call a Stitch function synchronously.\n+     *\n+     * @param name Name of the Stitch function to call.\n+     * @param args Arguments to the Stitch function.\n+     * @return Result of the Stitch function.\n+     *\n+     * // FIXME Document possible exceptions\n+     * @throws\n+     */\n+    public BsonValue callFunction(String name, BsonValue... args) {\n+        List<BsonElement> elements = new ArrayList<>(args.length);\n+        int i = 0;\n+        for (BsonValue arg : args) {\n+            // FIXME Bson argument naming\n+            elements.add(new BsonElement(\"arg\" + i, arg));\n+            ++i;\n+        }\n+        BsonDocument document = new BsonDocument(elements);\n+\n+        String resultString = invoke(name, document.toJson());\n+\n+        BsonDocument resultDocument = BsonDocument.parse(resultString);\n+        // FIXME Guard if no values, etc. when conventions are clarified\n+        BsonValue result = resultDocument.values().iterator().next();\n+        return result;\n+    }\n+\n+    <T extends BsonValue> T callFunctionTyped(String name, Class<T> clz, BsonValue... args) {", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNDMzMQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414534331", "bodyText": "Reworked public interface.", "author": "rorbech", "createdAt": "2020-04-24T12:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTk3OQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413361979", "bodyText": "Is the intent to have BsonValue... as input arguments? Did you consider Object...?", "author": "cmelchior", "createdAt": "2020-04-22T21:59:19Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -15,5 +15,107 @@\n  */\n package io.realm;\n \n-class RealmFunctions {\n+import org.bson.BsonDocument;\n+import org.bson.BsonElement;\n+import org.bson.BsonValue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.util.BsonConverter;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB functions.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+public class RealmFunctions {\n+\n+    /**\n+     * Call a Stitch function synchronously.\n+     *\n+     * @param name Name of the Stitch function to call.\n+     * @param args Arguments to the Stitch function.\n+     * @return Result of the Stitch function.\n+     *\n+     * // FIXME Document possible exceptions\n+     * @throws\n+     */\n+    public BsonValue callFunction(String name, BsonValue... args) {", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MjcxNg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413362716", "bodyText": "It should also throw ObjectServerError since it will hit the server", "author": "cmelchior", "createdAt": "2020-04-22T22:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNjY1Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414536652", "bodyText": "Intention was to also let people have an API without too much automatism, but have now updated interface to accept Objects doing automatic conversion for primitive types. Added 'ObjectServcerError' \ud83d\udc4d", "author": "rorbech", "createdAt": "2020-04-24T12:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NDgyMw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413364823", "bodyText": "Most likely we need to add the user as an argument to functions, but can be added when needed", "author": "cmelchior", "createdAt": "2020-04-22T22:05:30Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmUser.java", "diffHunk": "@@ -412,10 +413,16 @@ public synchronized ApiKeyAuthProvider getApiKeyAuthProvider() {\n     }\n \n     /**\n-     * FIXME Add support for functions. Name of Class and method still TBD.\n+     * Returns a <i>Realm Functions</i> manager need for invoking MongoDB Stitch Functions.\n+     *\n+     * FIXME Name of Class and method still TBD.\n      */\n-    public RealmFunctions getFunctions() {\n-        return null;\n+    public synchronized RealmFunctions getFunctions() {\n+        checkLoggedIn();\n+        if (functions == null) {\n+            functions = new RealmFunctions();", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NTQ1NA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413365454", "bodyText": "Normally we use the whole name to avoid confusion if it is a class name that exists in multiple packages.", "author": "cmelchior", "createdAt": "2020-04-22T22:06:43Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/util/BsonConverter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.util;\n+\n+import org.bson.BsonInt32;\n+import org.bson.BsonInt64;\n+import org.bson.BsonString;\n+import org.bson.BsonType;\n+import org.bson.BsonValue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A <i>BSON converter</i> to handle conversion between native Java types and BSON values.\n+ */\n+public class BsonConverter {\n+\n+    /**\n+     * Converts value object to BSON value based on type.\n+     *\n+     * @param value The object to convert.\n+     * @return BSON value representation of the origin value object.\n+     *\n+     * @throws UnsupportedOperationException If the object could not be mapped to a BSON type.\n+     */\n+    // FIXME Review supported types\n+    public static BsonValue to(Object value) {\n+        // Just leave BsonValues as is\n+        if (value instanceof BsonValue) {\n+            return (BsonValue) value;\n+        } else if (value instanceof Integer) {\n+            return new BsonInt32((Integer) value);\n+        } else if (value instanceof Long) {\n+            return new BsonInt64((Long) value);\n+        } else if (value instanceof String){\n+            return new BsonString((String) value);\n+        }\n+        throw new UnsupportedOperationException(\"Conversion to BSON value not supported for \" + value.getClass().getSimpleName() );", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNjc2Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414536762", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-04-24T12:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NjkzNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413366934", "bodyText": "This test is missing a bunch of supported types.", "author": "cmelchior", "createdAt": "2020-04-22T22:09:48Z", "path": "realm/realm-library/src/testObjectServer/kotlin/io/realm/BsonTest.kt", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import io.realm.internal.util.BsonConverter\n+import org.bson.*\n+import org.bson.types.ObjectId\n+import org.junit.Assert.assertEquals\n+import org.junit.Test\n+import kotlin.test.assertFailsWith\n+\n+class BsonTest {\n+\n+    /**\n+     * Simple test to verify semantics of org.bson JSON encoding and decoding.\n+     */\n+    @Test\n+    fun test_bson_roundtrip() {", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU2NjE0Ng==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413566146", "bodyText": "Normally we don't prefix tests with test since the @Test annotation already convey that", "author": "cmelchior", "createdAt": "2020-04-23T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzNzczMQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414537731", "bodyText": "Updated naming. This test is actually not testing any Realm specific code, so ignoring it, but left to future programmatic experiments with the BSON api.", "author": "rorbech", "createdAt": "2020-04-24T12:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NzQxOA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413367418", "bodyText": "Didn't knew that Kotlin had this. I added our own variant in another PR, but using this would be better \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-04-22T22:10:53Z", "path": "realm/realm-library/src/testObjectServer/kotlin/io/realm/BsonTest.kt", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import io.realm.internal.util.BsonConverter\n+import org.bson.*\n+import org.bson.types.ObjectId\n+import org.junit.Assert.assertEquals\n+import org.junit.Test\n+import kotlin.test.assertFailsWith", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NzUyNg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413367526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "cmelchior", "createdAt": "2020-04-22T22:11:05Z", "path": "realm/realm-library/src/testObjectServer/kotlin/io/realm/BsonTest.kt", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm\n+\n+import io.realm.internal.util.BsonConverter\n+import org.bson.*\n+import org.bson.types.ObjectId\n+import org.junit.Assert.assertEquals\n+import org.junit.Test\n+import kotlin.test.assertFailsWith\n+\n+class BsonTest {\n+\n+    /**\n+     * Simple test to verify semantics of org.bson JSON encoding and decoding.\n+     */\n+    @Test\n+    fun test_bson_roundtrip() {\n+        val valueInt32   = 42\n+        val valueInt64   = 42L\n+        val valueString  = \"Realm\"\n+        val valueBoolean = true\n+        val valueOid     = ObjectId()\n+\n+        val document = BsonDocument.parse(\"{}\")\n+\n+        document.append(\"arg1\", BsonInt32(valueInt32))\n+        document.append(\"arg2\", BsonInt64(valueInt64))\n+        document.append(\"arg3\", BsonString(valueString))\n+        document.append(\"arg4\", BsonBoolean(valueBoolean))\n+        document.append(\"arg5\", BsonObjectId(valueOid))\n+\n+        val roundtrip = BsonDocument.parse(document.toJson())\n+        assertEquals(valueInt32,   roundtrip.get(\"arg1\")?.asInt32()?.value)\n+        assertEquals(valueInt64,   roundtrip.get(\"arg2\")?.asInt64()?.value)\n+        assertEquals(valueString,  roundtrip.get(\"arg3\")?.asString()?.value)\n+        assertEquals(valueBoolean, roundtrip.get(\"arg4\")?.asBoolean()?.value)\n+        assertEquals(valueOid,     roundtrip.get(\"arg5\")?.asObjectId()?.value)\n+\n+        // We cannot retrieve bson values differently type, not even if it could fit in the type\n+        assertFailsWith<RuntimeException> {\n+            roundtrip.getInt32(\"arg2\");\n+        }\n+        assertFailsWith<RuntimeException> {\n+            roundtrip.getInt64(\"arg1\");\n+        }\n+    }\n+\n+    /**\n+     * Simple test of type conversion between native Java object types and BSON types.\n+     */\n+    @Test\n+    fun test_bson_conversion() {\n+        val values = BsonConverter.to(32, 43L, \"Realm\")\n+        assertEquals(listOf(BsonInt32(32), BsonInt64(43), BsonString(\"Realm\")), values)\n+\n+        assertEquals(32, BsonConverter.from(Integer::class.java, BsonInt32(32)))\n+\n+        // FIXME Do we need to add Kotlin extensions to work around having to reference java types explicitly\n+\n+        assertEquals(32L, BsonConverter.from(java.lang.Long::class.java, BsonInt64(32)))\n+        assertEquals(\"Realm\", BsonConverter.from(java.lang.String::class.java, BsonString(\"Realm\")))\n+        assertFailsWith<java.lang.UnsupportedOperationException> {\n+            BsonConverter.from(Long::class.java, BsonInt32(32))\n+        }\n+        assertFailsWith<java.lang.UnsupportedOperationException> {\n+            BsonConverter.from(Long::class.java, BsonInt32(32))\n+        }\n+\n+        // FIXME Add tests for BsonConverter.bsontype\n+    }\n+\n+}", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NzMxOQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414547319", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-04-24T12:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2NzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MjAwMA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r413372000", "bodyText": "Is this just a placeholder or the actual API contract?", "author": "cmelchior", "createdAt": "2020-04-22T22:20:22Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -15,5 +15,107 @@\n  */\n package io.realm;\n \n-class RealmFunctions {\n+import org.bson.BsonDocument;\n+import org.bson.BsonElement;\n+import org.bson.BsonValue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.util.BsonConverter;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB functions.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+public class RealmFunctions {\n+\n+    /**\n+     * Call a Stitch function synchronously.\n+     *\n+     * @param name Name of the Stitch function to call.\n+     * @param args Arguments to the Stitch function.\n+     * @return Result of the Stitch function.\n+     *\n+     * // FIXME Document possible exceptions\n+     * @throws\n+     */\n+    public BsonValue callFunction(String name, BsonValue... args) {\n+        List<BsonElement> elements = new ArrayList<>(args.length);\n+        int i = 0;\n+        for (BsonValue arg : args) {\n+            // FIXME Bson argument naming\n+            elements.add(new BsonElement(\"arg\" + i, arg));", "originalCommit": "6ff4df5e231e97908c3ae976bd9f44607d1190e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzOTE3Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414539172", "bodyText": "Contract seems to be passing all arguments as one BSONArray with key arguments.", "author": "rorbech", "createdAt": "2020-04-24T12:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MjAwMA=="}], "type": "inlineReview"}, {"oid": "d77bea209c999a2868d3b531457e4c19017f44d0", "url": "https://github.com/realm/realm-java/commit/d77bea209c999a2868d3b531457e4c19017f44d0", "message": "Collect JVM test results in CI", "committedDate": "2020-04-24T11:16:46Z", "type": "commit"}, {"oid": "e5c8fc010587b7eb6d92ab224416cedc749fbec6", "url": "https://github.com/realm/realm-java/commit/e5c8fc010587b7eb6d92ab224416cedc749fbec6", "message": "Update Functions API and BSON conversion accordingly", "committedDate": "2020-04-24T12:18:49Z", "type": "commit"}, {"oid": "fe2c357179fd57a242263b86d9bcb7fe22bfe5d5", "url": "https://github.com/realm/realm-java/commit/fe2c357179fd57a242263b86d9bcb7fe22bfe5d5", "message": "Fix access modifier for public api", "committedDate": "2020-04-24T12:35:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NzA2Ng==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414547066", "bodyText": "@cmelchior Right now?", "author": "rorbech", "createdAt": "2020-04-24T12:44:40Z", "path": "realm/realm-library/src/testObjectServer/kotlin/io/realm/BsonTest.kt", "diffHunk": "@@ -63,24 +65,46 @@ class BsonTest {\n      * Simple test of type conversion between native Java object types and BSON types.\n      */\n     @Test\n-    fun test_bson_conversion() {\n-        val values = BsonConverter.to(32, 43L, \"Realm\")\n-        assertEquals(listOf(BsonInt32(32), BsonInt64(43), BsonString(\"Realm\")), values)\n+    fun bsonConversion() {\n+        val b = true\n+        val i32 = 32\n+        val i64 = 32L\n+        val s = \"Realm\"\n+        val oid = ObjectId()\n \n-        assertEquals(32, BsonConverter.from(Integer::class.java, BsonInt32(32)))\n+        val bi32 = BsonInt32(15)\n+        val bOid = BsonObjectId(oid)\n+        val bDoc = BsonDocument()\n \n-        // FIXME Do we need to add Kotlin extensions to work around having to reference java types explicitly\n+        val values = BsonConverter.to(b, i32, i64, s, bi32, bOid, bDoc)\n+        assertEquals(listOf(BsonBoolean(b), BsonInt32(i32), BsonInt64(i64), BsonString(s), bi32, bOid, bDoc), values)\n \n-        assertEquals(32L, BsonConverter.from(java.lang.Long::class.java, BsonInt64(32)))\n-        assertEquals(\"Realm\", BsonConverter.from(java.lang.String::class.java, BsonString(\"Realm\")))\n-        assertFailsWith<java.lang.UnsupportedOperationException> {\n-            BsonConverter.from(Long::class.java, BsonInt32(32))\n+        // BsonValue types are just passed as is\n+        assertEquals(BsonInt32(i32), BsonConverter.from(BsonInt32::class.java, BsonInt32(i32)))\n+        assertEquals(BsonInt64(i64), BsonConverter.from(BsonInt64::class.java, BsonInt64(i64)))\n+        assertEquals(BsonString(s),  BsonConverter.from(BsonString::class.java, BsonString(s)))\n+\n+        // Native types are converted directly from BsonValue to equivalent type\n+        // FIXME Howto auto box/wrap as Kotlin's primitive types are not assignable\n+        //  (isAssignablefrom) Java's auto boxed types\n+        assertEquals(b, BsonConverter.from(java.lang.Boolean::class.java, BsonBoolean(b)))\n+        // assertEquals(i32, BsonConverter.from(Int::class.java, BsonInt32(i32)))\n+        assertEquals(i32, BsonConverter.from(Integer::class.java, BsonInt32(i32)))\n+        // assertEquals(i64, BsonConverter.from(Long::class.java, BsonInt64(i64)))\n+        assertEquals(i64, BsonConverter.from(java.lang.Long::class.java, BsonInt64(i64)))\n+        // ...not trying to fit wider types event though possible\n+        // FIXME Would we like to support this\n+        assertFailsWith<IllegalArgumentException> {\n+            BsonConverter.from(java.lang.Long::class.java, BsonInt32(i32))\n         }\n-        assertFailsWith<java.lang.UnsupportedOperationException> {\n-            BsonConverter.from(Long::class.java, BsonInt32(32))\n+        assertFailsWith<IllegalArgumentException> {\n+            BsonConverter.from(Int::class.java, BsonInt64(i64))\n         }\n+        assertEquals(s, BsonConverter.from(String::class.java, BsonString(s)))\n+\n+        // FIXME Do we actually want to unwrap all of the BsonValues?\n+        //assertEquals(oid, BsonConverter.from(ObjectId::class.java, bOid))\n \n-        // FIXME Add tests for BsonConverter.bsontype\n     }\n \n-}\n\\ No newline at end of file\n+}", "originalCommit": "e5c8fc010587b7eb6d92ab224416cedc749fbec6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1NzMwMA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r414557300", "bodyText": "Yes", "author": "cmelchior", "createdAt": "2020-04-24T13:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NzA2Ng=="}], "type": "inlineReview"}, {"oid": "427c243aa757bbfea03b887e06d08415bb702e93", "url": "https://github.com/realm/realm-java/commit/427c243aa757bbfea03b887e06d08415bb702e93", "message": "Fix syntax errors in RealmFunctionTests", "committedDate": "2020-04-27T12:31:28Z", "type": "commit"}, {"oid": "729b5084283a08e194c0658ac9a95e3f9389fa2c", "url": "https://github.com/realm/realm-java/commit/729b5084283a08e194c0658ac9a95e3f9389fa2c", "message": "Draft JNI binding for Realm Functions", "committedDate": "2020-04-27T19:30:11Z", "type": "commit"}, {"oid": "ef918722303890534e15c4d35112da7a1ae0580b", "url": "https://github.com/realm/realm-java/commit/ef918722303890534e15c4d35112da7a1ae0580b", "message": "Merge branch 'v10' into cr/functions-jni", "committedDate": "2020-04-27T19:35:40Z", "type": "commit"}, {"oid": "0c2008b30242cf661962284c4bc11c33d0e647c7", "url": "https://github.com/realm/realm-java/commit/0c2008b30242cf661962284c4bc11c33d0e647c7", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-01T16:19:00Z", "type": "commit"}, {"oid": "e63c0e5ebbac0ae97234c7fa295ab07a4aef8cbf", "url": "https://github.com/realm/realm-java/commit/e63c0e5ebbac0ae97234c7fa295ab07a4aef8cbf", "message": "Update OS to latest lm/remote-mongo-bson", "committedDate": "2020-05-01T21:56:33Z", "type": "commit"}, {"oid": "9528f524a672d686035f1f5305166525f41e357a", "url": "https://github.com/realm/realm-java/commit/9528f524a672d686035f1f5305166525f41e357a", "message": "Actual Stitch Function round trip", "committedDate": "2020-05-01T22:01:24Z", "type": "commit"}, {"oid": "8deaaca01601f2687faf7505d9facb8ab2934edb", "url": "https://github.com/realm/realm-java/commit/8deaaca01601f2687faf7505d9facb8ab2934edb", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-05T13:28:07Z", "type": "commit"}, {"oid": "795a9fc64e207913f15d95b40479ce0e793b05b3", "url": "https://github.com/realm/realm-java/commit/795a9fc64e207913f15d95b40479ce0e793b05b3", "message": "Add ability to use CodecRegistry for passing values as BSON to JNI", "committedDate": "2020-05-05T21:12:09Z", "type": "commit"}, {"oid": "4ea5fad0881c31175cffe8b3f6bce804a1d759bf", "url": "https://github.com/realm/realm-java/commit/4ea5fad0881c31175cffe8b3f6bce804a1d759bf", "message": "Remove unnecessary import", "committedDate": "2020-05-06T06:38:31Z", "type": "commit"}, {"oid": "11a7d7d77b3102996483f5db7576209677ee91c0", "url": "https://github.com/realm/realm-java/commit/11a7d7d77b3102996483f5db7576209677ee91c0", "message": "Add default codec registry to RealmAppConfiguration", "committedDate": "2020-05-06T11:29:14Z", "type": "commit"}, {"oid": "36814522fcf6a6a314dfcb05ab285c1bd6d09ce1", "url": "https://github.com/realm/realm-java/commit/36814522fcf6a6a314dfcb05ab285c1bd6d09ce1", "message": "Expose encoder/decoder variant for JniBsonProtocol methods", "committedDate": "2020-05-06T11:32:55Z", "type": "commit"}, {"oid": "23dd90f8f023341f7cfcbee93f77b916f621a2e9", "url": "https://github.com/realm/realm-java/commit/23dd90f8f023341f7cfcbee93f77b916f621a2e9", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-06T13:09:22Z", "type": "commit"}, {"oid": "6e275484ba89ea6d21efce1fb0136d4e9cf8a4b5", "url": "https://github.com/realm/realm-java/commit/6e275484ba89ea6d21efce1fb0136d4e9cf8a4b5", "message": "Rename RealmFunctionsTest->RealmFunctionsTests", "committedDate": "2020-05-06T13:26:27Z", "type": "commit"}, {"oid": "357a4ebe564588a2a84d5eba88dc6c93f3837bb7", "url": "https://github.com/realm/realm-java/commit/357a4ebe564588a2a84d5eba88dc6c93f3837bb7", "message": "Bump OS to get BSON parsing fix for boolean in an array", "committedDate": "2020-05-06T13:58:37Z", "type": "commit"}, {"oid": "9f24cccc23f5803311130d4b75fba03d74d5d9a5", "url": "https://github.com/realm/realm-java/commit/9f24cccc23f5803311130d4b75fba03d74d5d9a5", "message": "Merge branch 'cr/bson-jni-interaction' into cr/functions", "committedDate": "2020-05-06T19:06:11Z", "type": "commit"}, {"oid": "beaece4152fbe640931d747c76d883afa9600d47", "url": "https://github.com/realm/realm-java/commit/beaece4152fbe640931d747c76d883afa9600d47", "message": "Code review updates", "committedDate": "2020-05-06T19:49:11Z", "type": "commit"}, {"oid": "ae8321494eb2da51ef64be6063ca8a1397347c8b", "url": "https://github.com/realm/realm-java/commit/ae8321494eb2da51ef64be6063ca8a1397347c8b", "message": "Code review updates", "committedDate": "2020-05-06T20:00:20Z", "type": "commit"}, {"oid": "0812ed1e892a1b4d49672b9d3f14f878ee93dd50", "url": "https://github.com/realm/realm-java/commit/0812ed1e892a1b4d49672b9d3f14f878ee93dd50", "message": "Merge branch 'cr/bson-jni-interaction' into cr/functions", "committedDate": "2020-05-07T06:49:56Z", "type": "commit"}, {"oid": "c741703255ee1d8810de0881bab65fb54381027e", "url": "https://github.com/realm/realm-java/commit/c741703255ee1d8810de0881bab65fb54381027e", "message": "Start listing required tests", "committedDate": "2020-05-07T06:50:13Z", "type": "commit"}, {"oid": "bb503c7343e2c945c12d81645ffef97bb7180a78", "url": "https://github.com/realm/realm-java/commit/bb503c7343e2c945c12d81645ffef97bb7180a78", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-11T07:51:29Z", "type": "commit"}, {"oid": "5b065a8411b34802dc30defacf26bf27bcd65e29", "url": "https://github.com/realm/realm-java/commit/5b065a8411b34802dc30defacf26bf27bcd65e29", "message": "Add map/document codec providers to default codec registry", "committedDate": "2020-05-11T15:50:46Z", "type": "commit"}, {"oid": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "url": "https://github.com/realm/realm-java/commit/a9d6bf841950a2b2803a03686d01906e8a2d2a09", "message": "Documentation and tests", "committedDate": "2020-05-11T16:58:22Z", "type": "commit"}, {"oid": "bca9f6b265fe550a57e5afca9982c6cc9ee5c464", "url": "https://github.com/realm/realm-java/commit/bca9f6b265fe550a57e5afca9982c6cc9ee5c464", "message": "Update OS to latest v10 and included fixed tests", "committedDate": "2020-05-12T08:17:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyODA5NQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423528095", "bodyText": "Nitpick: I would probably have moved this up as one line in 169", "author": "cmelchior", "createdAt": "2020-05-12T07:44:39Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppConfigurationTests.kt", "diffHunk": "@@ -152,4 +155,29 @@ class RealmAppConfigurationTests {\n         assertTrue(file.createNewFile())\n         assertFailsWith<IllegalArgumentException> { builder.syncRootDirectory(file) }\n     }\n+\n+    @Test\n+    fun codecRegistry_null() {\n+        val builder: RealmAppConfiguration.Builder = RealmAppConfiguration.Builder(\"app-id\")\n+        assertFailsWith<IllegalArgumentException> {\n+            builder.codecRegistry(TestHelper.getNull())\n+        }\n+    }\n+\n+    @Test\n+    fun defaultFunctionsCodecRegistry() {\n+        val config: RealmAppConfiguration = RealmAppConfiguration.Builder(\"app-id\")\n+                .build()", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyOTU4Nw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423529587", "bodyText": "Is DEFAULT_BSON_CODEC_REGISTRY public? If it is, I would probably move it to RealmAppConfiguration. DEFAULT_BSON_CODEC_REGISTRY as it seems easier to find there. If it is just package protected. Having it here seems fine.", "author": "cmelchior", "createdAt": "2020-05-12T07:47:12Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmAppConfigurationTests.kt", "diffHunk": "@@ -152,4 +155,29 @@ class RealmAppConfigurationTests {\n         assertTrue(file.createNewFile())\n         assertFailsWith<IllegalArgumentException> { builder.syncRootDirectory(file) }\n     }\n+\n+    @Test\n+    fun codecRegistry_null() {\n+        val builder: RealmAppConfiguration.Builder = RealmAppConfiguration.Builder(\"app-id\")\n+        assertFailsWith<IllegalArgumentException> {\n+            builder.codecRegistry(TestHelper.getNull())\n+        }\n+    }\n+\n+    @Test\n+    fun defaultFunctionsCodecRegistry() {\n+        val config: RealmAppConfiguration = RealmAppConfiguration.Builder(\"app-id\")\n+                .build()\n+        assertEquals(RealmAppConfiguration.Builder.DEFAULT_BSON_CODEC_REGISTRY, config.defaultCodecRegistry)", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODQ5MQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424208491", "bodyText": "I guess it makes sense to allow people to retrieve to build on top of it. Exposing it in RealmAppConfiguration.", "author": "rorbech", "createdAt": "2020-05-13T06:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyOTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMTkwOQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423531909", "bodyText": "Any reason to remove this? Right now we are calling this in a few hidden places. I talked with @edualonso about removing those as it just makes the requirements for running tests kinda hidden.", "author": "cmelchior", "createdAt": "2020-05-12T07:51:03Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -16,28 +16,64 @@\n \n package io.realm\n \n-import androidx.test.platform.app.InstrumentationRegistry\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.rule.BlockingLooperThread\n import org.bson.*\n import org.bson.codecs.StringCodec\n+import org.bson.codecs.configuration.CodecConfigurationException\n import org.bson.codecs.configuration.CodecRegistries\n import org.bson.codecs.pojo.PojoCodecProvider\n import org.bson.types.Decimal128\n import org.bson.types.ObjectId\n import org.junit.After\n+import org.junit.Assert.fail\n import org.junit.Before\n+import org.junit.Ignore\n import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.time.Instant\n+import java.util.*\n import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n \n+@RunWith(AndroidJUnit4::class)\n class RealmFunctionsTests {\n \n+    companion object {\n+        const val FIRST_ARG_FUNCTION = \"firstArg\"\n+    }\n+\n+    // Pojo class for testing custom encoder/decoder\n+    data class Dog(var name: String? = null)\n+\n+    private val looperThread = BlockingLooperThread()\n+\n     private lateinit var app: TestRealmApp\n-    private lateinit var functions : RealmFunctions\n+    private lateinit var functions: RealmFunctions\n+\n+    private lateinit var anonUser: RealmUser\n+    private lateinit var admin: ServerAdmin\n+\n+    // Custom registry with support for encoding/decoding Dogs\n+    val pojoRegistry by lazy {\n+        CodecRegistries.fromRegistries(\n+                app.configuration.defaultCodecRegistry,\n+                CodecRegistries.fromProviders(\n+                        PojoCodecProvider.builder()\n+                                .register(Dog::class.java)\n+                                .build()\n+                )\n+        )\n+    }\n \n     @Before\n     fun setup() {\n-        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzQwNw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423597407", "bodyText": "Previously I did not have it, as I did not use have a TestRealmApp, so I am piggybacking on the hidden one now. I forgot it in the first place and forgetting that this was the root of my missing JNI symbols, so I guess some pattern for avoiding this pitfall in the future would be nice.\nI guess we can re-adopt to pattern if updating TestRealmApp.", "author": "rorbech", "createdAt": "2020-05-12T09:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMjc0OQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423532749", "bodyText": "Logging in a user here and using it for the majority of tests seems fine, but it also means that we are currently lacking a few tests around user handling. Like what happens if one user calls a function only available to another user.", "author": "cmelchior", "createdAt": "2020-05-12T07:52:31Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -16,28 +16,64 @@\n \n package io.realm\n \n-import androidx.test.platform.app.InstrumentationRegistry\n+import androidx.test.ext.junit.runners.AndroidJUnit4\n+import io.realm.admin.ServerAdmin\n+import io.realm.rule.BlockingLooperThread\n import org.bson.*\n import org.bson.codecs.StringCodec\n+import org.bson.codecs.configuration.CodecConfigurationException\n import org.bson.codecs.configuration.CodecRegistries\n import org.bson.codecs.pojo.PojoCodecProvider\n import org.bson.types.Decimal128\n import org.bson.types.ObjectId\n import org.junit.After\n+import org.junit.Assert.fail\n import org.junit.Before\n+import org.junit.Ignore\n import org.junit.Test\n+import org.junit.runner.RunWith\n+import java.time.Instant\n+import java.util.*\n import kotlin.test.assertEquals\n+import kotlin.test.assertFailsWith\n+import kotlin.test.assertTrue\n \n+@RunWith(AndroidJUnit4::class)\n class RealmFunctionsTests {\n \n+    companion object {\n+        const val FIRST_ARG_FUNCTION = \"firstArg\"\n+    }\n+\n+    // Pojo class for testing custom encoder/decoder\n+    data class Dog(var name: String? = null)\n+\n+    private val looperThread = BlockingLooperThread()\n+\n     private lateinit var app: TestRealmApp\n-    private lateinit var functions : RealmFunctions\n+    private lateinit var functions: RealmFunctions\n+\n+    private lateinit var anonUser: RealmUser\n+    private lateinit var admin: ServerAdmin\n+\n+    // Custom registry with support for encoding/decoding Dogs\n+    val pojoRegistry by lazy {\n+        CodecRegistries.fromRegistries(\n+                app.configuration.defaultCodecRegistry,\n+                CodecRegistries.fromProviders(\n+                        PojoCodecProvider.builder()\n+                                .register(Dog::class.java)\n+                                .build()\n+                )\n+        )\n+    }\n \n     @Before\n     fun setup() {\n-        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)\n         app = TestRealmApp()\n-        functions = RealmFunctions(app.configuration.defaultCodecRegistry)\n+        admin = ServerAdmin()\n+        anonUser = app.login(RealmCredentials.anonymous())", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNDc2Nw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r425424767", "bodyText": "Execution is controlled by Authorization Expressions, so technically it has not necessarily anything to do with user, but could be any scriptable check. I added a function that requires a specific user email address, and added a test showing that the anonymous user cannot execute it while the authorized user can.", "author": "rorbech", "createdAt": "2020-05-14T20:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMjc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMzgzOQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423533839", "bodyText": "Maybe just use assertTrue ?", "author": "cmelchior", "createdAt": "2020-05-12T07:54:21Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -56,56 +93,65 @@ class RealmFunctionsTests {\n         for (type in BsonType.values()) {\n             when (type) {\n                 BsonType.DOUBLE -> {\n-                    assertEquals(1.4f, functions.invoke(1.4f, java.lang.Float::class.java).toFloat())\n-                    assertEquals(1.4, functions.invoke(1.4, java.lang.Double::class.java).toDouble())\n-                    assertTypedEcho(BsonDouble(1.4), BsonDouble::class.java)\n+                    assertEquals(1.4f, functions.callFunction(FIRST_ARG_FUNCTION, listOf(1.4f), java.lang.Float::class.java).toFloat())\n+                    assertEquals(1.4, functions.callFunction(FIRST_ARG_FUNCTION, listOf(1.4f), java.lang.Double::class.java).toDouble())\n+                    assertTypeOfFirstArgFunction(BsonDouble(1.4), BsonDouble::class.java)\n                 }\n                 BsonType.STRING -> {\n-                    assertTypedEcho(\"Realm\", String::class.java)\n-                    assertTypedEcho(BsonString(\"Realm\"), BsonString::class.java)\n+                    assertTypeOfFirstArgFunction(\"Realm\", String::class.java)\n+                    assertTypeOfFirstArgFunction(BsonString(\"Realm\"), BsonString::class.java)\n                 }\n                 BsonType.ARRAY -> {\n                     val listValues = listOf<Any>(true, i32, i64)\n-                    assertTypedEcho(listValues, List::class.java)\n-                }\n-                BsonType.BINARY -> {\n-                    val value = byteArrayOf(1, 2, 3)\n-                    val actual = functions.invoke(value, ByteArray::class.java)\n-                    assertEquals(value.toList(), actual.toList())\n-                    // FIXME C++ Does not seem to preserve subtype\n-                    // arg      = \"{\"value\": {\"$binary\": {\"base64\": \"JmS8oQitTny4IPS2tyjmdA==\", \"subType\": \"04\"}}}\"\n-                    // response = \"{\"value\":{\"$binary\":{\"base64\":\"JmS8oQitTny4IPS2tyjmdA==\",\"subType\":\"00\"}}}\"\n-                    // assertTypedEcho(BsonBinary(UUID.randomUUID()), BsonBinary::class.java)\n-                    assertTypedEcho(BsonBinary(byteArrayOf(1,2,3)), BsonBinary::class.java)\n+                    assertEquals(listValues[0], functions.callFunction(FIRST_ARG_FUNCTION, listValues, java.lang.Boolean::class.java))\n                 }\n+                // FIXME Does not seem to work, typically this has indicated an issue with C++\n+                //  parser. Probably because of embedding an array in an array, added explicit test\n+//                BsonType.BINARY -> {\n+//                    val value = byteArrayOf(1, 2, 3)\n+//                    val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), ByteArray::class.java)\n+//                    assertEquals(value.toList(), actual.toList())\n+//                    // FIXME C++ Does not seem to preserve subtype\n+//                    // arg      = \"{\"value\": {\"$binary\": {\"base64\": \"JmS8oQitTny4IPS2tyjmdA==\", \"subType\": \"04\"}}}\"\n+//                    // response = \"{\"value\":{\"$binary\":{\"base64\":\"JmS8oQitTny4IPS2tyjmdA==\",\"subType\":\"00\"}}}\"\n+//                    // assertTypedEcho(BsonBinary(UUID.randomUUID()), BsonBinary::class.java)\n+//                    assertTypedEcho(BsonBinary(byteArrayOf(1,2,3)), BsonBinary::class.java)\n+//                }\n                 BsonType.OBJECT_ID -> {\n-                    assertTypedEcho(ObjectId(), ObjectId::class.java)\n-                    assertTypedEcho(BsonObjectId(ObjectId()), BsonObjectId::class.java)\n+                    assertTypeOfFirstArgFunction(ObjectId(), ObjectId::class.java)\n+                    assertTypeOfFirstArgFunction(BsonObjectId(ObjectId()), BsonObjectId::class.java)\n                 }\n                 BsonType.BOOLEAN -> {\n-                    val value: Boolean = true\n-                    val actual: java.lang.Boolean = functions.invoke(value, java.lang.Boolean::class.java)\n-                    assertEquals(value, actual.booleanValue())\n-                    assertTypedEcho(BsonBoolean(true), BsonBoolean::class.java)\n+                    assertEquals(true, functions.callFunction(FIRST_ARG_FUNCTION, listOf(true), java.lang.Boolean::class.java).booleanValue())", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDcwNw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423534707", "bodyText": "\ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-05-12T07:55:42Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNTgzNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423535834", "bodyText": "there is also result.getOrThrow() which could reduce this to\nassertEquals(32, result.orThrow.toInt())", "author": "cmelchior", "createdAt": "2020-05-12T07:57:25Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzOTUxNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423539514", "bodyText": "We have a better KotlinTestUtils.expectErrorCode for this. The name might need a revisit after moving to assertFailsWith though.", "author": "cmelchior", "createdAt": "2020-05-12T08:03:42Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MDU2Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423540562", "bodyText": "See above. Normally we assert on a specific the error code, so result.error.errorCode", "author": "cmelchior", "createdAt": "2020-05-12T08:05:32Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MDg3OQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423540879", "bodyText": "Yes, check the error code. See above.", "author": "cmelchior", "createdAt": "2020-05-12T08:06:05Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun asyncNonLoopers() {\n+        assertFailsWith<IllegalStateException> {\n+            functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java, pojoRegistry) { result ->\n+                fail()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_sum() {\n+        val numbers = listOf(1, 2, 3, 4)\n+        assertEquals(10, functions.callFunction(\"sum\", numbers, Integer::class.java).toInt())\n+    }\n \n-        val actual: Dog = functions.invoke(input, Dog::class.java, pojoRegistry)\n+    @Test\n+    fun callFunction_remoteError() {\n+        assertFailsWith<ObjectServerError> {\n+            // FIXME Do we need to assert more about the error", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MTU3Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423541572", "bodyText": "No, we normally don't do that. The general network transport is tested elsewhere and as long as there are tests that ensure an exception/error handler can be correctly called we assume that connection errors will also be reported correctly.", "author": "cmelchior", "createdAt": "2020-05-12T08:07:13Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun asyncNonLoopers() {\n+        assertFailsWith<IllegalStateException> {\n+            functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java, pojoRegistry) { result ->\n+                fail()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_sum() {\n+        val numbers = listOf(1, 2, 3, 4)\n+        assertEquals(10, functions.callFunction(\"sum\", numbers, Integer::class.java).toInt())\n+    }\n \n-        val actual: Dog = functions.invoke(input, Dog::class.java, pojoRegistry)\n+    @Test\n+    fun callFunction_remoteError() {\n+        assertFailsWith<ObjectServerError> {\n+            // FIXME Do we need to assert more about the error\n+            functions.callFunction(\"error\", emptyList<Any>(), String::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_null() {\n+        assertTrue(functions.callFunction(\"null\", emptyList<Any>(), BsonNull::class.java).isNull)\n+    }\n+\n+    @Test\n+    fun callFunction_empty() {\n+        assertEquals(BsonType.UNDEFINED, functions.callFunction(\"empty\", emptyList<Any>(), BsonUndefined::class.java).bsonType)\n+    }\n+\n+    // FIXME Do we need to test connectivity issues", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MjQ5Ng==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423542496", "bodyText": "The TestRealmApp actually allows you to define a custom builder for this exact case:\nTestRealmApp(networkTransport: OsJavaNetworkTransport? = null, customizeConfig: (RealmAppConfiguration.Builder) -> Unit = {})", "author": "cmelchior", "createdAt": "2020-05-12T08:08:43Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun asyncNonLoopers() {\n+        assertFailsWith<IllegalStateException> {\n+            functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java, pojoRegistry) { result ->\n+                fail()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_sum() {\n+        val numbers = listOf(1, 2, 3, 4)\n+        assertEquals(10, functions.callFunction(\"sum\", numbers, Integer::class.java).toInt())\n+    }\n \n-        val actual: Dog = functions.invoke(input, Dog::class.java, pojoRegistry)\n+    @Test\n+    fun callFunction_remoteError() {\n+        assertFailsWith<ObjectServerError> {\n+            // FIXME Do we need to assert more about the error\n+            functions.callFunction(\"error\", emptyList<Any>(), String::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_null() {\n+        assertTrue(functions.callFunction(\"null\", emptyList<Any>(), BsonNull::class.java).isNull)\n+    }\n+\n+    @Test\n+    fun callFunction_empty() {\n+        assertEquals(BsonType.UNDEFINED, functions.callFunction(\"empty\", emptyList<Any>(), BsonUndefined::class.java).bsonType)\n+    }\n+\n+    // FIXME Do we need to test connectivity issues\n+\n+    @Test\n+    fun defaultCodecRegistry() {\n+        // TODO Maybe we should test that setting configuration specific would propagate all the way", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMDY2Ng==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r425430666", "bodyText": "The configuration options for settings the default codec registry is already covered in the RealmAppConfigurationTests and we test that we get the same default as the configuration. So, as the customization options is not fully implemented, I will consider this customization update to be part of another PR.", "author": "rorbech", "createdAt": "2020-05-14T21:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjc3NQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423542775", "bodyText": "Is this still true?", "author": "cmelchior", "createdAt": "2020-05-12T08:09:10Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun asyncNonLoopers() {\n+        assertFailsWith<IllegalStateException> {\n+            functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java, pojoRegistry) { result ->\n+                fail()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_sum() {\n+        val numbers = listOf(1, 2, 3, 4)\n+        assertEquals(10, functions.callFunction(\"sum\", numbers, Integer::class.java).toInt())\n+    }\n \n-        val actual: Dog = functions.invoke(input, Dog::class.java, pojoRegistry)\n+    @Test\n+    fun callFunction_remoteError() {\n+        assertFailsWith<ObjectServerError> {\n+            // FIXME Do we need to assert more about the error\n+            functions.callFunction(\"error\", emptyList<Any>(), String::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_null() {\n+        assertTrue(functions.callFunction(\"null\", emptyList<Any>(), BsonNull::class.java).isNull)\n+    }\n+\n+    @Test\n+    fun callFunction_empty() {\n+        assertEquals(BsonType.UNDEFINED, functions.callFunction(\"empty\", emptyList<Any>(), BsonUndefined::class.java).bsonType)\n+    }\n+\n+    // FIXME Do we need to test connectivity issues\n+\n+    @Test\n+    fun defaultCodecRegistry() {\n+        // TODO Maybe we should test that setting configuration specific would propagate all the way\n+        //  to here, but we do not have infrastructure to easily override TestRealmApp coniguration,\n+        //  and actual configuration is verified in RealmAppConfigurationTests\n+        assertEquals(app.configuration.defaultCodecRegistry, functions.defaultCodecRegistry)\n+    }\n \n-        assertEquals(input, actual)\n+    @Test\n+    fun customCodecRegistry() {\n+        val configCodecRegistry = CodecRegistries.fromCodecs(StringCodec())\n+        val customCodecRegistryFunctions = anonUser.getFunctions(configCodecRegistry)\n+        assertEquals(configCodecRegistry, customCodecRegistryFunctions.defaultCodecRegistry)\n+    }\n+\n+    @Test\n+    // FIXME JNI Parsing crashes", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMDk1Mw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r425430953", "bodyText": "Yes, there are still issues with the C++ parser.", "author": "rorbech", "createdAt": "2020-05-14T21:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjg5MQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423542891", "bodyText": "Same, this was fixed, right?", "author": "cmelchior", "createdAt": "2020-05-12T08:09:22Z", "path": "realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/RealmFunctionsTests.kt", "diffHunk": "@@ -116,36 +162,205 @@ class RealmFunctionsTests {\n                 BsonType.END_OF_DOCUMENT,\n                 BsonType.MIN_KEY,\n                 BsonType.MAX_KEY -> {\n-                    // No conversion is implemented for these types yet\n+                    // Relying on org.bson codec providers for conversion, so skipping explicit\n+                    // tests for these more exotic types\n                 }\n             }\n         }\n     }\n \n-    private fun <T: Any> assertTypedEcho(value: T, returnClass: Class<T>) : T {\n-        val actual = functions.invoke(value, returnClass)\n+    private fun <T : Any> assertTypeOfFirstArgFunction(value: T, returnClass: Class<T>) : T {\n+        val actual = functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), returnClass)\n         assertEquals(value, actual)\n         return actual\n     }\n \n-    // Test of BSON JNI round trip until superseded with actual public api tests are added.\n-    data class Dog(var name: String? = null)\n     @Test\n-    fun pojoCodecRegistry() {\n-        val pojoRegistry = CodecRegistries.fromRegistries(\n-                CodecRegistries.fromCodecs(StringCodec()),\n-                CodecRegistries.fromProviders(\n-                        PojoCodecProvider.builder()\n-                                .register(Dog::class.java)\n-                                .build()\n-                )\n-        )\n+    fun asyncCallFunction() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(32, result.get().toInt())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+\n+    @Test\n+    fun codecArgumentFailure() {\n+        val input = Dog(\"PojoFido\")\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecArgumentFailure() = looperThread.runBlocking {\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun codecResponseFailure() {\n+        assertFailsWith<CodecConfigurationException> {\n+            functions.callFunction(FIRST_ARG_FUNCTION, listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncCodecResponseFailure() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(Dog(\"PojoFido\")), Integer::class.java) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                assertTrue(result.error.exception is CodecConfigurationException)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun localCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        assertEquals(input, functions.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry))\n+    }\n \n+    @Test\n+    fun asyncLocalCodecRegistry() = looperThread.runBlocking {\n+        val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                assertEquals(input, result.get())\n+            } else  {\n+                fail()\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun instanceCodecRegistry() {\n+        val input = Dog(\"PojoFido\")\n+        val functionsWithCodecRegistry = anonUser.getFunctions(pojoRegistry)\n+        assertEquals(input, functionsWithCodecRegistry.callFunction(FIRST_ARG_FUNCTION, listOf(input), Dog::class.java))\n+    }\n+\n+    @Test\n+    fun unknownFunction() {\n+        assertFailsWith<ObjectServerError> {\n+            functions.callFunction(\"unknown\", listOf(32), Dog::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun asyncUnknownFunction() = looperThread.runBlocking {\n         val input = Dog(\"PojoFido\")\n+        functions.callFunctionAsync(\"unknown\", listOf(input), Dog::class.java, pojoRegistry) { result ->\n+            if (result.isSuccess) {\n+                fail()\n+            } else  {\n+                // FIXME How verify exact error. NativeErrorIntValue? Or error message?\n+                assertTrue(result.error is ObjectServerError)\n+            }\n+            looperThread.testComplete()\n+        }\n+    }\n+\n+    @Test\n+    fun asyncNonLoopers() {\n+        assertFailsWith<IllegalStateException> {\n+            functions.callFunctionAsync(FIRST_ARG_FUNCTION, listOf(32), Integer::class.java, pojoRegistry) { result ->\n+                fail()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_sum() {\n+        val numbers = listOf(1, 2, 3, 4)\n+        assertEquals(10, functions.callFunction(\"sum\", numbers, Integer::class.java).toInt())\n+    }\n \n-        val actual: Dog = functions.invoke(input, Dog::class.java, pojoRegistry)\n+    @Test\n+    fun callFunction_remoteError() {\n+        assertFailsWith<ObjectServerError> {\n+            // FIXME Do we need to assert more about the error\n+            functions.callFunction(\"error\", emptyList<Any>(), String::class.java)\n+        }\n+    }\n+\n+    @Test\n+    fun callFunction_null() {\n+        assertTrue(functions.callFunction(\"null\", emptyList<Any>(), BsonNull::class.java).isNull)\n+    }\n+\n+    @Test\n+    fun callFunction_empty() {\n+        assertEquals(BsonType.UNDEFINED, functions.callFunction(\"empty\", emptyList<Any>(), BsonUndefined::class.java).bsonType)\n+    }\n+\n+    // FIXME Do we need to test connectivity issues\n+\n+    @Test\n+    fun defaultCodecRegistry() {\n+        // TODO Maybe we should test that setting configuration specific would propagate all the way\n+        //  to here, but we do not have infrastructure to easily override TestRealmApp coniguration,\n+        //  and actual configuration is verified in RealmAppConfigurationTests\n+        assertEquals(app.configuration.defaultCodecRegistry, functions.defaultCodecRegistry)\n+    }\n \n-        assertEquals(input, actual)\n+    @Test\n+    fun customCodecRegistry() {\n+        val configCodecRegistry = CodecRegistries.fromCodecs(StringCodec())\n+        val customCodecRegistryFunctions = anonUser.getFunctions(configCodecRegistry)\n+        assertEquals(configCodecRegistry, customCodecRegistryFunctions.defaultCodecRegistry)\n+    }\n+\n+    @Test\n+    // FIXME JNI Parsing crashes\n+    @Ignore(\"JNI parsing crashes tests\")\n+    fun jniParseErrorArrayOfArrayDifferentTypes() {\n+        // Just to show case that the format of the test is as expected\n+        val valueOk = listOf(1, 2, 3)\n+        assertEquals(valueOk, functions.callFunction(FIRST_ARG_FUNCTION, listOf(valueOk), List::class.java))\n+\n+        // Actual failing call\n+        // {\"value\": [[{\"$numberInt\": \"1\"}, true, {\"$numberInt\": \"3\"}]]}\n+        val value = listOf(1, true, 3)\n+        assertEquals(value, functions.callFunction(FIRST_ARG_FUNCTION, listOf(value), List::class.java))\n+    }\n+    @Test\n+    // FIXME JNI Parsing only returns part of array", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjA2Mg==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r425432062", "bodyText": "I have separated the current C++ parser issues into separate ignored test cases and added a todo element to follow up on it.", "author": "rorbech", "createdAt": "2020-05-14T21:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NTMwNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423545304", "bodyText": "If you throw a std::logic_error or std:runtime_error they will be caught by the CATCH() macro in the JNI layer and converted into a Java exception.\nThe logic for how the conversion is defined here: https://github.com/realm/realm-java/blob/v10/realm/realm-library/src/main/cpp/util.cpp#L156\nIf those exceptions do not match the error you want to return to Java, we normally create a custom exception class in C++ that can be caught explicitly and converted.", "author": "cmelchior", "createdAt": "2020-05-12T08:13:25Z", "path": "realm/realm-library/src/main/cpp/io_realm_RealmFunctions.cpp", "diffHunk": "@@ -18,19 +18,40 @@\n \n #include \"util.hpp\"\n #include \"jni_util/bson_util.hpp\"\n+#include \"java_network_transport.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n \n using namespace realm;\n+using namespace realm::app;\n using namespace realm::jni_util;\n \n-// FIXME This is just a basic round trip test for passing bson back and forth. Proper implementation\n-//  will come with actual Function implementation.\n-JNIEXPORT jstring JNICALL Java_io_realm_RealmFunctions_nativeCallFunction\n-        (JNIEnv* env, jclass, jstring j_args) {\n+static std::function<jobject(JNIEnv*, Optional<bson::Bson> )> response_mapper = [](JNIEnv* env, Optional<bson::Bson> response) {\n+    if (response) {\n+        return JniBsonProtocol::bson_to_jstring(env, *response);\n+    } else {\n+        // FIXME How to raise errors here", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMzYxNA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r425433614", "bodyText": "Seem like we should never reach here, as we would not reach here if we do not have a valid Bson response. I added a std::logic_error to propagate it nicely should it ever happen.", "author": "rorbech", "createdAt": "2020-05-14T21:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Njg0NA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423546844", "bodyText": "I assume the reason for doing this in two lines is for readability? But there is a slight performance penalty as you are creating a dummy callback that is being thrown away straight away.", "author": "cmelchior", "createdAt": "2020-05-12T08:15:45Z", "path": "realm/realm-library/src/main/cpp/io_realm_RealmFunctions.cpp", "diffHunk": "@@ -18,19 +18,40 @@\n \n #include \"util.hpp\"\n #include \"jni_util/bson_util.hpp\"\n+#include \"java_network_transport.hpp\"\n+#include \"object-store/src/sync/app.hpp\"\n \n using namespace realm;\n+using namespace realm::app;\n using namespace realm::jni_util;\n \n-// FIXME This is just a basic round trip test for passing bson back and forth. Proper implementation\n-//  will come with actual Function implementation.\n-JNIEXPORT jstring JNICALL Java_io_realm_RealmFunctions_nativeCallFunction\n-        (JNIEnv* env, jclass, jstring j_args) {\n+static std::function<jobject(JNIEnv*, Optional<bson::Bson> )> response_mapper = [](JNIEnv* env, Optional<bson::Bson> response) {\n+    if (response) {\n+        return JniBsonProtocol::bson_to_jstring(env, *response);\n+    } else {\n+        // FIXME How to raise errors here\n+        return to_jstring(env, \"{}\");\n+    }\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_io_realm_RealmFunctions_nativeCallFunction(JNIEnv* env, jclass , jlong j_app_ptr, jlong j_user_ptr, jstring j_name,\n+                                                jstring j_args_json , jobject j_callback) {\n     try {\n-        bson::Bson bson = JniBsonProtocol::jstring_to_bson(env, j_args);\n-        return JniBsonProtocol::bson_to_jstring(env, bson);\n+        auto app = *reinterpret_cast<std::shared_ptr<App>*>(j_app_ptr);\n+        auto user = *reinterpret_cast<std::shared_ptr<SyncUser>*>(j_user_ptr);\n+\n+        std::function<void(Optional<bson::Bson>, Optional<app::AppError>)> callback;", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMDU3OQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424210579", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-05-13T06:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Njg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Nzg3OQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423547879", "bodyText": "We need to manually add <p> tags for empty lines to make the generated Javadoc render correctly. This is also missing in a bunch of other places in this PR.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * <p>", "author": "cmelchior", "createdAt": "2020-05-12T08:17:21Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -17,30 +17,173 @@\n \n import org.bson.codecs.configuration.CodecRegistry;\n \n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB Realm functions.\n+ *", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0ODUwOA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423548508", "bodyText": "Not 100% sure what these FIXME's mean or if they are still relevant?", "author": "cmelchior", "createdAt": "2020-05-12T08:18:25Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -17,30 +17,173 @@\n \n import org.bson.codecs.configuration.CodecRegistry;\n \n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB Realm functions.\n+ *\n+ * Arguments and results are encoded/decoded with the <i>Realm functions'</i> codec registry either\n+ * inherited from the {@link RealmAppConfiguration#getDefaultCodecRegistry()} or set explicitly\n+ * when creating the <i>Realm functions</i>-instance through {@link RealmUser#getFunctions(CodecRegistry)}\n+ * or through the individual calls to {@link #callFunction(String, List, Class, CodecRegistry)}.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+// FIXME Application wide invocation; like StitchAppClient appClient = Stitch.getDefaultAppClient();", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMjYwMQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424212601", "bodyText": "Initially I though it was possible to execute a function without a user. Apparently it was due to implicitly resolving a current user. Since we want to avoid this implicit resolving of users this is no longer relevant.", "author": "rorbech", "createdAt": "2020-05-13T06:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0ODUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0ODc0MA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423548740", "bodyText": "What is the concern here?", "author": "cmelchior", "createdAt": "2020-05-12T08:18:48Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -17,30 +17,173 @@\n \n import org.bson.codecs.configuration.CodecRegistry;\n \n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB Realm functions.\n+ *\n+ * Arguments and results are encoded/decoded with the <i>Realm functions'</i> codec registry either\n+ * inherited from the {@link RealmAppConfiguration#getDefaultCodecRegistry()} or set explicitly\n+ * when creating the <i>Realm functions</i>-instance through {@link RealmUser#getFunctions(CodecRegistry)}\n+ * or through the individual calls to {@link #callFunction(String, List, Class, CodecRegistry)}.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+// FIXME Application wide invocation; like StitchAppClient appClient = Stitch.getDefaultAppClient();\n+// FIXME Encoder/Decoder specific variants\n+// FIXME Service?\n+public class RealmFunctions {\n+\n+    // FIXME Review memory allocation", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMzU1MA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424213550", "bodyText": "From before I had an overview of how we managed the underlying C++ objects. Just a reminder for me to check up on it.", "author": "rorbech", "createdAt": "2020-05-13T07:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0ODc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTI5MQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r423555291", "bodyText": "We should probably also expose getApp() and getUser() functions from this class. This is useful if the class is passed around by itself. We are doing something similar in ApiKeyAuth. This would also require tests.", "author": "cmelchior", "createdAt": "2020-05-12T08:28:57Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmFunctions.java", "diffHunk": "@@ -17,30 +17,173 @@\n \n import org.bson.codecs.configuration.CodecRegistry;\n \n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * A <i>Realm functions<i> manager to call MongoDB Realm functions.\n+ *\n+ * Arguments and results are encoded/decoded with the <i>Realm functions'</i> codec registry either\n+ * inherited from the {@link RealmAppConfiguration#getDefaultCodecRegistry()} or set explicitly\n+ * when creating the <i>Realm functions</i>-instance through {@link RealmUser#getFunctions(CodecRegistry)}\n+ * or through the individual calls to {@link #callFunction(String, List, Class, CodecRegistry)}.\n+ */\n+// TODO Timeout is currently handled uniformly through OkHttpNetworkTransport configured through RealmAppConfig\n+// FIXME Application wide invocation; like StitchAppClient appClient = Stitch.getDefaultAppClient();\n+// FIXME Encoder/Decoder specific variants\n+// FIXME Service?\n+public class RealmFunctions {", "originalCommit": "a9d6bf841950a2b2803a03686d01906e8a2d2a09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODk4Nw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424208987", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-05-13T06:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMzczMw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r424213733", "bodyText": "\ud83d\udc4d", "author": "rorbech", "createdAt": "2020-05-13T07:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTI5MQ=="}], "type": "inlineReview"}, {"oid": "def4bff1df815d6130f48816d0a42e8e2481dec6", "url": "https://github.com/realm/realm-java/commit/def4bff1df815d6130f48816d0a42e8e2481dec6", "message": "Expose DEFAULT_BSON_CODEC_REGISTRY publicly", "committedDate": "2020-05-12T09:25:04Z", "type": "commit"}, {"oid": "6305eb6b586ffb2630bfdaa3d3642921cc84ca17", "url": "https://github.com/realm/realm-java/commit/6305eb6b586ffb2630bfdaa3d3642921cc84ca17", "message": "Code review updates", "committedDate": "2020-05-12T22:43:41Z", "type": "commit"}, {"oid": "241725c7533d75f3ef67a99c63534d5033103918", "url": "https://github.com/realm/realm-java/commit/241725c7533d75f3ef67a99c63534d5033103918", "message": "Add BSON processing error test cases", "committedDate": "2020-05-12T22:44:11Z", "type": "commit"}, {"oid": "809c203fb9e8176ddd7362cc7dbb8ea05e10f60f", "url": "https://github.com/realm/realm-java/commit/809c203fb9e8176ddd7362cc7dbb8ea05e10f60f", "message": "Add getFuntions methods to App", "committedDate": "2020-05-13T06:42:49Z", "type": "commit"}, {"oid": "0df53b11dec7cc9a9edb426fc166c62a206ae794", "url": "https://github.com/realm/realm-java/commit/0df53b11dec7cc9a9edb426fc166c62a206ae794", "message": "Add (ignored) test case with C++ BSON parser crash", "committedDate": "2020-05-13T07:19:03Z", "type": "commit"}, {"oid": "55e1e398978ed810149f7b8b2a1c46161ee586de", "url": "https://github.com/realm/realm-java/commit/55e1e398978ed810149f7b8b2a1c46161ee586de", "message": "Make DEFAULT_BSON_CODEC_REGISTRY final", "committedDate": "2020-05-13T11:54:29Z", "type": "commit"}, {"oid": "32cefc57b4453fbdbb87432a5004c226f329f7d2", "url": "https://github.com/realm/realm-java/commit/32cefc57b4453fbdbb87432a5004c226f329f7d2", "message": "Cleaned up clarify asserts with error codes", "committedDate": "2020-05-14T20:27:48Z", "type": "commit"}, {"oid": "7cfa18e3838c82fc558b68387d2348e01a8c9f33", "url": "https://github.com/realm/realm-java/commit/7cfa18e3838c82fc558b68387d2348e01a8c9f33", "message": "Raise IllegalArgumentException from JNI if BSON argument to callFunction is not a BsonArray", "committedDate": "2020-05-14T20:31:16Z", "type": "commit"}, {"oid": "737bd27e3786f1c987694e2294dc35ac2720476e", "url": "https://github.com/realm/realm-java/commit/737bd27e3786f1c987694e2294dc35ac2720476e", "message": "Add test for non-evaluatable functions", "committedDate": "2020-05-14T20:41:27Z", "type": "commit"}, {"oid": "2f6c93f4895089284d1472b5358d4361339d2a73", "url": "https://github.com/realm/realm-java/commit/2f6c93f4895089284d1472b5358d4361339d2a73", "message": "Change Instant.now() to System.currentTimeMillis()", "committedDate": "2020-05-14T21:30:30Z", "type": "commit"}, {"oid": "8b1b80e744d28818018062ca471afc6283920a25", "url": "https://github.com/realm/realm-java/commit/8b1b80e744d28818018062ca471afc6283920a25", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-15T20:57:16Z", "type": "commit"}, {"oid": "03c95833cd759fb999739f321875f4671cf8ef30", "url": "https://github.com/realm/realm-java/commit/03c95833cd759fb999739f321875f4671cf8ef30", "message": "Fixes after merge", "committedDate": "2020-05-15T21:31:27Z", "type": "commit"}, {"oid": "ea5ba814315d3aeda48df9873d06a9080d75711b", "url": "https://github.com/realm/realm-java/commit/ea5ba814315d3aeda48df9873d06a9080d75711b", "message": "Move RealmFunctions to io.realm.mongodb.functions.Functions", "committedDate": "2020-05-17T16:17:31Z", "type": "commit"}, {"oid": "646e3c81385105ebcb10378fbdc493b22e955a2a", "url": "https://github.com/realm/realm-java/commit/646e3c81385105ebcb10378fbdc493b22e955a2a", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-17T16:18:42Z", "type": "commit"}, {"oid": "d7b600fc1b77960c7cda59058c24d2b4959bb498", "url": "https://github.com/realm/realm-java/commit/d7b600fc1b77960c7cda59058c24d2b4959bb498", "message": "Trying to disable sync test", "committedDate": "2020-05-17T19:36:04Z", "type": "commit"}, {"oid": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "url": "https://github.com/realm/realm-java/commit/bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "message": "Enabling debug output to debug CI-only issue", "committedDate": "2020-05-17T20:44:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMzYwMw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426523603", "bodyText": "Should live directly in Functions I think?", "author": "cmelchior", "createdAt": "2020-05-18T10:23:08Z", "path": "realm/realm-library/src/objectServer/java/io/realm/InternalFunctions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.functions.Functions;\n+\n+\n+/**\n+ * Internal implementation of Functions invoking the actual OS function in the context of the\n+ * {@link RealmUser}/{@link RealmApp}.\n+ */\n+class InternalFunctions extends Functions {\n+\n+    private final RealmUser user;\n+\n+    InternalFunctions(RealmUser user) {\n+        this(user, user.getApp().getConfiguration().getDefaultCodecRegistry());\n+    }\n+\n+    InternalFunctions(RealmUser user, CodecRegistry codecRegistry) {\n+        super(codecRegistry);\n+        this.user = user;\n+    }\n+\n+    @Override\n+    public RealmApp getApp() {", "originalCommit": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MzkyOQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426573929", "bodyText": "I kept it here to have all App/User related separately, but as none of it uses internals it can be in Functions. Will move it.", "author": "rorbech", "createdAt": "2020-05-18T12:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMzY4NA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426523684", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-05-18T10:23:16Z", "path": "realm/realm-library/src/objectServer/java/io/realm/InternalFunctions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.functions.Functions;\n+\n+\n+/**\n+ * Internal implementation of Functions invoking the actual OS function in the context of the\n+ * {@link RealmUser}/{@link RealmApp}.\n+ */\n+class InternalFunctions extends Functions {\n+\n+    private final RealmUser user;\n+\n+    InternalFunctions(RealmUser user) {\n+        this(user, user.getApp().getConfiguration().getDefaultCodecRegistry());\n+    }\n+\n+    InternalFunctions(RealmUser user, CodecRegistry codecRegistry) {\n+        super(codecRegistry);\n+        this.user = user;\n+    }\n+\n+    @Override\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    @Override\n+    public RealmUser getUser() {", "originalCommit": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0ODAyOQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426748029", "bodyText": "Moved", "author": "rorbech", "createdAt": "2020-05-18T16:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyMzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyNDc5Nw==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426524797", "bodyText": "I guess we should come up with a common name if we are to implement this pattern elsewhere.\nNitpick: Not sure how I feel about this compared to FunctionsImpl. Although FunctionsImpl is normally used when interfaces, it does feel more descriptive in my mind. But I don't have strong reasons and it is entirely subjective.", "author": "cmelchior", "createdAt": "2020-05-18T10:25:24Z", "path": "realm/realm-library/src/objectServer/java/io/realm/InternalFunctions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.jni.JniBsonProtocol;\n+import io.realm.internal.jni.OsJNIResultCallback;\n+import io.realm.internal.network.ResultHandler;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.log.RealmLog;\n+import io.realm.mongodb.functions.Functions;\n+\n+\n+/**\n+ * Internal implementation of Functions invoking the actual OS function in the context of the\n+ * {@link RealmUser}/{@link RealmApp}.\n+ */\n+class InternalFunctions extends Functions {", "originalCommit": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NDEzNQ==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426574135", "bodyText": "Ok. Will go for FunctionsImpl", "author": "rorbech", "createdAt": "2020-05-18T12:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyNDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyNTA2OA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426525068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public InternalFunctions getFunctions(RealmUser user) {\n          \n          \n            \n                public Functions getFunctions(RealmUser user) {", "author": "cmelchior", "createdAt": "2020-05-18T10:25:53Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -369,6 +371,25 @@ public RealmSync getSync() {\n         return syncManager;\n     }\n \n+    /**\n+     * Returns a <i>Realm Functions</i> manager for invoking MongoDB Realm Functions.\n+     * <p>\n+     * This will use the associated app's default codec registry to encode and decode arguments and\n+     * results.\n+     */\n+    public InternalFunctions getFunctions(RealmUser user) {", "originalCommit": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUyNTI4NA==", "url": "https://github.com/realm/realm-java/pull/6810#discussion_r426525284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public InternalFunctions getFunctions(RealmUser user, CodecRegistry codecRegistry) {\n          \n          \n            \n                public Functions getFunctions(RealmUser user, CodecRegistry codecRegistry) {", "author": "cmelchior", "createdAt": "2020-05-18T10:26:18Z", "path": "realm/realm-library/src/objectServer/java/io/realm/RealmApp.java", "diffHunk": "@@ -369,6 +371,25 @@ public RealmSync getSync() {\n         return syncManager;\n     }\n \n+    /**\n+     * Returns a <i>Realm Functions</i> manager for invoking MongoDB Realm Functions.\n+     * <p>\n+     * This will use the associated app's default codec registry to encode and decode arguments and\n+     * results.\n+     */\n+    public InternalFunctions getFunctions(RealmUser user) {\n+        return new InternalFunctions(user);\n+    }\n+\n+    /**\n+     * Returns a <i>Realm Functions</i> manager for invoking MongoDB Realm Functions with custom\n+     * codec registry for encoding and decoding arguments and results.\n+     */\n+    public InternalFunctions getFunctions(RealmUser user, CodecRegistry codecRegistry) {", "originalCommit": "bbca32780e1c2b0ffc412d6538fa8fe8dd85fcab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8042161126b44f2cf5234c7491ddae4a89aa607a", "url": "https://github.com/realm/realm-java/commit/8042161126b44f2cf5234c7491ddae4a89aa607a", "message": "Fix order or codec providers to fix MongoCollectionTests", "committedDate": "2020-05-18T11:44:29Z", "type": "commit"}, {"oid": "8ffc936c97c84f8f444f0a7116f0bc069f7dcc37", "url": "https://github.com/realm/realm-java/commit/8ffc936c97c84f8f444f0a7116f0bc069f7dcc37", "message": "Functions implementation", "committedDate": "2020-05-18T12:40:26Z", "type": "commit"}, {"oid": "705e25cc57f5dd890efdf1a2406341b7e072608f", "url": "https://github.com/realm/realm-java/commit/705e25cc57f5dd890efdf1a2406341b7e072608f", "message": "Merge branch 'v10' into cr/functions", "committedDate": "2020-05-18T13:58:48Z", "type": "commit"}, {"oid": "12bf3d96316f17c81f473c178efa756b8163b28e", "url": "https://github.com/realm/realm-java/commit/12bf3d96316f17c81f473c178efa756b8163b28e", "message": "Pure debug to track CI-only issue", "committedDate": "2020-05-18T14:10:36Z", "type": "commit"}, {"oid": "73545b26c3b7b9a98017b19e5fbf05a7a36c4ff6", "url": "https://github.com/realm/realm-java/commit/73545b26c3b7b9a98017b19e5fbf05a7a36c4ff6", "message": "Revert \"Pure debug to track CI-only issue\"\n\nThis reverts commit 12bf3d96316f17c81f473c178efa756b8163b28e.", "committedDate": "2020-05-19T09:12:28Z", "type": "commit"}, {"oid": "ea24fb72d2dddcefa13e19e6b42efd1cbc28a24a", "url": "https://github.com/realm/realm-java/commit/ea24fb72d2dddcefa13e19e6b42efd1cbc28a24a", "message": "Disabling debug output for tracing on CI-only issue.", "committedDate": "2020-05-19T09:21:47Z", "type": "commit"}, {"oid": "571ca4c6eec8a1483b33b9eaafc4a98be6dec917", "url": "https://github.com/realm/realm-java/commit/571ca4c6eec8a1483b33b9eaafc4a98be6dec917", "message": "Ignoring BSON test of dates until fixed in C++ BSON parser", "committedDate": "2020-05-19T10:00:43Z", "type": "commit"}]}