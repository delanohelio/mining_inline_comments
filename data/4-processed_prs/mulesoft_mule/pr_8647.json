{"pr_number": 8647, "pr_title": "MULE-18020: Fix reconnection for Paged Operations that fail after the first page.", "pr_createdAt": "2020-02-13T14:52:33Z", "pr_url": "https://github.com/mulesoft/mule/pull/8647", "timeline": [{"oid": "c2d721f4c941afc034a3d91b0f660426f4fb6d2a", "url": "https://github.com/mulesoft/mule/commit/c2d721f4c941afc034a3d91b0f660426f4fb6d2a", "message": "fix +  tests", "committedDate": "2020-02-12T19:13:23Z", "type": "commit"}, {"oid": "a9bd7a1c4eeb10a7db7af2972afbc8736f478d88", "url": "https://github.com/mulesoft/mule/commit/a9bd7a1c4eeb10a7db7af2972afbc8736f478d88", "message": "refactored tests to avoid issues when the whole suite was run", "committedDate": "2020-02-12T19:13:50Z", "type": "commit"}, {"oid": "def818d5b8da6787d2ccbf887386889c26dc2f6f", "url": "https://github.com/mulesoft/mule/commit/def818d5b8da6787d2ccbf887386889c26dc2f6f", "message": "merge", "committedDate": "2020-02-13T14:51:23Z", "type": "commit"}, {"oid": "0910f63f4ff3ac84aeece0f83cace5961080979c", "url": "https://github.com/mulesoft/mule/commit/0910f63f4ff3ac84aeece0f83cace5961080979c", "message": "boom", "committedDate": "2020-02-17T21:50:37Z", "type": "commit"}, {"oid": "dd303d2c83d06ef609e1e91a1ca3a6efc4468e49", "url": "https://github.com/mulesoft/mule/commit/dd303d2c83d06ef609e1e91a1ca3a6efc4468e49", "message": "minor changes (pr polish)", "committedDate": "2020-02-17T22:03:18Z", "type": "commit"}, {"oid": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "url": "https://github.com/mulesoft/mule/commit/76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "message": "schemas and refactor", "committedDate": "2020-02-18T16:07:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MjgxNw==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380942817", "bodyText": "use the ExpectedException rule and assert on the cause being THE SAME instance you are expecting and the actual exception being of the correct type", "author": "marianogonzalez", "createdAt": "2020-02-18T21:23:08Z", "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -106,13 +108,13 @@ public void getInlineRetryPolicyTemplate() throws Exception {\n   public void reconnectAfterConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n-  @Test\n-  public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n+  @Test(expected = IllegalArgumentException.class)", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM0OTIxNw==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r381349217", "bodyText": "I tried the approach with ExpectedException, but it does not allow me to assert other things after the exception is thrown (like the paging provider closing or the disconnection calls).", "author": "SebaElizalde", "createdAt": "2020-02-19T15:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mjk1Mg==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380942952", "bodyText": "replace all of this with the expectedException rule", "author": "marianogonzalez", "createdAt": "2020-02-18T21:23:26Z", "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzA3MQ==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943071", "bodyText": "same as before", "author": "marianogonzalez", "createdAt": "2020-02-18T21:23:40Z", "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzEyMQ==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943121", "bodyText": "same as before", "author": "marianogonzalez", "createdAt": "2020-02-18T21:23:47Z", "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));\n+      assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e;\n     }\n   }\n \n   @Test\n   public void stickyConnectionIsClosedAndReconnectedDuringConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n+  @Test(expected = ModuleException.class)\n+  public void stickyConnectionIsNotReconnectedDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, CONNECTIVITY);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(ModuleException.class));", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MzE3Nw==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380943177", "bodyText": "same as before", "author": "marianogonzalez", "createdAt": "2020-02-18T21:23:54Z", "path": "modules/extensions-spring-support/src/test/java/org/mule/test/module/extension/reconnection/ReconnectionTestCase.java", "diffHunk": "@@ -123,18 +125,83 @@ public void doNotReconnectAfterOtherExceptionOnFirstPage() {\n       assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n       assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n       assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e.getCause();\n+    }\n+  }\n+\n+  @Test\n+  public void reconnectionDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator = getCursor(\"pagedOperation\", 2, CONNECTIVITY);\n+\n+    iterator.next();\n+    assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+    assertThat(\"Paging provider was closed.\", closePagingProviderCalls, is(0));\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void doNotReconnectAfterOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    Iterator<ReconnectableConnection> iterator;\n+    try {\n+      iterator = getCursor(\"pagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));\n+      assertThat(e.getMessage(), is(\"An illegal argument was received.\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was disconnected.\", disconnectCalls, is(0));\n+      throw e;\n     }\n   }\n \n   @Test\n   public void stickyConnectionIsClosedAndReconnectedDuringConnectionExceptionOnFirstPage() throws Exception {\n     resetCounters();\n     Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 1, CONNECTIVITY);\n-    ReconnectableConnection firstPage = iterator.next();\n-    assertThat(\"Connection was not disconnected.\", firstPage.getDisconnectCalls(), is(1));\n+    iterator.next();\n+    assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n     assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(1));\n   }\n \n+  @Test(expected = ModuleException.class)\n+  public void stickyConnectionIsNotReconnectedDuringConnectionExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, CONNECTIVITY);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(ModuleException.class));\n+      assertThat(e.getCause(), instanceOf(ConnectionException.class));\n+      assertThat(e.getCause().getMessage(), is(\"Failed to retrieve Page\"));\n+      assertThat(\"Paging provider was not closed.\", closePagingProviderCalls, is(0));\n+      assertThat(\"Connection was not disconnected.\", disconnectCalls, is(1));\n+      throw e;\n+    }\n+  }\n+\n+  @Test(expected = IllegalArgumentException.class)\n+  public void stickyConnectionIsNotReconnectedDuringOtherExceptionOnSecondPage() throws Exception {\n+    resetCounters();\n+    try {\n+      Iterator<ReconnectableConnection> iterator = getCursor(\"stickyPagedOperation\", 2, VALIDATION);\n+      iterator.next();\n+      iterator.next();\n+    } catch (Exception e) {\n+      assertThat(e, instanceOf(IllegalArgumentException.class));", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDkwNQ==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380944905", "bodyText": "Define constant in org.mule.runtime.module.extension.internal.ExtensionProperties. Also the key should start with the proper prefix.", "author": "marianogonzalez", "createdAt": "2020-02-18T21:27:34Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/streaming/PagingProviderProducer.java", "diffHunk": "@@ -91,27 +101,58 @@ public int getSize() {\n    * @return\n    */\n   private <R> R performWithConnection(Function<Object, R> function) {\n+    Optional<MutableConfigurationStats> stats = getMutableConfigurationStats(executionContext);\n+    RetryPolicyTemplate retryPolicy =\n+        (RetryPolicyTemplate) executionContext.getRetryPolicyTemplate().orElseGet(NoRetryPolicyTemplate::new);\n+    CompletableFuture<R> future = retryPolicy.applyPolicy(() -> completedFuture(withConnection(function)),\n+                                                          e -> !isFirstPage && !delegate.useStickyConnections()\n+                                                              && shouldRetry(e, executionContext),\n+                                                          e -> {\n+                                                          },\n+                                                          e -> stats.ifPresent(s -> s.discountInflightOperation()),\n+                                                          identity(),\n+                                                          executionContext.getCurrentScheduler());\n+    try {\n+      return future.get();\n+    } catch (ExecutionException e) {\n+      if (e.getCause() instanceof RuntimeException) {\n+        throw (RuntimeException) e.getCause();\n+      }\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e.getCause());\n+    } catch (InterruptedException e) {\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e);\n+    }\n+  }\n+\n+  private <R> R withConnection(Function<Object, R> function) {\n     ConnectionSupplier connectionSupplier = getConnectionSupplier();\n     Object connection = getConnection(connectionSupplier);\n     try {\n       R result = function.apply(connection);\n       return result;\n-    } catch (Exception exception) {\n+    } catch (Exception caughtException) {\n       if (isFirstPage) {\n         safely(() -> delegate.close(connection), e -> LOGGER.debug(\"Found exception closing paging provider\", e));\n       }\n-      extractConnectionException(exception).ifPresent(ex -> {\n-        if (isTransactional()) {\n-          executionContext.setVariable(DO_NOT_RETRY, \"true\");\n-        }\n-        connectionSupplier.invalidateConnection();\n-      });\n-      throw exception;\n+      extractConnectionException(caughtException).ifPresent(e -> handleConnectionException(e, connectionSupplier));\n+      throw caughtException;\n     } finally {\n       safely(connectionSupplier::close, e -> LOGGER.debug(\"Found exception closing the connection supplier\", e));\n     }\n   }\n \n+  private void handleConnectionException(ConnectionException connectionException, ConnectionSupplier connectionSupplier) {\n+    Optional<String> exceptionConfigName =\n+        executionContext.getConfiguration().map(config -> ((ConfigurationInstance) config).getName());\n+    if (isTransactional()) {\n+      connectionException.addInfo(\"wasTransactional\", true);", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NTMwMA==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380945300", "bodyText": "same", "author": "marianogonzalez", "createdAt": "2020-02-18T21:28:22Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/streaming/PagingProviderProducer.java", "diffHunk": "@@ -91,27 +101,58 @@ public int getSize() {\n    * @return\n    */\n   private <R> R performWithConnection(Function<Object, R> function) {\n+    Optional<MutableConfigurationStats> stats = getMutableConfigurationStats(executionContext);\n+    RetryPolicyTemplate retryPolicy =\n+        (RetryPolicyTemplate) executionContext.getRetryPolicyTemplate().orElseGet(NoRetryPolicyTemplate::new);\n+    CompletableFuture<R> future = retryPolicy.applyPolicy(() -> completedFuture(withConnection(function)),\n+                                                          e -> !isFirstPage && !delegate.useStickyConnections()\n+                                                              && shouldRetry(e, executionContext),\n+                                                          e -> {\n+                                                          },\n+                                                          e -> stats.ifPresent(s -> s.discountInflightOperation()),\n+                                                          identity(),\n+                                                          executionContext.getCurrentScheduler());\n+    try {\n+      return future.get();\n+    } catch (ExecutionException e) {\n+      if (e.getCause() instanceof RuntimeException) {\n+        throw (RuntimeException) e.getCause();\n+      }\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e.getCause());\n+    } catch (InterruptedException e) {\n+      throw new MuleRuntimeException(createStaticMessage(COULD_NOT_EXECUTE), e);\n+    }\n+  }\n+\n+  private <R> R withConnection(Function<Object, R> function) {\n     ConnectionSupplier connectionSupplier = getConnectionSupplier();\n     Object connection = getConnection(connectionSupplier);\n     try {\n       R result = function.apply(connection);\n       return result;\n-    } catch (Exception exception) {\n+    } catch (Exception caughtException) {\n       if (isFirstPage) {\n         safely(() -> delegate.close(connection), e -> LOGGER.debug(\"Found exception closing paging provider\", e));\n       }\n-      extractConnectionException(exception).ifPresent(ex -> {\n-        if (isTransactional()) {\n-          executionContext.setVariable(DO_NOT_RETRY, \"true\");\n-        }\n-        connectionSupplier.invalidateConnection();\n-      });\n-      throw exception;\n+      extractConnectionException(caughtException).ifPresent(e -> handleConnectionException(e, connectionSupplier));\n+      throw caughtException;\n     } finally {\n       safely(connectionSupplier::close, e -> LOGGER.debug(\"Found exception closing the connection supplier\", e));\n     }\n   }\n \n+  private void handleConnectionException(ConnectionException connectionException, ConnectionSupplier connectionSupplier) {\n+    Optional<String> exceptionConfigName =\n+        executionContext.getConfiguration().map(config -> ((ConfigurationInstance) config).getName());\n+    if (isTransactional()) {\n+      connectionException.addInfo(\"wasTransactional\", true);\n+    }\n+    if (isFirstPage) {\n+      exceptionConfigName.ifPresent(name -> connectionException.addInfo(\"operationConfigName\", name));", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NjQ3Ng==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380946476", "bodyText": "return Objects.equals(operaetionConfigName, contextConfigName)", "author": "marianogonzalez", "createdAt": "2020-02-18T21:30:42Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/util/ReconnectionUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.util;\n+\n+import static java.lang.Boolean.parseBoolean;\n+import static org.mule.runtime.core.api.transaction.TransactionCoordination.isTransactionActive;\n+import static org.mule.runtime.core.api.util.ExceptionUtils.extractConnectionException;\n+import static org.mule.runtime.module.extension.internal.ExtensionProperties.DO_NOT_RETRY;\n+\n+import org.mule.runtime.api.connection.ConnectionException;\n+import org.mule.runtime.core.api.transaction.Transaction;\n+import org.mule.runtime.core.api.transaction.TransactionCoordination;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.module.extension.api.runtime.privileged.ExecutionContextAdapter;\n+import org.mule.runtime.module.extension.internal.runtime.transaction.ExtensionTransactionKey;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Utilities for handling reconnection on operations that use a connection.\n+ *\n+ * @since 4.2.3\n+ */\n+public class ReconnectionUtils {\n+\n+  /**\n+   * @param t the {@link Throwable} thrown during the execution of the operation\n+   * @param context the {@link ExecutionContextAdapter} that contains the context information about the operation's execution\n+   * @return whether or not the operation should be retried\n+   */\n+  public static boolean shouldRetry(Throwable t, ExecutionContextAdapter<?> context) {\n+    Optional<String> contextConfigName = context.getConfiguration().map(ConfigurationInstance::getName);\n+    Optional<ConnectionException> connectionException = extractConnectionException(t);\n+    if (Boolean.valueOf(context.getVariable(DO_NOT_RETRY)) || !connectionException.isPresent()) {\n+      return false;\n+    }\n+\n+    if (isTransactionActive()) {\n+      Transaction tx = TransactionCoordination.getInstance().getTransaction();\n+\n+      return !tx.hasResource(new ExtensionTransactionKey(context.getConfiguration().get()));\n+    }\n+\n+    return validateConnectionException(connectionException.get(), contextConfigName.orElse(null));\n+  }\n+\n+  private static boolean validateConnectionException(ConnectionException connectionException, String contextConfigName) {\n+    Boolean wasTransactional = (Boolean) connectionException.getInfo().get(\"wasTransactional\");\n+    if (wasTransactional != null && wasTransactional) {\n+      return false;\n+    }\n+    Object operationConfigName = connectionException.getInfo().get(\"operationConfigName\");\n+    if (operationConfigName != null && contextConfigName != null) {", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NzM4Ng==", "url": "https://github.com/mulesoft/mule/pull/8647#discussion_r380947386", "bodyText": "a boolean method should not start with validate. Give this a more meaningful name and add a comment explaining why this is necessary", "author": "marianogonzalez", "createdAt": "2020-02-18T21:32:34Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/util/ReconnectionUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.util;\n+\n+import static java.lang.Boolean.parseBoolean;\n+import static org.mule.runtime.core.api.transaction.TransactionCoordination.isTransactionActive;\n+import static org.mule.runtime.core.api.util.ExceptionUtils.extractConnectionException;\n+import static org.mule.runtime.module.extension.internal.ExtensionProperties.DO_NOT_RETRY;\n+\n+import org.mule.runtime.api.connection.ConnectionException;\n+import org.mule.runtime.core.api.transaction.Transaction;\n+import org.mule.runtime.core.api.transaction.TransactionCoordination;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.module.extension.api.runtime.privileged.ExecutionContextAdapter;\n+import org.mule.runtime.module.extension.internal.runtime.transaction.ExtensionTransactionKey;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Utilities for handling reconnection on operations that use a connection.\n+ *\n+ * @since 4.2.3\n+ */\n+public class ReconnectionUtils {\n+\n+  /**\n+   * @param t the {@link Throwable} thrown during the execution of the operation\n+   * @param context the {@link ExecutionContextAdapter} that contains the context information about the operation's execution\n+   * @return whether or not the operation should be retried\n+   */\n+  public static boolean shouldRetry(Throwable t, ExecutionContextAdapter<?> context) {\n+    Optional<String> contextConfigName = context.getConfiguration().map(ConfigurationInstance::getName);\n+    Optional<ConnectionException> connectionException = extractConnectionException(t);\n+    if (Boolean.valueOf(context.getVariable(DO_NOT_RETRY)) || !connectionException.isPresent()) {\n+      return false;\n+    }\n+\n+    if (isTransactionActive()) {\n+      Transaction tx = TransactionCoordination.getInstance().getTransaction();\n+\n+      return !tx.hasResource(new ExtensionTransactionKey(context.getConfiguration().get()));\n+    }\n+\n+    return validateConnectionException(connectionException.get(), contextConfigName.orElse(null));\n+  }\n+\n+  private static boolean validateConnectionException(ConnectionException connectionException, String contextConfigName) {", "originalCommit": "76d275e6aff35d8e6eeab109e2e82bc4fbd203ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5cecc385141e4af20237cc6f42f2415a15af7578", "url": "https://github.com/mulesoft/mule/commit/5cecc385141e4af20237cc6f42f2415a15af7578", "message": "refactor", "committedDate": "2020-02-18T22:05:24Z", "type": "commit"}, {"oid": "559d62af7b2a3d2af9d694b2f6a043a9fa49a9dc", "url": "https://github.com/mulesoft/mule/commit/559d62af7b2a3d2af9d694b2f6a043a9fa49a9dc", "message": "pr changes", "committedDate": "2020-02-19T18:56:57Z", "type": "commit"}, {"oid": "a55dcbc2a6fc3624bc134fc9ba7e22bd8aeef34d", "url": "https://github.com/mulesoft/mule/commit/a55dcbc2a6fc3624bc134fc9ba7e22bd8aeef34d", "message": "fixes", "committedDate": "2020-02-20T21:10:30Z", "type": "commit"}]}