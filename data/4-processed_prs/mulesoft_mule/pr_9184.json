{"pr_number": 9184, "pr_title": "MULE-18547: ValueProviderModel does not provide information of the resolver implementation therefore caching mechanism are not going to work correctly with providerName only", "pr_createdAt": "2020-08-11T05:32:38Z", "pr_url": "https://github.com/mulesoft/mule/pull/9184", "timeline": [{"oid": "0fea38974768933d94fe3e257c8aeec24dbb03ba", "url": "https://github.com/mulesoft/mule/commit/0fea38974768933d94fe3e257c8aeec24dbb03ba", "message": "progress", "committedDate": "2020-08-10T17:29:08Z", "type": "commit"}, {"oid": "6e348985536b96beddd82f74fcf9925c57c15a13", "url": "https://github.com/mulesoft/mule/commit/6e348985536b96beddd82f74fcf9925c57c15a13", "message": "more progress", "committedDate": "2020-08-10T17:29:08Z", "type": "commit"}, {"oid": "dc30aefc31380144623538d7387efa434a3e98c3", "url": "https://github.com/mulesoft/mule/commit/dc30aefc31380144623538d7387efa434a3e98c3", "message": "adds validator", "committedDate": "2020-08-10T17:29:08Z", "type": "commit"}, {"oid": "83a2c11296f5a03c6ed836dc91e969f9ddab6e23", "url": "https://github.com/mulesoft/mule/commit/83a2c11296f5a03c6ed836dc91e969f9ddab6e23", "message": "progress", "committedDate": "2020-08-11T04:15:37Z", "type": "commit"}, {"oid": "121a021dae6f9422de01af030418f0388741933b", "url": "https://github.com/mulesoft/mule/commit/121a021dae6f9422de01af030418f0388741933b", "message": "removes empty spaces", "committedDate": "2020-08-11T05:31:56Z", "type": "commit"}, {"oid": "675d06321b9e20bc2073aad6207abff50960d8f5", "url": "https://github.com/mulesoft/mule/commit/675d06321b9e20bc2073aad6207abff50960d8f5", "message": "fix", "committedDate": "2020-08-11T14:17:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwOTUxOA==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468709518", "bodyText": "exponential complexity algorithm. This will affect start up time. Optimize this.", "author": "marianogonzalez", "createdAt": "2020-08-11T16:27:58Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -45,48 +54,89 @@\n \n   @Override\n   public void validate(ExtensionModel model, ProblemsReporter problemsReporter) {\n+    final Map<String, ValueProviderInformation> valueProviders = new HashMap<>();\n     new IdempotentExtensionWalker() {\n \n       @Override\n       protected void onConfiguration(ConfigurationModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onConnectionProvider(ConnectionProviderModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onSource(SourceModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n \n       @Override\n       protected void onOperation(OperationModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n     }.walk(model);\n+    if (isCompiletime(model)) {\n+      validateProviderIds(valueProviders, problemsReporter);\n+    }\n+  }\n+\n+  private void validateProviderIds(Map<String, ValueProviderInformation> valueProviders, ProblemsReporter problemsReporter) {\n+    Set<String> processedValueProviders = new HashSet<>();\n+    valueProviders.entrySet().stream().forEach(entry -> {\n+      ValueProviderInformation valueProviderInformation = entry.getValue();\n+      ParameterizedModel ownerModel = valueProviderInformation.ownerModel;\n+      String valueProviderId = valueProviderInformation.getValueProviderModel().getProviderId();\n+      String valueProviderImplentation = entry.getKey();\n+      processedValueProviders.add(valueProviderImplentation);\n+      valueProviders.entrySet().stream().forEach(otherEntry -> {", "originalCommit": "675d06321b9e20bc2073aad6207abff50960d8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwOTg4Ng==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468709886", "bodyText": "you can simply use valueProviders.forEach((k, v) -> {})", "author": "marianogonzalez", "createdAt": "2020-08-11T16:28:29Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -45,48 +54,89 @@\n \n   @Override\n   public void validate(ExtensionModel model, ProblemsReporter problemsReporter) {\n+    final Map<String, ValueProviderInformation> valueProviders = new HashMap<>();\n     new IdempotentExtensionWalker() {\n \n       @Override\n       protected void onConfiguration(ConfigurationModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onConnectionProvider(ConnectionProviderModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onSource(SourceModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n \n       @Override\n       protected void onOperation(OperationModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n     }.walk(model);\n+    if (isCompiletime(model)) {\n+      validateProviderIds(valueProviders, problemsReporter);\n+    }\n+  }\n+\n+  private void validateProviderIds(Map<String, ValueProviderInformation> valueProviders, ProblemsReporter problemsReporter) {\n+    Set<String> processedValueProviders = new HashSet<>();\n+    valueProviders.entrySet().stream().forEach(entry -> {", "originalCommit": "675d06321b9e20bc2073aad6207abff50960d8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTM5NQ==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468831395", "bodyText": "Done, adding in next commit.", "author": "ndinu", "createdAt": "2020-08-11T20:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwOTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDg5MQ==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468710891", "bodyText": "this cache should be received as an argument and be reused in the entire validate() method. It's not much of a cache otherwise", "author": "marianogonzalez", "createdAt": "2020-08-11T16:29:54Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -45,48 +54,89 @@\n \n   @Override\n   public void validate(ExtensionModel model, ProblemsReporter problemsReporter) {\n+    final Map<String, ValueProviderInformation> valueProviders = new HashMap<>();\n     new IdempotentExtensionWalker() {\n \n       @Override\n       protected void onConfiguration(ConfigurationModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onConnectionProvider(ConnectionProviderModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onSource(SourceModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n \n       @Override\n       protected void onOperation(OperationModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n     }.walk(model);\n+    if (isCompiletime(model)) {\n+      validateProviderIds(valueProviders, problemsReporter);\n+    }\n+  }\n+\n+  private void validateProviderIds(Map<String, ValueProviderInformation> valueProviders, ProblemsReporter problemsReporter) {\n+    Set<String> processedValueProviders = new HashSet<>();\n+    valueProviders.entrySet().stream().forEach(entry -> {\n+      ValueProviderInformation valueProviderInformation = entry.getValue();\n+      ParameterizedModel ownerModel = valueProviderInformation.ownerModel;\n+      String valueProviderId = valueProviderInformation.getValueProviderModel().getProviderId();\n+      String valueProviderImplentation = entry.getKey();\n+      processedValueProviders.add(valueProviderImplentation);\n+      valueProviders.entrySet().stream().forEach(otherEntry -> {\n+        String otherValueProviderId = otherEntry.getValue().getValueProviderModel().getProviderId();\n+        String otherValueProviderImplentation = otherEntry.getKey();\n+        if (processedValueProviders.contains(otherValueProviderImplentation)) {\n+          return;\n+        }\n+        if (valueProviderId.equals(otherValueProviderId)) {\n+          problemsReporter.addError(new Problem(valueProviderInformation.ownerModel,\n+                                                format(\"Parameter '%s' from the %s '%s' uses an implementation of ValueProviders\"\n+                                                    + \" [%s] with id '%s'. There is another implementations of ValueProviders\"\n+                                                    + \" [%s] that uses the same id. ValueProviders id must be unique.\",\n+                                                       valueProviderInformation.parameterModel.getName(),\n+                                                       getComponentModelTypeName(ownerModel), getModelName(ownerModel),\n+                                                       valueProviderImplentation, valueProviderId,\n+                                                       otherValueProviderImplentation)));\n+        }\n+      });\n+    });\n   }\n \n-  private void validateModel(ParameterizedModel model, ProblemsReporter problemsReporter, boolean supportsConnectionsAndConfigs) {\n+  private void validateModel(ParameterizedModel model, ProblemsReporter problemsReporter, boolean supportsConnectionsAndConfigs,\n+                             Map<String, ValueProviderInformation> valueProviders) {\n     ReflectionCache reflectionCache = new ReflectionCache();", "originalCommit": "675d06321b9e20bc2073aad6207abff50960d8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTMxMA==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468831310", "bodyText": "Done, adding in next commit.", "author": "ndinu", "createdAt": "2020-08-11T20:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjEzOQ==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468712139", "bodyText": "why enforce this? can't this break backwards compatiblity?", "author": "marianogonzalez", "createdAt": "2020-08-11T16:31:47Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -45,48 +54,89 @@\n \n   @Override\n   public void validate(ExtensionModel model, ProblemsReporter problemsReporter) {\n+    final Map<String, ValueProviderInformation> valueProviders = new HashMap<>();\n     new IdempotentExtensionWalker() {\n \n       @Override\n       protected void onConfiguration(ConfigurationModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onConnectionProvider(ConnectionProviderModel model) {\n-        validateModel(model, problemsReporter, false);\n+        validateModel(model, problemsReporter, false, valueProviders);\n       }\n \n       @Override\n       protected void onSource(SourceModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n \n       @Override\n       protected void onOperation(OperationModel model) {\n-        validateModel(model, problemsReporter, true);\n+        validateModel(model, problemsReporter, true, valueProviders);\n       }\n     }.walk(model);\n+    if (isCompiletime(model)) {\n+      validateProviderIds(valueProviders, problemsReporter);\n+    }\n+  }\n+\n+  private void validateProviderIds(Map<String, ValueProviderInformation> valueProviders, ProblemsReporter problemsReporter) {\n+    Set<String> processedValueProviders = new HashSet<>();\n+    valueProviders.entrySet().stream().forEach(entry -> {\n+      ValueProviderInformation valueProviderInformation = entry.getValue();\n+      ParameterizedModel ownerModel = valueProviderInformation.ownerModel;\n+      String valueProviderId = valueProviderInformation.getValueProviderModel().getProviderId();\n+      String valueProviderImplentation = entry.getKey();\n+      processedValueProviders.add(valueProviderImplentation);\n+      valueProviders.entrySet().stream().forEach(otherEntry -> {\n+        String otherValueProviderId = otherEntry.getValue().getValueProviderModel().getProviderId();\n+        String otherValueProviderImplentation = otherEntry.getKey();\n+        if (processedValueProviders.contains(otherValueProviderImplentation)) {\n+          return;\n+        }\n+        if (valueProviderId.equals(otherValueProviderId)) {\n+          problemsReporter.addError(new Problem(valueProviderInformation.ownerModel,\n+                                                format(\"Parameter '%s' from the %s '%s' uses an implementation of ValueProviders\"\n+                                                    + \" [%s] with id '%s'. There is another implementations of ValueProviders\"\n+                                                    + \" [%s] that uses the same id. ValueProviders id must be unique.\",\n+                                                       valueProviderInformation.parameterModel.getName(),\n+                                                       getComponentModelTypeName(ownerModel), getModelName(ownerModel),\n+                                                       valueProviderImplentation, valueProviderId,\n+                                                       otherValueProviderImplentation)));\n+        }\n+      });\n+    });\n   }\n \n-  private void validateModel(ParameterizedModel model, ProblemsReporter problemsReporter, boolean supportsConnectionsAndConfigs) {\n+  private void validateModel(ParameterizedModel model, ProblemsReporter problemsReporter, boolean supportsConnectionsAndConfigs,\n+                             Map<String, ValueProviderInformation> valueProviders) {\n     ReflectionCache reflectionCache = new ReflectionCache();\n     model.getAllParameterModels()\n         .forEach(param -> param\n             .getModelProperty(ValueProviderFactoryModelProperty.class)\n             .ifPresent(modelProperty -> validateOptionsResolver(param, modelProperty, model, problemsReporter,\n-                                                                supportsConnectionsAndConfigs, reflectionCache)));\n+                                                                supportsConnectionsAndConfigs, reflectionCache, valueProviders)));\n   }\n \n   private void validateOptionsResolver(ParameterModel param, ValueProviderFactoryModelProperty modelProperty,\n                                        ParameterizedModel model, ProblemsReporter problemsReporter,\n-                                       boolean supportsConnectionsAndConfigs, ReflectionCache reflectionCache) {\n+                                       boolean supportsConnectionsAndConfigs, ReflectionCache reflectionCache,\n+                                       Map<String, ValueProviderInformation> valueProviders) {\n     Class<? extends ValueProvider> valueProvider = modelProperty.getValueProvider();\n     String providerName = valueProvider.getSimpleName();\n+    Optional<ValueProviderModel> valueProviderModel = param.getValueProviderModel();\n+    if (!valueProviderModel.isPresent()) {\n+      throw new IllegalStateException(format(\"Parameter %s from %s with name %s has should have a ValueProviderModel associated.\",", "originalCommit": "675d06321b9e20bc2073aad6207abff50960d8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgxMDIyNw==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468810227", "bodyText": "This should never happen. The parameterModel will always have the valueProviderModel if the modelProperty is present, I did not want to get the value from the optional without checking, so that if this breaks by any chance, we have a good error message. I can make it fail only at compile time.", "author": "ndinu", "createdAt": "2020-08-11T19:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1MDkwNg==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468750906", "bodyText": "if this method is called add, then it should just add, not validate. It's also weird that  you also have the  validateProviderIds  method traversing the map again validating other aspects. You should either completely separate data gathering from data validation all-together, or validate as you gather, but this mix up is not a good idea and ultimately needs to the algorithm being highly inefficient.", "author": "marianogonzalez", "createdAt": "2020-08-11T17:37:04Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -146,4 +196,46 @@ private void validateOptionsResolver(ParameterModel param, ValueProviderFactoryM\n       }\n     }\n   }\n+\n+  private void addValueProvider(String providerName, ValueProviderModel valueProviderModel,\n+                                Map<String, ValueProviderInformation> valueProviders, ProblemsReporter problemsReporter,\n+                                ParameterizedModel model, ParameterModel parameterModel) {\n+    if (valueProviders.containsKey(providerName)) {\n+      String storedProviderId = valueProviders.get(providerName).getValueProviderModel().getProviderId();\n+      String providerId = valueProviderModel.getProviderId();\n+      if (!providerId.equals(storedProviderId)) {", "originalCommit": "675d06321b9e20bc2073aad6207abff50960d8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTE0OQ==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r468831149", "bodyText": "What I am validating here is that no implementation of value provider is associated with more than one id. This should not happen unless the value provider implementation uses a random component for the getId() method. With the structure that I am storing the values, this information is not available later on. I will make this information available to validate it later so that gathering and validation are completely separated.", "author": "ndinu", "createdAt": "2020-08-11T20:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1MDkwNg=="}], "type": "inlineReview"}, {"oid": "df4af95f637186a99546661c4391bba8404640cf", "url": "https://github.com/mulesoft/mule/commit/df4af95f637186a99546661c4391bba8404640cf", "message": "progress", "committedDate": "2020-08-12T02:21:27Z", "type": "commit"}, {"oid": "e67a57cac1a64326ef469d5d3898ef0673a5efb2", "url": "https://github.com/mulesoft/mule/commit/e67a57cac1a64326ef469d5d3898ef0673a5efb2", "message": "Adds requested changes", "committedDate": "2020-08-12T06:18:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMwOTIxNA==", "url": "https://github.com/mulesoft/mule/pull/9184#discussion_r469309214", "bodyText": "the runtime already has a centralized control to decide when to invoke validators and when not. If the runtime decides it wants to run the validations, the validator should not go rogue and decide otherwise. This is just a flag which doesn't fix the problems with this algorithms", "author": "marianogonzalez", "createdAt": "2020-08-12T14:38:41Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/loader/validation/ValueProviderModelValidator.java", "diffHunk": "@@ -45,48 +54,111 @@\n \n   @Override\n   public void validate(ExtensionModel model, ProblemsReporter problemsReporter) {\n+    final ReflectionCache reflectionCache = new ReflectionCache();\n+    boolean isCompileTime = isCompiletime(model);", "originalCommit": "e67a57cac1a64326ef469d5d3898ef0673a5efb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1263f2c0c26f69118a522259e74d8753f19b3759", "url": "https://github.com/mulesoft/mule/commit/1263f2c0c26f69118a522259e74d8753f19b3759", "message": "Adds requested changes", "committedDate": "2020-08-12T16:13:52Z", "type": "commit"}]}