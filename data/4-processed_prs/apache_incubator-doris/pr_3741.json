{"pr_number": 3741, "pr_title": "Ignore broken disks when BE starts up", "pr_createdAt": "2020-06-01T10:55:38Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3741", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI1MjAyNw==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r433252027", "bodyText": "Just use:\nreturn boost::filesystem::exists(p);", "author": "morningman", "createdAt": "2020-06-01T14:01:59Z", "path": "be/src/olap/utils.cpp", "diffHunk": "@@ -973,6 +979,108 @@ OLAPStatus copy_file(const string& src, const string& dest) {\n     \n     return res;\n }\n+OLAPStatus read_write_test_file(const string& test_file_path) {\n+    if (access(test_file_path.c_str(), F_OK) == 0) {\n+        if (remove(test_file_path.c_str()) != 0) {\n+            char errmsg[64];\n+            LOG(WARNING) << \"fail to delete test file. \"\n+                         << \"path=\" << test_file_path\n+                         << \", errno=\" << errno << \", err=\" << strerror_r(errno, errmsg, 64);\n+            return OLAP_ERR_IO_ERROR;\n+        }\n+    } else {\n+        if (errno != ENOENT) {\n+            char errmsg[64];\n+            LOG(WARNING) << \"fail to access test file. \"\n+                         << \"path=\" << test_file_path\n+                         << \", errno=\" << errno << \", err=\" << strerror_r(errno, errmsg, 64);\n+            return OLAP_ERR_IO_ERROR;\n+        }\n+    }\n+    OLAPStatus res = OLAP_SUCCESS;\n+    FileHandler file_handler;\n+    if ((res = file_handler.open_with_mode(test_file_path.c_str(),\n+                                           O_RDWR | O_CREAT | O_DIRECT,\n+                                           S_IRUSR | S_IWUSR)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to create test file. path=\" << test_file_path;\n+        return res;\n+    }\n+    const size_t TEST_FILE_BUF_SIZE = 4096;\n+    const size_t DIRECT_IO_ALIGNMENT = 512;\n+    char *write_test_buff = nullptr;\n+    char *read_test_buff = nullptr;\n+    if (posix_memalign((void**) &write_test_buff, DIRECT_IO_ALIGNMENT, TEST_FILE_BUF_SIZE)!= 0) {\n+        LOG(WARNING) << \"fail to allocate write buffer memory. size=\" <<  TEST_FILE_BUF_SIZE;\n+        return OLAP_ERR_MALLOC_ERROR;\n+    }\n+    AutoDeallocator write_buff(write_test_buff);\n+    if (posix_memalign((void**) &read_test_buff, DIRECT_IO_ALIGNMENT, TEST_FILE_BUF_SIZE)!= 0) {\n+        LOG(WARNING) << \"fail to allocate read buffer memory. size=\" <<  TEST_FILE_BUF_SIZE;\n+        return OLAP_ERR_MALLOC_ERROR;\n+    }\n+    AutoDeallocator read_buff(read_test_buff);\n+    // generate random numbers\n+    uint32_t rand_seed = static_cast<uint32_t>(time(NULL));\n+    for (size_t i = 0; i < TEST_FILE_BUF_SIZE; ++i) {\n+        int32_t tmp_value = rand_r(&rand_seed);\n+        write_test_buff[i] = static_cast<char>(tmp_value);\n+    }\n+    if ((res = file_handler.pwrite(write_buff.get(), TEST_FILE_BUF_SIZE, SEEK_SET)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to write test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if ((res = file_handler.pread(read_buff.get(), TEST_FILE_BUF_SIZE, SEEK_SET)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to read test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if (memcmp(write_buff.get(), read_buff.get(), TEST_FILE_BUF_SIZE) != 0) {\n+        LOG(WARNING) << \"the test file write_buf and read_buf not equal, [file_name = \" << test_file_path << \"]\";\n+        return OLAP_ERR_TEST_FILE_ERROR;\n+    }\n+    if ((res = file_handler.close()) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to close test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if (remove(test_file_path.c_str()) != 0) {\n+        char errmsg[64];\n+        VLOG(3) << \"fail to delete test file. [err='\" << strerror_r(errno, errmsg, 64)\n+                << \"' path='\" << test_file_path << \"']\";\n+        return OLAP_ERR_IO_ERROR;\n+    }\n+    return res;\n+}\n+\n+bool check_datapath_rw(const string& path) {\n+    if (!check_dir_existed(path))\n+        return false;\n+    string file_path = path + \"/.read_write_test_file\";\n+    try {\n+        OLAPStatus res = read_write_test_file(file_path);\n+        return res == OLAP_SUCCESS;\n+    } catch (...) {\n+        // do nothing\n+    }\n+    LOG(WARNING) << \"error when try to read and write temp file under the data path and return false. [path=\" << path << \"]\";\n+    return false;\n+}\n+\n+bool check_dir_existed(const string& path) {\n+    boost::filesystem::path p(path.c_str());\n+\n+    try {\n+        if (boost::filesystem::exists(p)) {", "originalCommit": "ee4339a75922b0e3cbfcec989f85fc52abc0d0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTc0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r433291742", "bodyText": "ignore_broken_disk has handled in parse_conf_store_paths.", "author": "kangkaisen", "createdAt": "2020-06-01T15:08:37Z", "path": "be/src/service/doris_main.cpp", "diffHunk": "@@ -136,6 +136,25 @@ int main(int argc, char** argv) {\n         LOG(FATAL) << \"parse config storage path failed, path=\" << doris::config::storage_root_path;\n         exit(-1);\n     }\n+    auto it = paths.begin();", "originalCommit": "ee4339a75922b0e3cbfcec989f85fc52abc0d0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1NTk3Mg==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r433355972", "bodyText": "Yeah, but i think it just checked whether the data path is existed. It didn't attempt to read or write test files in data path.\nThe current version didn't cover the following situation:\n\nData path is existed but the disk is broken.\nWe can use command 'cd path' into the data path directory, but we can not create or write files for lots of reasons, for instance, no write permission.\n\nSo i try to add the read_write_check step before BE starts up.", "author": "spaces-X", "createdAt": "2020-06-01T16:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mjc1MA==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r433782750", "bodyText": "OK, I see. Thanks.", "author": "kangkaisen", "createdAt": "2020-06-02T10:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5NjMyNw==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r433296327", "bodyText": "We don't need this class. std::unique_ptr and std::shared_ptr is enough", "author": "kangkaisen", "createdAt": "2020-06-01T15:16:11Z", "path": "be/src/util/auto_deallocator.h", "diffHunk": "@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+# pragma once\n+#include <stdlib.h>\n+\n+namespace doris{\n+\n+// A move-only type which manage the lifecycle of allocated data by malloc or posix_memalign\n+// use free() to de-allocate data\n+// Usage example:\n+//  {\n+//      ...\n+//      char *s = nullptr;\n+//      posix_memalign((void **)s, 512, 4096);\n+//      AutoDeallocator tmps(s);\n+//      char *p = (char *)malloc(100*sizeof(char));\n+//      AutoDeallocator tmpp(p);\n+//      ...\n+//  }\n+    class AutoDeallocator {", "originalCommit": "ee4339a75922b0e3cbfcec989f85fc52abc0d0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4NTk2MQ==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r434385961", "bodyText": "You can use check_exist function in util/file_utils.h.\nBoots::filesystem::exist will be replace by util/file_utils.h.", "author": "chaoyli", "createdAt": "2020-06-03T08:09:59Z", "path": "be/src/olap/utils.cpp", "diffHunk": "@@ -973,6 +979,104 @@ OLAPStatus copy_file(const string& src, const string& dest) {\n     \n     return res;\n }\n+OLAPStatus read_write_test_file(const string& test_file_path) {\n+    if (access(test_file_path.c_str(), F_OK) == 0) {\n+        if (remove(test_file_path.c_str()) != 0) {\n+            char errmsg[64];\n+            LOG(WARNING) << \"fail to delete test file. \"\n+                         << \"path=\" << test_file_path\n+                         << \", errno=\" << errno << \", err=\" << strerror_r(errno, errmsg, 64);\n+            return OLAP_ERR_IO_ERROR;\n+        }\n+    } else {\n+        if (errno != ENOENT) {\n+            char errmsg[64];\n+            LOG(WARNING) << \"fail to access test file. \"\n+                         << \"path=\" << test_file_path\n+                         << \", errno=\" << errno << \", err=\" << strerror_r(errno, errmsg, 64);\n+            return OLAP_ERR_IO_ERROR;\n+        }\n+    }\n+    OLAPStatus res = OLAP_SUCCESS;\n+    FileHandler file_handler;\n+    if ((res = file_handler.open_with_mode(test_file_path.c_str(),\n+                                           O_RDWR | O_CREAT | O_DIRECT,\n+                                           S_IRUSR | S_IWUSR)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to create test file. path=\" << test_file_path;\n+        return res;\n+    }\n+    const size_t TEST_FILE_BUF_SIZE = 4096;\n+    const size_t DIRECT_IO_ALIGNMENT = 512;\n+    char *write_test_buff = nullptr;\n+    char *read_test_buff = nullptr;\n+    if (posix_memalign((void**) &write_test_buff, DIRECT_IO_ALIGNMENT, TEST_FILE_BUF_SIZE)!= 0) {\n+        LOG(WARNING) << \"fail to allocate write buffer memory. size=\" <<  TEST_FILE_BUF_SIZE;\n+        return OLAP_ERR_MALLOC_ERROR;\n+    }\n+    unique_ptr<char, decltype(&std::free)> write_buff (write_test_buff, &std::free);\n+    if (posix_memalign((void**) &read_test_buff, DIRECT_IO_ALIGNMENT, TEST_FILE_BUF_SIZE)!= 0) {\n+        LOG(WARNING) << \"fail to allocate read buffer memory. size=\" <<  TEST_FILE_BUF_SIZE;\n+        return OLAP_ERR_MALLOC_ERROR;\n+    }\n+    unique_ptr<char, decltype(&std::free)> read_buff (read_test_buff, &std::free);\n+    // generate random numbers\n+    uint32_t rand_seed = static_cast<uint32_t>(time(NULL));\n+    for (size_t i = 0; i < TEST_FILE_BUF_SIZE; ++i) {\n+        int32_t tmp_value = rand_r(&rand_seed);\n+        write_test_buff[i] = static_cast<char>(tmp_value);\n+    }\n+    if ((res = file_handler.pwrite(write_buff.get(), TEST_FILE_BUF_SIZE, SEEK_SET)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to write test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if ((res = file_handler.pread(read_buff.get(), TEST_FILE_BUF_SIZE, SEEK_SET)) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to read test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if (memcmp(write_buff.get(), read_buff.get(), TEST_FILE_BUF_SIZE) != 0) {\n+        LOG(WARNING) << \"the test file write_buf and read_buf not equal, [file_name = \" << test_file_path << \"]\";\n+        return OLAP_ERR_TEST_FILE_ERROR;\n+    }\n+    if ((res = file_handler.close()) != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"fail to close test file. [file_name=\" << test_file_path << \"]\";\n+        return res;\n+    }\n+    if (remove(test_file_path.c_str()) != 0) {\n+        char errmsg[64];\n+        VLOG(3) << \"fail to delete test file. [err='\" << strerror_r(errno, errmsg, 64)\n+                << \"' path='\" << test_file_path << \"']\";\n+        return OLAP_ERR_IO_ERROR;\n+    }\n+    return res;\n+}\n+\n+bool check_datapath_rw(const string& path) {\n+    if (!check_dir_existed(path))\n+        return false;\n+    string file_path = path + \"/.read_write_test_file\";\n+    try {\n+        OLAPStatus res = read_write_test_file(file_path);\n+        return res == OLAP_SUCCESS;\n+    } catch (...) {\n+        // do nothing\n+    }\n+    LOG(WARNING) << \"error when try to read and write temp file under the data path and return false. [path=\" << path << \"]\";\n+    return false;\n+}\n+\n+bool check_dir_existed(const string& path) {\n+    boost::filesystem::path p(path.c_str());\n+\n+    try {\n+        return boost::filesystem::exists(p);", "originalCommit": "8a17ef80c94f2335111441a272e9bbefd624e1ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4NzIzNw==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r434387237", "bodyText": "This is related to this issue #2857", "author": "chaoyli", "createdAt": "2020-06-03T08:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4NTk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5OTUxNg==", "url": "https://github.com/apache/incubator-doris/pull/3741#discussion_r434699516", "bodyText": "done", "author": "spaces-X", "createdAt": "2020-06-03T16:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4NTk2MQ=="}], "type": "inlineReview"}, {"oid": "fab4eee0189bdde5288ddfc66aeba78b32d62759", "url": "https://github.com/apache/incubator-doris/commit/fab4eee0189bdde5288ddfc66aeba78b32d62759", "message": "Ignore broken disk when BE starts up", "committedDate": "2020-06-04T02:52:21Z", "type": "commit"}]}