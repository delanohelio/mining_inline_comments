{"pr_number": 3580, "pr_title": "[Memory Engine] Add column reader/writer", "pr_createdAt": "2020-05-13T08:49:22Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3580", "timeline": [{"oid": "1d3270e8505e511397c9656d96020949bab17486", "url": "https://github.com/apache/incubator-doris/commit/1d3270e8505e511397c9656d96020949bab17486", "message": "[Memory Engine] Add column reader/writer", "committedDate": "2020-05-13T08:33:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMDc3Mg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425520772", "bodyText": "better to add #undef CREATE_READER after usage", "author": "imay", "createdAt": "2020-05-15T01:44:39Z", "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMzY3OA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425733678", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-15T11:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMDc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTExNA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425521114", "bodyText": "Is this thread-safe? Better declare it in the comment.", "author": "imay", "createdAt": "2020-05-15T01:45:50Z", "path": "be/src/olap/memory/column_reader.h", "diffHunk": "@@ -0,0 +1,95 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Holder for a ColumnBlock\n+// Although ColumnBlock support reference counting, we avoid using it because\n+// a reader already hold a proxy to all the ColumnBlocks, it's unnecessary\n+// and inefficient to inc/dec refcount, so we use this holder instead.\n+//\n+// If the underlying column data doesn't need merge-on-read, we can use the\n+// underlying base's ColumnBlock directly, and _own_cb equals false.\n+//\n+// If there are some deltas need to be merged, a new ColumnBlock will be\n+// created, and _own_cb equals true.\n+class ColumnBlockHolder {", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDg2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425734869", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-15T11:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTk2NA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425521964", "bodyText": "default value", "author": "imay", "createdAt": "2020-05-15T01:49:01Z", "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNzYxMg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425737612", "bodyText": "I rethought about this, actually, maybe we should avoid initializing those fields for performance reasons, because these fields will be properly assigned in related methods.", "author": "decster", "createdAt": "2020-05-15T11:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzg2Nw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425523867", "bodyText": "Is the class a writer of class or a writer of part of column?\nIn my opinion, column will contain all data for a table \"column\", and its data is not written at one time. One Writer may update some part of column data.\nIf my understanding is right, I think ColumnBlockWriter/ColumnChunkWriter is a better name.", "author": "imay", "createdAt": "2020-05-15T01:56:59Z", "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2Njc2MQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425666761", "bodyText": "Is the class a writer of class or a writer of part of column?\n\nIt is the writer of a whole column, it will write all the inserts/updates of this column of a writetx.", "author": "decster", "createdAt": "2020-05-15T09:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDExNQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425524115", "bodyText": "And how about delete operation.", "author": "imay", "createdAt": "2020-05-15T01:57:49Z", "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);\n+//   writer->update(rowid, &value, 0);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;\n+\n+    // Borrow a vtable slot to do typed hashcode calculation, mainly used to find\n+    // row by rowkey using hash index.\n+    //\n+    // It's designed to support array operator, so there are two parameters for user\n+    // to pass array start and array index.\n+    //\n+    // Note: this is the same method as ColumnReader::hashcode\n+    virtual uint64_t hashcode(const void* rhs, size_t rhs_idx) const = 0;\n+\n+    // Check cell equality, mainly used to find row by rowkey using hash index.\n+    //\n+    // Note: this is the same method as ColumnReader::equals\n+    virtual bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const = 0;\n+\n+    virtual string debug_string() const = 0;\n+\n+    // Insert/append a cell at specified row\n+    virtual Status insert(uint32_t rid, const void* value) = 0;\n+\n+    // Update a cell at specified row\n+    virtual Status update(uint32_t rid, const void* value) = 0;", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NzIwMw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425667203", "bodyText": "delete is handled in a special delete flag column.", "author": "decster", "createdAt": "2020-05-15T09:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDExNQ=="}], "type": "inlineReview"}, {"oid": "44e9cbf65355e9fb340db054f569c9203e6e0e03", "url": "https://github.com/apache/incubator-doris/commit/44e9cbf65355e9fb340db054f569c9203e6e0e03", "message": "[Memory Engine] Add column reader/writer: address review comments", "committedDate": "2020-05-15T11:27:29Z", "type": "commit"}, {"oid": "fd93586f13fa3ad2878d43b63e651769fa2138ed", "url": "https://github.com/apache/incubator-doris/commit/fd93586f13fa3ad2878d43b63e651769fa2138ed", "message": "[Memory Engine] Add column reader/writer: remove comma at undef end", "committedDate": "2020-05-15T11:29:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc1MTYyMg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425751622", "bodyText": "Write is the meaning of write actual data. This name may be confused.", "author": "chaoyli", "createdAt": "2020-05-15T11:56:42Z", "path": "be/src/olap/memory/column.cpp", "diffHunk": "@@ -105,19 +108,102 @@ Status Column::capture_version(uint64_t version, vector<ColumnDelta*>* deltas,\n     return Status::OK();\n }\n \n-void Column::capture_latest(vector<ColumnDelta*>* deltas) const {\n+void Column::capture_latest(vector<ColumnDelta*>* deltas, uint64_t* version) const {\n     deltas->reserve(_versions.size() - _base_idx - 1);\n     for (size_t i = _base_idx + 1; i < _versions.size(); i++) {\n         deltas->emplace_back(_versions[i].delta.get());\n     }\n+    *version = _versions.back().version;\n }\n \n Status Column::read(uint64_t version, std::unique_ptr<ColumnReader>* reader) {\n-    return Status::NotSupported(\"not supported\");\n+    ColumnType type = schema().type();\n+    bool nullable = schema().is_nullable();\n+    vector<ColumnDelta*> deltas;\n+    uint64_t real_version;\n+    RETURN_IF_ERROR(capture_version(version, &deltas, &real_version));\n+\n+#define CREATE_READER(T)                                                                          \\\n+    if (nullable) {                                                                               \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, true>(this, version, real_version, std::move(deltas)));  \\\n+    } else {                                                                                      \\\n+        (*reader).reset(                                                                          \\\n+                new TypedColumnReader<T, false>(this, version, real_version, std::move(deltas))); \\\n+    }\n+\n+    switch (type) {\n+    case OLAP_FIELD_TYPE_BOOL:\n+    case OLAP_FIELD_TYPE_TINYINT:\n+        CREATE_READER(int8_t)\n+        break;\n+    case OLAP_FIELD_TYPE_SMALLINT:\n+        CREATE_READER(int16_t)\n+        break;\n+    case OLAP_FIELD_TYPE_INT:\n+        CREATE_READER(int32_t)\n+        break;\n+    case OLAP_FIELD_TYPE_BIGINT:\n+        CREATE_READER(int64_t)\n+        break;\n+    case OLAP_FIELD_TYPE_LARGEINT:\n+        CREATE_READER(int128_t)\n+        break;\n+    case OLAP_FIELD_TYPE_FLOAT:\n+        CREATE_READER(float)\n+        break;\n+    case OLAP_FIELD_TYPE_DOUBLE:\n+        CREATE_READER(double)\n+        break;\n+    default:\n+        return Status::NotSupported(\"create column reader: type not supported\");\n+    }\n+    return Status::OK();\n }\n \n Status Column::write(std::unique_ptr<ColumnWriter>* writer) {", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTE0MQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131141", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-16T08:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc1MTYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3MzE0Nw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425773147", "bodyText": "I found page/block are used interleaved. It's better to use one name to remove misapprehension.", "author": "chaoyli", "createdAt": "2020-05-15T12:40:00Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const Reader& reader, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*reader._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t block, ColumnBlockHolder* cbh) const {", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTI3OA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131278", "bodyText": "fixed, all renamed to block", "author": "decster", "createdAt": "2020-05-16T08:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3MzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NTczMw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425775733", "bodyText": "class Reader is ambiguous", "author": "chaoyli", "createdAt": "2020-05-15T12:44:37Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {\n+    for (ssize_t i = reader._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = reader._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < reader._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*reader._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*reader._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*reader._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+template <class Reader, class T, bool Nullable, class ST>", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTQ0MQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131441", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-16T08:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Njk0Mw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425776943", "bodyText": "What the function want to return, may be add a comment to elaborate it.", "author": "chaoyli", "createdAt": "2020-05-15T12:46:47Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,208 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// This method needs to be shared by reader/writer, so extract it as template function\n+template <class Reader, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const Reader& reader, const uint32_t rid) {", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjU2NA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426132564", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-16T08:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Njk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Nzk3MA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r425777970", "bodyText": "writer->insert(new_rowid, &value);\nwriter->update(rowid, &value);", "author": "chaoyli", "createdAt": "2020-05-15T12:48:33Z", "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());\n+//   writer->insert(new_rowid, &value, 0);", "originalCommit": "1d3270e8505e511397c9656d96020949bab17486", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMTU3OQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426131579", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-16T08:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3Nzk3MA=="}], "type": "inlineReview"}, {"oid": "fdd2a1e2ab18cecb5c36b8bba873bdd4472ebe56", "url": "https://github.com/apache/incubator-doris/commit/fdd2a1e2ab18cecb5c36b8bba873bdd4472ebe56", "message": "[Memory Engine] Add column reader/writer: address review comments", "committedDate": "2020-05-16T08:35:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NTcwNg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426165706", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //   RETURN_IF_ERROR(column->write(&writer).ok());\n          \n          \n            \n            //   RETURN_IF_ERROR(column->create_writer(&writer).ok());", "author": "morningman", "createdAt": "2020-05-16T15:55:40Z", "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->write(&writer).ok());", "originalCommit": "fdd2a1e2ab18cecb5c36b8bba873bdd4472ebe56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3MzY4Ng==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426273686", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-17T15:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NTcwNg=="}], "type": "inlineReview"}, {"oid": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "url": "https://github.com/apache/incubator-doris/commit/de4527fd48317a5ca2ce583540e2d70e4182f79d", "message": "[Memory Engine] Add column reader/writer: address review comments", "committedDate": "2020-05-17T15:25:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTU3NA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426335574", "bodyText": "Give some comments for this template parameters to help others understand", "author": "imay", "createdAt": "2020-05-18T01:53:33Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0Njc0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446742", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjE5Mw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426336193", "bodyText": "It will be better if you can give some comment about how this function works", "author": "imay", "createdAt": "2020-05-18T01:57:29Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjgxOA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446818", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjM1MA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426336350", "bodyText": "Please give comment for this fast path.", "author": "imay", "createdAt": "2020-05-18T01:58:12Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        bool isnull = (*rw._base)[bid]->is_null(idx);\n+        if (isnull) {\n+            return nullptr;\n+        } else {\n+            return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+        }\n+    } else {\n+        return &((*rw._base)[bid]->data().template as<ST>()[idx]);\n+    }\n+}\n+\n+// Get a cell's hashcode of a typed array\n+template <class T, class ST>\n+inline uint64_t TypedColumnHashcode(const void* rhs, size_t rhs_idx) {\n+    if (std::is_same<T, ST>::value) {\n+        const T* prhs = ((const T*)rhs) + rhs_idx;\n+        return HashUtil::fnv_hash64(prhs, sizeof(T), 0);\n+    } else {\n+        // TODO: support other type's hash\n+        return 0;\n+    }\n+}\n+\n+// Compare equality of a typed array's cell with this column's cell\n+template <class RW, class T, bool Nullable, class ST>\n+bool TypedColumnEquals(const RW& rw, const uint32_t rid, const void* rhs, size_t rhs_idx) {\n+    const T& rhs_value = ((const T*)rhs)[rhs_idx];\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                CHECK(false) << \"only used for key column\";\n+                return false;\n+            } else {\n+                return (pdelta->data().template as<T>()[pos]) == rhs_value;\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;\n+    DCHECK(bid < rw._base->size());\n+    uint32_t idx = rid & 0xffff;\n+    DCHECK(idx * sizeof(ST) < (*rw._base)[bid]->data().bsize());\n+    if (Nullable) {\n+        CHECK(false) << \"only used for key column\";\n+        return false;\n+    } else {\n+        DCHECK(rhs);\n+        return ((*rw._base)[bid]->data().template as<T>()[idx]) == rhs_value;\n+    }\n+}\n+\n+// ColumnReader typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+//\n+// Template type meanings:\n+// T: column type used for interface\n+// Nullable: whether column type is nullable\n+// ST: column type used for internal storage\n+//\n+// For fixed size scalar types(int/float), T should be the same as ST\n+// For var size typse(string), when using dict encoding, ST may be integer\n+//\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T>\n+class TypedColumnReader : public ColumnReader {\n+public:\n+    TypedColumnReader(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnReader<T, Nullable, ST>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    Status get_block(size_t nrows, size_t bid, ColumnBlockHolder* cbh) const {\n+        bool base_only = true;\n+        for (size_t i = 0; i < _deltas.size(); ++i) {\n+            if (_deltas[i]->contains_block(bid)) {\n+                base_only = false;\n+                break;\n+            }\n+        }\n+        auto& block = (*_base)[bid];", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NzgzNw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426447837", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMzNjM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426340637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  vector<ColumnDelta*>&& deltas)\n          \n          \n            \n                                  vector<ColumnDelta*> deltas)", "author": "imay", "createdAt": "2020-05-18T02:23:58Z", "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NjUzMw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426446533", "bodyText": "why? This is intended for move semantics", "author": "decster", "createdAt": "2020-05-18T08:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjM3Ng==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r427146376", "bodyText": "Value passing is the same with rvalue reference and const left reference.", "author": "imay", "createdAt": "2020-05-19T09:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTQyNg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426341426", "bodyText": "more comments for arguments. I'm not very clear about what does rw stands for?", "author": "imay", "createdAt": "2020-05-18T02:28:19Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0ODAzOA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426448038", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTkzMw==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426341933", "bodyText": "Why does a writer need a get interface? Better to comment.\nAnd so does equals interface.", "author": "imay", "createdAt": "2020-05-18T02:30:56Z", "path": "be/src/olap/memory/column_writer.h", "diffHunk": "@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class Column;\n+\n+// Exclusive writer for column, also with some reader's functionality\n+//\n+// Example writer usage:\n+//   scoped_refptr<Column> column;\n+//   std::unique_ptr<ColumnWriter> writer;\n+//   // create writer\n+//   RETURN_IF_ERROR(column->create_writer(&writer).ok());\n+//   writer->insert(new_rowid, &value);\n+//   writer->update(rowid, &value);\n+//   writer->finalize(new_version);\n+//   // get new column refptr\n+//   // if a COW has been done, column will point to new column object\n+//   // else column will remain the same.\n+//   writer->get_new_column(&column);\n+class ColumnWriter {\n+public:\n+    virtual ~ColumnWriter() {}\n+\n+    // Get cell by rid, caller needs to make sure rid is in valid range\n+    //\n+    // Note: this is the same method as ColumnReader::get\n+    virtual const void* get(const uint32_t rid) const = 0;", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0OTA5NQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426449095", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MjMzMA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426342330", "bodyText": "Is it better to define a macro for BLOCK_SIZE and write some inline functions to get block id from row id and row offset in a block.", "author": "imay", "createdAt": "2020-05-18T02:33:16Z", "path": "be/src/olap/memory/typed_column_reader.h", "diffHunk": "@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column_reader.h\"\n+#include \"util/hash_util.hpp\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Those methods need to be shared by reader/writer, so extract them as template functions\n+\n+// Get Column's storage cell address by rowid.\n+template <class RW, class T, bool Nullable, class ST>\n+inline const void* TypedColumnGet(const RW& rw, const uint32_t rid) {\n+    for (ssize_t i = rw._deltas.size() - 1; i >= 0; i--) {\n+        ColumnDelta* pdelta = rw._deltas[i];\n+        uint32_t pos = pdelta->find_idx(rid);\n+        if (pos != DeltaIndex::npos) {\n+            if (Nullable) {\n+                bool isnull = pdelta->nulls() && pdelta->nulls().as<bool>()[pos];\n+                if (isnull) {\n+                    return nullptr;\n+                } else {\n+                    return &(pdelta->data().template as<ST>()[pos]);\n+                }\n+            } else {\n+                return &(pdelta->data().template as<ST>()[pos]);\n+            }\n+        }\n+    }\n+    uint32_t bid = rid >> 16;", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0OTE5MQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426449191", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0NjkxMQ==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426346911", "bodyText": "Better to leave a CHECK(false) to make process crash", "author": "imay", "createdAt": "2020-05-18T02:57:29Z", "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzODc3Mg==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426438772", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-18T08:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0NjkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0ODEwMA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426348100", "bodyText": "why not use unordered_map?", "author": "imay", "createdAt": "2020-05-18T03:04:21Z", "path": "be/src/olap/memory/typed_column_writer.h", "diffHunk": "@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/typed_column_reader.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Used to hold temporary nullable update cells in ColumnWriter\n+template <class T>\n+class NullableUpdateType {\n+public:\n+    bool& isnull() { return _isnull; }\n+    T& value() { return _value; }\n+\n+private:\n+    bool _isnull;\n+    T _value;\n+};\n+\n+// Used to hold temporary update cells in ColumnWriter\n+template <class T>\n+class UpdateType {\n+public:\n+    bool& isnull() { return *static_cast<bool*>(0); /*unused*/ }\n+    T& value() { return _value; }\n+\n+private:\n+    T _value;\n+};\n+\n+// ColumnWriter typed implementations\n+// currently only works for int8/int16/int32/int64/int128/float/double\n+// TODO: add string and other varlen type support\n+template <class T, bool Nullable = false, class ST = T, class UT = T>\n+class TypedColumnWriter : public ColumnWriter {\n+public:\n+    TypedColumnWriter(Column* column, uint64_t version, uint64_t real_version,\n+                      vector<ColumnDelta*>&& deltas)\n+            : _column(column),\n+              _base(&_column->_base),\n+              _version(version),\n+              _real_version(real_version),\n+              _deltas(std::move(deltas)) {}\n+\n+    const void* get(const uint32_t rid) const {\n+        return TypedColumnGet<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(*this, rid);\n+    }\n+\n+    uint64_t hashcode(const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnHashcode<T, ST>(rhs, rhs_idx);\n+    }\n+\n+    bool equals(const uint32_t rid, const void* rhs, size_t rhs_idx) const {\n+        return TypedColumnEquals<TypedColumnWriter<T, Nullable, ST, UT>, T, Nullable, ST>(\n+                *this, rid, rhs, rhs_idx);\n+    }\n+\n+    string debug_string() const {\n+        return StringPrintf(\"%s version=%zu(real=%zu) ndelta=%zu insert:%zu update:%zu\",\n+                            _column->debug_string().c_str(), _version, _real_version,\n+                            _deltas.size(), _num_insert, _num_update);\n+    }\n+\n+    Status insert(uint32_t rid, const void* value) {\n+        uint32_t bid = rid >> 16;\n+        if (bid >= _base->size()) {\n+            RETURN_IF_ERROR(add_block());\n+            // add one block should be enough\n+            CHECK(bid < _base->size());\n+        }\n+        auto& block = (*_base)[bid];\n+        uint32_t idx = rid & 0xffff;\n+        DCHECK(idx * sizeof(T) < block->data().bsize());\n+        if (Nullable) {\n+            if (value) {\n+                if (std::is_same<T, ST>::value) {\n+                    block->set_not_null(idx);\n+                    block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                block->set_null(idx);\n+            }\n+        } else {\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                block->data().as<ST>()[idx] = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_insert++;\n+        return Status::OK();\n+    }\n+\n+    Status update(uint32_t rid, const void* value) {\n+        DCHECK_LT(rid, _base->size() * Column::BLOCK_SIZE);\n+        if (Nullable) {\n+            auto& uv = _updates[rid];\n+            if (value) {\n+                uv.isnull() = false;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = *reinterpret_cast<const T*>(value);\n+                } else {\n+                    // TODO: string support\n+                }\n+            } else {\n+                _update_has_null = true;\n+                uv.isnull() = true;\n+                if (std::is_same<T, ST>::value) {\n+                    uv.value() = (T)0;\n+                } else {\n+                    // TODO: string support\n+                }\n+            }\n+        } else {\n+            auto& uv = _updates[rid];\n+            DCHECK(value);\n+            if (std::is_same<T, ST>::value) {\n+                uv.value() = *static_cast<const ST*>(value);\n+            } else {\n+                // TODO: string support\n+            }\n+        }\n+        _num_update++;\n+        return Status::OK();\n+    }\n+\n+    Status finalize(uint64_t version) {\n+        if (_updates.size() == 0) {\n+            // insert(append) only\n+            return Status::OK();\n+        }\n+        // prepare delta\n+        size_t nblock = _base->size();\n+        scoped_refptr<ColumnDelta> delta(new ColumnDelta());\n+        RETURN_IF_ERROR(delta->alloc(nblock, _updates.size(), sizeof(ST), _update_has_null));\n+        DeltaIndex* index = delta->index();\n+        vector<uint32_t>& block_ends = index->block_ends();\n+        Buffer& idxdata = index->data();\n+        Buffer& data = delta->data();\n+        Buffer& nulls = delta->nulls();\n+        uint32_t cidx = 0;\n+        uint32_t curbid = 0;\n+        for (auto& e : _updates) {\n+            uint32_t rid = e.first;\n+            uint32_t bid = rid >> 16;\n+            while (curbid < bid) {\n+                block_ends[curbid] = cidx;\n+                curbid++;\n+            }\n+            idxdata.as<uint16_t>()[cidx] = rid & 0xffff;\n+            if (Nullable) {\n+                bool isnull = e.second.isnull();\n+                if (isnull) {\n+                    nulls.as<bool>()[cidx] = true;\n+                } else {\n+                    data.as<ST>()[cidx] = e.second.value();\n+                }\n+            } else {\n+                data.as<ST>()[cidx] = e.second.value();\n+            }\n+            cidx++;\n+        }\n+        while (curbid < nblock) {\n+            block_ends[curbid] = cidx;\n+            curbid++;\n+        }\n+        _updates.clear();\n+        RETURN_IF_ERROR(add_delta(std::move(delta), version));\n+        return Status::OK();\n+    }\n+\n+    Status get_new_column(scoped_refptr<Column>* ret) {\n+        if (*ret != _column) {\n+            DLOG(INFO) << StringPrintf(\"%s switch new column\", _column->debug_string().c_str());\n+            (*ret).swap(_column);\n+            _column.reset();\n+        }\n+        return Status::OK();\n+    }\n+\n+private:\n+    // Expand base vector, do a copy-on-write\n+    Status expand_base() {\n+        size_t added = std::min((size_t)Column::BASE_CAPACITY_MAX_STEP_SIZE, _base->capacity());\n+        size_t new_base_capacity =\n+                padding(_base->capacity() + added, Column::BASE_CAPACITY_MIN_STEP_SIZE);\n+        // check if version needs expanding too\n+        size_t new_version_capacity = 0;\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            new_version_capacity =\n+                    padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                            Column::VERSION_CAPACITY_STEP_SIZE);\n+        }\n+        // check pool doesn't need expanding\n+        DCHECK_EQ(_base->size(), _base->capacity());\n+        DCHECK(_base->capacity() < new_base_capacity);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand base base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, new_base_capacity,\n+                                   new_version_capacity);\n+        scoped_refptr<Column> cow(\n+                new Column(*_column.get(), new_base_capacity, new_version_capacity));\n+        cow.swap(_column);\n+        _base = &(_column->_base);\n+        return Status::OK();\n+    }\n+\n+    // Try to append a new block to this column, if base vector is at it's capacity,\n+    // call expand base.\n+    Status add_block() {\n+        if (_base->size() == _base->capacity()) {\n+            RETURN_IF_ERROR(expand_base());\n+        }\n+        CHECK_LT(_base->size(), _base->capacity());\n+        scoped_refptr<ColumnBlock> block(new ColumnBlock());\n+        RETURN_IF_ERROR(block->alloc(Column::BLOCK_SIZE, sizeof(ST)));\n+        _base->emplace_back(std::move(block));\n+        if (_column->schema().cid() == 1) {\n+            // only log when first column add block\n+            DLOG(INFO) << StringPrintf(\"Column(cid=%u) add ColumnBlock %zu/%zu\",\n+                                       _column->schema().cid(), _base->size(), _base->capacity());\n+        }\n+        return Status::OK();\n+    }\n+\n+    // Expand versions vector, do a copy-on-write\n+    Status expand_versions() {\n+        size_t new_capacity =\n+                padding(_column->_versions.capacity() + Column::VERSION_CAPACITY_STEP_SIZE,\n+                        Column::VERSION_CAPACITY_STEP_SIZE);\n+        DLOG(INFO) << StringPrintf(\"%s memory=%.1lfM expand delta base=%zu version=%zu\",\n+                                   _column->schema().debug_string().c_str(),\n+                                   _column->memory() / 1000000.0, _base->capacity(), new_capacity);\n+        scoped_refptr<Column> cow(new Column(*_column.get(), 0, new_capacity));\n+        cow.swap(_column);\n+        return Status::OK();\n+    }\n+\n+    // Try to add a new delta to versions vector, if versions vector is at it's capcacity,\n+    // call expand versions\n+    Status add_delta(scoped_refptr<ColumnDelta>&& delta, uint64_t version) {\n+        if (_column->_versions.size() == _column->_versions.capacity()) {\n+            expand_versions();\n+        }\n+        DLOG(INFO) << StringPrintf(\"%s add version %zu update: %zu\",\n+                                   _column->debug_string().c_str(), version, delta->size());\n+        CHECK_LT(_column->_versions.size(), _column->_versions.capacity());\n+        _column->_versions.emplace_back();\n+        Column::VersionInfo& vinfo = _column->_versions.back();\n+        vinfo.version = version;\n+        vinfo.delta = delta;\n+        return Status::OK();\n+    }\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend const void* TypedColumnGet(const Reader& reader, const uint32_t rid);\n+\n+    template <class T2, class ST2>\n+    friend bool TypedColumnHashcode(const void*, size_t);\n+\n+    template <class Reader, class T2, bool Nullable2, class ST2>\n+    friend bool TypedColumnEquals(const Reader&, const uint32_t, const void*, size_t);\n+\n+    // The following members need to be identical to TypedColumnReader\n+    // because they share same reader methods: get/hashcode/equals\n+    scoped_refptr<Column> _column;\n+    vector<scoped_refptr<ColumnBlock>>* _base;\n+    uint64_t _version;\n+    uint64_t _real_version;\n+    vector<ColumnDelta*> _deltas;\n+\n+    size_t _num_insert = 0;\n+    size_t _num_update = 0;\n+    bool _update_has_null = false;\n+    typedef typename std::conditional<Nullable, NullableUpdateType<UT>, UpdateType<UT>>::type\n+            UpdateMapType;\n+    // Temporary stoarage to hold all updated cells' values\n+    // rowid -> updated values\n+    std::map<uint32_t, UpdateMapType> _updates;", "originalCommit": "de4527fd48317a5ca2ce583540e2d70e4182f79d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzODQ1MA==", "url": "https://github.com/apache/incubator-doris/pull/3580#discussion_r426438450", "bodyText": "updates will be finalized to delta, and delta_index needs to be in order, std::map has order.", "author": "decster", "createdAt": "2020-05-18T08:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0ODEwMA=="}], "type": "inlineReview"}, {"oid": "e16bbcb23a915714d8db7163e794426d38dc19da", "url": "https://github.com/apache/incubator-doris/commit/e16bbcb23a915714d8db7163e794426d38dc19da", "message": "[Memory Engine] Add column reader/writer: address review comments", "committedDate": "2020-05-18T08:29:39Z", "type": "commit"}]}