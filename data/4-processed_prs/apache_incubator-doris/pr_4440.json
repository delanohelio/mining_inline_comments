{"pr_number": 4440, "pr_title": "[refactor] Optimize threads usage mode in BE", "pr_createdAt": "2020-08-24T14:39:55Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4440", "timeline": [{"oid": "250e9b30b769dc81650b3b186e22ace6c2311950", "url": "https://github.com/apache/incubator-doris/commit/250e9b30b769dc81650b3b186e22ace6c2311950", "message": "[refactor] Optimize threads usage mode in BE\n\nBE can not graceful exit because some threads are running in endless\nloop. This patch do the following optimization:\n- Use the well encapsulated Thread and ThreadPool instead of std::thread\n  and std::vector<std::thread>\n- Use CountDownLatch in thread's loop condition to avoid endless loop\n- Introduce a new class Daemon for daemon works, like tcmalloc_gc,\n  memory_maintenance and calculate_metrics\n- Decouple statistics type TaskWorkerPool and StorageEngine notification\n  by submit tasks to TaskWorkerPool's queue\n- Reorder objects' stop and deconstruct in main(), i.e. stop network\n  services at first, then internal services\n- Use libevent in pthreads mode, by calling evthread_use_pthreads(),\n  then EvHttpServer can exit gracefully in multi-threads\n- Call brpc::Server's Stop() and ClearServices() explicitly", "committedDate": "2020-08-28T14:11:28Z", "type": "commit"}, {"oid": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "url": "https://github.com/apache/incubator-doris/commit/9413ab409579cd8c20f5c1831d242b31ecb3e153", "message": "remove comments", "committedDate": "2020-08-28T14:11:28Z", "type": "commit"}, {"oid": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "url": "https://github.com/apache/incubator-doris/commit/9413ab409579cd8c20f5c1831d242b31ecb3e153", "message": "remove comments", "committedDate": "2020-08-28T14:11:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4NDU1NA==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481784554", "bodyText": "redundant assignment", "author": "chaoyli", "createdAt": "2020-09-02T06:29:20Z", "path": "be/src/olap/olap_server.cpp", "diffHunk": "@@ -263,27 +238,24 @@ void* StorageEngine::_garbage_sweeper_thread_callback(void* arg) {\n             // do nothing. continue next loop.\n         }\n     }\n-\n-    return nullptr;\n }\n \n-void* StorageEngine::_disk_stat_monitor_thread_callback(void* arg) {\n+void StorageEngine::_disk_stat_monitor_thread_callback() {\n #ifdef GOOGLE_PROFILER\n     ProfilerRegisterThread();\n #endif\n-    while (!_stop_bg_worker) {\n+\n+    int32_t interval = config::disk_stat_monitor_interval;\n+    do {\n         _start_disk_stat_monitor();\n \n-        int32_t interval = config::disk_stat_monitor_interval;\n+        interval = config::disk_stat_monitor_interval;", "originalCommit": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc5OTA1Mw==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481799053", "bodyText": "Same", "author": "acelyc111", "createdAt": "2020-09-02T06:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4NDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4NDc2Mw==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481784763", "bodyText": "redundant assignment", "author": "chaoyli", "createdAt": "2020-09-02T06:29:39Z", "path": "be/src/olap/olap_server.cpp", "diffHunk": "@@ -330,108 +303,92 @@ void* StorageEngine::_cumulative_compaction_thread_callback(void* arg, DataDir*\n                 _perform_cumulative_compaction(data_dir);\n             }\n         }\n-        int32_t interval = config::cumulative_compaction_check_interval_seconds;\n+\n+        interval = config::cumulative_compaction_check_interval_seconds;", "originalCommit": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc5OTI0OQ==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481799249", "bodyText": "Same", "author": "acelyc111", "createdAt": "2020-09-02T06:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4NDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4NTE2Nw==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481785167", "bodyText": "redundant assignment", "author": "chaoyli", "createdAt": "2020-09-02T06:30:14Z", "path": "be/src/olap/olap_server.cpp", "diffHunk": "@@ -330,108 +303,92 @@ void* StorageEngine::_cumulative_compaction_thread_callback(void* arg, DataDir*\n                 _perform_cumulative_compaction(data_dir);\n             }\n         }\n-        int32_t interval = config::cumulative_compaction_check_interval_seconds;\n+\n+        interval = config::cumulative_compaction_check_interval_seconds;\n         if (interval <= 0) {\n             LOG(WARNING) << \"cumulative compaction check interval config is illegal:\" << interval\n                         << \"will be forced set to one\";\n             interval = 1;\n         }\n-        SLEEP_IN_BG_WORKER(interval);\n-    }\n-\n-    return nullptr;\n+    } while (!_stop_background_threads_latch.wait_for(MonoDelta::FromSeconds(interval)));\n }\n \n-void* StorageEngine::_unused_rowset_monitor_thread_callback(void* arg) {\n+void StorageEngine::_unused_rowset_monitor_thread_callback() {\n #ifdef GOOGLE_PROFILER\n     ProfilerRegisterThread();\n #endif\n-    while (!_stop_bg_worker) {\n+    int32_t interval = config::unused_rowset_monitor_interval;\n+    do {\n         start_delete_unused_rowset();\n \n-        int32_t interval = config::unused_rowset_monitor_interval;\n+        interval = config::unused_rowset_monitor_interval;\n         if (interval <= 0) {\n             LOG(WARNING) << \"unused_rowset_monitor_interval config is illegal: \" << interval\n                          << \", force set to 1\";\n             interval = 1;\n         }\n-        SLEEP_IN_BG_WORKER(interval);\n-    }\n-\n-    return nullptr;\n+    } while (!_stop_background_threads_latch.wait_for(MonoDelta::FromSeconds(interval)));\n }\n \n-\n-\n-void* StorageEngine::_path_gc_thread_callback(void* arg) {\n+void StorageEngine::_path_gc_thread_callback(DataDir* data_dir) {\n #ifdef GOOGLE_PROFILER\n     ProfilerRegisterThread();\n #endif\n \n     LOG(INFO) << \"try to start path gc thread!\";\n-\n-    while (!_stop_bg_worker) {\n+    int32_t interval = config::path_gc_check_interval_second;\n+    do {\n         LOG(INFO) << \"try to perform path gc by tablet!\";\n-        ((DataDir*)arg)->perform_path_gc_by_tablet();\n+        data_dir->perform_path_gc_by_tablet();\n         \n         LOG(INFO) << \"try to perform path gc by rowsetid!\";\n-        // perform path gc by rowset id\n-        ((DataDir*)arg)->perform_path_gc_by_rowsetid();\n+        data_dir->perform_path_gc_by_rowsetid();\n \n-        int32_t interval = config::path_gc_check_interval_second;\n+        interval = config::path_gc_check_interval_second;\n         if (interval <= 0) {\n             LOG(WARNING) << \"path gc thread check interval config is illegal:\" << interval\n                          << \"will be forced set to half hour\";\n             interval = 1800; // 0.5 hour\n         }\n-        SLEEP_IN_BG_WORKER(interval);\n-    }\n-\n-    return nullptr;\n+    } while (!_stop_background_threads_latch.wait_for(MonoDelta::FromSeconds(interval)));\n }\n \n-void* StorageEngine::_path_scan_thread_callback(void* arg) {\n+void StorageEngine::_path_scan_thread_callback(DataDir* data_dir) {\n #ifdef GOOGLE_PROFILER\n     ProfilerRegisterThread();\n #endif\n \n-    LOG(INFO) << \"try to start path scan thread!\";\n-\n-    while (!_stop_bg_worker) {\n+    int32_t interval = config::path_scan_interval_second;\n+    do {\n         LOG(INFO) << \"try to perform path scan!\";\n-        ((DataDir*)arg)->perform_path_scan();\n+        data_dir->perform_path_scan();\n \n         int32_t interval = config::path_scan_interval_second;", "originalCommit": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc5MTk4MA==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481791980", "bodyText": "abundant assignment", "author": "chaoyli", "createdAt": "2020-09-02T06:39:40Z", "path": "be/src/olap/olap_server.cpp", "diffHunk": "@@ -208,20 +186,17 @@ void* StorageEngine::_base_compaction_thread_callback(void* arg, DataDir* data_d\n             }\n         }\n \n-        int32_t interval = config::base_compaction_check_interval_seconds;\n+        interval = config::base_compaction_check_interval_seconds;", "originalCommit": "9413ab409579cd8c20f5c1831d242b31ecb3e153", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc5ODcyOQ==", "url": "https://github.com/apache/incubator-doris/pull/4440#discussion_r481798729", "bodyText": "Yes, I redundant assign it intentionally here, because base_compaction_check_interval_seconds is a mutable config, we can change it by http api dynamically (/api/update_config?config_name=new_value), it may be changed when do the next loop.", "author": "acelyc111", "createdAt": "2020-09-02T06:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc5MTk4MA=="}], "type": "inlineReview"}, {"oid": "2f878abbf846b9359086b6a4315ce102087cad32", "url": "https://github.com/apache/incubator-doris/commit/2f878abbf846b9359086b6a4315ce102087cad32", "message": "fix redundant assignment", "committedDate": "2020-09-02T06:51:56Z", "type": "commit"}]}