{"pr_number": 4115, "pr_title": "[metrics] Redesign metrics to 3 layers", "pr_createdAt": "2020-07-18T15:03:57Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4115", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NjkyMA==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r459496920", "bodyText": "Use 4 space instead of tab", "author": "morningman", "createdAt": "2020-07-23T14:34:52Z", "path": "be/src/util/doris_metrics.h", "diffHunk": "@@ -28,163 +28,152 @@\n \n namespace doris {\n \n-class IntGaugeMetricsMap {\n-public:\n-    void set_metric(const std::string& key, int64_t val) {\n-        auto metric = metrics.find(key);\n-        if (metric != metrics.end()) {\n-            metric->second->set_value(val);\n-        }\n-    }\n-\n-    IntGauge* add_metric(const std::string& key, const MetricUnit unit) {\n-        metrics.emplace(key, new IntGauge(unit));\n-        return metrics.find(key)->second.get();\n-    }\n-\n-private:\n-    std::unordered_map<std::string, std::unique_ptr<IntGauge>> metrics;\n-};\n-\n-#define REGISTER_GAUGE_DORIS_METRIC(name, func) \\\n-  DorisMetrics::instance()->metrics()->register_metric(#name, &DorisMetrics::instance()->name); \\\n-  DorisMetrics::instance()->metrics()->register_hook(#name, [&]() { \\\n+#define REGISTER_HOOK_METRIC(name, func) \\\n+  DorisMetrics::instance()->server_entity()->register_metric(&METRIC_##name, &DorisMetrics::instance()->name); \\\n+  DorisMetrics::instance()->server_entity()->register_hook(#name, [&]() { \\\n       DorisMetrics::instance()->name.set_value(func());  \\\n });\n \n+#define DEREGISTER_HOOK_METRIC(name) \\\n+  DorisMetrics::instance()->server_entity()->deregister_metric(&METRIC_##name); \\\n+  DorisMetrics::instance()->server_entity()->deregister_hook(#name);\n+\n class DorisMetrics {\n public:\n-    // counters\n-    METRIC_DEFINE_INT_COUNTER(fragment_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(fragment_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(http_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(http_request_send_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_success_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_fail_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(drop_tablet_requests_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(storage_migrate_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_bytes_total, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_bytes_total, MetricUnit::BYTES);\n-\n-    METRIC_DEFINE_INT_COUNTER(publish_task_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(publish_task_failed_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_duration_us, MetricUnit::MICROSECONDS);\n+    //METRIC_DEFINE_INT_COUNTER(load_rows_total, MetricUnit::ROWS);\n+    //METRIC_DEFINE_INT_COUNTER(load_bytes_total, MetricUnit::BYTES);\n+\n+    //IntGaugeMetricsMap disks_total_capacity;\n+    //IntGaugeMetricsMap disks_avail_capacity;\n+    //IntGaugeMetricsMap disks_data_used_capacity;\n+    //IntGaugeMetricsMap disks_state;\n+\n+    IntCounter fragment_requests_total;\n+\tIntCounter fragment_request_duration_us;", "originalCommit": "6408d940d09614e6351f9eb3fcec1b775392c679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5NzAyOA==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r459497028", "bodyText": "Remove the unused code", "author": "morningman", "createdAt": "2020-07-23T14:34:59Z", "path": "be/src/util/doris_metrics.h", "diffHunk": "@@ -28,163 +28,152 @@\n \n namespace doris {\n \n-class IntGaugeMetricsMap {\n-public:\n-    void set_metric(const std::string& key, int64_t val) {\n-        auto metric = metrics.find(key);\n-        if (metric != metrics.end()) {\n-            metric->second->set_value(val);\n-        }\n-    }\n-\n-    IntGauge* add_metric(const std::string& key, const MetricUnit unit) {\n-        metrics.emplace(key, new IntGauge(unit));\n-        return metrics.find(key)->second.get();\n-    }\n-\n-private:\n-    std::unordered_map<std::string, std::unique_ptr<IntGauge>> metrics;\n-};\n-\n-#define REGISTER_GAUGE_DORIS_METRIC(name, func) \\\n-  DorisMetrics::instance()->metrics()->register_metric(#name, &DorisMetrics::instance()->name); \\\n-  DorisMetrics::instance()->metrics()->register_hook(#name, [&]() { \\\n+#define REGISTER_HOOK_METRIC(name, func) \\\n+  DorisMetrics::instance()->server_entity()->register_metric(&METRIC_##name, &DorisMetrics::instance()->name); \\\n+  DorisMetrics::instance()->server_entity()->register_hook(#name, [&]() { \\\n       DorisMetrics::instance()->name.set_value(func());  \\\n });\n \n+#define DEREGISTER_HOOK_METRIC(name) \\\n+  DorisMetrics::instance()->server_entity()->deregister_metric(&METRIC_##name); \\\n+  DorisMetrics::instance()->server_entity()->deregister_hook(#name);\n+\n class DorisMetrics {\n public:\n-    // counters\n-    METRIC_DEFINE_INT_COUNTER(fragment_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(fragment_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(http_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(http_request_send_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(query_scan_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_success_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_requests_fail_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_bytes, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(push_request_write_rows, MetricUnit::ROWS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(drop_tablet_requests_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_all_tablets_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_tablet_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_disk_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(report_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(schema_change_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(create_rollup_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(storage_migrate_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(delete_requests_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(clone_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(finish_task_requests_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_request_failed, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_request_failed, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(base_compaction_bytes_total, MetricUnit::BYTES);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_deltas_total, MetricUnit::ROWSETS);\n-    METRIC_DEFINE_INT_COUNTER(cumulative_compaction_bytes_total, MetricUnit::BYTES);\n-\n-    METRIC_DEFINE_INT_COUNTER(publish_task_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(publish_task_failed_total, MetricUnit::REQUESTS);\n-\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_write_request_duration_us, MetricUnit::MICROSECONDS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_total, MetricUnit::REQUESTS);\n-    METRIC_DEFINE_INT_COUNTER(meta_read_request_duration_us, MetricUnit::MICROSECONDS);\n+    //METRIC_DEFINE_INT_COUNTER(load_rows_total, MetricUnit::ROWS);\n+    //METRIC_DEFINE_INT_COUNTER(load_bytes_total, MetricUnit::BYTES);\n+\n+    //IntGaugeMetricsMap disks_total_capacity;", "originalCommit": "6408d940d09614e6351f9eb3fcec1b775392c679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1ee00bd5f87832b71b61d82a569d0fb48bc80fea", "url": "https://github.com/apache/incubator-doris/commit/1ee00bd5f87832b71b61d82a569d0fb48bc80fea", "message": "[metrics] Redesign metrics to 3 layers\n\nRedesign metrics to 3 layers:\nMetricRegistry - MetricEntity - Metrics\nMetricRegistry: the register center\nMetricEntity: the enity registered on MetricRegistry. Generally a MetricRegistry\ncan be registered on serveral MetricEntities, each of MetricEntity is an\nindependent entity, such as server, disk_devices, data_directories,\nthrift clients and servers, and so on.\nMetric: metrics of an entity. Such as fragment_requests_total on server\nentity, disk_bytes_read on a disk_device entity, thrift_opened_clients\non a thrift_client entity.\nMetricPrototype: the type of a metric. MetricPrototype is a global\nvariable, can be shared by the same metrics across different\nMetricEntities.\n\nThe output of /metrics interface also keep compatiable with old versions.", "committedDate": "2020-07-27T08:21:52Z", "type": "forcePushed"}, {"oid": "c30137953e6b61d7308acebab4f9aabee67a6f79", "url": "https://github.com/apache/incubator-doris/commit/c30137953e6b61d7308acebab4f9aabee67a6f79", "message": "[metrics] Redesign metrics to 3 layers\n\nRedesign metrics to 3 layers:\nMetricRegistry - MetricEntity - Metrics\nMetricRegistry: the register center\nMetricEntity: the enity registered on MetricRegistry. Generally a MetricRegistry\ncan be registered on serveral MetricEntities, each of MetricEntity is an\nindependent entity, such as server, disk_devices, data_directories,\nthrift clients and servers, and so on.\nMetric: metrics of an entity. Such as fragment_requests_total on server\nentity, disk_bytes_read on a disk_device entity, thrift_opened_clients\non a thrift_client entity.\nMetricPrototype: the type of a metric. MetricPrototype is a global\nvariable, can be shared by the same metrics across different\nMetricEntities.\n\nThe output of /metrics interface also keep compatiable with old versions.", "committedDate": "2020-07-27T08:39:41Z", "type": "forcePushed"}, {"oid": "6d0da8c1e1b9041c3c9dfe8e2214921a4dd2328f", "url": "https://github.com/apache/incubator-doris/commit/6d0da8c1e1b9041c3c9dfe8e2214921a4dd2328f", "message": "[metrics] Redesign metrics to 3 layers\n\nRedesign metrics to 3 layers:\nMetricRegistry - MetricEntity - Metrics\nMetricRegistry: the register center\nMetricEntity: the enity registered on MetricRegistry. Generally a MetricRegistry\ncan be registered on serveral MetricEntities, each of MetricEntity is an\nindependent entity, such as server, disk_devices, data_directories,\nthrift clients and servers, and so on.\nMetric: metrics of an entity. Such as fragment_requests_total on server\nentity, disk_bytes_read on a disk_device entity, thrift_opened_clients\non a thrift_client entity.\nMetricPrototype: the type of a metric. MetricPrototype is a global\nvariable, can be shared by the same metrics across different\nMetricEntities.\n\nThe output of /metrics interface also keep compatiable with old versions.", "committedDate": "2020-07-28T16:26:13Z", "type": "forcePushed"}, {"oid": "26cf5b213c006da9aeb3ccf9acfc568ad470d5d9", "url": "https://github.com/apache/incubator-doris/commit/26cf5b213c006da9aeb3ccf9acfc568ad470d5d9", "message": "gauge counter", "committedDate": "2020-08-01T02:25:24Z", "type": "forcePushed"}, {"oid": "629574b90721433f09acf7eec54136021666aef4", "url": "https://github.com/apache/incubator-doris/commit/629574b90721433f09acf7eec54136021666aef4", "message": "[metrics] Redesign metrics to 3 layers\n\nRedesign metrics to 3 layers:\nMetricRegistry - MetricEntity - Metrics\nMetricRegistry: the register center\nMetricEntity: the enity registered on MetricRegistry. Generally a MetricRegistry\ncan be registered on serveral MetricEntities, each of MetricEntity is an\nindependent entity, such as server, disk_devices, data_directories,\nthrift clients and servers, and so on.\nMetric: metrics of an entity. Such as fragment_requests_total on server\nentity, disk_bytes_read on a disk_device entity, thrift_opened_clients\non a thrift_client entity.\nMetricPrototype: the type of a metric. MetricPrototype is a global\nvariable, can be shared by the same metrics across different\nMetricEntities.\n\nThe output of /metrics interface also keep compatiable with old versions.", "committedDate": "2020-08-06T14:36:47Z", "type": "commit"}, {"oid": "ba12868e86f10e613896356237bc1c8a1641faf1", "url": "https://github.com/apache/incubator-doris/commit/ba12868e86f10e613896356237bc1c8a1641faf1", "message": "force", "committedDate": "2020-08-06T14:36:47Z", "type": "commit"}, {"oid": "5463cc3e194faa45b161ad1674af82ef37a48075", "url": "https://github.com/apache/incubator-doris/commit/5463cc3e194faa45b161ad1674af82ef37a48075", "message": "gauge counter", "committedDate": "2020-08-06T14:36:47Z", "type": "commit"}, {"oid": "be5c8fff631d0dc83eefa442a3c7c55a79e7d20c", "url": "https://github.com/apache/incubator-doris/commit/be5c8fff631d0dc83eefa442a3c7c55a79e7d20c", "message": "update", "committedDate": "2020-08-06T14:36:47Z", "type": "commit"}, {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c", "url": "https://github.com/apache/incubator-doris/commit/b9d906ec5fadbcfea164828e86b8028a67e9b38c", "message": "update", "committedDate": "2020-08-06T14:36:47Z", "type": "commit"}, {"oid": "b9d906ec5fadbcfea164828e86b8028a67e9b38c", "url": "https://github.com/apache/incubator-doris/commit/b9d906ec5fadbcfea164828e86b8028a67e9b38c", "message": "update", "committedDate": "2020-08-06T14:36:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTMxOQ==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895319", "bodyText": "may be used DEFINE_METRIC_PROTOTYPE better", "author": "chaoyli", "createdAt": "2020-08-07T08:21:30Z", "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {\n+public:\n+    MetricPrototype(MetricType type_,\n+                    MetricUnit unit_,\n+                    std::string name_,\n+                    std::string description_ = \"\",\n+                    std::string group_name_ = \"\",\n+                    Labels labels_ = Labels(),\n+                    bool is_core_metric_ = false)\n+        : is_core_metric(is_core_metric_),\n+          type(type_),\n+          unit(unit_),\n+          name(std::move(name_)),\n+          description(std::move(description_)),\n+          group_name(std::move(group_name_)),\n+          labels(std::move(labels_)) {}\n+\n+    std::string simple_name() const;\n+    std::string combine_name(const std::string& registry_name) const;\n+\n+    bool is_core_metric;\n+    MetricType type;\n+    MetricUnit unit;\n     std::string name;\n-    std::string value;\n+    std::string description;\n+    std::string group_name;\n+    Labels labels;\n+};\n \n-    MetricLabel() { }\n-    MetricLabel(const std::string& name_, const std::string& value_) :name(name_), value(value_) {\n-    }\n+#define DEFINE_METRIC(name, type, unit, desc, group, labels, core)      \\", "originalCommit": "b9d906ec5fadbcfea164828e86b8028a67e9b38c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTY0MA==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895640", "bodyText": "What's the purpose of MetricPrototype?\nUnder which circumstance, MetricPrototype can be used to split the Metric.", "author": "chaoyli", "createdAt": "2020-08-07T08:22:06Z", "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {", "originalCommit": "b9d906ec5fadbcfea164828e86b8028a67e9b38c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTgxMA==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466895810", "bodyText": "MetricMap is better name or not?", "author": "chaoyli", "createdAt": "2020-08-07T08:22:29Z", "path": "be/src/util/metrics.h", "diffHunk": "@@ -193,230 +174,163 @@ class CoreLocalCounter : public Metric {\n     void increment(const T& delta) {\n         __sync_fetch_and_add(_value.access(), delta);\n     }\n+\n+    rj::Value to_json_value() const override {\n+        return rj::Value(value());\n+    }\n+\n protected:\n     CoreLocalValue<T> _value;\n };\n \n template<typename T>\n class AtomicCounter : public AtomicMetric<T> {\n public:\n-    AtomicCounter(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~AtomicCounter() { }\n+    AtomicCounter() {}\n+    virtual ~AtomicCounter() {}\n };\n \n template<typename T>\n class AtomicGauge : public AtomicMetric<T> {\n public:\n-    AtomicGauge(MetricUnit unit)\n-            : AtomicMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~AtomicGauge() { }\n+    AtomicGauge() : AtomicMetric<T>() {}\n+    virtual ~AtomicGauge() {}\n };\n \n template<typename T>\n class LockCounter : public LockSimpleMetric<T> {\n public:\n-    LockCounter(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::COUNTER, unit) {}\n-    virtual ~LockCounter() { }\n+    LockCounter() : LockSimpleMetric<T>() {}\n+    virtual ~LockCounter() {}\n };\n \n // This can only used for trival type\n template<typename T>\n class LockGauge : public LockSimpleMetric<T> {\n public:\n-    LockGauge(MetricUnit unit)\n-      : LockSimpleMetric<T>(MetricType::GAUGE, unit) {}\n-    virtual ~LockGauge() { }\n+    LockGauge() : LockSimpleMetric<T>() {}\n+    virtual ~LockGauge() {}\n };\n \n-// one key-value pair used to\n-struct MetricLabel {\n+using Labels = std::unordered_map<std::string, std::string>;\n+struct MetricPrototype {\n+public:\n+    MetricPrototype(MetricType type_,\n+                    MetricUnit unit_,\n+                    std::string name_,\n+                    std::string description_ = \"\",\n+                    std::string group_name_ = \"\",\n+                    Labels labels_ = Labels(),\n+                    bool is_core_metric_ = false)\n+        : is_core_metric(is_core_metric_),\n+          type(type_),\n+          unit(unit_),\n+          name(std::move(name_)),\n+          description(std::move(description_)),\n+          group_name(std::move(group_name_)),\n+          labels(std::move(labels_)) {}\n+\n+    std::string simple_name() const;\n+    std::string combine_name(const std::string& registry_name) const;\n+\n+    bool is_core_metric;\n+    MetricType type;\n+    MetricUnit unit;\n     std::string name;\n-    std::string value;\n+    std::string description;\n+    std::string group_name;\n+    Labels labels;\n+};\n \n-    MetricLabel() { }\n-    MetricLabel(const std::string& name_, const std::string& value_) :name(name_), value(value_) {\n-    }\n+#define DEFINE_METRIC(name, type, unit, desc, group, labels, core)      \\\n+    ::doris::MetricPrototype METRIC_##name(type, unit, #name, desc, group, labels, core)\n \n-    bool operator==(const MetricLabel& other) const {\n-        return name == other.name && value == other.value;\n-    }\n-    bool operator!=(const MetricLabel& other) const {\n-        return !(*this == other);\n-    }\n-    bool operator<(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value < other.value;\n-        }\n-        return res < 0;\n-    }\n-    int compare(const MetricLabel& other) const {\n-        auto res = name.compare(other.name);\n-        if (res == 0) {\n-            return value.compare(other.value);\n-        }\n-        return res;\n-    }\n-    std::string to_string() const {\n-        return name + \"=\" + value;\n-    }\n-};\n+#define DEFINE_COUNTER_METRIC_2ARG(name, unit)                          \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, \"\", \"\", Labels(), false)\n \n-struct MetricLabels {\n-    static MetricLabels EmptyLabels;\n-    // used std::set to sort MetricLabel so that we can get compare two MetricLabels\n-    std::set<MetricLabel> labels;\n+#define DEFINE_COUNTER_METRIC_3ARG(name, unit, desc)                    \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, \"\", Labels(), false)\n \n-    MetricLabels& add(const std::string& name, const std::string& value) {\n-        labels.emplace(name, value);\n-        return *this;\n-    }\n+#define DEFINE_COUNTER_METRIC_5ARG(name, unit, desc, group, labels)     \\\n+    DEFINE_METRIC(name, MetricType::COUNTER, unit, desc, #group, labels, false)\n \n-    bool operator==(const MetricLabels& other) const {\n-        if (labels.size() != other.labels.size()) {\n-            return false;\n-        }\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end()) {\n-            if (*it != *other_it) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        return true;\n-    }\n-    bool operator<(const MetricLabels& other) const {\n-        auto it = labels.begin();\n-        auto other_it = other.labels.begin();\n-        while (it != labels.end() && other_it != other.labels.end()) {\n-            auto res = it->compare(*other_it);\n-            if (res < 0) {\n-                return true;\n-            } else if (res > 0) {\n-                return false;\n-            }\n-            ++it;\n-            ++other_it;\n-        }\n-        if (it == labels.end()) {\n-            if (other_it == other.labels.end()) {\n-                return false;\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-    bool empty() const {\n-        return labels.empty();\n+#define DEFINE_GAUGE_METRIC_2ARG(name, unit)                            \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), false)\n+\n+#define DEFINE_CORE_GAUGE_METRIC_2ARG(name, unit)                       \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, \"\", \"\", Labels(), true)\n+\n+#define DEFINE_GAUGE_METRIC_3ARG(name, unit, desc)                      \\\n+    DEFINE_METRIC(name, MetricType::GAUGE, unit, desc, \"\", Labels(), false)\n+\n+#define METRIC_REGISTER(entity, metric)                                 \\\n+    entity->register_metric(&METRIC_##metric, &metric)\n+\n+#define METRIC_DEREGISTER(entity, metric)                               \\\n+    entity->deregister_metric(&METRIC_##metric)\n+\n+// For 'metrics' in MetricEntity.\n+struct MetricPrototypeHash {\n+    size_t operator()(const MetricPrototype* metric_prototype) const {\n+        return std::hash<std::string>()(metric_prototype->group_name.empty() ? metric_prototype->name : metric_prototype->group_name);\n     }\n+};\n \n-    std::string to_string() const {\n-        std::stringstream ss;\n-        int i = 0;\n-        for (auto& label : labels) {\n-            if (i++ > 0) {\n-                ss << \",\";\n-            }\n-            ss << label.to_string();\n-        }\n-        return ss.str();\n+struct MetricPrototypeEqualTo {\n+    bool operator()(const MetricPrototype* first, const MetricPrototype* second) const {\n+        return first->group_name == second->group_name && first->name == second->name;\n     }\n };\n \n-class MetricCollector;\n+using MetricByType = std::unordered_map<const MetricPrototype*, Metric*, MetricPrototypeHash, MetricPrototypeEqualTo>;", "originalCommit": "b9d906ec5fadbcfea164828e86b8028a67e9b38c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNzg0Nw==", "url": "https://github.com/apache/incubator-doris/pull/4115#discussion_r466937847", "bodyText": "MetricMap would be better", "author": "acelyc111", "createdAt": "2020-08-07T09:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NTgxMA=="}], "type": "inlineReview"}, {"oid": "9c540096f5893b5dea331b096d86dc0aa7c3995d", "url": "https://github.com/apache/incubator-doris/commit/9c540096f5893b5dea331b096d86dc0aa7c3995d", "message": "DEFINE_METRIC -> DEFINE_METRIC_PROTOTYPE", "committedDate": "2020-08-07T09:44:21Z", "type": "commit"}, {"oid": "fa27a6386759189c7800a05475966dd6f8fa3908", "url": "https://github.com/apache/incubator-doris/commit/fa27a6386759189c7800a05475966dd6f8fa3908", "message": "MetricByType -> MetricMap", "committedDate": "2020-08-07T09:46:00Z", "type": "commit"}]}