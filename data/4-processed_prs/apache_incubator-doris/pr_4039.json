{"pr_number": 4039, "pr_title": "Add delayed deletion of rowsets function, fix -230 error.", "pr_createdAt": "2020-07-07T08:51:52Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4039", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMDc5NA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450710794", "bodyText": "It is better to add unit to your config item", "author": "wuyunfeng", "createdAt": "2020-07-07T08:53:47Z", "path": "be/src/common/config.h", "diffHunk": "@@ -230,6 +230,8 @@ namespace config {\n     CONF_mInt32(pending_data_expire_time_sec, \"1800\");\n     // inc_rowset expired interval\n     CONF_mInt32(inc_rowset_expired_sec, \"1800\");\n+    // inc_rowset snapshot rs sweep time interval\n+    CONF_mInt32(tablet_rowset_expired_snapshot_sweep_time, \"1800\");", "originalCommit": "0f8d14d72bd50a55275dabdaff309a14cb560efc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMTQwNg==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450711406", "bodyText": "merge this two comment into one line maybe better", "author": "wuyunfeng", "createdAt": "2020-07-07T08:54:51Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,247 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowsetGraph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // fill main_path\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path\n+            //   begin from min_begin_version", "originalCommit": "0f8d14d72bd50a55275dabdaff309a14cb560efc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMTUzMA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450711530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //   tracker the first\n          \n          \n            \n                        // tracker the first", "author": "wuyunfeng", "createdAt": "2020-07-07T08:55:03Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,247 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowsetGraph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // fill main_path\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path\n+            //   begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            //   tracker the first", "originalCommit": "0f8d14d72bd50a55275dabdaff309a14cb560efc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcxMjU0OA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450712548", "bodyText": "66 - 67 has nonstandard format", "author": "wuyunfeng", "createdAt": "2020-07-07T08:56:42Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -61,7 +61,10 @@ Tablet::Tablet(TabletMetaSharedPtr tablet_meta, DataDir* data_dir) :\n         _last_cumu_compaction_success_millis(0),\n         _last_base_compaction_success_millis(0),\n         _cumulative_point(kInvalidCumulativePoint) {\n-    _rs_graph.construct_rowset_graph(_tablet_meta->all_rs_metas());\n+    // change _rs_graph to _versioned_rs_tracker\n+    // _rs_graph.construct_rowset_graph(_tablet_meta->all_rs_metas());\n+    _versioned_rs_tracker.construct_versioned_tracker(_tablet_meta->all_rs_metas(),", "originalCommit": "0f8d14d72bd50a55275dabdaff309a14cb560efc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyNzUyMg==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450727522", "bodyText": "_next_path_version", "author": "xy720", "createdAt": "2020-07-07T09:22:12Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +50,86 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+class VersionTracker {\n+public:\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    Version version() const { return _version; }\n+\n+    int64_t get_create_time() { return _create_time; }\n+\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;\n+    }\n+\n+private:\n+    Version _version;\n+    int64_t _create_time;\n+};\n+\n+using VersionTrackerSharedPtr = std::shared_ptr<VersionTracker>;\n+using PathVersionListSharedPtr = std::shared_ptr<std::vector<VersionTrackerSharedPtr>>;\n+\n+class VersionedRowsetTracker {\n+public:\n+    // Construct rowsets version tracker with expired snapshot rowsets\n+    void construct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    // Reconstruct rowsets version tracker with expired snapshot rowsets\n+    void reconstruct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    // Add a version\n+    void add_version(const Version& version);\n+\n+    // Add a version path with expired_snapshot_rs_metas\n+    void add_expired_path_version(\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    // Capture consistent versions from graph\n+    OLAPStatus capture_consistent_versions(const Version& spec_version,\n+                                           std::vector<Version>* version_path) const;\n+\n+    // Capture all expired path version.\n+    // When the last rowset createtime of a path greater than expired time  which can be expressed\n+    // \"now() - tablet_rowset_expired_snapshot_sweep_time\" , this path will be remained.\n+    // Otherwise, this path will be added to versions.\n+    void capture_expired_path_version(int64_t expired_snapshot_sweep_endtime,\n+                                      std::vector<int64_t>* path_version) const;\n+\n+    void fetch_path_version(int64_t path_version, std::vector<Version>& version_path);\n+\n+    void fetch_and_delete_path_version(int64_t path_version, std::vector<Version>& version_path);\n+\n+    void _print_current_state();\n+\n+private:\n+    // construct rowsets version tracker with expired snapshot rowsets\n+    void _construct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+private:\n+    int64_t next_path_version = 1;", "originalCommit": "0f8d14d72bd50a55275dabdaff309a14cb560efc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "url": "https://github.com/apache/incubator-doris/commit/5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "message": "merged rowset version delay unused, fix -230 error", "committedDate": "2020-07-07T11:56:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3Mzg0Nw==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450873847", "bodyText": "Remove the code if not use", "author": "morningman", "createdAt": "2020-07-07T13:42:46Z", "path": "be/src/olap/base_compaction.cpp", "diffHunk": "@@ -56,9 +56,10 @@ OLAPStatus BaseCompaction::compact() {\n     DorisMetrics::instance()->base_compaction_bytes_total.increment(_input_rowsets_size);\n     TRACE(\"save base compaction metrics\");\n \n+    // delay garbage operation \n     // 5. garbage collect input rowsets after base compaction \n-    RETURN_NOT_OK(gc_unused_rowsets());\n-    TRACE(\"unused rowsets have been moved to GC queue\");\n+    // RETURN_NOT_OK(gc_unused_rowsets());", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3NDA4NA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450874084", "bodyText": "Remove it", "author": "morningman", "createdAt": "2020-07-07T13:43:05Z", "path": "be/src/olap/cumulative_compaction.cpp", "diffHunk": "@@ -65,9 +65,10 @@ OLAPStatus CumulativeCompaction::compact() {\n     DorisMetrics::instance()->cumulative_compaction_bytes_total.increment(_input_rowsets_size);\n     TRACE(\"save cumulative compaction metrics\");\n \n+    // delay garbage operation\n     // 7. garbage collect input rowsets after cumulative compaction \n-    RETURN_NOT_OK(gc_unused_rowsets());\n-    TRACE(\"unused rowsets have been moved to GC queue\");\n+    // RETURN_NOT_OK(gc_unused_rowsets());\n+    // TRACE(\"unused rowsets have been moved to GC queue\");", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3NTY3Mg==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450875672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     int64_t& max_version) {\n          \n          \n            \n                                                     int64_t* max_version) {\n          \n      \n    \n    \n  \n\nBetter to use point to indicate it is a output parameter.", "author": "morningman", "createdAt": "2020-07-07T13:45:27Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,243 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowset_graph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // version -> rowsetmeta\n+    // fill main_path which are included not merged rowsets\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path which are included merged rowsets\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path, begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            // tracker the first\n+            VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                    Version(min_begin_version, min_end_version), min_rs_meta->creation_time()));\n+            path_version_ptr->push_back(tracker_ptr);\n+            // 1.1 do loop, find next start to make a path\n+            auto tmp_start_version = min_end_version + 1;\n+            do {\n+                int64_t tmp_end_version = -1;\n+                int64_t create_time = -1;\n+                // 1.2 the next must in other_path, find from other_path\n+                auto tmp_edge_iter = other_path.find(tmp_start_version);\n+                if (tmp_edge_iter == other_path.end() || tmp_edge_iter->second->empty()) {\n+                    break;\n+                }\n+                // 1.3 record this version to make a tracker, put into path_version\n+                auto next_rs_meta_iter = tmp_edge_iter->second->begin();\n+                tmp_end_version = next_rs_meta_iter->first;\n+                create_time = next_rs_meta_iter->second->creation_time();\n+                VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                        Version(tmp_start_version, tmp_end_version), create_time));\n+                path_version_ptr->push_back(tracker_ptr);\n+                // 1.4 judge if this path finish\n+                auto max_end_version = tmp_end_version;\n+                // find from other_path\n+                if (edges->find(max_end_version) != edges->end()) {\n+                    break;\n+                }\n+                // find from main_path\n+                if (main_path.find(Version(min_begin_version, max_end_version)) !=\n+                    main_path.end()) {\n+                    break;\n+                }\n+                // 1.5 do next\n+                tmp_start_version = tmp_end_version + 1;\n+\n+            } while (true);\n+            // 1.6 add path_version to map\n+            _expired_snapshot_rs_path_map[_next_path_version++] = path_version_ptr;\n+\n+            // 2 remove this path from other_path\n+            auto path_iter = path_version_ptr->begin();\n+            for (; path_iter != path_version_ptr->end(); path_iter++) {\n+                Version version = (*path_iter)->version();\n+                other_path[version.first]->erase(version.second);\n+            }\n+        }\n+    }\n+    other_path.clear();\n+    main_path.clear();\n+    _print_current_state();\n+}\n+\n+void VersionedRowsetTracker::construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::reconstruct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+    _expired_snapshot_rs_path_map.clear();\n+    _next_path_version = 1;\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::add_version(const Version& version) {\n+    _rowset_graph.add_version_to_graph(version);\n+}\n+\n+void VersionedRowsetTracker::add_expired_path_version(\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (expired_snapshot_rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the expired_snapshot_rs_metas.\";\n+        return;\n+    }\n+\n+    PathVersionListSharedPtr ptr(new std::vector<VersionTrackerSharedPtr>());\n+    for (auto rs : expired_snapshot_rs_metas) {\n+        VersionTrackerSharedPtr vt_ptr(new VersionTracker(rs->version(), rs->creation_time()));\n+        ptr->push_back(vt_ptr);\n+    }\n+    sort(ptr->begin(), ptr->end());\n+    _expired_snapshot_rs_path_map[_next_path_version] = ptr;\n+    _next_path_version++;\n+}\n+\n+// Capture consistent versions from graph\n+OLAPStatus VersionedRowsetTracker::capture_consistent_versions(\n+        const Version& spec_version, std::vector<Version>* version_path) const {\n+    return _rowset_graph.capture_consistent_versions(spec_version, version_path);\n+}\n+\n+void VersionedRowsetTracker::capture_expired_path_version(\n+        int64_t expired_snapshot_sweep_endtime, std::vector<int64_t>* path_version_vec) const {\n+    std::unordered_map<int64_t, PathVersionListSharedPtr>::const_iterator iter =\n+            _expired_snapshot_rs_path_map.begin();\n+\n+    while (iter != _expired_snapshot_rs_path_map.end()) {\n+        std::vector<VersionTrackerSharedPtr>::iterator version_path_iter = iter->second->begin();\n+        int64_t max_create_time = -1;\n+        while (version_path_iter != iter->second->end()) {\n+            if (max_create_time < (*version_path_iter)->get_create_time()) {\n+                max_create_time = (*version_path_iter)->get_create_time();\n+            }\n+\n+            version_path_iter++;\n+        }\n+        if (max_create_time <= expired_snapshot_sweep_endtime) {\n+            int64_t path_version = iter->first;\n+            path_version_vec->push_back(path_version);\n+        }\n+        iter++;\n+    }\n+}\n+\n+void VersionedRowsetTracker::fetch_path_version(int64_t path_version,\n+                                                std::vector<Version>& version_path) {\n+    if (_expired_snapshot_rs_path_map.count(path_version) == 0) {\n+        VLOG(3) << \"path version \" << path_version << \" does not exist!\";\n+        return;\n+    }\n+\n+    PathVersionListSharedPtr ptr = _expired_snapshot_rs_path_map[path_version];\n+\n+    std::vector<VersionTrackerSharedPtr>::iterator iter = ptr->begin();\n+    while (iter != ptr->end()) {\n+        version_path.push_back((*iter)->version());\n+        iter++;\n+    }\n+}\n+\n+void VersionedRowsetTracker::fetch_and_delete_path_version(int64_t path_version,\n+                                                           std::vector<Version>& version_path) {\n+    if (_expired_snapshot_rs_path_map.count(path_version) == 0) {\n+        VLOG(3) << \"path version \" << path_version << \" does not exist!\";\n+        return;\n+    }\n+\n+    _print_current_state();\n+    fetch_path_version(path_version, version_path);\n+\n+    _expired_snapshot_rs_path_map.erase(path_version);\n+\n+    for (auto& version : version_path) {\n+        _rowset_graph.delete_version_from_graph(version);\n+    }\n+}\n+\n+void VersionedRowsetTracker::_print_current_state() {\n+    LOG(INFO) << \"current expired next_path_version \" << _next_path_version;\n+\n+    std::unordered_map<int64_t, PathVersionListSharedPtr>::const_iterator iter =\n+            _expired_snapshot_rs_path_map.begin();\n+    while (iter != _expired_snapshot_rs_path_map.end()) {\n+        std::stringstream tracker_info;\n+        tracker_info << \"current expired path_version \" << iter->first;\n+\n+        std::vector<VersionTrackerSharedPtr>::iterator version_path_iter = iter->second->begin();\n+        int64_t max_create_time = -1;\n+        while (version_path_iter != iter->second->end()) {\n+            if (max_create_time < (*version_path_iter)->get_create_time()) {\n+                max_create_time = (*version_path_iter)->get_create_time();\n+            }\n+            tracker_info << \" -> [\";\n+            tracker_info << (*version_path_iter)->version().first;\n+            tracker_info << \",\";\n+            tracker_info << (*version_path_iter)->version().second;\n+            tracker_info << \"]\";\n+\n+            version_path_iter++;\n+        }\n+        LOG(INFO) << tracker_info.str();\n+\n+        iter++;\n+    }\n+}\n+\n+void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+                                         int64_t& max_version) {", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3OTA5NQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450879095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /// and a link is the _version object of a rowset (from start version to end version).\n          \n          \n            \n            /// and a link is the _version object of a rowset (from start version to end version + 1).", "author": "morningman", "createdAt": "2020-07-07T13:50:08Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -23,16 +23,32 @@\n #include \"olap/rowset/rowset_meta.h\"\n \n namespace doris {\n-\n+/// RowsetGraph class which is implemented to build and maintain total versions of rowsets. \n+/// This class use adjacency-matrix represent rowsets version and links. A vertex is a version \n+/// and a link is the _version object of a rowset (from start version to end version).", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4MTI3Ng==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450881276", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n          \n          \n            \n            /// VersionTracker class which is implemented to maintain multi-version path of rowsets.", "author": "morningman", "createdAt": "2020-07-07T13:52:59Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. ", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4MjAxMA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450882010", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                VersionTracker(Version version, int64_t create_time)\n          \n          \n            \n                VersionTracker(const Version& version, int64_t create_time)", "author": "morningman", "createdAt": "2020-07-07T13:54:00Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4MzkzNA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450883934", "bodyText": "How about name it to TimestampedVersion ?\nTracker sounds like it needs to have a certain function, and this class is actually just adding a time stamp to the version.", "author": "morningman", "createdAt": "2020-07-07T13:56:36Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4NTk2OA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450885968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return _version.first != rhs._version.first || _version.second != rhs._version.second;\n          \n          \n            \n                    return _version != rhs._version;", "author": "morningman", "createdAt": "2020-07-07T13:59:20Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4NjExOQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450886119", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return _version.first == rhs._version.first && _version.second == rhs._version.second;\n          \n          \n            \n                    return _version == rhs._version;", "author": "morningman", "createdAt": "2020-07-07T13:59:32Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4NjM1OQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450886359", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return _version.first <= other._version.first && _version.second >= other._version.second;\n          \n          \n            \n                    return _version.contains(rhs._version);", "author": "morningman", "createdAt": "2020-07-07T13:59:52Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    /// Judge if a tracker contains the other.\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MDA5NQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450890095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /// Otherwise, this path will be added to versions.\n          \n          \n            \n                /// Otherwise, this path will be added to path_version.", "author": "morningman", "createdAt": "2020-07-07T14:04:53Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    /// Judge if a tracker contains the other.\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;\n+    }\n+\n+private:\n+    Version _version;\n+    int64_t _create_time;\n+};\n+\n+using VersionTrackerSharedPtr = std::shared_ptr<VersionTracker>;\n+using PathVersionListSharedPtr = std::shared_ptr<std::vector<VersionTrackerSharedPtr>>;\n+\n+/// VersionedRowsetTracker class is responsible to track all rowsets version links of a tablet.\n+/// This class not only records the graph of all versions, but also records the paths which will be removed\n+/// after the path is expired.\n+class VersionedRowsetTracker {\n+public:\n+    /// Construct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void construct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Reconstruct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void reconstruct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Add a version to tracker, this version is a new version rowset, not merged rowset.\n+    void add_version(const Version& version);\n+\n+    /// Add a version path with expired_snapshot_rs_metas, this versions in version path\n+    /// are merged rowsets.  These rowsets are tracked and removed after they are expired.\n+    /// TabletManager sweep these rowsets using tracker by timing.\n+    void add_expired_path_version(\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Given a spec_version, this method can find a version path which is the shortest path\n+    /// in the graph. The version paths are added to version_path as return info.\n+    /// If this version not in main version, version_path can be included expired rowset.\n+    OLAPStatus capture_consistent_versions(const Version& spec_version,\n+                                           std::vector<Version>* version_path) const;\n+\n+    /// Capture all expired path version.\n+    /// When the last rowset createtime of a path greater than expired time  which can be expressed\n+    /// \"now() - tablet_rowset_expired_snapshot_sweep_time\" , this path will be remained.\n+    /// Otherwise, this path will be added to versions.", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MDMzOQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450890339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /// Fetch all versions in a path_version.\n          \n          \n            \n                /// Fetch all versions with a path_version.", "author": "morningman", "createdAt": "2020-07-07T14:05:13Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    /// Judge if a tracker contains the other.\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;\n+    }\n+\n+private:\n+    Version _version;\n+    int64_t _create_time;\n+};\n+\n+using VersionTrackerSharedPtr = std::shared_ptr<VersionTracker>;\n+using PathVersionListSharedPtr = std::shared_ptr<std::vector<VersionTrackerSharedPtr>>;\n+\n+/// VersionedRowsetTracker class is responsible to track all rowsets version links of a tablet.\n+/// This class not only records the graph of all versions, but also records the paths which will be removed\n+/// after the path is expired.\n+class VersionedRowsetTracker {\n+public:\n+    /// Construct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void construct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Reconstruct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void reconstruct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Add a version to tracker, this version is a new version rowset, not merged rowset.\n+    void add_version(const Version& version);\n+\n+    /// Add a version path with expired_snapshot_rs_metas, this versions in version path\n+    /// are merged rowsets.  These rowsets are tracked and removed after they are expired.\n+    /// TabletManager sweep these rowsets using tracker by timing.\n+    void add_expired_path_version(\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Given a spec_version, this method can find a version path which is the shortest path\n+    /// in the graph. The version paths are added to version_path as return info.\n+    /// If this version not in main version, version_path can be included expired rowset.\n+    OLAPStatus capture_consistent_versions(const Version& spec_version,\n+                                           std::vector<Version>* version_path) const;\n+\n+    /// Capture all expired path version.\n+    /// When the last rowset createtime of a path greater than expired time  which can be expressed\n+    /// \"now() - tablet_rowset_expired_snapshot_sweep_time\" , this path will be remained.\n+    /// Otherwise, this path will be added to versions.\n+    void capture_expired_path_version(int64_t expired_snapshot_sweep_endtime,\n+                                      std::vector<int64_t>* path_version) const;\n+\n+    /// Fetch all versions in a path_version.", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MDg1MQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450890851", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /// Fetch all versions in a path_version, as the same time remove this path from the tracker.\n          \n          \n            \n                /// Fetch all versions with a path_version, at the same time remove this path from the tracker.", "author": "morningman", "createdAt": "2020-07-07T14:05:55Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    /// Judge if a tracker contains the other.\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;\n+    }\n+\n+private:\n+    Version _version;\n+    int64_t _create_time;\n+};\n+\n+using VersionTrackerSharedPtr = std::shared_ptr<VersionTracker>;\n+using PathVersionListSharedPtr = std::shared_ptr<std::vector<VersionTrackerSharedPtr>>;\n+\n+/// VersionedRowsetTracker class is responsible to track all rowsets version links of a tablet.\n+/// This class not only records the graph of all versions, but also records the paths which will be removed\n+/// after the path is expired.\n+class VersionedRowsetTracker {\n+public:\n+    /// Construct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void construct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Reconstruct rowsets version tracker by rs_metas and expired snapshot rowsets.\n+    void reconstruct_versioned_tracker(\n+            const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Add a version to tracker, this version is a new version rowset, not merged rowset.\n+    void add_version(const Version& version);\n+\n+    /// Add a version path with expired_snapshot_rs_metas, this versions in version path\n+    /// are merged rowsets.  These rowsets are tracked and removed after they are expired.\n+    /// TabletManager sweep these rowsets using tracker by timing.\n+    void add_expired_path_version(\n+            const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas);\n+\n+    /// Given a spec_version, this method can find a version path which is the shortest path\n+    /// in the graph. The version paths are added to version_path as return info.\n+    /// If this version not in main version, version_path can be included expired rowset.\n+    OLAPStatus capture_consistent_versions(const Version& spec_version,\n+                                           std::vector<Version>* version_path) const;\n+\n+    /// Capture all expired path version.\n+    /// When the last rowset createtime of a path greater than expired time  which can be expressed\n+    /// \"now() - tablet_rowset_expired_snapshot_sweep_time\" , this path will be remained.\n+    /// Otherwise, this path will be added to versions.\n+    void capture_expired_path_version(int64_t expired_snapshot_sweep_endtime,\n+                                      std::vector<int64_t>* path_version) const;\n+\n+    /// Fetch all versions in a path_version.\n+    void fetch_path_version(int64_t path_version, std::vector<Version>& version_path);\n+\n+    /// Fetch all versions in a path_version, as the same time remove this path from the tracker.", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5NDUyMQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450894521", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            class VersionedRowsetTracker {\n          \n          \n            \n            class TimestampedVersionTracker {", "author": "morningman", "createdAt": "2020-07-07T14:10:55Z", "path": "be/src/olap/rowset_graph.h", "diffHunk": "@@ -47,6 +63,109 @@ class RowsetGraph {\n     std::unordered_map<int64_t, int64_t> _vertex_index_map;\n };\n \n-}  // namespace doris\n+/// VersionTracker class which is implemented to maintain compacted version path of rowsets. \n+/// This compaction info of a rowset includes start version, end version and the create time.\n+class VersionTracker {\n+public:\n+    /// VersionTracker construction function. Use rowset version and create time to build a VersionTracker.\n+    VersionTracker(Version version, int64_t create_time)\n+            : _version(version.first, version.second), _create_time(create_time) {}\n+\n+    ~VersionTracker() {}\n+\n+    /// Return the rowset version of VersionTracker record.\n+    Version version() const { return _version; }\n+    /// Return the rowset create_time of VersionTracker record.\n+    int64_t get_create_time() { return _create_time; }\n+\n+    /// Compare two version trackers.\n+    bool operator!=(const VersionTracker& rhs) const {\n+        return _version.first != rhs._version.first || _version.second != rhs._version.second;\n+    }\n+\n+    /// Compare two version trackers.\n+    bool operator==(const VersionTracker& rhs) const {\n+        return _version.first == rhs._version.first && _version.second == rhs._version.second;\n+    }\n+\n+    /// Judge if a tracker contains the other.\n+    bool contains(const VersionTracker& other) const {\n+        return _version.first <= other._version.first && _version.second >= other._version.second;\n+    }\n+\n+private:\n+    Version _version;\n+    int64_t _create_time;\n+};\n+\n+using VersionTrackerSharedPtr = std::shared_ptr<VersionTracker>;\n+using PathVersionListSharedPtr = std::shared_ptr<std::vector<VersionTrackerSharedPtr>>;\n+\n+/// VersionedRowsetTracker class is responsible to track all rowsets version links of a tablet.\n+/// This class not only records the graph of all versions, but also records the paths which will be removed\n+/// after the path is expired.\n+class VersionedRowsetTracker {", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMjgzMw==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450902833", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Version version = (*path_iter)->version();\n          \n          \n            \n                            const Version& version = (*path_iter)->version();", "author": "morningman", "createdAt": "2020-07-07T14:21:54Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,243 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowset_graph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // version -> rowsetmeta\n+    // fill main_path which are included not merged rowsets\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path which are included merged rowsets\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path, begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            // tracker the first\n+            VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                    Version(min_begin_version, min_end_version), min_rs_meta->creation_time()));\n+            path_version_ptr->push_back(tracker_ptr);\n+            // 1.1 do loop, find next start to make a path\n+            auto tmp_start_version = min_end_version + 1;\n+            do {\n+                int64_t tmp_end_version = -1;\n+                int64_t create_time = -1;\n+                // 1.2 the next must in other_path, find from other_path\n+                auto tmp_edge_iter = other_path.find(tmp_start_version);\n+                if (tmp_edge_iter == other_path.end() || tmp_edge_iter->second->empty()) {\n+                    break;\n+                }\n+                // 1.3 record this version to make a tracker, put into path_version\n+                auto next_rs_meta_iter = tmp_edge_iter->second->begin();\n+                tmp_end_version = next_rs_meta_iter->first;\n+                create_time = next_rs_meta_iter->second->creation_time();\n+                VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                        Version(tmp_start_version, tmp_end_version), create_time));\n+                path_version_ptr->push_back(tracker_ptr);\n+                // 1.4 judge if this path finish\n+                auto max_end_version = tmp_end_version;\n+                // find from other_path\n+                if (edges->find(max_end_version) != edges->end()) {\n+                    break;\n+                }\n+                // find from main_path\n+                if (main_path.find(Version(min_begin_version, max_end_version)) !=\n+                    main_path.end()) {\n+                    break;\n+                }\n+                // 1.5 do next\n+                tmp_start_version = tmp_end_version + 1;\n+\n+            } while (true);\n+            // 1.6 add path_version to map\n+            _expired_snapshot_rs_path_map[_next_path_version++] = path_version_ptr;\n+\n+            // 2 remove this path from other_path\n+            auto path_iter = path_version_ptr->begin();\n+            for (; path_iter != path_version_ptr->end(); path_iter++) {\n+                Version version = (*path_iter)->version();", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwNDQ3NA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450904474", "bodyText": "Looks same as construct_versioned_tracker()", "author": "morningman", "createdAt": "2020-07-07T14:24:02Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,243 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowset_graph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // version -> rowsetmeta\n+    // fill main_path which are included not merged rowsets\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path which are included merged rowsets\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path, begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            // tracker the first\n+            VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                    Version(min_begin_version, min_end_version), min_rs_meta->creation_time()));\n+            path_version_ptr->push_back(tracker_ptr);\n+            // 1.1 do loop, find next start to make a path\n+            auto tmp_start_version = min_end_version + 1;\n+            do {\n+                int64_t tmp_end_version = -1;\n+                int64_t create_time = -1;\n+                // 1.2 the next must in other_path, find from other_path\n+                auto tmp_edge_iter = other_path.find(tmp_start_version);\n+                if (tmp_edge_iter == other_path.end() || tmp_edge_iter->second->empty()) {\n+                    break;\n+                }\n+                // 1.3 record this version to make a tracker, put into path_version\n+                auto next_rs_meta_iter = tmp_edge_iter->second->begin();\n+                tmp_end_version = next_rs_meta_iter->first;\n+                create_time = next_rs_meta_iter->second->creation_time();\n+                VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                        Version(tmp_start_version, tmp_end_version), create_time));\n+                path_version_ptr->push_back(tracker_ptr);\n+                // 1.4 judge if this path finish\n+                auto max_end_version = tmp_end_version;\n+                // find from other_path\n+                if (edges->find(max_end_version) != edges->end()) {\n+                    break;\n+                }\n+                // find from main_path\n+                if (main_path.find(Version(min_begin_version, max_end_version)) !=\n+                    main_path.end()) {\n+                    break;\n+                }\n+                // 1.5 do next\n+                tmp_start_version = tmp_end_version + 1;\n+\n+            } while (true);\n+            // 1.6 add path_version to map\n+            _expired_snapshot_rs_path_map[_next_path_version++] = path_version_ptr;\n+\n+            // 2 remove this path from other_path\n+            auto path_iter = path_version_ptr->begin();\n+            for (; path_iter != path_version_ptr->end(); path_iter++) {\n+                Version version = (*path_iter)->version();\n+                other_path[version.first]->erase(version.second);\n+            }\n+        }\n+    }\n+    other_path.clear();\n+    main_path.clear();\n+    _print_current_state();\n+}\n+\n+void VersionedRowsetTracker::construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::reconstruct_versioned_tracker(", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwNjE4OQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450906189", "bodyText": "I think we can save the max_create_time of a version path in _expired_snapshot_rs_path_map", "author": "morningman", "createdAt": "2020-07-07T14:26:12Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,243 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowset_graph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // version -> rowsetmeta\n+    // fill main_path which are included not merged rowsets\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path which are included merged rowsets\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path, begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            // tracker the first\n+            VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                    Version(min_begin_version, min_end_version), min_rs_meta->creation_time()));\n+            path_version_ptr->push_back(tracker_ptr);\n+            // 1.1 do loop, find next start to make a path\n+            auto tmp_start_version = min_end_version + 1;\n+            do {\n+                int64_t tmp_end_version = -1;\n+                int64_t create_time = -1;\n+                // 1.2 the next must in other_path, find from other_path\n+                auto tmp_edge_iter = other_path.find(tmp_start_version);\n+                if (tmp_edge_iter == other_path.end() || tmp_edge_iter->second->empty()) {\n+                    break;\n+                }\n+                // 1.3 record this version to make a tracker, put into path_version\n+                auto next_rs_meta_iter = tmp_edge_iter->second->begin();\n+                tmp_end_version = next_rs_meta_iter->first;\n+                create_time = next_rs_meta_iter->second->creation_time();\n+                VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                        Version(tmp_start_version, tmp_end_version), create_time));\n+                path_version_ptr->push_back(tracker_ptr);\n+                // 1.4 judge if this path finish\n+                auto max_end_version = tmp_end_version;\n+                // find from other_path\n+                if (edges->find(max_end_version) != edges->end()) {\n+                    break;\n+                }\n+                // find from main_path\n+                if (main_path.find(Version(min_begin_version, max_end_version)) !=\n+                    main_path.end()) {\n+                    break;\n+                }\n+                // 1.5 do next\n+                tmp_start_version = tmp_end_version + 1;\n+\n+            } while (true);\n+            // 1.6 add path_version to map\n+            _expired_snapshot_rs_path_map[_next_path_version++] = path_version_ptr;\n+\n+            // 2 remove this path from other_path\n+            auto path_iter = path_version_ptr->begin();\n+            for (; path_iter != path_version_ptr->end(); path_iter++) {\n+                Version version = (*path_iter)->version();\n+                other_path[version.first]->erase(version.second);\n+            }\n+        }\n+    }\n+    other_path.clear();\n+    main_path.clear();\n+    _print_current_state();\n+}\n+\n+void VersionedRowsetTracker::construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::reconstruct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+    _expired_snapshot_rs_path_map.clear();\n+    _next_path_version = 1;\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::add_version(const Version& version) {\n+    _rowset_graph.add_version_to_graph(version);\n+}\n+\n+void VersionedRowsetTracker::add_expired_path_version(\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (expired_snapshot_rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the expired_snapshot_rs_metas.\";\n+        return;\n+    }\n+\n+    PathVersionListSharedPtr ptr(new std::vector<VersionTrackerSharedPtr>());\n+    for (auto rs : expired_snapshot_rs_metas) {\n+        VersionTrackerSharedPtr vt_ptr(new VersionTracker(rs->version(), rs->creation_time()));\n+        ptr->push_back(vt_ptr);\n+    }\n+    sort(ptr->begin(), ptr->end());\n+    _expired_snapshot_rs_path_map[_next_path_version] = ptr;\n+    _next_path_version++;\n+}\n+\n+// Capture consistent versions from graph\n+OLAPStatus VersionedRowsetTracker::capture_consistent_versions(\n+        const Version& spec_version, std::vector<Version>* version_path) const {\n+    return _rowset_graph.capture_consistent_versions(spec_version, version_path);\n+}\n+\n+void VersionedRowsetTracker::capture_expired_path_version(\n+        int64_t expired_snapshot_sweep_endtime, std::vector<int64_t>* path_version_vec) const {\n+    std::unordered_map<int64_t, PathVersionListSharedPtr>::const_iterator iter =\n+            _expired_snapshot_rs_path_map.begin();\n+\n+    while (iter != _expired_snapshot_rs_path_map.end()) {\n+        std::vector<VersionTrackerSharedPtr>::iterator version_path_iter = iter->second->begin();\n+        int64_t max_create_time = -1;", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkyOTgwMA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r450929800", "bodyText": "Better to return a string, and let the caller decide how to print it.", "author": "morningman", "createdAt": "2020-07-07T14:57:04Z", "path": "be/src/olap/rowset_graph.cpp", "diffHunk": "@@ -17,14 +17,243 @@\n \n #include \"olap/rowset_graph.h\"\n \n-#include <queue>\n #include <memory>\n+#include <queue>\n \n #include \"common/logging.h\"\n \n namespace doris {\n \n-void RowsetGraph::construct_rowset_graph(const std::vector<RowsetMetaSharedPtr>& rs_metas) {\n+void VersionedRowsetTracker::_construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    int64_t max_version = 0;\n+\n+    std::vector<RowsetMetaSharedPtr> all_rs_metas(rs_metas);\n+    all_rs_metas.insert(all_rs_metas.end(), expired_snapshot_rs_metas.begin(),\n+                        expired_snapshot_rs_metas.end());\n+    // construct the roset graph\n+    _rowset_graph.reconstruct_rowset_graph(all_rs_metas, max_version);\n+\n+    // version -> rowsetmeta\n+    // fill main_path which are included not merged rowsets\n+    std::unordered_map<Version, RowsetMetaSharedPtr, HashOfVersion> main_path;\n+    for (auto& rs_meta : rs_metas) {\n+        main_path[rs_meta->version()] = rs_meta;\n+    }\n+    // fill other_path which are included merged rowsets\n+    typedef std::shared_ptr<std::map<int64_t, RowsetMetaSharedPtr>> Edges;\n+    std::map<int64_t, Edges> other_path;\n+\n+    for (auto& rs_meta : expired_snapshot_rs_metas) {\n+        if (other_path.find(rs_meta->start_version()) == other_path.end()) {\n+            other_path[rs_meta->start_version()] =\n+                    Edges(new std::map<int64_t, RowsetMetaSharedPtr>());\n+        }\n+        other_path[rs_meta->start_version()]->insert(\n+                std::pair<int64_t, RowsetMetaSharedPtr>(rs_meta->end_version(), rs_meta));\n+    }\n+\n+    auto iter = other_path.begin();\n+    for (; iter != other_path.end(); iter++) {\n+        Edges edges = iter->second;\n+        auto min_begin_version = iter->first;\n+\n+        while (!edges->empty()) {\n+            PathVersionListSharedPtr path_version_ptr(new std::vector<VersionTrackerSharedPtr>());\n+            // 1. find a path, begin from min_begin_version\n+            auto min_end_version = edges->begin()->first;\n+            auto min_rs_meta = edges->begin()->second;\n+            // tracker the first\n+            VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                    Version(min_begin_version, min_end_version), min_rs_meta->creation_time()));\n+            path_version_ptr->push_back(tracker_ptr);\n+            // 1.1 do loop, find next start to make a path\n+            auto tmp_start_version = min_end_version + 1;\n+            do {\n+                int64_t tmp_end_version = -1;\n+                int64_t create_time = -1;\n+                // 1.2 the next must in other_path, find from other_path\n+                auto tmp_edge_iter = other_path.find(tmp_start_version);\n+                if (tmp_edge_iter == other_path.end() || tmp_edge_iter->second->empty()) {\n+                    break;\n+                }\n+                // 1.3 record this version to make a tracker, put into path_version\n+                auto next_rs_meta_iter = tmp_edge_iter->second->begin();\n+                tmp_end_version = next_rs_meta_iter->first;\n+                create_time = next_rs_meta_iter->second->creation_time();\n+                VersionTrackerSharedPtr tracker_ptr(new VersionTracker(\n+                        Version(tmp_start_version, tmp_end_version), create_time));\n+                path_version_ptr->push_back(tracker_ptr);\n+                // 1.4 judge if this path finish\n+                auto max_end_version = tmp_end_version;\n+                // find from other_path\n+                if (edges->find(max_end_version) != edges->end()) {\n+                    break;\n+                }\n+                // find from main_path\n+                if (main_path.find(Version(min_begin_version, max_end_version)) !=\n+                    main_path.end()) {\n+                    break;\n+                }\n+                // 1.5 do next\n+                tmp_start_version = tmp_end_version + 1;\n+\n+            } while (true);\n+            // 1.6 add path_version to map\n+            _expired_snapshot_rs_path_map[_next_path_version++] = path_version_ptr;\n+\n+            // 2 remove this path from other_path\n+            auto path_iter = path_version_ptr->begin();\n+            for (; path_iter != path_version_ptr->end(); path_iter++) {\n+                Version version = (*path_iter)->version();\n+                other_path[version.first]->erase(version.second);\n+            }\n+        }\n+    }\n+    other_path.clear();\n+    main_path.clear();\n+    _print_current_state();\n+}\n+\n+void VersionedRowsetTracker::construct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::reconstruct_versioned_tracker(\n+        const std::vector<RowsetMetaSharedPtr>& rs_metas,\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the header.\";\n+        return;\n+    }\n+    _expired_snapshot_rs_path_map.clear();\n+    _next_path_version = 1;\n+\n+    _construct_versioned_tracker(rs_metas, expired_snapshot_rs_metas);\n+}\n+\n+void VersionedRowsetTracker::add_version(const Version& version) {\n+    _rowset_graph.add_version_to_graph(version);\n+}\n+\n+void VersionedRowsetTracker::add_expired_path_version(\n+        const std::vector<RowsetMetaSharedPtr>& expired_snapshot_rs_metas) {\n+    if (expired_snapshot_rs_metas.empty()) {\n+        VLOG(3) << \"there is no version in the expired_snapshot_rs_metas.\";\n+        return;\n+    }\n+\n+    PathVersionListSharedPtr ptr(new std::vector<VersionTrackerSharedPtr>());\n+    for (auto rs : expired_snapshot_rs_metas) {\n+        VersionTrackerSharedPtr vt_ptr(new VersionTracker(rs->version(), rs->creation_time()));\n+        ptr->push_back(vt_ptr);\n+    }\n+    sort(ptr->begin(), ptr->end());\n+    _expired_snapshot_rs_path_map[_next_path_version] = ptr;\n+    _next_path_version++;\n+}\n+\n+// Capture consistent versions from graph\n+OLAPStatus VersionedRowsetTracker::capture_consistent_versions(\n+        const Version& spec_version, std::vector<Version>* version_path) const {\n+    return _rowset_graph.capture_consistent_versions(spec_version, version_path);\n+}\n+\n+void VersionedRowsetTracker::capture_expired_path_version(\n+        int64_t expired_snapshot_sweep_endtime, std::vector<int64_t>* path_version_vec) const {\n+    std::unordered_map<int64_t, PathVersionListSharedPtr>::const_iterator iter =\n+            _expired_snapshot_rs_path_map.begin();\n+\n+    while (iter != _expired_snapshot_rs_path_map.end()) {\n+        std::vector<VersionTrackerSharedPtr>::iterator version_path_iter = iter->second->begin();\n+        int64_t max_create_time = -1;\n+        while (version_path_iter != iter->second->end()) {\n+            if (max_create_time < (*version_path_iter)->get_create_time()) {\n+                max_create_time = (*version_path_iter)->get_create_time();\n+            }\n+\n+            version_path_iter++;\n+        }\n+        if (max_create_time <= expired_snapshot_sweep_endtime) {\n+            int64_t path_version = iter->first;\n+            path_version_vec->push_back(path_version);\n+        }\n+        iter++;\n+    }\n+}\n+\n+void VersionedRowsetTracker::fetch_path_version(int64_t path_version,\n+                                                std::vector<Version>& version_path) {\n+    if (_expired_snapshot_rs_path_map.count(path_version) == 0) {\n+        VLOG(3) << \"path version \" << path_version << \" does not exist!\";\n+        return;\n+    }\n+\n+    PathVersionListSharedPtr ptr = _expired_snapshot_rs_path_map[path_version];\n+\n+    std::vector<VersionTrackerSharedPtr>::iterator iter = ptr->begin();\n+    while (iter != ptr->end()) {\n+        version_path.push_back((*iter)->version());\n+        iter++;\n+    }\n+}\n+\n+void VersionedRowsetTracker::fetch_and_delete_path_version(int64_t path_version,\n+                                                           std::vector<Version>& version_path) {\n+    if (_expired_snapshot_rs_path_map.count(path_version) == 0) {\n+        VLOG(3) << \"path version \" << path_version << \" does not exist!\";\n+        return;\n+    }\n+\n+    _print_current_state();\n+    fetch_path_version(path_version, version_path);\n+\n+    _expired_snapshot_rs_path_map.erase(path_version);\n+\n+    for (auto& version : version_path) {\n+        _rowset_graph.delete_version_from_graph(version);\n+    }\n+}\n+\n+void VersionedRowsetTracker::_print_current_state() {", "originalCommit": "5eb43d3af376d3d6d649c0e1bd7841e0294cf441", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA2MTMwMw==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r454061303", "bodyText": "remove this line\uff1f", "author": "wutiangan", "createdAt": "2020-07-14T02:31:45Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -310,7 +321,10 @@ OLAPStatus Tablet::add_inc_rowset(const RowsetSharedPtr& rowset) {\n     RETURN_NOT_OK(_tablet_meta->add_rs_meta(rowset->rowset_meta()));\n     _rs_version_map[rowset->version()] = rowset;\n     _inc_rs_version_map[rowset->version()] = rowset;\n-    _rs_graph.add_version_to_graph(rowset->version());\n+\n+    // _rs_graph.add_version_to_graph(rowset->version());", "originalCommit": "30a3810ba49d1b87c43fc5a2360dd7fa4bdc2176", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3OTcyMA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r452279720", "bodyText": "how about _stale_rs_metas", "author": "morningman", "createdAt": "2020-07-09T14:55:13Z", "path": "be/src/olap/tablet_meta.h", "diffHunk": "@@ -325,6 +334,10 @@ inline const std::vector<RowsetMetaSharedPtr>& TabletMeta::all_inc_rs_metas() co\n     return _inc_rs_metas;\n }\n \n+inline const std::vector<RowsetMetaSharedPtr>& TabletMeta::all_expired_snapshot_rs_metas() const {\n+    return _expired_snapshot_rs_metas;", "originalCommit": "91ffbd41fea6aa7c4d4c954f83143a5f3e72fe63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA5NzY2Mw==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r454097663", "bodyText": "print tablet id too", "author": "morningman", "createdAt": "2020-07-14T04:47:36Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -358,9 +384,89 @@ void Tablet::delete_expired_inc_rowsets() {\n     save_meta();\n }\n \n+void Tablet::delete_expired_snapshot_rowset() {\n+\n+    int64_t now = UnixSeconds();\n+    vector<pair<Version, VersionHash>> expired_versions;\n+    WriteLock wrlock(&_meta_lock);\n+    // Compute the end time to delete rowsets, when a expired rowset createtime less then this time, it will be deleted.\n+    double expired_snapshot_sweep_endtime = ::difftime(now, config::tablet_rowset_expired_snapshot_sweep_time);\n+    \n+    std::vector<int64_t> path_version_vec;\n+    // capture the path version to delete\n+    _timestamped_version_tracker.capture_expired_paths(static_cast<int64_t>(expired_snapshot_sweep_endtime), &path_version_vec);\n+\n+    auto old_size = _expired_snapshot_rs_version_map.size();\n+    auto old_meta_size = _tablet_meta->all_expired_snapshot_rs_metas().size();\n+\n+    std::vector<Version> to_delete_version;\n+    // fetch all versions of rowsets to delete\n+    for (auto& path_version : path_version_vec) {\n+        std::vector<Version> version_path;\n+        // fetch the path versions in the version path and delete the path version in tracker\n+        _timestamped_version_tracker.fetch_and_delete_path_by_id(path_version, &version_path);\n+        to_delete_version.insert(to_delete_version.end(), version_path.begin(), version_path.end());\n+    }\n+\n+    if (to_delete_version.empty()) {\n+        return;\n+    }\n+\n+    // check consistent versions\n+    const RowsetSharedPtr lastest_delta = rowset_with_max_version();\n+    DCHECK(lastest_delta != nullptr);\n+\n+    Version test_version = Version(0, lastest_delta->end_version());\n+    OLAPStatus status = capture_consistent_versions(test_version, nullptr);\n+\n+    // When there is no consistent versions, we must reconstruct the tracker.\n+    if (status != OLAP_SUCCESS) {\n+        LOG(WARNING) << \"The consistent version check fails, there are bugs. \"\n+                        << \"Reconstruct the tracker to recover versions.\";", "originalCommit": "30a3810ba49d1b87c43fc5a2360dd7fa4bdc2176", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1NTQ0NQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r455055445", "bodyText": "expired_snapshot_version_path_map does not contains the expired path you just deleted.", "author": "morningman", "createdAt": "2020-07-15T13:34:46Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -358,9 +383,102 @@ void Tablet::delete_expired_inc_rowsets() {\n     save_meta();\n }\n \n+void Tablet::delete_expired_snapshot_rowset() {\n+\n+    int64_t now = UnixSeconds();\n+    vector<pair<Version, VersionHash>> expired_versions;\n+    WriteLock wrlock(&_meta_lock);\n+    // Compute the end time to delete rowsets, when a expired rowset createtime less then this time, it will be deleted.\n+    double expired_snapshot_sweep_endtime = ::difftime(now, config::tablet_rowset_expired_snapshot_sweep_time);\n+    \n+    std::vector<int64_t> path_version_vec;\n+    // capture the path version to delete\n+    _timestamped_version_tracker.capture_expired_paths(static_cast<int64_t>(expired_snapshot_sweep_endtime), &path_version_vec);\n+\n+    if (path_version_vec.empty()) {\n+        return;\n+    }\n+\n+    // do check consistent operation\n+    auto path_id_iter = path_version_vec.rbegin();\n+\n+    std::map<int64_t, PathVersionListSharedPtr> expired_snapshot_version_path_map;\n+    while (path_id_iter != path_version_vec.rend()) {\n+\n+        PathVersionListSharedPtr version_path = _timestamped_version_tracker.fetch_and_delete_path_by_id(*path_id_iter);\n+        const std::vector<TimestampedVersionSharedPtr>& to_delete_version = version_path->timestamped_versions();\n+\n+        auto first_version = to_delete_version.front();\n+        auto end_version = to_delete_version.back();\n+        Version test_version = Version(first_version->version().first, end_version->version().second);\n+\n+        OLAPStatus status = capture_consistent_versions(test_version, nullptr);\n+        // When there is no consistent versions, we must reconstruct the tracker.\n+        if (status != OLAP_SUCCESS) {\n+            LOG(WARNING) << \"The consistent version check fails, there are bugs. \"\n+                << \"Reconstruct the tracker to recover versions in tablet=\" << tablet_id();\n+\n+            _timestamped_version_tracker.reconstruct_versioned_tracker(\n+                    _tablet_meta->all_rs_metas(), expired_snapshot_version_path_map);", "originalCommit": "d7e83dfb835f73dee90886d3daa687cb27157ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1OTA1Mw==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r455059053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                << \"] not find in expired snapshot rs version \";\n          \n          \n            \n                                << \"] not find in expired snapshot rs version map\";", "author": "morningman", "createdAt": "2020-07-15T13:39:53Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -358,9 +383,102 @@ void Tablet::delete_expired_inc_rowsets() {\n     save_meta();\n }\n \n+void Tablet::delete_expired_snapshot_rowset() {\n+\n+    int64_t now = UnixSeconds();\n+    vector<pair<Version, VersionHash>> expired_versions;\n+    WriteLock wrlock(&_meta_lock);\n+    // Compute the end time to delete rowsets, when a expired rowset createtime less then this time, it will be deleted.\n+    double expired_snapshot_sweep_endtime = ::difftime(now, config::tablet_rowset_expired_snapshot_sweep_time);\n+    \n+    std::vector<int64_t> path_version_vec;\n+    // capture the path version to delete\n+    _timestamped_version_tracker.capture_expired_paths(static_cast<int64_t>(expired_snapshot_sweep_endtime), &path_version_vec);\n+\n+    if (path_version_vec.empty()) {\n+        return;\n+    }\n+\n+    // do check consistent operation\n+    auto path_id_iter = path_version_vec.rbegin();\n+\n+    std::map<int64_t, PathVersionListSharedPtr> expired_snapshot_version_path_map;\n+    while (path_id_iter != path_version_vec.rend()) {\n+\n+        PathVersionListSharedPtr version_path = _timestamped_version_tracker.fetch_and_delete_path_by_id(*path_id_iter);\n+        const std::vector<TimestampedVersionSharedPtr>& to_delete_version = version_path->timestamped_versions();\n+\n+        auto first_version = to_delete_version.front();\n+        auto end_version = to_delete_version.back();\n+        Version test_version = Version(first_version->version().first, end_version->version().second);\n+\n+        OLAPStatus status = capture_consistent_versions(test_version, nullptr);\n+        // When there is no consistent versions, we must reconstruct the tracker.\n+        if (status != OLAP_SUCCESS) {\n+            LOG(WARNING) << \"The consistent version check fails, there are bugs. \"\n+                << \"Reconstruct the tracker to recover versions in tablet=\" << tablet_id();\n+\n+            _timestamped_version_tracker.reconstruct_versioned_tracker(\n+                    _tablet_meta->all_rs_metas(), expired_snapshot_version_path_map);\n+\n+            // double check the consistent versions\n+            status = capture_consistent_versions(test_version, nullptr);\n+\n+            if (status != OLAP_SUCCESS) {\n+                if (!config::ignore_rowset_expired_snapshot_unconsistent_delete) {\n+                    LOG(FATAL) << \"rowset expired snapshot unconsistent delete. tablet= \" << tablet_id();\n+                } else {\n+                    LOG(WARNING) << \"rowset expired snapshot unconsistent delete. tablet= \" << tablet_id();\n+                }\n+            }\n+            return;\n+        }\n+        expired_snapshot_version_path_map[*path_id_iter] = version_path;\n+        path_id_iter++;\n+    }\n+\n+    auto old_size = _expired_snapshot_rs_version_map.size();\n+    auto old_meta_size = _tablet_meta->all_expired_snapshot_rs_metas().size();\n+\n+    // do delete operation\n+    auto to_delete_iter = expired_snapshot_version_path_map.begin();\n+    while (to_delete_iter != expired_snapshot_version_path_map.end()) {\n+        \n+        std::vector<TimestampedVersionSharedPtr>& to_delete_version = to_delete_iter->second->timestamped_versions();\n+        for (auto& timestampedVersion : to_delete_version) {\n+            auto it = _expired_snapshot_rs_version_map.find(timestampedVersion->version());\n+            if (it != _expired_snapshot_rs_version_map.end()) {\n+                // delete rowset\n+                StorageEngine::instance()->add_unused_rowset(it->second);\n+                _expired_snapshot_rs_version_map.erase(it);\n+                LOG(INFO) << \"delete expired snapshot rowset tablet=\" << full_name() \n+                    <<\" version[\" << timestampedVersion->version().first << \",\" << timestampedVersion->version().second \n+                    << \"] move to unused_rowset success \" << std::fixed << expired_snapshot_sweep_endtime;\n+            } else {\n+                LOG(WARNING) << \"delete expired snapshot rowset tablet=\" << full_name() \n+                    <<\" version[\" << timestampedVersion->version().first << \",\" << timestampedVersion->version().second \n+                    << \"] not find in expired snapshot rs version \";", "originalCommit": "d7e83dfb835f73dee90886d3daa687cb27157ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA2MTE3OA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r455061178", "bodyText": "in _delete_expired_snapshot_rowset_by_version, we call _expired_snapshot_rs_version_map.erase() again, which is duplicated.", "author": "morningman", "createdAt": "2020-07-15T13:42:52Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -358,9 +383,102 @@ void Tablet::delete_expired_inc_rowsets() {\n     save_meta();\n }\n \n+void Tablet::delete_expired_snapshot_rowset() {\n+\n+    int64_t now = UnixSeconds();\n+    vector<pair<Version, VersionHash>> expired_versions;\n+    WriteLock wrlock(&_meta_lock);\n+    // Compute the end time to delete rowsets, when a expired rowset createtime less then this time, it will be deleted.\n+    double expired_snapshot_sweep_endtime = ::difftime(now, config::tablet_rowset_expired_snapshot_sweep_time);\n+    \n+    std::vector<int64_t> path_version_vec;\n+    // capture the path version to delete\n+    _timestamped_version_tracker.capture_expired_paths(static_cast<int64_t>(expired_snapshot_sweep_endtime), &path_version_vec);\n+\n+    if (path_version_vec.empty()) {\n+        return;\n+    }\n+\n+    // do check consistent operation\n+    auto path_id_iter = path_version_vec.rbegin();\n+\n+    std::map<int64_t, PathVersionListSharedPtr> expired_snapshot_version_path_map;\n+    while (path_id_iter != path_version_vec.rend()) {\n+\n+        PathVersionListSharedPtr version_path = _timestamped_version_tracker.fetch_and_delete_path_by_id(*path_id_iter);\n+        const std::vector<TimestampedVersionSharedPtr>& to_delete_version = version_path->timestamped_versions();\n+\n+        auto first_version = to_delete_version.front();\n+        auto end_version = to_delete_version.back();\n+        Version test_version = Version(first_version->version().first, end_version->version().second);\n+\n+        OLAPStatus status = capture_consistent_versions(test_version, nullptr);\n+        // When there is no consistent versions, we must reconstruct the tracker.\n+        if (status != OLAP_SUCCESS) {\n+            LOG(WARNING) << \"The consistent version check fails, there are bugs. \"\n+                << \"Reconstruct the tracker to recover versions in tablet=\" << tablet_id();\n+\n+            _timestamped_version_tracker.reconstruct_versioned_tracker(\n+                    _tablet_meta->all_rs_metas(), expired_snapshot_version_path_map);\n+\n+            // double check the consistent versions\n+            status = capture_consistent_versions(test_version, nullptr);\n+\n+            if (status != OLAP_SUCCESS) {\n+                if (!config::ignore_rowset_expired_snapshot_unconsistent_delete) {\n+                    LOG(FATAL) << \"rowset expired snapshot unconsistent delete. tablet= \" << tablet_id();\n+                } else {\n+                    LOG(WARNING) << \"rowset expired snapshot unconsistent delete. tablet= \" << tablet_id();\n+                }\n+            }\n+            return;\n+        }\n+        expired_snapshot_version_path_map[*path_id_iter] = version_path;\n+        path_id_iter++;\n+    }\n+\n+    auto old_size = _expired_snapshot_rs_version_map.size();\n+    auto old_meta_size = _tablet_meta->all_expired_snapshot_rs_metas().size();\n+\n+    // do delete operation\n+    auto to_delete_iter = expired_snapshot_version_path_map.begin();\n+    while (to_delete_iter != expired_snapshot_version_path_map.end()) {\n+        \n+        std::vector<TimestampedVersionSharedPtr>& to_delete_version = to_delete_iter->second->timestamped_versions();\n+        for (auto& timestampedVersion : to_delete_version) {\n+            auto it = _expired_snapshot_rs_version_map.find(timestampedVersion->version());\n+            if (it != _expired_snapshot_rs_version_map.end()) {\n+                // delete rowset\n+                StorageEngine::instance()->add_unused_rowset(it->second);\n+                _expired_snapshot_rs_version_map.erase(it);\n+                LOG(INFO) << \"delete expired snapshot rowset tablet=\" << full_name() \n+                    <<\" version[\" << timestampedVersion->version().first << \",\" << timestampedVersion->version().second \n+                    << \"] move to unused_rowset success \" << std::fixed << expired_snapshot_sweep_endtime;\n+            } else {\n+                LOG(WARNING) << \"delete expired snapshot rowset tablet=\" << full_name() \n+                    <<\" version[\" << timestampedVersion->version().first << \",\" << timestampedVersion->version().second \n+                    << \"] not find in expired snapshot rs version \";\n+            }\n+            _delete_expired_snapshot_rowset_by_version(timestampedVersion->version());", "originalCommit": "d7e83dfb835f73dee90886d3daa687cb27157ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA2MjcxMQ==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r455062711", "bodyText": "This check is meaningless. I think you can just call\n_tablet_meta->delete_expired_snapshot_rs_meta_by_version(version);", "author": "morningman", "createdAt": "2020-07-15T13:44:52Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -329,6 +342,18 @@ void Tablet::_delete_inc_rowset_by_version(const Version& version,\n     VLOG(3) << \"delete incremental rowset. tablet=\" << full_name() << \", version=\" << version;\n }\n \n+void Tablet::_delete_expired_snapshot_rowset_by_version(const Version& version) {\n+    // delete expired snapshot rowset from map\n+    _expired_snapshot_rs_version_map.erase(version);\n+\n+    RowsetMetaSharedPtr rowset_meta = _tablet_meta->acquire_expired_snapshot_rs_meta_by_version(version);", "originalCommit": "d7e83dfb835f73dee90886d3daa687cb27157ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA2NDcyNA==", "url": "https://github.com/apache/incubator-doris/pull/4039#discussion_r455064724", "bodyText": "Are you sure there will be only one version which equals to the specified version?", "author": "morningman", "createdAt": "2020-07-15T13:47:35Z", "path": "be/src/olap/tablet_meta.cpp", "diffHunk": "@@ -544,6 +548,27 @@ OLAPStatus TabletMeta::add_inc_rs_meta(const RowsetMetaSharedPtr& rs_meta) {\n     return OLAP_SUCCESS;\n }\n \n+void TabletMeta::delete_expired_snapshot_rs_meta_by_version(const Version& version) {\n+    auto it = _expired_snapshot_rs_metas.begin();\n+    while (it != _expired_snapshot_rs_metas.end()) {\n+        if ((*it)->version() == version) {\n+            _expired_snapshot_rs_metas.erase(it);\n+            break;", "originalCommit": "d7e83dfb835f73dee90886d3daa687cb27157ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "68a34aa83bb78238d4702bce155881add78679fa", "url": "https://github.com/apache/incubator-doris/commit/68a34aa83bb78238d4702bce155881add78679fa", "message": "merged rowset version delay unused, fix -230 error", "committedDate": "2020-07-15T15:44:05Z", "type": "commit"}, {"oid": "ecf54c2d9ae1f974a3b79b621093bba669da2f20", "url": "https://github.com/apache/incubator-doris/commit/ecf54c2d9ae1f974a3b79b621093bba669da2f20", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:44:05Z", "type": "commit"}, {"oid": "7c8489a3fb06a3b3697b3943b05a33cc8ff5a527", "url": "https://github.com/apache/incubator-doris/commit/7c8489a3fb06a3b3697b3943b05a33cc8ff5a527", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:44:05Z", "type": "commit"}, {"oid": "a638c7e9ea0da4d1aecc49612ddabbae7e6e1c3f", "url": "https://github.com/apache/incubator-doris/commit/a638c7e9ea0da4d1aecc49612ddabbae7e6e1c3f", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:49:35Z", "type": "commit"}, {"oid": "b8f23aa312d27f0c199c1d94c79bea8fa2238082", "url": "https://github.com/apache/incubator-doris/commit/b8f23aa312d27f0c199c1d94c79bea8fa2238082", "message": "Add expired path version json info", "committedDate": "2020-07-15T15:49:39Z", "type": "commit"}, {"oid": "1dd0e78ab8a0321ff2f9b75a488ab6df584d5e9c", "url": "https://github.com/apache/incubator-doris/commit/1dd0e78ab8a0321ff2f9b75a488ab6df584d5e9c", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:50:28Z", "type": "commit"}, {"oid": "05080a289107b769d3725b5c5fca1c58ad5903dd", "url": "https://github.com/apache/incubator-doris/commit/05080a289107b769d3725b5c5fca1c58ad5903dd", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:50:30Z", "type": "commit"}, {"oid": "2aa76935364d7c8bdbd0765d85d315132ccf6a87", "url": "https://github.com/apache/incubator-doris/commit/2aa76935364d7c8bdbd0765d85d315132ccf6a87", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:51:28Z", "type": "commit"}, {"oid": "f9b59cb5d3d4fd06dbb2dd2ba33ae732a1086e86", "url": "https://github.com/apache/incubator-doris/commit/f9b59cb5d3d4fd06dbb2dd2ba33ae732a1086e86", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:52:41Z", "type": "commit"}, {"oid": "24a8ff51811edf928e5e71bd1f620a7a0fc3c59b", "url": "https://github.com/apache/incubator-doris/commit/24a8ff51811edf928e5e71bd1f620a7a0fc3c59b", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T15:52:44Z", "type": "commit"}, {"oid": "64713d0e9fd60fd212231055c00ac350613f0f36", "url": "https://github.com/apache/incubator-doris/commit/64713d0e9fd60fd212231055c00ac350613f0f36", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T16:29:06Z", "type": "commit"}, {"oid": "64713d0e9fd60fd212231055c00ac350613f0f36", "url": "https://github.com/apache/incubator-doris/commit/64713d0e9fd60fd212231055c00ac350613f0f36", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-15T16:29:06Z", "type": "forcePushed"}, {"oid": "dbed890ed0521bb19ee660aa03631f94caff9095", "url": "https://github.com/apache/incubator-doris/commit/dbed890ed0521bb19ee660aa03631f94caff9095", "message": "Add delayed deletion of rowsets function, fix -230 error.", "committedDate": "2020-07-16T06:43:35Z", "type": "commit"}]}