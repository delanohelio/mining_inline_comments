{"pr_number": 5008, "pr_title": "[Optimize][Cache]Implementation of Separated Page Cache", "pr_createdAt": "2020-12-02T10:26:39Z", "pr_url": "https://github.com/apache/incubator-doris/pull/5008", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0ODI4NA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538048284", "bodyText": "I think it's better to give more description, such as what does the left size used for?", "author": "acelyc111", "createdAt": "2020-12-08T05:35:02Z", "path": "be/src/common/config.h", "diffHunk": "@@ -260,6 +260,8 @@ CONF_Int64(index_stream_cache_capacity, \"10737418240\");\n \n // Cache for storage page size\n CONF_String(storage_page_cache_limit, \"20G\");\n+// Ratio for index page cache", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA0OTEzNw==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538049137", "bodyText": "Better to define it as a static function", "author": "acelyc111", "createdAt": "2020-12-08T05:37:23Z", "path": "be/src/olap/page_cache.h", "diffHunk": "@@ -53,36 +54,44 @@ class StoragePageCache {\n     };\n \n     // Create global instance of this class\n-    static void create_global_cache(size_t capacity);\n+    static void create_global_cache(size_t capacity, double index_cache_ratio);\n \n     // Return global instance.\n     // Client should call create_global_cache before.\n     static StoragePageCache* instance() { return _s_instance; }\n \n-    StoragePageCache(size_t capacity);\n+    StoragePageCache(size_t capacity, double index_cache_ratio);\n \n     // Lookup the given page in the cache.\n     //\n     // If the page is found, the cache entry will be written into handle.\n     // PageCacheHandle will release cache entry to cache when it\n     // destructs.\n     //\n+    // Cache type selection is determined by page_type argument\n+    //\n     // Return true if entry is found, otherwise return false.\n-    bool lookup(const CacheKey& key, PageCacheHandle* handle);\n+    bool lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type);\n \n     // Insert a page with key into this cache.\n     // Given handle will be set to valid reference.\n     // This function is thread-safe, and when two clients insert two same key\n     // concurrently, this function can assure that only one page is cached.\n     // The in_memory page will have higher priority.\n     void insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                bool in_memory = false);\n+                segment_v2::PageTypePB page_type, bool in_memory = false);\n+\n+    // Page cache available check.\n+    // When ratio is set to 0 or 1, the index or data cache will not be allocated.\n+    bool is_cache_available(segment_v2::PageTypePB page_type);", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MTk1NA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538051954", "bodyText": "For double type values, better to use expression like std::abs(index_cache_ratio) < 1e-6 to judge whether they are equaled. If you think it's too ugly, you can use percentagle int value instead.", "author": "acelyc111", "createdAt": "2020-12-08T05:45:20Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0NzAxMQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538947011", "bodyText": "I think it is a good idea to use the percentage as index cache ratio because of the safety problem as you mentioned and could also avoid using the type cast. I will change the definition. Thank you very much!", "author": "Skysheepwang", "createdAt": "2020-12-09T02:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1MzIyNA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538053224", "bodyText": "What if the other values passed, how about add CHECK(false) << \"xxx\" in else scope?", "author": "acelyc111", "createdAt": "2020-12-08T05:48:58Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   ", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDIwOQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054209", "bodyText": "There are some duplicate code, how about define a function like Cache::Handle* get_cache(segment_v2::PageTypePB page_type) to get lru_handle  at first, then do the same thing as before?", "author": "acelyc111", "createdAt": "2020-12-08T05:51:49Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDgzMA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538964830", "bodyText": "Sorry, it should be Cache* get_cache(segment_v2::PageTypePB page_type) to get Cache at first", "author": "acelyc111", "createdAt": "2020-12-09T02:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDM1Mg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054352", "bodyText": "Same", "author": "acelyc111", "createdAt": "2020-12-08T05:52:11Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NDk4OQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538054989", "bodyText": "If you do the refactor as mentioned above, you can simply judge whether the return Cache*  is nullptr or not", "author": "acelyc111", "createdAt": "2020-12-08T05:54:03Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,81 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, double index_cache_ratio) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_ratio);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, double index_cache_ratio)\n+        : _index_cache_ratio(index_cache_ratio) {\n+    if (index_cache_ratio == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio == 1) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_ratio > 0 && index_cache_ratio < 1) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", static_cast<size_t>(capacity * (1 - index_cache_ratio))));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", static_cast<size_t>(capacity * index_cache_ratio)));\n+    }   \n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n-    if (lru_handle == nullptr) {\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->lookup(key.encode());\n+        if (lru_handle == nullptr) {\n+            return false;\n+        }\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    switch (page_type) {\n+    case segment_v2::DATA_PAGE:\n+        lru_handle = _data_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_data_page_cache.get(), lru_handle);\n+        break;\n+    case segment_v2::INDEX_PAGE:\n+        lru_handle = _index_page_cache->insert(key.encode(), data.data, data.size, deleter, priority);\n+        *handle = PageCacheHandle(_index_page_cache.get(), lru_handle);\n+        break;\n+    default:\n+        break;\n+    }\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (page_type == segment_v2::DATA_PAGE && _index_cache_ratio == 1) {\n+        return false;\n+    }\n+    else if (page_type == segment_v2::INDEX_PAGE && _index_cache_ratio == 0) {\n+        return false;\n+    }", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQzNA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056434", "bodyText": "Add descriptions.", "author": "acelyc111", "createdAt": "2020-12-08T05:57:52Z", "path": "docs/en/administrator-guide/config/be_config.md", "diffHunk": "@@ -695,6 +695,8 @@ Indicates how many tablets in this data directory failed to load. At the same ti\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1NjQ4Mg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r538056482", "bodyText": "Add descriptions.", "author": "acelyc111", "createdAt": "2020-12-08T05:58:01Z", "path": "docs/zh-CN/administrator-guide/config/be_config.md", "diffHunk": "@@ -693,6 +693,8 @@ load tablets from header failed, failed tablets size: xxx, path=xxx\n \n ### `storage_page_cache_limit`\n \n+### `index_page_cache_ratio`", "originalCommit": "fe9cf7be97076f8c8c545789e032ef734412a180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "url": "https://github.com/apache/incubator-doris/commit/0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "message": "improve implementation following acelyc111 's review", "committedDate": "2020-12-09T07:44:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0NzE0Mg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539347142", "bodyText": "How about\nauto cache = _get_page_cache(page_type);\nauto lru_handle = cache->lookup(key.encode());\nif (lru_handle == nullptr) {\n    return false;\n}\n*handle = PageCacheHandle(cache, lru_handle);\nreturn true;", "author": "acelyc111", "createdAt": "2020-12-09T14:23:12Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;", "originalCommit": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODAyNQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539348025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (_get_page_cache(page_type) == nullptr) {\n          \n          \n            \n                    return false;\n          \n          \n            \n                }\n          \n          \n            \n                return true;\n          \n          \n            \n                return _get_page_cache(page_type) != nullptr;", "author": "acelyc111", "createdAt": "2020-12-09T14:24:24Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n+}\n+\n+bool StoragePageCache::is_cache_available(segment_v2::PageTypePB page_type) {\n+    if (_get_page_cache(page_type) == nullptr) {\n+        return false;\n+    }\n+    return true;", "originalCommit": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2OTAyMA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539769020", "bodyText": "Thank you! I think it is a really good change. I will take it and change the method to an inline member method.", "author": "Skysheepwang", "createdAt": "2020-12-10T01:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0OTEzMg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539349132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Cache::Handle* lru_handle = nullptr;\n          \n          \n            \n                lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n          \n          \n            \n                auto cache = _get_page_cache(page_type);\n          \n          \n            \n                Cache::Handle* lru_handle = cache->insert(key.encode(), data.data, data.size, deleter, priority);\n          \n          \n            \n                *handle = PageCacheHandle(cache, lru_handle);", "author": "acelyc111", "createdAt": "2020-12-09T14:25:44Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,70 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    Cache::Handle* lru_handle = nullptr;\n+    lru_handle = _get_page_cache(page_type)->insert(key.encode(), data.data, data.size, deleter, priority);\n+    *handle = PageCacheHandle(_get_page_cache(page_type), lru_handle);", "originalCommit": "0086e4efcdff1ebeb77ff4843bc18b2e087ef041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5OTU5OQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r539999599", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                }\n          \n          \n            \n                else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                }\n          \n          \n            \n                else {\n          \n          \n            \n                } else if (index_cache_percentage == 100) {\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n          \n          \n            \n                } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n          \n          \n            \n                    _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n          \n          \n            \n                    _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n          \n          \n            \n                } else {", "author": "acelyc111", "createdAt": "2020-12-10T09:15:10Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,51 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    }\n+    else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    }\n+    else {", "originalCommit": "c02b4de626bb5658dcedec67dee0be713a001aed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542387836", "bodyText": "the cache maybe null if the index_page_cache_percentage is 0 or 100", "author": "morningman", "createdAt": "2020-12-14T13:36:23Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);", "originalCommit": "e0248a305493f08105722a75bf6cb4ac3394392c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzYzMg==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993632", "bodyText": "Actually not because the is_cache_available() check will be called before using the lookup() method.", "author": "Skysheepwang", "createdAt": "2020-12-15T02:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NDkwNQ==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r544144905", "bodyText": "Ok", "author": "morningman", "createdAt": "2020-12-16T09:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODkxNA==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542388914", "bodyText": "cache may be null", "author": "morningman", "createdAt": "2020-12-14T13:37:53Z", "path": "be/src/olap/page_cache.cpp", "diffHunk": "@@ -21,35 +21,48 @@ namespace doris {\n \n StoragePageCache* StoragePageCache::_s_instance = nullptr;\n \n-void StoragePageCache::create_global_cache(size_t capacity) {\n+void StoragePageCache::create_global_cache(size_t capacity, int32_t index_cache_percentage) {\n     DCHECK(_s_instance == nullptr);\n-    static StoragePageCache instance(capacity);\n+    static StoragePageCache instance(capacity, index_cache_percentage);\n     _s_instance = &instance;\n }\n \n-StoragePageCache::StoragePageCache(size_t capacity)\n-        : _cache(new_lru_cache(\"StoragePageCache\", capacity)) {}\n+StoragePageCache::StoragePageCache(size_t capacity, int32_t index_cache_percentage)\n+        : _index_cache_percentage(index_cache_percentage) {\n+    if (index_cache_percentage == 0) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity));\n+    } else if (index_cache_percentage == 100) {\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity));\n+    } else if (index_cache_percentage > 0 && index_cache_percentage < 100) {\n+        _data_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"DataPageCache\", capacity * (100 - index_cache_percentage) / 100));\n+        _index_page_cache = std::unique_ptr<Cache>(new_lru_cache(\"IndexPageCache\", capacity * index_cache_percentage / 100));\n+    } else {\n+        CHECK(false) << \"invalid index page cache percentage\";\n+    }\n+}\n \n-bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle) {\n-    auto lru_handle = _cache->lookup(key.encode());\n+bool StoragePageCache::lookup(const CacheKey& key, PageCacheHandle* handle, segment_v2::PageTypePB page_type) {\n+    auto cache = _get_page_cache(page_type);\n+    auto lru_handle = cache->lookup(key.encode());\n     if (lru_handle == nullptr) {\n         return false;\n     }\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    *handle = PageCacheHandle(cache, lru_handle);\n     return true;\n }\n \n void StoragePageCache::insert(const CacheKey& key, const Slice& data, PageCacheHandle* handle,\n-                              bool in_memory) {\n+                              segment_v2::PageTypePB page_type, bool in_memory) {\n     auto deleter = [](const doris::CacheKey& key, void* value) { delete[](uint8_t*) value; };\n \n     CachePriority priority = CachePriority::NORMAL;\n     if (in_memory) {\n         priority = CachePriority::DURABLE;\n     }\n \n-    auto lru_handle = _cache->insert(key.encode(), data.data, data.size, deleter, priority);\n-    *handle = PageCacheHandle(_cache.get(), lru_handle);\n+    auto cache = _get_page_cache(page_type);", "originalCommit": "e0248a305493f08105722a75bf6cb4ac3394392c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzcxMw==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993713", "bodyText": "Same as above.", "author": "Skysheepwang", "createdAt": "2020-12-15T02:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM5MDkxMw==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542390913", "bodyText": "I think the check of is_cache_available() can be put into lookup() method for easy to use?\nAs well as the following insert logic", "author": "morningman", "createdAt": "2020-12-14T13:40:46Z", "path": "be/src/olap/rowset/segment_v2/page_io.cpp", "diffHunk": "@@ -112,7 +112,7 @@ Status PageIO::read_and_decompress_page(const PageReadOptions& opts, PageHandle*\n     auto cache = StoragePageCache::instance();\n     PageCacheHandle cache_handle;\n     StoragePageCache::CacheKey cache_key(opts.rblock->path(), opts.page_pointer.offset);\n-    if (opts.use_page_cache && cache->lookup(cache_key, &cache_handle)) {\n+    if (opts.use_page_cache && cache->is_cache_available(opts.type) && cache->lookup(cache_key, &cache_handle, opts.type)) {", "originalCommit": "e0248a305493f08105722a75bf6cb4ac3394392c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5MzE3Ng==", "url": "https://github.com/apache/incubator-doris/pull/5008#discussion_r542993176", "bodyText": "I choose to make the is_cache_available() check as an interface basically for two reasons:\n\nIf the check is failed (which means that the percentage is set to 0 or 100), the lookup() and insert() method will not be called, which could save some of the cost of parameter passing.\nIt will do minimal changes to the original read_and_decompress_page() method in page_io.cpp and remain its design on whether call the lookup() and insert() methods.", "author": "Skysheepwang", "createdAt": "2020-12-15T02:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM5MDkxMw=="}], "type": "inlineReview"}, {"oid": "adb95fce0b9a66d0973852278e7f41380270a614", "url": "https://github.com/apache/incubator-doris/commit/adb95fce0b9a66d0973852278e7f41380270a614", "message": "Implementation of Separated Page Cache", "committedDate": "2020-12-16T09:38:56Z", "type": "forcePushed"}, {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "message": "Implementation of Separated Page Cache", "committedDate": "2020-12-16T09:52:42Z", "type": "commit"}, {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "message": "Implementation of Separated Page Cache", "committedDate": "2020-12-16T09:52:42Z", "type": "forcePushed"}, {"oid": "2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "url": "https://github.com/apache/incubator-doris/commit/2149cfd9692f5b0d6875a7b4c5a5fbbd38cdd00d", "message": "Implementation of Separated Page Cache", "committedDate": "2020-12-16T09:52:42Z", "type": "forcePushed"}, {"oid": "140a8e52bd9e81d0bd339bee37f522884da1955c", "url": "https://github.com/apache/incubator-doris/commit/140a8e52bd9e81d0bd339bee37f522884da1955c", "message": "Merge branch 'master' into master", "committedDate": "2020-12-24T02:07:52Z", "type": "commit"}]}