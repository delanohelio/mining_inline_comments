{"pr_number": 3278, "pr_title": "Optimzie where cluase when have duplicate ors", "pr_createdAt": "2020-04-08T06:36:02Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3278", "timeline": [{"oid": "411a43e8f53435d2bb86999f5b66bf43476eb4d2", "url": "https://github.com/apache/incubator-doris/commit/411a43e8f53435d2bb86999f5b66bf43476eb4d2", "message": "optimize duplicated ors", "committedDate": "2020-04-08T06:37:00Z", "type": "forcePushed"}, {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba", "url": "https://github.com/apache/incubator-doris/commit/865e7124da66e3a956dffba1d40be4cb550048ba", "message": "optimize duplicated ors", "committedDate": "2020-04-08T07:56:43Z", "type": "commit"}, {"oid": "865e7124da66e3a956dffba1d40be4cb550048ba", "url": "https://github.com/apache/incubator-doris/commit/865e7124da66e3a956dffba1d40be4cb550048ba", "message": "optimize duplicated ors", "committedDate": "2020-04-08T07:56:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjgxNw==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405362817", "bodyText": "Could we move this improve to ExprRewriteRule ?", "author": "kangkaisen", "createdAt": "2020-04-08T08:52:15Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {", "originalCommit": "865e7124da66e3a956dffba1d40be4cb550048ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxMjIxMA==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405412210", "bodyText": "ExprRewriteRule will apply to expr bottom-up, this will make cannot get the longest or predicates, this rewrite needed  top-down", "author": "yangzhg", "createdAt": "2020-04-08T10:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MjQzOQ==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405582439", "bodyText": "Only exprs.size() < 2 is enough.\nexprs will not be NULL here.", "author": "morningman", "createdAt": "2020-04-08T14:48:13Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {", "originalCommit": "865e7124da66e3a956dffba1d40be4cb550048ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4MzI4MQ==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405583281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n          \n          \n            \n                    // 1. remove duplicated elements [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "author": "morningman", "createdAt": "2020-04-08T14:49:24Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]", "originalCommit": "865e7124da66e3a956dffba1d40be4cb550048ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NDA2NQ==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405584065", "bodyText": "Better NOT to modify the parameter. It will make the method error-prone", "author": "morningman", "createdAt": "2020-04-08T14:50:27Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();", "originalCommit": "865e7124da66e3a956dffba1d40be4cb550048ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NjE5Mw==", "url": "https://github.com/apache/incubator-doris/pull/3278#discussion_r405586193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"rewrite ors: \" + result.toSql());\n          \n          \n            \n                    LOG.debug(\"rewrite ors: \" + result.toSql());", "author": "morningman", "createdAt": "2020-04-08T14:53:13Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -504,6 +509,132 @@ private void whereClauseRewrite() {\n         }\n     }\n \n+    /**\n+     * this function only process (a and b and c) or (d and e and f) like clause,\n+     * this function will extract this to [[a, b, c], [d, e, f]]\n+     */\n+    private List<List<Expr>> extractDuplicateOrs(CompoundPredicate expr) {\n+        List<List<Expr>> orExprs = new ArrayList<>();\n+        for (Expr child : expr.getChildren()) {\n+            if (child instanceof CompoundPredicate) {\n+                CompoundPredicate childCp = (CompoundPredicate) child;\n+                if (childCp.getOp() == CompoundPredicate.Operator.OR) {\n+                    orExprs.addAll(extractDuplicateOrs(childCp));\n+                    continue;\n+                } else if (childCp.getOp() == CompoundPredicate.Operator.AND) {\n+                    orExprs.add(flatAndExpr(child));\n+                    continue;\n+                }\n+            }\n+            orExprs.add(Arrays.asList(child));\n+        }\n+        return orExprs;\n+    }\n+\n+    /**\n+     * This function attempts to apply the inverse OR distributive law:\n+     * ((A AND B) OR (A AND C))  =>  (A AND (B OR C))\n+     * That is, locate OR clauses in which every subclause contains an\n+     * identical term, and pull out the duplicated terms.\n+     */\n+    private Expr deduplicateOrs(Expr expr) {\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.OR) {\n+            Expr rewritedExpr = processDuplicateOrs(extractDuplicateOrs((CompoundPredicate) expr));\n+            if (rewritedExpr != null) {\n+                return rewritedExpr;\n+            }\n+        } else {\n+            for (int i = 0; i < expr.getChildren().size(); i++) {\n+                Expr rewritedExpr = deduplicateOrs(expr.getChild(i));\n+                if (rewritedExpr != null) {\n+                    expr.setChild(i, rewritedExpr);\n+                }\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    /**\n+     * try to flat and , a and b and c => [a, b, c]\n+     */\n+    private List<Expr> flatAndExpr(Expr expr) {\n+        List<Expr> andExprs = new ArrayList<>();\n+        if (expr instanceof CompoundPredicate && ((CompoundPredicate) expr).getOp() == CompoundPredicate.Operator.AND) {\n+            andExprs.addAll(flatAndExpr(expr.getChild(0)));\n+            andExprs.addAll(flatAndExpr(expr.getChild(1)));\n+        } else {\n+            andExprs.add(expr);\n+        }\n+        return andExprs;\n+    }\n+\n+    /**\n+     * the input is a list of list, the inner list is and connected exprs, the outer list is or connected\n+     * for example clause (a and b and c) or (a and e and f) after extractDuplicateOrs will be [[a, b, c], [a, e, f]]\n+     * this is the input of this function, first step is deduplicate [[a, b, c], [a, e, f]] => [[a], [b, c], [e, f]]\n+     * then rebuild the expr to a and ((b and c) or (e and f))\n+     */\n+    private Expr processDuplicateOrs(List<List<Expr>> exprs) {\n+        if (CollectionUtils.isEmpty(exprs) || exprs.size() < 2) {\n+            return null;\n+        }\n+        // 1. remove duplcated elemnents [[a,a], [a, b], [a,b]] => [[a], [a,b]]\n+        Set<Set<Expr>> set = new LinkedHashSet<>();\n+        for (List<Expr> ex : exprs) {\n+            Set<Expr> es = new LinkedHashSet<>();\n+            es.addAll(ex);\n+            set.add(es);\n+        }\n+        exprs.clear();\n+        for (Set<Expr> es : set) {\n+            List<Expr> el = new ArrayList<>();\n+            el.addAll(es);\n+            exprs.add(el);\n+        }\n+        if (exprs.size() == 1) {\n+            return makeCompound(exprs.get(0), CompoundPredicate.Operator.AND);\n+        }\n+        // 2. find duplcate cross the clause\n+        List<Expr> cloneExprs = new ArrayList<>(exprs.get(0));\n+        for (int i = 1; i < exprs.size(); ++i) {\n+            cloneExprs.retainAll(exprs.get(i));\n+        }\n+        List<Expr> temp = new ArrayList<>();\n+        if (CollectionUtils.isNotEmpty(cloneExprs)) {\n+            temp.add(makeCompound(cloneExprs, CompoundPredicate.Operator.AND));\n+        }\n+\n+        for (List<Expr> exprList : exprs) {\n+            exprList.removeAll(cloneExprs);\n+            temp.add(makeCompound(exprList, CompoundPredicate.Operator.AND));\n+        }\n+\n+        // rebuild CompoundPredicate if found duplicate predicate will build \uff08predcate) and (.. or ..)  predicate in\n+        // step 1: will build (.. or ..)\n+        Expr result = CollectionUtils.isNotEmpty(cloneExprs) ? new CompoundPredicate(CompoundPredicate.Operator.AND,\n+                temp.get(0), makeCompound(temp.subList(1, temp.size()), CompoundPredicate.Operator.OR))\n+                : makeCompound(temp, CompoundPredicate.Operator.OR);\n+        LOG.info(\"rewrite ors: \" + result.toSql());", "originalCommit": "865e7124da66e3a956dffba1d40be4cb550048ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c73cd6b81f747b4ee4ec490a169b9618e169991", "url": "https://github.com/apache/incubator-doris/commit/8c73cd6b81f747b4ee4ec490a169b9618e169991", "message": "fix some typo and pr comments", "committedDate": "2020-04-09T01:56:25Z", "type": "commit"}]}