{"pr_number": 2782, "pr_title": "Add file cache for v2", "pr_createdAt": "2020-01-16T13:04:08Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2782", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367409462", "bodyText": "How about change the name to make if different with another new_random_access_file() method?", "author": "morningman", "createdAt": "2020-01-16T13:14:17Z", "path": "be/src/env/env_posix.cpp", "diffHunk": "@@ -498,6 +499,11 @@ class PosixEnv : public Env {\n         return Status::OK();\n     }\n \n+    Status new_random_access_file(const std::string& fname,", "originalCommit": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxMzM1MQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367813351", "bodyText": "I think it is just ok, because of overload is common.", "author": "kangpinghuang", "createdAt": "2020-01-17T08:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NzQ1MQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368257451", "bodyText": "ok, I will add some comments.", "author": "kangpinghuang", "createdAt": "2020-01-19T00:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NTMzMw==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367795333", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                CONF_Int32(file_cache_expiry_period_ms, \"60000\");\n          \n          \n            \n                CONF_Int32(fd_cache_expiry_period_ms, \"60000\");", "author": "gaodayue", "createdAt": "2020-01-17T07:10:20Z", "path": "be/src/common/config.h", "diffHunk": "@@ -221,6 +221,7 @@ namespace config {\n     CONF_Bool(row_nums_check, \"true\")\n     //file descriptors cache, by default, cache 32768 descriptors\n     CONF_Int32(file_descriptor_cache_capacity, \"32768\");\n+    CONF_Int32(file_cache_expiry_period_ms, \"60000\");", "originalCommit": "1a7a5b0c62dbc8a1858c6e1ebe278b0b8d824f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM3NQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275375", "bodyText": "done", "author": "kangpinghuang", "createdAt": "2020-01-19T08:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzAyNA==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823024", "bodyText": "what does the TODO mean here?", "author": "gaodayue", "createdAt": "2020-01-17T08:45:27Z", "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)", "originalCommit": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM3OA==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275378", "bodyText": "remove", "author": "kangpinghuang", "createdAt": "2020-01-19T08:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzI3Ng==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823276", "bodyText": "The third argument should be 1, since cache's capacity is set to max_open_files.", "author": "gaodayue", "createdAt": "2020-01-17T08:46:11Z", "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);", "originalCommit": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM5OQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275399", "bodyText": "done", "author": "kangpinghuang", "createdAt": "2020-01-19T08:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzc5Nw==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r367823797", "bodyText": "what does the TODO mean?", "author": "gaodayue", "createdAt": "2020-01-17T08:47:28Z", "path": "be/src/util/file_cache.cpp", "diffHunk": "@@ -0,0 +1,416 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/file_cache.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <ostream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include <chrono>\n+#include <functional>\n+\n+#include \"env/env.h\"\n+#include \"gutil/strings/substitute.h\"\n+\n+namespace doris {\n+\n+namespace internal {\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        // TODO(hkp)\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, sizeof(file_ptr), deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        // TODO(hkp): use lru_cache to replace", "originalCommit": "5b4a8168a3f5aa79480e4c3e4158b5f592c11788", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3NTM5Mg==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368275392", "bodyText": "remove", "author": "kangpinghuang", "createdAt": "2020-01-19T08:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMzc5Nw=="}], "type": "inlineReview"}, {"oid": "d608ed68c47e613cc414a7cb5e1eff9ae0c11aaf", "url": "https://github.com/apache/incubator-doris/commit/d608ed68c47e613cc414a7cb5e1eff9ae0c11aaf", "message": "add file cache for segment v2", "committedDate": "2020-01-19T08:35:40Z", "type": "commit"}, {"oid": "46cbeacde38d1db9dd7634fd72aac89c4b4beee3", "url": "https://github.com/apache/incubator-doris/commit/46cbeacde38d1db9dd7634fd72aac89c4b4beee3", "message": "add fd cache for segment v2", "committedDate": "2020-01-19T08:35:40Z", "type": "commit"}, {"oid": "a9bb63ede54be47ca6824bc325422509a6e7d7ec", "url": "https://github.com/apache/incubator-doris/commit/a9bb63ede54be47ca6824bc325422509a6e7d7ec", "message": "fix expiry thread init bug", "committedDate": "2020-01-19T08:35:40Z", "type": "commit"}, {"oid": "d18db99c1c49302561884e8c530782fb59d47390", "url": "https://github.com/apache/incubator-doris/commit/d18db99c1c49302561884e8c530782fb59d47390", "message": "optimze read by using file handle to read in iterator", "committedDate": "2020-01-19T08:35:40Z", "type": "commit"}, {"oid": "d18db99c1c49302561884e8c530782fb59d47390", "url": "https://github.com/apache/incubator-doris/commit/d18db99c1c49302561884e8c530782fb59d47390", "message": "optimze read by using file handle to read in iterator", "committedDate": "2020-01-19T08:35:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODUyMQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278521", "bodyText": "I think second is enough", "author": "imay", "createdAt": "2020-01-19T09:23:08Z", "path": "be/src/common/config.h", "diffHunk": "@@ -221,6 +221,7 @@ namespace config {\n     CONF_Bool(row_nums_check, \"true\")\n     //file descriptors cache, by default, cache 32768 descriptors\n     CONF_Int32(file_descriptor_cache_capacity, \"32768\");\n+    CONF_Int32(fd_cache_expiry_period_ms, \"60000\");", "originalCommit": "d18db99c1c49302561884e8c530782fb59d47390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODc2Mw==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278763", "bodyText": "I think this function is not necessary, the above function can achieve your purpose.\nstd::unique_ptr<RandomAccessFile> file;\nnew_random_access_file(opts, fname, &file);\nstd::shared_ptr<RandomAccessFile> shared_file(file.release());\n\nAnd this is not a good way to make file cache in this env. Need to let the caller decide whether to cache.", "author": "imay", "createdAt": "2020-01-19T09:27:17Z", "path": "be/src/env/env.h", "diffHunk": "@@ -73,6 +76,9 @@ class Env {\n                                           const std::string& fname,\n                                           std::unique_ptr<RandomAccessFile>* result) = 0;\n \n+    virtual Status new_random_access_file(const std::string& fname,", "originalCommit": "d18db99c1c49302561884e8c530782fb59d47390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODkyNQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368278925", "bodyText": "should add some UT for this new added class.", "author": "imay", "createdAt": "2020-01-19T09:30:14Z", "path": "be/src/util/file_cache.h", "diffHunk": "@@ -0,0 +1,316 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <condition_variable>\n+#include <mutex>\n+#include <thread>\n+\n+#include \"common/status.h\"\n+#include \"env/env.h\"\n+#include \"util/spinlock.h\"\n+#include \"util/once.h\"\n+#include \"olap/lru_cache.h\"\n+\n+namespace doris {\n+\n+class Env;\n+\n+template <class FileType>\n+class FileCache;\n+\n+template <class FileType>\n+class OpenedFileHandle;\n+\n+namespace internal {\n+\n+template <class FileType>\n+class Descriptor;\n+\n+} // namespace internal\n+\n+// Encapsulates common descriptor fields and methods.\n+template <class FileType>\n+class BaseDescriptor {\n+public:\n+    BaseDescriptor(FileCache<FileType>* file_cache, const std::string& filename)\n+        : _file_cache(file_cache), _file_name(filename) { }\n+\n+    ~BaseDescriptor() {\n+        // The (now expired) weak_ptr remains in '_descriptors', to be removed\n+        // by the next call to RunDescriptorExpiry(). Removing it here would\n+        // risk a deadlock on recursive acquisition of '_lock'.\n+\n+        if (deleted()) {\n+            cache()->erase(filename());\n+\n+            WARN_IF_ERROR(env()->delete_file(filename()), \"delete file failed:\");\n+        }\n+    }\n+\n+    // Insert a pointer to an open file object(FileType*) into the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the inserted entry. The handle always contains an\n+    // open file.\n+    OpenedFileHandle<FileType> insert_into_cache(void* file_ptr) const {\n+        auto deleter = [](const doris::CacheKey& key, void* value) {\n+            delete (FileType*)value;\n+        };\n+        FileType* file = reinterpret_cast<FileType*>(file_ptr);\n+        CacheKey key(file->file_name());\n+        auto lru_handle = cache()->insert(key, file_ptr, 1, deleter);\n+        return OpenedFileHandle<FileType>(this, lru_handle);\n+    }\n+\n+    // Retrieves a pointer to an open file object from the file cache with the\n+    // filename as the cache key.\n+    //\n+    // Returns a handle to the looked up entry. The handle may or may not\n+    // contain an open file, depending on whether the cache hit or missed.\n+    OpenedFileHandle<FileType> lookup_from_cache() const {\n+        CacheKey key(filename());\n+        return OpenedFileHandle<FileType>(this, cache()->lookup(key));\n+    }\n+\n+    // Mark this descriptor as to-be-deleted later.\n+    void mark_deleted() {\n+        DCHECK(!deleted());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | FILE_DELETED)) return;\n+        }\n+    }\n+\n+    // Mark this descriptor as invalidated. No further access is allowed\n+    // to this file.\n+    void mark_invalidated() {\n+        DCHECK(!invalidated());\n+        while (true) {\n+            auto v = _flags.load();\n+            if (_flags.compare_exchange_weak(v, v | INVALIDATED)) return;\n+        }\n+    }\n+\n+    Cache* cache() const { return _file_cache->_cache.get(); }\n+\n+    Env* env() const { return _file_cache->_env; }\n+\n+    const std::string& filename() const { return _file_name; }\n+\n+    bool deleted() const { return _flags.load() & FILE_DELETED; }\n+    bool invalidated() const { return _flags.load() & INVALIDATED; }\n+\n+private:\n+    FileCache<FileType>* _file_cache;\n+    std::string _file_name;\n+    enum Flags { FILE_DELETED = 1 << 0, INVALIDATED = 1 << 1 };\n+    std::atomic<uint8_t> _flags{0};\n+\n+    DISALLOW_COPY_AND_ASSIGN(BaseDescriptor);\n+};\n+\n+// A \"smart\" retrieved LRU cache handle.\n+//\n+// The cache handle is released when this object goes out of scope, possibly\n+// closing the opened file if it is no longer in the cache.\n+template <class FileType>\n+class OpenedFileHandle {\n+public:\n+    // A not-yet-but-soon-to-be opened descriptor.\n+    explicit OpenedFileHandle(const BaseDescriptor<FileType>* desc)\n+        : _desc(desc), _handle(nullptr) { }\n+\n+    // An opened descriptor. Its handle may or may not contain an open file.\n+    OpenedFileHandle(const BaseDescriptor<FileType>* desc,\n+                     Cache::Handle* handle) : _desc(desc), _handle(handle) { }\n+\n+    ~OpenedFileHandle() {\n+        if (_handle != nullptr) {\n+            _desc->cache()->release(_handle);\n+        }\n+    }\n+\n+    OpenedFileHandle(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+    }\n+\n+    OpenedFileHandle& operator=(OpenedFileHandle&& other) noexcept {\n+        std::swap(_desc, other._desc);\n+        std::swap(_handle, other._handle);\n+        return *this;\n+    }\n+\n+    bool opened() {\n+        return _handle != nullptr;\n+    }\n+\n+    FileType* file() const {\n+        DCHECK(_handle != nullptr);\n+        return reinterpret_cast<FileType*>(_desc->cache()->value(_handle));\n+    }\n+\n+private:\n+    const BaseDescriptor<FileType>* _desc;\n+    Cache::Handle* _handle;\n+};\n+\n+// Cache of open files.\n+//\n+// The purpose of this cache is to enforce an upper bound on the maximum number\n+// of files open at a time. Files opened through the cache may be closed at any\n+// time, only to be reopened upon next use.\n+//\n+// The file cache can be viewed as having two logical parts: the client-facing\n+// API and the LRU cache.\n+//\n+// Client-facing API\n+// -----------------\n+// The core of the client-facing API is the cache descriptor. A descriptor\n+// uniquely identifies an opened file. To a client, a descriptor is just an\n+// open file interface of the variety defined in util/env.h. Clients open\n+// descriptors via the OpenExistingFile() cache method.\n+//\n+// Descriptors are shared objects; an existing descriptor is handed back to a\n+// client if a file with the same name is already opened. To facilitate\n+// descriptor sharing, the file cache maintains a by-file-name descriptor map.\n+// The values are weak references to the descriptors so that map entries don't\n+// affect the descriptor lifecycle.\n+//\n+// LRU cache\n+// ---------\n+// The lower half of the file cache is a standard LRU cache whose keys are file\n+// names and whose values are pointers to opened file objects allocated on the\n+// heap. Unlike the descriptor map, this cache has an upper bound on capacity,\n+// and handles are evicted (and closed) according to an LRU algorithm.\n+//\n+// Whenever a descriptor is used by a client in file I/O, its file name is used\n+// in an LRU cache lookup. If found, the underlying file is still open and the\n+// file access is performed. Otherwise, the file must have been evicted and\n+// closed, so it is reopened and reinserted (possibly evicting a different open\n+// file) before the file access is performed.\n+//\n+// Other notes\n+// -----------\n+// In a world where files are opened and closed transparently, file deletion\n+// demands special care if UNIX semantics are to be preserved. When a call to\n+// DeleteFile() is made to a file with an opened descriptor, the descriptor is\n+// simply \"marked\" as to-be-deleted-later. Only when all references to the\n+// descriptor are dropped is the file actually deleted. If there is no open\n+// descriptor, the file is deleted immediately.\n+//\n+// Every public method in the file cache is thread safe.\n+template <class FileType>\n+class FileCache {", "originalCommit": "d18db99c1c49302561884e8c530782fb59d47390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyODE5OA==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r368428198", "bodyText": "done", "author": "kangpinghuang", "createdAt": "2020-01-20T08:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3ODkyNQ=="}], "type": "inlineReview"}, {"oid": "80b69d599e792fdb4a20249d810fca669c9b8e08", "url": "https://github.com/apache/incubator-doris/commit/80b69d599e792fdb4a20249d810fca669c9b8e08", "message": "optimize file cache", "committedDate": "2020-01-20T08:54:42Z", "type": "commit"}, {"oid": "83f3af2d42ecd7f96e37adc6845a8954d5c1cac2", "url": "https://github.com/apache/incubator-doris/commit/83f3af2d42ecd7f96e37adc6845a8954d5c1cac2", "message": "add missed file", "committedDate": "2020-02-03T03:12:36Z", "type": "commit"}, {"oid": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "url": "https://github.com/apache/incubator-doris/commit/0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "message": "fix wrong variable", "committedDate": "2020-02-03T04:21:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk4OTM0OQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373989349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                explicit BitmapIndexReader(const std::string file_name,\n          \n          \n            \n                explicit BitmapIndexReader(const std::string& file_name,", "author": "imay", "createdAt": "2020-02-03T09:13:08Z", "path": "be/src/olap/rowset/segment_v2/bitmap_index_reader.h", "diffHunk": "@@ -40,9 +40,9 @@ class IndexedColumnIterator;\n \n class BitmapIndexReader {\n public:\n-    explicit BitmapIndexReader(RandomAccessFile* file,\n+    explicit BitmapIndexReader(const std::string file_name,", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NDUzNA==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373994534", "bodyText": "Is OpenedFileCache better?", "author": "imay", "createdAt": "2020-02-03T09:24:59Z", "path": "be/src/util/file_cache.h", "diffHunk": "@@ -0,0 +1,129 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"olap/lru_cache.h\"\n+\n+namespace doris {\n+\n+class Env;\n+\n+// A \"smart\" retrieved LRU cache handle.\n+//\n+// The cache handle is released when this object goes out of scope, possibly\n+// closing the opened file if it is no longer in the cache.\n+template <class FileType>\n+class OpenedFileHandle {\n+public:\n+    OpenedFileHandle() : _cache(nullptr), _handle(nullptr) { }\n+\n+    // A opened file handle\n+    explicit OpenedFileHandle(Cache* cache, Cache::Handle* handle)\n+        : _cache(cache), _handle(handle) { }\n+\n+    // release cache handle\n+    ~OpenedFileHandle() {\n+        if (_handle != nullptr) {\n+            _cache->release(_handle);\n+        }\n+    }\n+\n+    OpenedFileHandle(OpenedFileHandle&& other) noexcept {\n+        std::swap(_cache, other._cache);\n+        std::swap(_handle, other._handle);\n+    }\n+\n+    OpenedFileHandle& operator=(OpenedFileHandle&& other) noexcept {\n+        std::swap(_cache, other._cache);\n+        std::swap(_handle, other._handle);\n+        return *this;\n+    }\n+\n+    FileType* file() const {\n+        DCHECK(_handle != nullptr);\n+        return reinterpret_cast<FileType*>(_cache->value(_handle));\n+    }\n+\n+private:\n+    Cache* _cache;\n+    Cache::Handle* _handle;\n+};\n+\n+// Cache of open files.\n+//\n+// The purpose of this cache is to enforce an upper bound on the maximum number\n+// of files open at a time. Files opened through the cache may be closed at any\n+// time, only to be reopened upon next use.\n+//\n+// The file cache can be viewed as having two logical parts: the client-facing\n+// File handle and the LRU cache.\n+//\n+// Client-facing API\n+// -----------------\n+// The core of the client-facing API is the cache descriptor. A descriptor\n+\n+// LRU cache\n+// ---------\n+// The lower half of the file cache is a standard LRU cache whose keys are file\n+// names and whose values are pointers to opened file objects allocated on the\n+// heap. Unlike the descriptor map, this cache has an upper bound on capacity,\n+// and handles are evicted (and closed) according to an LRU algorithm.\n+//\n+// Whenever a descriptor is used by a client in file I/O, its file name is used\n+// in an LRU cache lookup. If found, the underlying file is still open and the\n+// file access is performed. Otherwise, the file must have been evicted and\n+// closed, so it is reopened and reinserted (possibly evicting a different open\n+// file) before the file access is performed.\n+//\n+// Every public method in the file cache is thread safe.\n+template <class FileType>\n+class FileCache {", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NjgyMQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373996821", "bodyText": "Why not use OpenedFileHandle directly?", "author": "imay", "createdAt": "2020-02-03T09:29:52Z", "path": "be/src/olap/rowset/segment_v2/segment_iterator.h", "diffHunk": "@@ -120,6 +121,9 @@ class SegmentIterator : public RowwiseIterator {\n     // used to binary search the rowid for a given key\n     // only used in `_get_row_ranges_by_keys`\n     std::unique_ptr<RowBlockV2> _seek_block;\n+\n+    // Handle for file to read\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODIxMw==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998213", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                RandomAccessFile* _file;\n          \n          \n            \n                RandomAccessFile* _file = nullptr;", "author": "imay", "createdAt": "2020-02-03T09:32:48Z", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;\n+    // file to read\n+    RandomAccessFile* _file;", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODI3NQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998275", "bodyText": "Use OpenedFileHandle directly?", "author": "imay", "createdAt": "2020-02-03T09:32:55Z", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5ODM3OQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r373998379", "bodyText": "use OpenedFileHandle directly?", "author": "imay", "createdAt": "2020-02-03T09:33:08Z", "path": "be/src/olap/rowset/segment_v2/indexed_column_reader.h", "diffHunk": "@@ -131,6 +140,10 @@ class IndexedColumnIterator {\n     std::unique_ptr<ParsedPage> _data_page;\n     // next_batch() will read from this position\n     rowid_t _current_rowid = 0;\n+    // open file handle\n+    std::unique_ptr<OpenedFileHandle<RandomAccessFile>> _file_handle;", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwOTU3MQ==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r374009571", "bodyText": "is it useful?", "author": "imay", "createdAt": "2020-02-03T09:55:37Z", "path": "be/src/env/env.h", "diffHunk": "@@ -230,6 +233,12 @@ class RandomAccessFile {\n     RandomAccessFile() { }\n     virtual ~RandomAccessFile() { }\n \n+    // get the cache handle of file\n+    // only realized for file in cache\n+    virtual Status file_handle(std::unique_ptr<OpenedFileHandle<RandomAccessFile>>* file) {", "originalCommit": "0668e1aa846e9e0a3a0dd0251c41d19a38bfd34a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "450e16613032a2dfcd5ea983109d11d5b01293ea", "url": "https://github.com/apache/incubator-doris/commit/450e16613032a2dfcd5ea983109d11d5b01293ea", "message": "modify pr comment", "committedDate": "2020-02-03T14:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE1NzY4Nw==", "url": "https://github.com/apache/incubator-doris/pull/2782#discussion_r374157687", "bodyText": "useless", "author": "imay", "createdAt": "2020-02-03T15:12:36Z", "path": "be/src/env/env.h", "diffHunk": "@@ -25,6 +25,9 @@ class WritableFileOptions;\n class RandomAccessFileOptions;\n class RandomRWFileOptions;\n \n+template <class FileType>", "originalCommit": "450e16613032a2dfcd5ea983109d11d5b01293ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "edc4c2553037f59ebd203d3916e6229653ec33ca", "url": "https://github.com/apache/incubator-doris/commit/edc4c2553037f59ebd203d3916e6229653ec33ca", "message": "remove useless code", "committedDate": "2020-02-03T15:14:29Z", "type": "commit"}]}