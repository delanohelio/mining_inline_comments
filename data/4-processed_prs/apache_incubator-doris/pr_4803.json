{"pr_number": 4803, "pr_title": "[Feature] Add Topn udaf", "pr_createdAt": "2020-10-27T07:29:40Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4803", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwMzY2OA==", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r528203668", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                required uint64  count = 2;\n          \n          \n            \n                required uint64 count = 2;", "author": "morningman", "createdAt": "2020-11-21T14:43:04Z", "path": "gensrc/proto/olap_common.proto", "diffHunk": "@@ -48,3 +48,14 @@ enum CompressKind {\n     COMPRESS_LZ4 = 2;\n }\n \n+message PCounter {\n+    required string item = 1;\n+    required uint64  count = 2;", "originalCommit": "03fbc56c62acade492594c47a2a97b876c349b39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNDA5MQ==", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r528204091", "bodyText": "How about using JSON format output?", "author": "morningman", "createdAt": "2020-11-21T14:47:31Z", "path": "be/src/util/topn_counter.cpp", "diffHunk": "@@ -0,0 +1,138 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include \"gen_cpp/olap_common.pb.h\"\n+#include \"topn_counter.h\"\n+#include \"slice.h\"\n+\n+namespace doris {\n+\n+void TopNCounter::add_item(const std::string& item, uint64_t incrementCount) {\n+    auto iter = _counter_map->find(item);\n+    if (iter != _counter_map->end()) {\n+        iter->second.add_count(incrementCount);\n+    } else {\n+        _counter_map->insert(std::make_pair(item, Counter(item, incrementCount)));\n+    }\n+    _ordered = false;\n+}\n+\n+void TopNCounter::serialize(std::string* buffer) {\n+    sort_retain(_capacity);\n+    PTopNCounter topn_counter;\n+    topn_counter.set_top_num(_top_num);\n+    topn_counter.set_space_expand_rate(_space_expand_rate);\n+    for(std::vector<Counter>::const_iterator it = _counter_vec->begin(); it != _counter_vec->end(); ++it)\n+    {\n+        PCounter* counter = topn_counter.add_counter();\n+        counter->set_item(it->get_item());\n+        counter->set_count(it->get_count());\n+    }\n+    topn_counter.SerializeToString(buffer);\n+}\n+\n+bool TopNCounter::deserialize(const doris::Slice &src) {\n+    PTopNCounter topn_counter;\n+    if (!topn_counter.ParseFromArray(src.data, src.size)) {\n+        LOG(WARNING) << \"topn counter deserialize failed\";\n+        return false;\n+    }\n+\n+    _space_expand_rate = topn_counter.space_expand_rate();\n+    set_top_num(topn_counter.top_num());\n+    for (int i = 0; i < topn_counter.counter_size(); ++i) {\n+        const PCounter& counter = topn_counter.counter(i);\n+        _counter_map->insert(std::make_pair(counter.item(), Counter(counter.item(), counter.count())));\n+        _counter_vec->emplace_back(counter.item(), counter.count());\n+    }\n+    _ordered = true;\n+    return true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity) {\n+    _counter_vec->clear();\n+    sort_retain(capacity, _counter_vec);\n+    _ordered = true;\n+}\n+\n+void TopNCounter::sort_retain(uint32_t capacity, std::vector<Counter>* sort_vec) {\n+    for(std::unordered_map<std::string, Counter>::const_iterator it = _counter_map->begin(); it != _counter_map->end(); ++it) {\n+        sort_vec->emplace_back(it->second.get_item(), it->second.get_count());\n+    }\n+\n+    std::sort(sort_vec->begin(), sort_vec->end(), TopNComparator());\n+    if (sort_vec->size() > capacity) {\n+        for (uint32_t i = 0, n = sort_vec->size() - capacity; i < n; ++i) {\n+            auto &counter = sort_vec->back();\n+            _counter_map->erase(counter.get_item());\n+            sort_vec->pop_back();\n+        }\n+    }\n+}\n+\n+// Based on the  parallel version of the Space Saving algorithm as described in:\n+// A parallel space saving algorithm for frequent items and the Hurwitz zeta distribution by Massimo Cafaro, et al.\n+void TopNCounter::merge(doris::TopNCounter &&other) {\n+    if (other._counter_map->size() == 0) {\n+        return;\n+    }\n+\n+    _space_expand_rate = other._space_expand_rate;\n+    set_top_num(other._top_num);\n+    bool this_full = _counter_map->size() >= _capacity;\n+    bool another_full = other._counter_map->size() >= other._capacity;\n+\n+    uint64_t m1 = this_full ? _counter_vec->back().get_count() : 0;\n+    uint64_t m2 = another_full ? other._counter_vec->back().get_count() : 0;\n+   \n+    if (another_full == true) {\n+        for (auto &entry : *(this->_counter_map)) {\n+            entry.second.add_count(m2);\n+        }\n+    }\n+\n+    for (auto &other_entry : *(other._counter_map)) {\n+        auto itr = this->_counter_map->find(other_entry.first);\n+        if (itr != _counter_map->end()) {\n+            itr->second.add_count(other_entry.second.get_count() - m2);\n+        } else {\n+            this->_counter_map->insert(std::make_pair(other_entry.first,\n+                    Counter(other_entry.first,other_entry.second.get_count() + m1)));\n+        }\n+    }\n+    _ordered = false;\n+    sort_retain(_capacity);\n+}\n+\n+void TopNCounter::finalize(std::string& finalize_str) {", "originalCommit": "03fbc56c62acade492594c47a2a97b876c349b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEwMjA3NA==", "url": "https://github.com/apache/incubator-doris/pull/4803#discussion_r543102074", "bodyText": "ok,done", "author": "Youngwb", "createdAt": "2020-12-15T07:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNDA5MQ=="}], "type": "inlineReview"}, {"oid": "0c55b7cc139736fe8c0609e885596598ff05e7be", "url": "https://github.com/apache/incubator-doris/commit/0c55b7cc139736fe8c0609e885596598ff05e7be", "message": "topn", "committedDate": "2020-12-15T03:04:55Z", "type": "commit"}, {"oid": "55c79cc4764009d1bf37822038a00091c64b48af", "url": "https://github.com/apache/incubator-doris/commit/55c79cc4764009d1bf37822038a00091c64b48af", "message": "add doc", "committedDate": "2020-12-15T03:05:04Z", "type": "commit"}, {"oid": "1a5ec0617c896f9522c8438e30bd81a260e50375", "url": "https://github.com/apache/incubator-doris/commit/1a5ec0617c896f9522c8438e30bd81a260e50375", "message": "Update gensrc/proto/olap_common.proto\n\nCo-authored-by: Mingyu Chen <morningman.cmy@gmail.com>", "committedDate": "2020-12-15T03:05:04Z", "type": "commit"}, {"oid": "1a5ec0617c896f9522c8438e30bd81a260e50375", "url": "https://github.com/apache/incubator-doris/commit/1a5ec0617c896f9522c8438e30bd81a260e50375", "message": "Update gensrc/proto/olap_common.proto\n\nCo-authored-by: Mingyu Chen <morningman.cmy@gmail.com>", "committedDate": "2020-12-15T03:05:04Z", "type": "forcePushed"}, {"oid": "1f187d5ac564094007bb51f4176fe0344c969801", "url": "https://github.com/apache/incubator-doris/commit/1f187d5ac564094007bb51f4176fe0344c969801", "message": "json result", "committedDate": "2020-12-15T06:21:16Z", "type": "commit"}, {"oid": "0ab589d5ddc85981145e6cf516f91ac64099354a", "url": "https://github.com/apache/incubator-doris/commit/0ab589d5ddc85981145e6cf516f91ac64099354a", "message": "fix test", "committedDate": "2020-12-15T07:17:01Z", "type": "commit"}]}