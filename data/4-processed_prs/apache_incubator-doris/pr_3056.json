{"pr_number": 3056, "pr_title": "implement except node", "pr_createdAt": "2020-03-09T03:10:41Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3056", "timeline": [{"oid": "7907e605127c6c4972e0db066055e6e4a4f722f3", "url": "https://github.com/apache/incubator-doris/commit/7907e605127c6c4972e0db066055e6e4a4f722f3", "message": "implement except node", "committedDate": "2020-03-09T03:16:57Z", "type": "forcePushed"}, {"oid": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "url": "https://github.com/apache/incubator-doris/commit/f8f32a4d3e4dde0daef959f20eecd66fb309804a", "message": "implement except node", "committedDate": "2020-03-10T11:41:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMzg0NA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390323844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "morningman", "createdAt": "2020-03-10T13:47:14Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}", "originalCommit": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzMjU0OA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390332548", "bodyText": "Should it be\n_hash_tbl_iterator == _hash_tbl->end()", "author": "morningman", "createdAt": "2020-03-10T13:59:27Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,158 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {", "originalCommit": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMzNTAwOQ==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390335009", "bodyText": "What this for? Could you add comment to explain this rewrite?", "author": "morningman", "createdAt": "2020-03-10T14:02:57Z", "path": "fe/src/main/java/org/apache/doris/analysis/SetOperationStmt.java", "diffHunk": "@@ -649,6 +648,13 @@ public void analyze(Analyzer parent) throws AnalysisException, UserException {\n             if (isAnalyzed()) {\n                 return;\n             }\n+            if (queryStmt instanceof SelectStmt && ((SelectStmt) queryStmt).fromClause_.isEmpty()) {", "originalCommit": "f8f32a4d3e4dde0daef959f20eecd66fb309804a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5abb4947cf850faa8b653866d86e7901fe07781b", "url": "https://github.com/apache/incubator-doris/commit/5abb4947cf850faa8b653866d86e7901fe07781b", "message": "implement except node", "committedDate": "2020-03-11T01:52:29Z", "type": "forcePushed"}, {"oid": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "url": "https://github.com/apache/incubator-doris/commit/cbd649b19d05a2870dc4d3f39d1243061cd764a6", "message": "implement except node", "committedDate": "2020-03-11T02:15:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTkyMQ==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390729921", "bodyText": "why do you use  'if (!_hash_tbl_iterator.matched())'?\nmay be you should use ' if (_hash_tbl_iterator.matched())'\nmatched means exceptNode", "author": "wutiangan", "createdAt": "2020-03-11T03:39:04Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {", "originalCommit": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDUzNw==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390734537", "bodyText": "a excepte b , use a to build a hash table and use b to probe\nthe result is  element in a and never mached", "author": "yangzhg", "createdAt": "2020-03-11T04:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMTQ3Mw==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390731473", "bodyText": "How about if the hash value of hashtable is - 1\uff1f", "author": "wutiangan", "createdAt": "2020-03-11T03:46:27Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {", "originalCommit": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDk1NA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390734954", "bodyText": "because hash value  is a unsigned int", "author": "yangzhg", "createdAt": "2020-03-11T04:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMjAxNg==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r390732016", "bodyText": "If the two hash values are equal, it does not mean that the two values are equal. You need to compare the original values.\nThere may be a problem with the else's logic", "author": "wutiangan", "createdAt": "2020-03-11T03:48:52Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +40,157 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[1], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        if (i != _children.size() - 1) {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+            previous_hash = _hash_tbl_iterator.get_hash();\n+            if (!_hash_tbl_iterator.matched()) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+            }\n+        }", "originalCommit": "cbd649b19d05a2870dc4d3f39d1243061cd764a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "727b5048355f0092fed2eb8a54efd0e547b90bd3", "url": "https://github.com/apache/incubator-doris/commit/727b5048355f0092fed2eb8a54efd0e547b90bd3", "message": "implement except node", "committedDate": "2020-03-11T08:49:34Z", "type": "forcePushed"}, {"oid": "9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "url": "https://github.com/apache/incubator-doris/commit/9ffa4f6ecda7a71667728d2d427b58af18d43f0b", "message": "implement except node", "committedDate": "2020-03-11T09:41:05Z", "type": "forcePushed"}, {"oid": "8382d2c4f6b04213f474753222e29f4d44fa7aa4", "url": "https://github.com/apache/incubator-doris/commit/8382d2c4f6b04213f474753222e29f4d44fa7aa4", "message": "implement except node", "committedDate": "2020-03-11T09:42:59Z", "type": "forcePushed"}, {"oid": "92ded2b1b77a542900d8af4b7498431ad48d778d", "url": "https://github.com/apache/incubator-doris/commit/92ded2b1b77a542900d8af4b7498431ad48d778d", "message": "implement except node", "committedDate": "2020-03-12T10:19:10Z", "type": "forcePushed"}, {"oid": "25a0421f0d5724a069e6d02cd368c01dea22f9a3", "url": "https://github.com/apache/incubator-doris/commit/25a0421f0d5724a069e6d02cd368c01dea22f9a3", "message": "implement except node", "committedDate": "2020-03-12T10:21:57Z", "type": "forcePushed"}, {"oid": "3c389d87d741591e0be2195d86ee5d108c6bc6d3", "url": "https://github.com/apache/incubator-doris/commit/3c389d87d741591e0be2195d86ee5d108c6bc6d3", "message": "implement except node", "committedDate": "2020-03-12T12:38:11Z", "type": "forcePushed"}, {"oid": "0b9b7b13d3b513540873b661af36bb4be3ba22ac", "url": "https://github.com/apache/incubator-doris/commit/0b9b7b13d3b513540873b661af36bb4be3ba22ac", "message": "implement except node", "committedDate": "2020-03-12T12:47:10Z", "type": "forcePushed"}, {"oid": "0af0965cd0c69396220547174f0f0af29e502d09", "url": "https://github.com/apache/incubator-doris/commit/0af0965cd0c69396220547174f0f0af29e502d09", "message": "implement except node", "committedDate": "2020-03-12T12:48:58Z", "type": "forcePushed"}, {"oid": "a29557713b40217ed8b9382836ac478e23a0495c", "url": "https://github.com/apache/incubator-doris/commit/a29557713b40217ed8b9382836ac478e23a0495c", "message": "implement except node", "committedDate": "2020-03-12T12:53:49Z", "type": "forcePushed"}, {"oid": "114592c40f47c1444ff2b57b301728d73e401e0c", "url": "https://github.com/apache/incubator-doris/commit/114592c40f47c1444ff2b57b301728d73e401e0c", "message": "implement except node", "committedDate": "2020-03-12T13:09:35Z", "type": "forcePushed"}, {"oid": "0c173175e897b39c0b49086986c40e814bb1a8dc", "url": "https://github.com/apache/incubator-doris/commit/0c173175e897b39c0b49086986c40e814bb1a8dc", "message": "implement except node", "committedDate": "2020-03-12T13:11:05Z", "type": "forcePushed"}, {"oid": "fa077db918bc11ac23ae339790ff481d94dc1417", "url": "https://github.com/apache/incubator-doris/commit/fa077db918bc11ac23ae339790ff481d94dc1417", "message": "implement except node", "committedDate": "2020-03-12T13:18:01Z", "type": "forcePushed"}, {"oid": "1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "url": "https://github.com/apache/incubator-doris/commit/1887fba5e89af8f1b3ca691db0ecdfcfbab935e6", "message": "implement except node", "committedDate": "2020-03-12T13:21:00Z", "type": "forcePushed"}, {"oid": "784e6c40d167844dd7e589d48937456ffa450281", "url": "https://github.com/apache/incubator-doris/commit/784e6c40d167844dd7e589d48937456ffa450281", "message": "implement except node", "committedDate": "2020-03-13T01:55:46Z", "type": "forcePushed"}, {"oid": "b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "url": "https://github.com/apache/incubator-doris/commit/b4a1ef5ce2e568a56596c8df503f0d7b5ce0c4ec", "message": "implement except node", "committedDate": "2020-03-13T01:57:41Z", "type": "forcePushed"}, {"oid": "cd5988a0258ef181fc737adc103f1c867236e63a", "url": "https://github.com/apache/incubator-doris/commit/cd5988a0258ef181fc737adc103f1c867236e63a", "message": "implement except node", "committedDate": "2020-03-13T01:58:53Z", "type": "forcePushed"}, {"oid": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "url": "https://github.com/apache/incubator-doris/commit/06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "message": "implement except node", "committedDate": "2020-03-13T03:17:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODA3OQ==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392178079", "bodyText": "Remove this line.", "author": "kangkaisen", "createdAt": "2020-03-13T11:40:57Z", "path": "be/src/exec/exec_node.cpp", "diffHunk": "@@ -446,9 +446,9 @@ Status ExecNode::create_node(RuntimeState* state, ObjectPool* pool, const TPlanN\n         *node = pool->add(new IntersectNode(pool, tnode, descs));\n         return Status::OK();\n \n-    // case TPlanNodeType::EXCEPT_NODE:\n-    //     *node = pool->add(new ExceptNode(pool, tnode, descs));\n-    //     return Status::OK();", "originalCommit": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwMzk4OQ==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392203989", "bodyText": "comment in wrong place \uff1f", "author": "yangzhg", "createdAt": "2020-03-13T12:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE3ODA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392184633", "bodyText": "This if statement could remove ?", "author": "kangkaisen", "createdAt": "2020-03-13T11:56:42Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {", "originalCommit": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwNDU3Mg==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392204572", "bodyText": "this for a safe guard", "author": "yangzhg", "createdAt": "2020-03-13T12:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwNjg2Mw==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392206863", "bodyText": "I don't see any meaning.", "author": "kangkaisen", "createdAt": "2020-03-13T12:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0NDY0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392244642", "bodyText": "this for a safe guard\n\nI think kaisen means this if (row == nullptr && other == nullptr) clause is meaningless because you write another if (row == nullptr || other == nullptr) below.", "author": "morningman", "createdAt": "2020-03-13T13:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392185880", "bodyText": "why continue?", "author": "kangkaisen", "createdAt": "2020-03-13T11:59:48Z", "path": "be/src/exec/except_node.cpp", "diffHunk": "@@ -56,4 +41,190 @@ Status ExceptNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status ExceptNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_timer = ADD_TIMER(runtime_profile(), \"BuildTime\");\n+    _probe_timer = ADD_TIMER(runtime_profile(), \"ProbeTime\");\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_build_tuple_size, true);\n+    return Status::OK();\n+}\n+Status ExceptNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+    return ExecNode::close(state);\n+}\n+Status ExceptNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+    // initial build hash table, use _child_expr_lists[0] as probe is used for remove duplicted\n+    _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[0], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+    RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+    RETURN_IF_ERROR(child(0)->open(state));\n+\n+    bool eos = false;\n+    while (!eos) {\n+        SCOPED_TIMER(_build_timer);\n+        RETURN_IF_CANCELLED(state);\n+        RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+        // take ownership of tuple data of build_batch\n+        _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+        RETURN_IF_LIMIT_EXCEEDED(state, \" Except, while constructing the hash table.\");\n+        // build hash table and remvoe duplicate items\n+        for (int i = 0; i < build_batch.num_rows(); ++i) {\n+            _hash_tbl->insert_unique(build_batch.get_row(i));\n+        }\n+        VLOG_ROW << \"hash table content: \" << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+        build_batch.reset();\n+    }\n+    // if a table is empty, the result must be empty\n+\n+    if (_hash_tbl->size() == 0) {\n+        _hash_tbl_iterator = _hash_tbl->begin();\n+        return Status::OK();\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // rebuid hash table, for first time will rebuild with the no duplicated _hash_tbl,\n+        if (i > 1) {\n+            SCOPED_TIMER(_build_timer);\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  true, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            uint32_t previous_hash = -1;\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (previous_hash != _hash_tbl_iterator.get_hash()) {\n+                    previous_hash = _hash_tbl_iterator.get_hash();\n+                    if (!_hash_tbl_iterator.matched()) {\n+                        temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                    }\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl.swap(temp_tbl);\n+            temp_tbl->close();\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        ScopedTimer<MonotonicStopWatch> probe_timer(_probe_timer);\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        eos = false;\n+        while (!eos) {\n+            RETURN_IF_CANCELLED(state);\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Except , while probing the hash table.\");\n+            for (int j = 0; j < _probe_batch->num_rows(); ++j) {\n+                _hash_tbl_iterator = _hash_tbl->find(_probe_batch->get_row(j));\n+                if (_hash_tbl_iterator != _hash_tbl->end()) {\n+                    _hash_tbl_iterator.set_matched();\n+                }\n+            }\n+            _probe_batch->reset();\n+        }\n+        // if a table is empty, the result must be empty\n+        if (_hash_tbl->size() == 0) {\n+            break;\n+        }\n+    }\n+    _hash_tbl_iterator = _hash_tbl->begin();\n+    return Status::OK();\n+}\n+\n+Status ExceptNode::get_next(RuntimeState* state, RowBatch* out_batch, bool* eos) {\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::GETNEXT));\n+    RETURN_IF_CANCELLED(state);\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    *eos = true;\n+    if (reached_limit()) {\n+        return Status::OK();\n+    }\n+    uint32_t previous_hash = -1;\n+    TupleRow* previous_row = nullptr;\n+    while (_hash_tbl_iterator.has_next()) {\n+        if (!_hash_tbl_iterator.matched()) {\n+            if (previous_hash != _hash_tbl_iterator.get_hash() ||\n+                !equals(previous_row, _hash_tbl_iterator.get_row())) {\n+                int row_idx = out_batch->add_row();\n+                TupleRow* out_row = out_batch->get_row(row_idx);\n+                uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out_row);\n+                memcpy(out_ptr, _hash_tbl_iterator.get_row(), _build_tuple_row_size);\n+                out_batch->commit_last_row();\n+                ++_num_rows_returned;\n+            }\n+        }\n+        previous_hash = _hash_tbl_iterator.get_hash();\n+        previous_row = _hash_tbl_iterator.get_row();\n+        _hash_tbl_iterator.next<false>();\n+\n+        *eos = !_hash_tbl_iterator.has_next() || reached_limit();\n+        if (out_batch->is_full() || out_batch->at_resource_limit() || *eos) {\n+            return Status::OK();\n+        }\n+    }\n+    return Status::OK();\n+}\n+\n+bool ExceptNode::equals(TupleRow* row, TupleRow* other) {\n+    if (row == nullptr && other == nullptr) {\n+        return false;\n+    }\n+    if (row == nullptr || other == nullptr) {\n+        return false;\n+    }\n+    for (int i = 0; i < _child_expr_lists[0].size(); ++i) {\n+        void* val_row = _child_expr_lists[0][i]->get_value(row);\n+        void* val_other = _child_expr_lists[0][i]->get_value(other);\n+        if (val_row == nullptr && val_other == nullptr) {\n+            continue;", "originalCommit": "06b13e2ebc7c0facd2aa5d56bbc7529ccfc6e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwMzE1NQ==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392203155", "bodyText": "for nullable value when is null", "author": "yangzhg", "createdAt": "2020-03-13T12:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIwOTIwNA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r392209204", "bodyText": "If _child_expr_lists[0].size is 1. ExceptNode::equals will return true. which is your expectation \uff1f which should be conflicting with else if (val_row == nullptr || val_other == nullptr) { return false;", "author": "kangkaisen", "createdAt": "2020-03-13T12:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQwMzU5OA==", "url": "https://github.com/apache/incubator-doris/pull/3056#discussion_r393403598", "bodyText": "if table a is\nc1\n---\nnull\n\ntable b is\nc2\n---\nnull\n\nif caluse is\nselect c1 from a except select c2 from b \nwill hit val_row == nullptr && val_other == nullptr\nnull and null is equal", "author": "yangzhg", "createdAt": "2020-03-17T01:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE4NTg4MA=="}], "type": "inlineReview"}, {"oid": "10bd38aef60ad500dbaf4234cbea8f031be221fe", "url": "https://github.com/apache/incubator-doris/commit/10bd38aef60ad500dbaf4234cbea8f031be221fe", "message": "implement except node", "committedDate": "2020-03-17T01:48:56Z", "type": "forcePushed"}, {"oid": "9c3e401b9e331f5289cca318fcd7833809160c98", "url": "https://github.com/apache/incubator-doris/commit/9c3e401b9e331f5289cca318fcd7833809160c98", "message": "implement except node", "committedDate": "2020-03-17T02:40:31Z", "type": "commit"}, {"oid": "9c3e401b9e331f5289cca318fcd7833809160c98", "url": "https://github.com/apache/incubator-doris/commit/9c3e401b9e331f5289cca318fcd7833809160c98", "message": "implement except node", "committedDate": "2020-03-17T02:40:31Z", "type": "forcePushed"}]}