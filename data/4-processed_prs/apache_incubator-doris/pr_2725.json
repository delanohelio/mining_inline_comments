{"pr_number": 2725, "pr_title": "Add timestampadd/timestampdiff function", "pr_createdAt": "2020-01-10T03:51:57Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2725", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDE0MQ==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365064141", "bodyText": "remove it?", "author": "kangkaisen", "createdAt": "2020-01-10T03:57:23Z", "path": "be/src/exprs/timestamp_functions.cpp", "diffHunk": "@@ -351,6 +351,92 @@ DateTimeVal TimestampFunctions::timestamp_time_op(\n     return new_ts_val;\n }\n \n+BigIntVal TimestampFunctions::years_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<YEAR>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::months_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<MONTH>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::weeks_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<WEEK>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::days_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<DAY>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::hours_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<HOUR>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::minutes_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<MINUTE>(ctx, ts_val1, ts_val2);\n+}\n+\n+BigIntVal TimestampFunctions::seconds_diff(\n+        FunctionContext* ctx, const DateTimeVal& ts_val1, const DateTimeVal& ts_val2) {\n+    return timestamp_diff<SECOND>(ctx, ts_val1, ts_val2);\n+}\n+\n+template <TimeUnit unit>\n+BigIntVal TimestampFunctions::timestamp_diff(FunctionContext* ctx, const DateTimeVal& ts_val2, const DateTimeVal& ts_val1) {\n+    std::cout << \"null\" << std::endl;", "originalCommit": "f5bd079a53cf6b6e0a38375fd58e95283ec90321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTMwNA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365065304", "bodyText": "Sorry, I forget", "author": "HangyuanLiu", "createdAt": "2020-01-10T04:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDUyNw==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365064527", "bodyText": "remove this comment?", "author": "kangkaisen", "createdAt": "2020-01-10T04:00:00Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,65 +120,142 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                // The first child must return a timestamp or null.\n+                if (!getChild(1).getType().isDateType() && !getChild(1).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 1);\n+                }\n+\n+                type = Type.BIGINT;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit, \"DIFF\");\n             } else {\n-                throw new AnalysisException(\"Encountered function name '\" + funcName\n-                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n-                        + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE'\"\n-                        + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                if (funcName.toUpperCase().equals(\"DATE_ADD\")\n+                        || funcName.toUpperCase().equals(\"DAYS_ADD\")\n+                        || funcName.toUpperCase().equals(\"ADDDATE\")\n+                        || funcName.toUpperCase().equals(\"TIMESTAMPADD\")) {\n+                    op = ArithmeticExpr.Operator.ADD;\n+                } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n+                        || funcName.toUpperCase().equals(\"DAYS_SUB\")\n+                        || funcName.toUpperCase().equals(\"SUBDATE\")) {\n+                    op = ArithmeticExpr.Operator.SUBTRACT;\n+                } else {\n+                    throw new AnalysisException(\"Encountered function name '\" + funcName\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n+                            + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE/TIMESTAMPADD'\"\n+                            + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                }\n+\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                if (!getChild(1).getType().isScalarType()) {\n+                    throw new AnalysisException(\"must be a scalar type.\");\n+                }\n+\n+                // The second child must be of type 'INT' or castable to it.\n+                if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                    if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                    }\n+                    castChild(Type.INT, 1);\n+                }\n+\n+                type = dateType;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                        (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+                // For the month interval, use the invisible special-case implementation.", "originalCommit": "f5bd079a53cf6b6e0a38375fd58e95283ec90321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTMyMg==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365065322", "bodyText": "Done", "author": "HangyuanLiu", "createdAt": "2020-01-10T04:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc0MQ==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365064741", "bodyText": "fn is {} name is {} thie log should be remove or change to debug level.  There will be a lot of this log from doris 0.11", "author": "kangkaisen", "createdAt": "2020-01-10T04:01:12Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,65 +120,142 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                // The first child must return a timestamp or null.\n+                if (!getChild(1).getType().isDateType() && !getChild(1).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 1);\n+                }\n+\n+                type = Type.BIGINT;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit, \"DIFF\");\n             } else {\n-                throw new AnalysisException(\"Encountered function name '\" + funcName\n-                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n-                        + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE'\"\n-                        + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                if (funcName.toUpperCase().equals(\"DATE_ADD\")\n+                        || funcName.toUpperCase().equals(\"DAYS_ADD\")\n+                        || funcName.toUpperCase().equals(\"ADDDATE\")\n+                        || funcName.toUpperCase().equals(\"TIMESTAMPADD\")) {\n+                    op = ArithmeticExpr.Operator.ADD;\n+                } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n+                        || funcName.toUpperCase().equals(\"DAYS_SUB\")\n+                        || funcName.toUpperCase().equals(\"SUBDATE\")) {\n+                    op = ArithmeticExpr.Operator.SUBTRACT;\n+                } else {\n+                    throw new AnalysisException(\"Encountered function name '\" + funcName\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n+                            + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE/TIMESTAMPADD'\"\n+                            + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                }\n+\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                if (!getChild(1).getType().isScalarType()) {\n+                    throw new AnalysisException(\"must be a scalar type.\");\n+                }\n+\n+                // The second child must be of type 'INT' or castable to it.\n+                if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                    if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                    }\n+                    castChild(Type.INT, 1);\n+                }\n+\n+                type = dateType;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                        (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+                // For the month interval, use the invisible special-case implementation.\n+                // \"ADD_MONTHS(t, m)\" by definition is different from \"t + INTERVAL m MONTHS\".\n+                // if (timeUnit == TimeUnit.MONTH) {\n+                //     funcOpName += \"_INTERVAL\";\n+                // }\n+            }\n+        } else {\n+            timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+            if (timeUnit == null) {\n+                throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n             }\n-        }\n-        timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n-        if (timeUnit == null) {\n-            throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n-                    + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n-        }\n \n-        Type dateType = fixType();\n-        if (dateType.isDate() && timeUnit.isDateTime()) {\n-            dateType = Type.DATETIME;\n-        }\n-        // The first child must return a timestamp or null.\n-        if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n-            if (!dateType.isValid()) {\n-                throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n-                        + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n-                        + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+            Type dateType = fixType();\n+            if (dateType.isDate() && timeUnit.isDateTime()) {\n+                dateType = Type.DATETIME;\n+            }\n+            // The first child must return a timestamp or null.\n+            if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                if (!dateType.isValid()) {\n+                    throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                            + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                            + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                }\n+                castChild(dateType, 0);\n             }\n-            castChild(dateType, 0);\n-        }\n \n-        if (!getChild(1).getType().isScalarType()) {\n-            throw new AnalysisException(\"must be a scalar type.\");\n-        }\n+            if (!getChild(1).getType().isScalarType()) {\n+                throw new AnalysisException(\"must be a scalar type.\");\n+            }\n \n-        // The second child must be of type 'INT' or castable to it.\n-        if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n-            if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n-                throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n-                        + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n-                        + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+            // The second child must be of type 'INT' or castable to it.\n+            if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                    throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                            + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                            + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                }\n+                castChild(Type.INT, 1);\n             }\n-            castChild(Type.INT, 1);\n-        }\n \n-        type = dateType;\n-        opcode = getOpCode();\n-        String funcOpName = String.format(\"%sS_%s\",  timeUnit,\n-                (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n-        // For the month interval, use the invisible special-case implementation.\n-        // \"ADD_MONTHS(t, m)\" by definition is different from \"t + INTERVAL m MONTHS\".\n-        // if (timeUnit == TimeUnit.MONTH) {\n-        //     funcOpName += \"_INTERVAL\";\n-        // }\n+            type = dateType;\n+            opcode = getOpCode();\n+            funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                    (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+        }\n \n         fn = getBuiltinFunction(analyzer, funcOpName.toLowerCase(),\n                 collectChildReturnTypes(), Function.CompareMode.IS_NONSTRICT_SUPERTYPE_OF);", "originalCommit": "f5bd079a53cf6b6e0a38375fd58e95283ec90321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTM1MA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365065350", "bodyText": "OK", "author": "HangyuanLiu", "createdAt": "2020-01-10T04:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc0MQ=="}], "type": "inlineReview"}, {"oid": "c02ed755e82978733568dc583f9d880ddbbbfd6e", "url": "https://github.com/apache/incubator-doris/commit/c02ed755e82978733568dc583f9d880ddbbbfd6e", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T04:03:49Z", "type": "commit"}, {"oid": "c02ed755e82978733568dc583f9d880ddbbbfd6e", "url": "https://github.com/apache/incubator-doris/commit/c02ed755e82978733568dc583f9d880ddbbbfd6e", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T04:03:49Z", "type": "forcePushed"}, {"oid": "d2ea231dafa23da6aecc51973eea53c3fdfa625c", "url": "https://github.com/apache/incubator-doris/commit/d2ea231dafa23da6aecc51973eea53c3fdfa625c", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T08:10:16Z", "type": "commit"}, {"oid": "d2ea231dafa23da6aecc51973eea53c3fdfa625c", "url": "https://github.com/apache/incubator-doris/commit/d2ea231dafa23da6aecc51973eea53c3fdfa625c", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T08:10:16Z", "type": "forcePushed"}, {"oid": "68dc4e40193855ec6203d9588fc49dcc9ed1ca16", "url": "https://github.com/apache/incubator-doris/commit/68dc4e40193855ec6203d9588fc49dcc9ed1ca16", "message": "add doc", "committedDate": "2020-01-10T08:10:48Z", "type": "commit"}, {"oid": "f22d576b34594911b5ac7d561c493df77c05b3ec", "url": "https://github.com/apache/incubator-doris/commit/f22d576b34594911b5ac7d561c493df77c05b3ec", "message": "Merge remote-tracking branch 'origin/timestampdiff' into timestampdiff\n\n# Conflicts:\n#\tbe/src/exprs/timestamp_functions.cpp\n#\tbe/test/exprs/timestamp_functions_test.cpp", "committedDate": "2020-01-10T08:11:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUyMDExNw==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365520117", "bodyText": "should add this new keyword to keywords rule", "author": "imay", "createdAt": "2020-01-11T12:58:39Z", "path": "fe/src/main/cup/sql_parser.cup", "diffHunk": "@@ -3779,8 +3783,29 @@ timestamp_arithmetic_expr ::=\n \n     RESULT = new TimestampArithmeticExpr(functionName.getFunction(), l.get(0), v, u);\n   :}\n+  | function_name:functionName LPAREN unit:u COMMA expr:e1 COMMA expr:e2 RPAREN\n+  {:\n+    RESULT = new TimestampArithmeticExpr(functionName.getFunction(), e2, e1, u);\n+  :}\n   ;\n \n+unit ::=\n+    KW_YEAR", "originalCommit": "f22d576b34594911b5ac7d561c493df77c05b3ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUyMDY4OQ==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365520689", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # day\n          \n          \n            \n            # TIMESTAMPADD", "author": "imay", "createdAt": "2020-01-11T13:11:24Z", "path": "docs/documentation/cn/sql-reference/sql-functions/date-time-functions/timestampadd.md", "diffHunk": "@@ -0,0 +1,52 @@\n+<!-- \n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+# day", "originalCommit": "f22d576b34594911b5ac7d561c493df77c05b3ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUyMDY5OA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365520698", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # day\n          \n          \n            \n            # TIMESTAMPDIFF", "author": "imay", "createdAt": "2020-01-11T13:11:37Z", "path": "docs/documentation/cn/sql-reference/sql-functions/date-time-functions/timestampdiff.md", "diffHunk": "@@ -0,0 +1,60 @@\n+<!-- \n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+# day", "originalCommit": "f22d576b34594911b5ac7d561c493df77c05b3ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "afeaba2202af796189bedb6ddbabbbeb51de1094", "url": "https://github.com/apache/incubator-doris/commit/afeaba2202af796189bedb6ddbabbbeb51de1094", "message": "fix format", "committedDate": "2020-01-13T07:12:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNzg1NA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365807854", "bodyText": "seems that these codes are the same with others.\nCould you try to reduce these same code?", "author": "imay", "createdAt": "2020-01-13T13:39:35Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,69 +120,141 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }", "originalCommit": "afeaba2202af796189bedb6ddbabbbeb51de1094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b478b4dba14f6874060b3bd57a27cf3f9da0859", "url": "https://github.com/apache/incubator-doris/commit/8b478b4dba14f6874060b3bd57a27cf3f9da0859", "message": "fix format", "committedDate": "2020-01-14T04:07:15Z", "type": "commit"}, {"oid": "8b478b4dba14f6874060b3bd57a27cf3f9da0859", "url": "https://github.com/apache/incubator-doris/commit/8b478b4dba14f6874060b3bd57a27cf3f9da0859", "message": "fix format", "committedDate": "2020-01-14T04:07:15Z", "type": "forcePushed"}]}