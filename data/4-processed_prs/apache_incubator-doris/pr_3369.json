{"pr_number": 3369, "pr_title": "Support txn management in db level isolation and use ArrayDeque to improve txn task performance", "pr_createdAt": "2020-04-21T14:20:01Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3369", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MzkzNA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r412283934", "bodyText": "Please add some comment for this class", "author": "morningman", "createdAt": "2020-04-21T15:25:24Z", "path": "fe/src/main/java/org/apache/doris/transaction/DatabaseTransactionMgr.java", "diffHunk": "@@ -0,0 +1,556 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.transaction;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.persist.EditLog;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.ClearTransactionTask;\n+import org.apache.doris.task.PublishVersionTask;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+public class DatabaseTransactionMgr {", "originalCommit": "fd06610e4f848c84a3ac18b22c358a4dfd27593d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NzAwNw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r412287007", "bodyText": "finalStatusTransactionStateDeque is not thread safe. So does it matter to call this without ReadLock?", "author": "morningman", "createdAt": "2020-04-21T15:28:55Z", "path": "fe/src/main/java/org/apache/doris/transaction/DatabaseTransactionMgr.java", "diffHunk": "@@ -0,0 +1,556 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.transaction;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.ErrorCode;\n+import org.apache.doris.common.ErrorReport;\n+import org.apache.doris.common.util.TimeUtils;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.mysql.privilege.PrivPredicate;\n+import org.apache.doris.persist.EditLog;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.task.AgentBatchTask;\n+import org.apache.doris.task.AgentTaskExecutor;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.ClearTransactionTask;\n+import org.apache.doris.task.PublishVersionTask;\n+import org.apache.doris.thrift.TTaskType;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+public class DatabaseTransactionMgr {\n+\n+    private static final Logger LOG = LogManager.getLogger(DatabaseTransactionMgr.class);\n+\n+    // the lock is used to control the access to transaction states\n+    // no other locks should be inside this lock\n+    private ReentrantReadWriteLock transactionLock = new ReentrantReadWriteLock(true);\n+\n+    // transactionId -> running TransactionState\n+    private Map<Long, TransactionState> idToRunningTransactionState = Maps.newHashMap();\n+\n+    // transactionId -> final status TransactionState\n+    private Map<Long, TransactionState> idToFinalStatusTransactionState = Maps.newHashMap();\n+\n+\n+    // to store transtactionStates with final status\n+    private ArrayDeque<TransactionState> finalStatusTransactionStateDeque = new ArrayDeque<>();\n+\n+    // label -> txn ids\n+    // this is used for checking if label already used. a label may correspond to multiple txns,\n+    // and only one is success.\n+    // this member should be consistent with idToTransactionState,\n+    // which means if a txn exist in idToRunningTransactionState or idToFinalStatusTransactionState\n+    // it must exists in dbIdToTxnLabels, and vice versa\n+    private Map<String, Set<Long>> labelToTxnIds = Maps.newConcurrentMap();\n+\n+\n+    // count the number of running txns of database, except for the routine load txn\n+    private AtomicInteger runningTxnNums = new AtomicInteger(0);\n+\n+    // count only the number of running routine load txns of database\n+    private AtomicInteger runningRoutineLoadTxnNums = new AtomicInteger(0);\n+\n+    private EditLog editLog;\n+\n+    private List<ClearTransactionTask> clearTransactionTasks = Lists.newArrayList();\n+\n+    protected void readLock() {\n+        this.transactionLock.readLock().lock();\n+    }\n+\n+    protected void readUnlock() {\n+        this.transactionLock.readLock().unlock();\n+    }\n+\n+    protected void writeLock() {\n+        this.transactionLock.writeLock().lock();\n+    }\n+\n+    protected void writeUnlock() {\n+        this.transactionLock.writeLock().unlock();\n+    }\n+\n+    public DatabaseTransactionMgr(EditLog editLog) {\n+        this.editLog = editLog;\n+    }\n+\n+    public TransactionState getTransactionState(Long transactionId) {\n+        TransactionState transactionState = idToRunningTransactionState.get(transactionId);\n+        if (transactionState != null) {\n+            return transactionState;\n+        } else {\n+            return idToFinalStatusTransactionState.get(transactionId);\n+        }\n+    }\n+\n+    public Set<Long> getTxnIdsByLabel(String label) {\n+        return labelToTxnIds.get(label);\n+    }\n+\n+    public int getRunningTxnNums() {\n+        return runningTxnNums.get();\n+    }\n+\n+    public int getRunningRoutineLoadTxnNums() {\n+        return runningRoutineLoadTxnNums.get();\n+    }\n+\n+    public int getFinishedTxnNums() {\n+        return finalStatusTransactionStateDeque.size();\n+    }\n+\n+    public List<List<String>> getTxnStateInfoList(boolean running, int limit) {\n+        List<List<String>> infos = Lists.newArrayList();\n+        Collection<TransactionState> transactionStateCollection = null;\n+        readLock();\n+        try {\n+            if (running) {\n+                transactionStateCollection = idToRunningTransactionState.values();\n+            } else {\n+                transactionStateCollection = finalStatusTransactionStateDeque;\n+            }\n+            // get transaction order by txn id desc limit 'limit'\n+            transactionStateCollection.stream()\n+                    .sorted(TransactionState.TXN_ID_COMPARATOR)\n+                    .limit(limit)\n+                    .forEach(t -> {\n+                        List<String> info = Lists.newArrayList();\n+                        getTxnStateInfo(t, info);\n+                        infos.add(info);\n+                    });\n+        } finally {\n+            readUnlock();\n+        }\n+        return infos;\n+    }\n+\n+    private void getTxnStateInfo(TransactionState txnState, List<String> info) {\n+        info.add(String.valueOf(txnState.getTransactionId()));\n+        info.add(txnState.getLabel());\n+        info.add(txnState.getCoordinator().toString());\n+        info.add(txnState.getTransactionStatus().name());\n+        info.add(txnState.getSourceType().name());\n+        info.add(TimeUtils.longToTimeString(txnState.getPrepareTime()));\n+        info.add(TimeUtils.longToTimeString(txnState.getCommitTime()));\n+        info.add(TimeUtils.longToTimeString(txnState.getFinishTime()));\n+        info.add(txnState.getReason());\n+        info.add(String.valueOf(txnState.getErrorReplicas().size()));\n+        info.add(String.valueOf(txnState.getCallbackId()));\n+        info.add(String.valueOf(txnState.getTimeoutMs()));\n+    }\n+\n+    public void deleteTransaction(TransactionState transactionState) {\n+        writeLock();\n+        try {\n+            // here we only delete the oldest element, so if element exist in finalStatusTransactionStateDeque,\n+            // it must at the front of the finalStatusTransactionStateDeque\n+            if (!finalStatusTransactionStateDeque.isEmpty() &&\n+            transactionState.getTransactionId() == finalStatusTransactionStateDeque.getFirst().getTransactionId()) {\n+                finalStatusTransactionStateDeque.pop();\n+                idToFinalStatusTransactionState.remove(transactionState.getTransactionId());\n+                Set<Long> txnIds = labelToTxnIds.get(transactionState.getLabel());\n+                txnIds.remove(transactionState.getTransactionId());\n+                if (txnIds.isEmpty()) {\n+                    labelToTxnIds.remove(transactionState.getLabel());\n+                }\n+            }\n+        } finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    public Map<Long, TransactionState> getIdToRunningTransactionState() {\n+        return idToRunningTransactionState;\n+    }\n+\n+    public ArrayDeque<TransactionState> getFinalStatusTransactionStateDeque() {\n+        return finalStatusTransactionStateDeque;\n+    }\n+\n+    protected void  unprotectedCommitTransaction(TransactionState transactionState, Set<Long> errorReplicaIds,\n+                                               Map<Long, Set<Long>> tableToPartition, Set<Long> totalInvolvedBackends,\n+                                               Database db) {\n+        // transaction state is modified during check if the transaction could committed\n+        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE) {\n+            return;\n+        }\n+        // update transaction state version\n+        transactionState.setCommitTime(System.currentTimeMillis());\n+        transactionState.setTransactionStatus(TransactionStatus.COMMITTED);\n+        transactionState.setErrorReplicas(errorReplicaIds);\n+        for (long tableId : tableToPartition.keySet()) {\n+            TableCommitInfo tableCommitInfo = new TableCommitInfo(tableId);\n+            for (long partitionId : tableToPartition.get(tableId)) {\n+                OlapTable table = (OlapTable) db.getTable(tableId);\n+                Partition partition = table.getPartition(partitionId);\n+                PartitionCommitInfo partitionCommitInfo = new PartitionCommitInfo(partitionId,\n+                        partition.getNextVersion(),\n+                        partition.getNextVersionHash());\n+                tableCommitInfo.addPartitionCommitInfo(partitionCommitInfo);\n+            }\n+            transactionState.putIdToTableCommitInfo(tableId, tableCommitInfo);\n+        }\n+        // persist transactionState\n+        unprotectUpsertTransactionState(transactionState, false);\n+\n+        // add publish version tasks. set task to null as a placeholder.\n+        // tasks will be created when publishing version.\n+        for (long backendId : totalInvolvedBackends) {\n+            transactionState.addPublishVersionTask(backendId, null);\n+        }\n+    }\n+\n+    // for add/update/delete TransactionState\n+    protected void unprotectUpsertTransactionState(TransactionState transactionState, boolean isReplay) {\n+        // if this is a replay operation, we should not log it\n+        if (!isReplay) {\n+            if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE\n+                    || transactionState.getSourceType() == TransactionState.LoadJobSourceType.FRONTEND) {\n+                // if this is a prepare txn, and load source type is not FRONTEND\n+                // no need to persist it. if prepare txn lost, the following commit will just be failed.\n+                // user only need to retry this txn.\n+                // The FRONTEND type txn is committed and running asynchronously, so we have to persist it.\n+                editLog.logInsertTransactionState(transactionState);\n+            }\n+        }\n+\n+        if (transactionState.isRunning()) {\n+            idToRunningTransactionState.put(transactionState.getTransactionId(), transactionState);\n+        } else {\n+            idToRunningTransactionState.remove(transactionState.getTransactionId());\n+            idToFinalStatusTransactionState.put(transactionState.getTransactionId(), transactionState);\n+            finalStatusTransactionStateDeque.add(transactionState);\n+        }\n+\n+        updateTxnLabels(transactionState);\n+        updateDbRunningTxnNum(transactionState.getPreStatus(), transactionState);\n+    }\n+\n+    private void updateTxnLabels(TransactionState transactionState) {\n+        Set<Long> txnIds = labelToTxnIds.get(transactionState.getLabel());\n+        if (txnIds == null) {\n+            txnIds = Sets.newHashSet();\n+            labelToTxnIds.put(transactionState.getLabel(), txnIds);\n+        }\n+        txnIds.add(transactionState.getTransactionId());\n+    }\n+\n+    private void updateDbRunningTxnNum(TransactionStatus preStatus, TransactionState curTxnState) {\n+        AtomicInteger txnNum = null;\n+        if (curTxnState.getSourceType() == TransactionState.LoadJobSourceType.ROUTINE_LOAD_TASK) {\n+            txnNum = runningRoutineLoadTxnNums;\n+        } else {\n+            txnNum = runningTxnNums;\n+        }\n+\n+        if (preStatus == null\n+                && (curTxnState.getTransactionStatus() == TransactionStatus.PREPARE\n+                || curTxnState.getTransactionStatus() == TransactionStatus.COMMITTED)) {\n+            txnNum.incrementAndGet();\n+        } else if ((preStatus == TransactionStatus.PREPARE\n+                || preStatus == TransactionStatus.COMMITTED)\n+                && (curTxnState.getTransactionStatus() == TransactionStatus.VISIBLE\n+                || curTxnState.getTransactionStatus() == TransactionStatus.ABORTED)) {\n+            txnNum.decrementAndGet();\n+        }\n+    }\n+\n+    public void abortTransaction(long transactionId, String reason, TxnCommitAttachment txnCommitAttachment) throws UserException {\n+        if (transactionId < 0) {\n+            LOG.info(\"transaction id is {}, less than 0, maybe this is an old type load job, ignore abort operation\", transactionId);\n+            return;\n+        }\n+        TransactionState transactionState = idToRunningTransactionState.get(transactionId);\n+        if (transactionState == null) {\n+            throw new UserException(\"transaction not found\");\n+        }\n+\n+        // update transaction state extra if exists\n+        if (txnCommitAttachment != null) {\n+            transactionState.setTxnCommitAttachment(txnCommitAttachment);\n+        }\n+\n+        // before state transform\n+        transactionState.beforeStateTransform(TransactionStatus.ABORTED);\n+        boolean txnOperated = false;\n+        writeLock();\n+        try {\n+            txnOperated = unprotectAbortTransaction(transactionId, reason);\n+        } finally {\n+            writeUnlock();\n+            transactionState.afterStateTransform(TransactionStatus.ABORTED, txnOperated, reason);\n+        }\n+\n+        // send clear txn task to BE to clear the transactions on BE.\n+        // This is because parts of a txn may succeed in some BE, and these parts of txn should be cleared\n+        // explicitly, or it will be remained on BE forever\n+        // (However the report process will do the diff and send clear txn tasks to BE, but that is our\n+        // last defense)\n+        if (txnOperated && transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n+            clearBackendTransactions(transactionState);\n+        }\n+    }\n+\n+    private boolean unprotectAbortTransaction(long transactionId, String reason)\n+            throws UserException {\n+        TransactionState transactionState = getTransactionState(transactionId);\n+        if (transactionState == null) {\n+            throw new UserException(\"transaction not found\");\n+        }\n+        if (transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n+            return false;\n+        }\n+        if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED\n+                || transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n+            throw new UserException(\"transaction's state is already \"\n+                    + transactionState.getTransactionStatus() + \", could not abort\");\n+        }\n+        transactionState.setFinishTime(System.currentTimeMillis());\n+        transactionState.setReason(reason);\n+        transactionState.setTransactionStatus(TransactionStatus.ABORTED);\n+        unprotectUpsertTransactionState(transactionState, false);\n+        for (PublishVersionTask task : transactionState.getPublishVersionTasks().values()) {\n+            AgentTaskQueue.removeTask(task.getBackendId(), TTaskType.PUBLISH_VERSION, task.getSignature());\n+        }\n+        return true;\n+    }\n+\n+    private void clearBackendTransactions(TransactionState transactionState) {\n+        Preconditions.checkState(transactionState.getTransactionStatus() == TransactionStatus.ABORTED);\n+        // for aborted transaction, we don't know which backends are involved, so we have to send clear task\n+        // to all backends.\n+        List<Long> allBeIds = Catalog.getCurrentSystemInfo().getBackendIds(false);\n+        AgentBatchTask batchTask = null;\n+        synchronized (clearTransactionTasks) {\n+            for (Long beId : allBeIds) {\n+                ClearTransactionTask task = new ClearTransactionTask(beId, transactionState.getTransactionId(), Lists.newArrayList());\n+                clearTransactionTasks.add(task);\n+            }\n+\n+            // try to group send tasks, not sending every time a txn is aborted. to avoid too many task rpc.\n+            if (clearTransactionTasks.size() > allBeIds.size() * 2) {\n+                batchTask = new AgentBatchTask();\n+                for (ClearTransactionTask clearTransactionTask : clearTransactionTasks) {\n+                    batchTask.addTask(clearTransactionTask);\n+                }\n+                clearTransactionTasks.clear();\n+            }\n+        }\n+\n+        if (batchTask != null) {\n+            AgentTaskExecutor.submit(batchTask);\n+        }\n+    }\n+\n+\n+    protected List<List<Comparable>> getTableTransInfo(long txnId) throws AnalysisException {\n+        List<List<Comparable>> tableInfos = new ArrayList<>();\n+        readLock();\n+        try {\n+            TransactionState transactionState = getTransactionState(txnId);\n+            if (null == transactionState) {\n+                throw new AnalysisException(\"Transaction[\" + txnId + \"] does not exist.\");\n+            }\n+\n+            for (Map.Entry<Long, TableCommitInfo> entry : transactionState.getIdToTableCommitInfos().entrySet()) {\n+                List<Comparable> tableInfo = new ArrayList<>();\n+                tableInfo.add(entry.getKey());\n+                tableInfo.add(Joiner.on(\", \").join(entry.getValue().getIdToPartitionCommitInfo().values().stream().map(\n+                        PartitionCommitInfo::getPartitionId).collect(Collectors.toList())));\n+                tableInfos.add(tableInfo);\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+        return tableInfos;\n+    }\n+\n+    protected List<List<Comparable>> getPartitionTransInfo(long txnId, long tableId) throws AnalysisException {\n+        List<List<Comparable>> partitionInfos = new ArrayList<List<Comparable>>();\n+        readLock();\n+        try {\n+            TransactionState transactionState = getTransactionState(txnId);\n+            if (null == transactionState) {\n+                throw new AnalysisException(\"Transaction[\" + txnId + \"] does not exist.\");\n+            }\n+\n+            TableCommitInfo tableCommitInfo = transactionState.getIdToTableCommitInfos().get(tableId);\n+            Map<Long, PartitionCommitInfo> idToPartitionCommitInfo = tableCommitInfo.getIdToPartitionCommitInfo();\n+            for (Map.Entry<Long, PartitionCommitInfo> entry : idToPartitionCommitInfo.entrySet()) {\n+                List<Comparable> partitionInfo = new ArrayList<Comparable>();\n+                partitionInfo.add(entry.getKey());\n+                partitionInfo.add(entry.getValue().getVersion());\n+                partitionInfo.add(entry.getValue().getVersionHash());\n+                partitionInfos.add(partitionInfo);\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+        return partitionInfos;\n+    }\n+\n+    public void removeExpiredTxns() {\n+        long currentMillis = System.currentTimeMillis();\n+        writeLock();\n+        try {\n+            while (!finalStatusTransactionStateDeque.isEmpty()) {\n+                TransactionState transactionState = finalStatusTransactionStateDeque.getFirst();\n+                if (transactionState.isExpired(currentMillis)) {\n+                    finalStatusTransactionStateDeque.pop();\n+                    Set<Long> txnIds = labelToTxnIds.get(transactionState.getLabel());\n+                    txnIds.remove(transactionState.getTransactionId());\n+                    if (txnIds.isEmpty()) {\n+                        labelToTxnIds.remove(transactionState.getLabel());\n+                    }\n+                    editLog.logDeleteTransactionState(transactionState);\n+                    LOG.info(\"transaction [\" + transactionState.getTransactionId() + \"] is expired, remove it from transaction manager\");\n+                } else {\n+                    break;\n+                }\n+\n+            }\n+        } finally {\n+            writeUnlock();\n+        }\n+    }\n+\n+    public int getTransactionNum() {\n+        return idToRunningTransactionState.size() + finalStatusTransactionStateDeque.size();", "originalCommit": "fd06610e4f848c84a3ac18b22c358a4dfd27593d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAxMTkxNg==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r415011916", "bodyText": "I find it is only invoked by checkpoint thread or image dump thread with db lock, so it is ok for not thread safe, maybe there need some comment to explain it", "author": "caiconghui", "createdAt": "2020-04-25T08:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4OTI3MA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r412289270", "bodyText": "Parameter dbTransactionMgr and dbId are redundant, I think we can get dbTransactionMgr from dbId, and we can also get dbId from dbTransactionMgr.\nSo only one of them is needed.", "author": "morningman", "createdAt": "2020-04-21T15:32:12Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -216,11 +206,11 @@ public long beginTransaction(long dbId, List<Long> tableIdList, String label, TU\n             }\n             throw e;\n         } finally {\n-            writeUnlock();\n+            dbTransactionMgr.writeUnlock();\n         }\n     }\n     \n-    private void checkRunningTxnExceedLimit(long dbId, LoadJobSourceType sourceType) throws BeginTransactionException {\n+    private void checkRunningTxnExceedLimit(DatabaseTransactionMgr dbTransactionMgr, Long dbId, LoadJobSourceType sourceType) throws BeginTransactionException {", "originalCommit": "fd06610e4f848c84a3ac18b22c358a4dfd27593d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDYzMw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r412294633", "bodyText": "How about not expose the dbTransactionMgr's lock outside?", "author": "morningman", "createdAt": "2020-04-21T15:51:31Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -500,8 +485,15 @@ public boolean commitAndPublishTransaction(Database db, long transactionId,\n         } finally {\n             db.writeUnlock();\n         }\n-        \n-        TransactionState transactionState = idToTransactionState.get(transactionId);\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(db.getId());\n+        TransactionState transactionState = null;\n+        dbTransactionMgr.readLock();", "originalCommit": "fd06610e4f848c84a3ac18b22c358a4dfd27593d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAxNTY3OQ==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r415015679", "bodyText": "it is only exposed to GlobalTransactionMgr, we still use GlobalTransactionMgr to do some txn management work in global view, DatabaeTransactionMgr cannot be an independent existence without GlobalTransactionMgr. it is normal for  GlobalTransactionMgr to invoke some DatabaeTransactionMgr's methods and ensure they are 'atomatic' by lock, while DatabaseTransactionMgr only need to provide some basic methods about txn. If we not expose dbTransactionMgr's lock to GlobalTransactionMgr, the work for DatabaeTransactionMgr is too heavy.", "author": "caiconghui", "createdAt": "2020-04-25T08:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyOTI0OA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r419829248", "bodyText": "In fact, you will find that all the logic in GlobalTransactionMgr is now executed in DbTransactionMgr. GlobalTransactionMgr has only become a class for managing DbTransactionMgr.\nThe usage patterns of most methods are:\nDbTransactionMgr dbMgr = getDbTransactionMgr(dbId);\ndbMgr.lock()\ntry {\n    dbMgr.doSomeTxnThing();\n} finally {\n    dbMgr.unlock();\n}\n\nTherefore, I think it is more appropriate to move all the main implementation logic into DbTransactionMgr. In this way, the responsibilities of GlobalTransactionMgr and DbTransactionMgr will be clearer. GlobalTransactionMgr only serves as the entry class for transaction operations and is responsible for managing DbTransactionMgr. And DbTransactionMgr is the actual transaction operation class.", "author": "morningman", "createdAt": "2020-05-05T02:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyMTgzNg==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r419821836", "bodyText": "getDb() may return null if database does not exist yet.", "author": "morningman", "createdAt": "2020-05-05T01:37:18Z", "path": "fe/src/main/java/org/apache/doris/service/FrontendServiceImpl.java", "diffHunk": "@@ -800,8 +800,8 @@ private void loadTxnRollbackImpl(TLoadTxnRollbackRequest request) throws UserExc\n             checkPasswordAndPrivs(cluster, request.getUser(), request.getPasswd(), request.getDb(),\n                     request.getTbl(), request.getUser_ip(), PrivPredicate.LOAD);\n         }\n-\n-        Catalog.getCurrentGlobalTransactionMgr().abortTransaction(request.getTxnId(),\n+        long dbId = Catalog.getInstance().getDb(request.getDb()).getId();", "originalCommit": "843657106febab6c935f299587e3540d9e436cbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyMjU3MQ==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r419822571", "bodyText": "Not using NullPointerException, you can use TransactionException", "author": "morningman", "createdAt": "2020-05-05T01:40:15Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -123,6 +95,22 @@ public TxnStateCallbackFactory getCallbackFactory() {\n         return callbackFactory;\n     }\n \n+    public DatabaseTransactionMgr getDatabaseTransactioMgr(long dbId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        if (dbTransactionMgr == null) {\n+            throw new NullPointerException(\"databaseTransactionMgr[\" + dbId + \"] does not exist\");", "originalCommit": "843657106febab6c935f299587e3540d9e436cbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyMjc5MA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r419822790", "bodyText": "Is it more safe to use putIfAbsent() method?", "author": "morningman", "createdAt": "2020-05-05T01:41:15Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -123,6 +95,22 @@ public TxnStateCallbackFactory getCallbackFactory() {\n         return callbackFactory;\n     }\n \n+    public DatabaseTransactionMgr getDatabaseTransactioMgr(long dbId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        if (dbTransactionMgr == null) {\n+            throw new NullPointerException(\"databaseTransactionMgr[\" + dbId + \"] does not exist\");\n+        }\n+        return dbTransactionMgr;\n+    }\n+\n+    public void addDatabaseTransactionMgr(Long dbId, EditLog editLog) {\n+        dbIdToDatabaseTransactionMgrs.put(dbId, new DatabaseTransactionMgr(dbId, editLog));", "originalCommit": "843657106febab6c935f299587e3540d9e436cbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyMzQ1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r419823457", "bodyText": "I think checkRunningTxnExceedLimit() this method can be moved into the DbTransactionMgr", "author": "morningman", "createdAt": "2020-05-05T01:44:23Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -194,14 +184,14 @@ public long beginTransaction(long dbId, List<Long> tableIdList, String label, TU\n                 }\n             }\n \n-            checkRunningTxnExceedLimit(dbId, sourceType);\n+            checkRunningTxnExceedLimit(dbTransactionMgr, sourceType);", "originalCommit": "843657106febab6c935f299587e3540d9e436cbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f38eb0be3f9ff8313b0893863310f65efb036da", "url": "https://github.com/apache/incubator-doris/commit/4f38eb0be3f9ff8313b0893863310f65efb036da", "message": "fix", "committedDate": "2020-05-06T10:51:26Z", "type": "forcePushed"}, {"oid": "4f38eb0be3f9ff8313b0893863310f65efb036da", "url": "https://github.com/apache/incubator-doris/commit/4f38eb0be3f9ff8313b0893863310f65efb036da", "message": "fix", "committedDate": "2020-05-06T10:51:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNzYzNg==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421537636", "bodyText": "Actually, the operation DropDb is just put database to CatalogRecycleBin, not actually drop it. And the database can be recovered by Recover operation.\nSo here you should not removeDatabaseTransactionMgr(), Instead, it should be called in CatalogRecycleBin.eraseDatabase()", "author": "morningman", "createdAt": "2020-05-07T14:14:34Z", "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -2639,6 +2641,7 @@ public void dropDb(DropDbStmt stmt) throws DdlException {\n             fullNameToDb.remove(db.getFullName());\n             final Cluster cluster = nameToCluster.get(db.getClusterName());\n             cluster.removeDb(dbName, db.getId());\n+            globalTransactionMgr.removeDatabaseTransactionMgr(db.getId());", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzODkxMg==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421538912", "bodyText": "Same to dropDb, this should be called in CatalogRecycleBin.replayEraseDatabase()", "author": "morningman", "createdAt": "2020-05-07T14:16:10Z", "path": "fe/src/main/java/org/apache/doris/catalog/Catalog.java", "diffHunk": "@@ -2686,6 +2689,7 @@ public void replayDropDb(String dbName) throws DdlException {\n             idToDb.remove(db.getId());\n             final Cluster cluster = nameToCluster.get(db.getClusterName());\n             cluster.removeDb(dbName, db.getId());\n+            globalTransactionMgr.removeDatabaseTransactionMgr(db.getId());", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0MjY1MQ==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421542651", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DatabaseTransactionMgr getDatabaseTransactioMgr(long dbId) throws AnalysisException {\n          \n          \n            \n                public DatabaseTransactionMgr getDatabaseTransactionMgr(long dbId) throws AnalysisException {", "author": "morningman", "createdAt": "2020-05-07T14:20:59Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -123,6 +70,22 @@ public TxnStateCallbackFactory getCallbackFactory() {\n         return callbackFactory;\n     }\n \n+    public DatabaseTransactionMgr getDatabaseTransactioMgr(long dbId) throws AnalysisException {", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0NDIzOQ==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421544239", "bodyText": "AnalysisException is not suitable here.\nBut it can be modified next time", "author": "morningman", "createdAt": "2020-05-07T14:22:59Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -123,6 +70,22 @@ public TxnStateCallbackFactory getCallbackFactory() {\n         return callbackFactory;\n     }\n \n+    public DatabaseTransactionMgr getDatabaseTransactioMgr(long dbId) throws AnalysisException {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        if (dbTransactionMgr == null) {\n+            throw new AnalysisException(\"databaseTransactionMgr[\" + dbId + \"] does not exist\");", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0NDc0Mw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421544743", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return null;\n          \n          \n            \n                        return TransactionStatus.UNKNOWN;", "author": "morningman", "createdAt": "2020-05-07T14:23:38Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -156,114 +119,20 @@ public long beginTransaction(long dbId, List<Long> tableIdList, String label, TU\n                     + Config.min_load_timeout_second + \" and \" + Config.max_load_timeout_second\n                     + \" seconds\");\n         }\n-        \n-        writeLock();\n-        try {\n-            Preconditions.checkNotNull(coordinator);\n-            Preconditions.checkNotNull(label);\n-            FeNameFormat.checkLabel(label);\n-\n-            /*\n-             * Check if label already used, by following steps\n-             * 1. get all existing transactions\n-             * 2. if there is a PREPARE transaction, check if this is a retry request. If yes, return the\n-             *    existing txn id.\n-             * 3. if there is a non-aborted transaction, throw label already used exception.\n-             */\n-            Set<Long> existingTxnIds = dbIdToTxnLabels.get(dbId, label);\n-            if (existingTxnIds != null && !existingTxnIds.isEmpty()) {\n-                List<TransactionState> notAbortedTxns = Lists.newArrayList();\n-                for (long txnId : existingTxnIds) {\n-                    TransactionState txn = idToTransactionState.get(txnId);\n-                    Preconditions.checkNotNull(txn);\n-                    if (txn.getTransactionStatus() != TransactionStatus.ABORTED) {\n-                        notAbortedTxns.add(txn);\n-                    }\n-                }\n-                // there should be at most 1 txn in PREPARE/COMMITTED/VISIBLE status\n-                Preconditions.checkState(notAbortedTxns.size() <= 1, notAbortedTxns);\n-                if (!notAbortedTxns.isEmpty()) {\n-                    TransactionState notAbortedTxn = notAbortedTxns.get(0);\n-                    if (requestId != null && notAbortedTxn.getTransactionStatus() == TransactionStatus.PREPARE\n-                            && notAbortedTxn.getRequsetId() != null && notAbortedTxn.getRequsetId().equals(requestId)) {\n-                        // this may be a retry request for same job, just return existing txn id.\n-                        throw new DuplicatedRequestException(DebugUtil.printId(requestId),\n-                                notAbortedTxn.getTransactionId(), \"\");\n-                    }\n-                    throw new LabelAlreadyUsedException(label, notAbortedTxn.getTransactionStatus());\n-                }\n-            }\n \n-            checkRunningTxnExceedLimit(dbId, sourceType);\n-          \n-            long tid = idGenerator.getNextTransactionId();\n-            LOG.info(\"begin transaction: txn id {} with label {} from coordinator {}\", tid, label, coordinator);\n-            TransactionState transactionState = new TransactionState(dbId, tableIdList, tid, label, requestId, sourceType,\n-                    coordinator, listenerId, timeoutSecond * 1000);\n-            transactionState.setPrepareTime(System.currentTimeMillis());\n-            unprotectUpsertTransactionState(transactionState);\n-\n-            if (MetricRepo.isInit.get()) {\n-                MetricRepo.COUNTER_TXN_BEGIN.increase(1L);\n-            }\n-\n-            return tid;\n-        } catch (DuplicatedRequestException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            if (MetricRepo.isInit.get()) {\n-                MetricRepo.COUNTER_TXN_REJECT.increase(1L);\n-            }\n-            throw e;\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-    \n-    private void checkRunningTxnExceedLimit(long dbId, LoadJobSourceType sourceType) throws BeginTransactionException {\n-        switch (sourceType) {\n-            case ROUTINE_LOAD_TASK:\n-                // no need to check limit for routine load task:\n-                // 1. the number of running routine load tasks is limited by Config.max_routine_load_task_num_per_be\n-                // 2. if we add routine load txn to runningTxnNums, runningTxnNums will always be occupied by routine load,\n-                //    and other txn may not be able to submitted.\n-                break;\n-            default:\n-                if (runningTxnNums.getOrDefault(dbId, 0) >= Config.max_running_txn_num_per_db) {\n-                    throw new BeginTransactionException(\"current running txns on db \" + dbId + \" is \"\n-                            + runningTxnNums.get(dbId) + \", larger than limit \" + Config.max_running_txn_num_per_db);\n-                }\n-                break;\n-        }\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+        return dbTransactionMgr.beginTransaction(tableIdList, label, requestId, coordinator, sourceType, listenerId, timeoutSecond);\n     }\n \n     public TransactionStatus getLabelState(long dbId, String label) {\n-        readLock();\n         try {\n-            Set<Long> existingTxnIds = dbIdToTxnLabels.get(dbId, label);\n-            if (existingTxnIds == null || existingTxnIds.isEmpty()) {\n-                return TransactionStatus.UNKNOWN;\n-            }\n-            // find the latest txn (which id is largest)\n-            long maxTxnId = existingTxnIds.stream().max(Comparator.comparingLong(Long::valueOf)).get();\n-            return idToTransactionState.get(maxTxnId).getTransactionStatus();\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-    \n-    public void deleteTransaction(long transactionId) {\n-        writeLock();\n-        try {\n-            TransactionState state = idToTransactionState.get(transactionId);\n-            if (state == null) {\n-                return;\n-            }\n-            replayDeleteTransactionState(state);\n-            editLog.logDeleteTransactionState(state);\n-        } finally {\n-            writeUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+            return dbTransactionMgr.getLabelState(label);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"Get transaction status by label \" + label + \" failed\", e);\n+            return null;", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0NzY5Nw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421547697", "bodyText": "This logic(Remove the timeout txn) can also be put into DatabaseTransactionMgr.\ndbTransactionMgr. removeExpiredAndTimeoutTxns();", "author": "morningman", "createdAt": "2020-05-07T14:27:06Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0ODIzMg==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421548232", "bodyText": "No throw exception? dbTransactionMgr could be null", "author": "morningman", "createdAt": "2020-05-07T14:27:45Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {\n+                try {\n+                    dbTransactionMgr.abortTransaction(txnId, \"timeout by txn manager\", null);\n+                    LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n+                } catch (UserException e) {\n+                    // abort may be failed. it is acceptable. just print a log\n+                    LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n                 }\n             }\n-        } finally {\n-            readUnlock();\n-        }\n \n-        // delete expired txns\n-        for (Long txnId : expiredTxns) {\n-            deleteTransaction(txnId);\n-            LOG.info(\"transaction [\" + txnId + \"] is expired, remove it from transaction manager\");\n-        }\n-\n-        // abort timeout txns\n-        for (Long txnId : timeoutTxns) {\n-            try {\n-                abortTransaction(txnId, \"timeout by txn manager\");\n-                LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n-            } catch (UserException e) {\n-                // abort may be failed. it is acceptable. just print a log\n-                LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n-            }\n         }\n     }\n \n-    public TransactionState getTransactionState(long transactionId) {\n-        readLock();\n-        try {\n-            return idToTransactionState.get(transactionId);\n-        } finally {\n-            readUnlock();\n-        }\n+    public TransactionState getTransactionState(long dbId, long transactionId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0OTA5OQ==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421549099", "bodyText": "add transaction's id in log, for easy debugging.", "author": "morningman", "createdAt": "2020-05-07T14:28:46Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {\n+                try {\n+                    dbTransactionMgr.abortTransaction(txnId, \"timeout by txn manager\", null);\n+                    LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n+                } catch (UserException e) {\n+                    // abort may be failed. it is acceptable. just print a log\n+                    LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n                 }\n             }\n-        } finally {\n-            readUnlock();\n-        }\n \n-        // delete expired txns\n-        for (Long txnId : expiredTxns) {\n-            deleteTransaction(txnId);\n-            LOG.info(\"transaction [\" + txnId + \"] is expired, remove it from transaction manager\");\n-        }\n-\n-        // abort timeout txns\n-        for (Long txnId : timeoutTxns) {\n-            try {\n-                abortTransaction(txnId, \"timeout by txn manager\");\n-                LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n-            } catch (UserException e) {\n-                // abort may be failed. it is acceptable. just print a log\n-                LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n-            }\n         }\n     }\n \n-    public TransactionState getTransactionState(long transactionId) {\n-        readLock();\n-        try {\n-            return idToTransactionState.get(transactionId);\n-        } finally {\n-            readUnlock();\n-        }\n+    public TransactionState getTransactionState(long dbId, long transactionId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        return dbTransactionMgr.getTransactionState(transactionId);\n     }\n     \n     public void setEditLog(EditLog editLog) {\n-        this.editLog = editLog;\n         this.idGenerator.setEditLog(editLog);\n     }\n-    \n-    private void readLock() {\n-        this.transactionLock.readLock().lock();\n-    }\n-    \n-    private void readUnlock() {\n-        this.transactionLock.readLock().unlock();\n-    }\n-    \n-    private void writeLock() {\n-        this.transactionLock.writeLock().lock();\n-    }\n-    \n-    private void writeUnlock() {\n-        this.transactionLock.writeLock().unlock();\n-    }\n-    \n-    // for add/update/delete TransactionState\n-    private void unprotectUpsertTransactionState(TransactionState transactionState) {\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE\n-                || transactionState.getSourceType() == LoadJobSourceType.FRONTEND) {\n-            // if this is a prepare txn, and load source type is not FRONTEND\n-            // no need to persist it. if prepare txn lost, the following commit will just be failed.\n-            // user only need to retry this txn.\n-            // The FRONTEND type txn is committed and running asynchronously, so we have to persist it.\n-            editLog.logInsertTransactionState(transactionState);\n-        }\n-        idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-        updateTxnLabels(transactionState);\n-        updateDbRunningTxnNum(transactionState.getPreStatus(), transactionState);\n-    }\n-\n-    private void unprotectedCommitTransaction(TransactionState transactionState, Set<Long> errorReplicaIds,\n-                                              Map<Long, Set<Long>> tableToPartition, Set<Long> totalInvolvedBackends,\n-                                              Database db) {\n-        // transaction state is modified during check if the transaction could committed\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE) {\n-            return;\n-        }\n-        // update transaction state version\n-        transactionState.setCommitTime(System.currentTimeMillis());\n-        transactionState.setTransactionStatus(TransactionStatus.COMMITTED);\n-        transactionState.setErrorReplicas(errorReplicaIds);\n-        for (long tableId : tableToPartition.keySet()) {\n-            TableCommitInfo tableCommitInfo = new TableCommitInfo(tableId);\n-            for (long partitionId : tableToPartition.get(tableId)) {\n-                OlapTable table = (OlapTable) db.getTable(tableId);\n-                Partition partition = table.getPartition(partitionId);\n-                PartitionCommitInfo partitionCommitInfo = new PartitionCommitInfo(partitionId,\n-                                                                                  partition.getNextVersion(),\n-                                                                                  partition.getNextVersionHash());\n-                tableCommitInfo.addPartitionCommitInfo(partitionCommitInfo);\n-            }\n-            transactionState.putIdToTableCommitInfo(tableId, tableCommitInfo);\n-        }\n-        // persist transactionState\n-        unprotectUpsertTransactionState(transactionState);\n-\n-        // add publish version tasks. set task to null as a placeholder.\n-        // tasks will be created when publishing version.\n-        for (long backendId : totalInvolvedBackends) {\n-            transactionState.addPublishVersionTask(backendId, null);\n-        }\n-    }\n \n-    private boolean unprotectAbortTransaction(long transactionId, String reason)\n-            throws UserException {\n-        TransactionState transactionState = idToTransactionState.get(transactionId);\n-        if (transactionState == null) {\n-            throw new UserException(\"transaction not found\");\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n-            return false;\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED\n-                || transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-            throw new UserException(\"transaction's state is already \"\n-                    + transactionState.getTransactionStatus() + \", could not abort\");\n-        }\n-        transactionState.setFinishTime(System.currentTimeMillis());\n-        transactionState.setReason(reason);\n-        transactionState.setTransactionStatus(TransactionStatus.ABORTED);\n-        unprotectUpsertTransactionState(transactionState);\n-        for (PublishVersionTask task : transactionState.getPublishVersionTasks().values()) {\n-            AgentTaskQueue.removeTask(task.getBackendId(), TTaskType.PUBLISH_VERSION, task.getSignature());\n-        }\n-        return true;\n-    }\n-    \n     // for replay idToTransactionState\n     // check point also run transaction cleaner, the cleaner maybe concurrently modify id to \n     public void replayUpsertTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            // set transaction status will call txn state change listener\n-            transactionState.replaySetTransactionStatus();\n-            Database db = catalog.getDb(transactionState.getDbId());\n-            if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED) {\n-                LOG.info(\"replay a committed transaction {}\", transactionState);\n-                updateCatalogAfterCommitted(transactionState, db);\n-            } else if (transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.info(\"replay a visible transaction {}\", transactionState);\n-                updateCatalogAfterVisible(transactionState, db);\n-            }\n-            TransactionState preTxnState = idToTransactionState.get(transactionState.getTransactionId());\n-            idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-            updateTxnLabels(transactionState);\n-            updateDbRunningTxnNum(preTxnState == null ? null : preTxnState.getTransactionStatus(),\n-                                  transactionState);\n-        } finally {\n-            writeUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.replayUpsertTransactionState(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay upsert transaction failed\", e);", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0OTMxMw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421549313", "bodyText": "Add txn id in log.", "author": "morningman", "createdAt": "2020-05-07T14:29:02Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {\n+                try {\n+                    dbTransactionMgr.abortTransaction(txnId, \"timeout by txn manager\", null);\n+                    LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n+                } catch (UserException e) {\n+                    // abort may be failed. it is acceptable. just print a log\n+                    LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n                 }\n             }\n-        } finally {\n-            readUnlock();\n-        }\n \n-        // delete expired txns\n-        for (Long txnId : expiredTxns) {\n-            deleteTransaction(txnId);\n-            LOG.info(\"transaction [\" + txnId + \"] is expired, remove it from transaction manager\");\n-        }\n-\n-        // abort timeout txns\n-        for (Long txnId : timeoutTxns) {\n-            try {\n-                abortTransaction(txnId, \"timeout by txn manager\");\n-                LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n-            } catch (UserException e) {\n-                // abort may be failed. it is acceptable. just print a log\n-                LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n-            }\n         }\n     }\n \n-    public TransactionState getTransactionState(long transactionId) {\n-        readLock();\n-        try {\n-            return idToTransactionState.get(transactionId);\n-        } finally {\n-            readUnlock();\n-        }\n+    public TransactionState getTransactionState(long dbId, long transactionId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        return dbTransactionMgr.getTransactionState(transactionId);\n     }\n     \n     public void setEditLog(EditLog editLog) {\n-        this.editLog = editLog;\n         this.idGenerator.setEditLog(editLog);\n     }\n-    \n-    private void readLock() {\n-        this.transactionLock.readLock().lock();\n-    }\n-    \n-    private void readUnlock() {\n-        this.transactionLock.readLock().unlock();\n-    }\n-    \n-    private void writeLock() {\n-        this.transactionLock.writeLock().lock();\n-    }\n-    \n-    private void writeUnlock() {\n-        this.transactionLock.writeLock().unlock();\n-    }\n-    \n-    // for add/update/delete TransactionState\n-    private void unprotectUpsertTransactionState(TransactionState transactionState) {\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE\n-                || transactionState.getSourceType() == LoadJobSourceType.FRONTEND) {\n-            // if this is a prepare txn, and load source type is not FRONTEND\n-            // no need to persist it. if prepare txn lost, the following commit will just be failed.\n-            // user only need to retry this txn.\n-            // The FRONTEND type txn is committed and running asynchronously, so we have to persist it.\n-            editLog.logInsertTransactionState(transactionState);\n-        }\n-        idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-        updateTxnLabels(transactionState);\n-        updateDbRunningTxnNum(transactionState.getPreStatus(), transactionState);\n-    }\n-\n-    private void unprotectedCommitTransaction(TransactionState transactionState, Set<Long> errorReplicaIds,\n-                                              Map<Long, Set<Long>> tableToPartition, Set<Long> totalInvolvedBackends,\n-                                              Database db) {\n-        // transaction state is modified during check if the transaction could committed\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE) {\n-            return;\n-        }\n-        // update transaction state version\n-        transactionState.setCommitTime(System.currentTimeMillis());\n-        transactionState.setTransactionStatus(TransactionStatus.COMMITTED);\n-        transactionState.setErrorReplicas(errorReplicaIds);\n-        for (long tableId : tableToPartition.keySet()) {\n-            TableCommitInfo tableCommitInfo = new TableCommitInfo(tableId);\n-            for (long partitionId : tableToPartition.get(tableId)) {\n-                OlapTable table = (OlapTable) db.getTable(tableId);\n-                Partition partition = table.getPartition(partitionId);\n-                PartitionCommitInfo partitionCommitInfo = new PartitionCommitInfo(partitionId,\n-                                                                                  partition.getNextVersion(),\n-                                                                                  partition.getNextVersionHash());\n-                tableCommitInfo.addPartitionCommitInfo(partitionCommitInfo);\n-            }\n-            transactionState.putIdToTableCommitInfo(tableId, tableCommitInfo);\n-        }\n-        // persist transactionState\n-        unprotectUpsertTransactionState(transactionState);\n-\n-        // add publish version tasks. set task to null as a placeholder.\n-        // tasks will be created when publishing version.\n-        for (long backendId : totalInvolvedBackends) {\n-            transactionState.addPublishVersionTask(backendId, null);\n-        }\n-    }\n \n-    private boolean unprotectAbortTransaction(long transactionId, String reason)\n-            throws UserException {\n-        TransactionState transactionState = idToTransactionState.get(transactionId);\n-        if (transactionState == null) {\n-            throw new UserException(\"transaction not found\");\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n-            return false;\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED\n-                || transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-            throw new UserException(\"transaction's state is already \"\n-                    + transactionState.getTransactionStatus() + \", could not abort\");\n-        }\n-        transactionState.setFinishTime(System.currentTimeMillis());\n-        transactionState.setReason(reason);\n-        transactionState.setTransactionStatus(TransactionStatus.ABORTED);\n-        unprotectUpsertTransactionState(transactionState);\n-        for (PublishVersionTask task : transactionState.getPublishVersionTasks().values()) {\n-            AgentTaskQueue.removeTask(task.getBackendId(), TTaskType.PUBLISH_VERSION, task.getSignature());\n-        }\n-        return true;\n-    }\n-    \n     // for replay idToTransactionState\n     // check point also run transaction cleaner, the cleaner maybe concurrently modify id to \n     public void replayUpsertTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            // set transaction status will call txn state change listener\n-            transactionState.replaySetTransactionStatus();\n-            Database db = catalog.getDb(transactionState.getDbId());\n-            if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED) {\n-                LOG.info(\"replay a committed transaction {}\", transactionState);\n-                updateCatalogAfterCommitted(transactionState, db);\n-            } else if (transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.info(\"replay a visible transaction {}\", transactionState);\n-                updateCatalogAfterVisible(transactionState, db);\n-            }\n-            TransactionState preTxnState = idToTransactionState.get(transactionState.getTransactionId());\n-            idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-            updateTxnLabels(transactionState);\n-            updateDbRunningTxnNum(preTxnState == null ? null : preTxnState.getTransactionStatus(),\n-                                  transactionState);\n-        } finally {\n-            writeUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.replayUpsertTransactionState(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay upsert transaction failed\", e);\n         }\n+\n     }\n     \n     public void replayDeleteTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            idToTransactionState.remove(transactionState.getTransactionId());\n-            Set<Long> txnIds = dbIdToTxnLabels.get(transactionState.getDbId(), transactionState.getLabel());\n-            txnIds.remove(transactionState.getTransactionId());\n-            if (txnIds.isEmpty()) {\n-                dbIdToTxnLabels.remove(transactionState.getDbId(), transactionState.getLabel());\n-            }\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-    \n-    private void updateCatalogAfterCommitted(TransactionState transactionState, Database db) {\n-        Set<Long> errorReplicaIds = transactionState.getErrorReplicas();\n-        for (TableCommitInfo tableCommitInfo : transactionState.getIdToTableCommitInfos().values()) {\n-            long tableId = tableCommitInfo.getTableId();\n-            OlapTable table = (OlapTable) db.getTable(tableId);\n-            for (PartitionCommitInfo partitionCommitInfo : tableCommitInfo.getIdToPartitionCommitInfo().values()) {\n-                long partitionId = partitionCommitInfo.getPartitionId();\n-                Partition partition = table.getPartition(partitionId);\n-                List<MaterializedIndex> allIndices = partition.getMaterializedIndices(IndexExtState.ALL);\n-                for (MaterializedIndex index : allIndices) {\n-                    List<Tablet> tablets = index.getTablets();\n-                    for (Tablet tablet : tablets) {\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            if (errorReplicaIds.contains(replica.getId())) {\n-                                // should not use partition.getNextVersion and partition.getNextVersionHash because partition's next version hash is generated locally\n-                                // should get from transaction state\n-                                replica.updateLastFailedVersion(partitionCommitInfo.getVersion(),\n-                                                                partitionCommitInfo.getVersionHash());\n-                            }\n-                        }\n-                    }\n-                }\n-                partition.setNextVersion(partition.getNextVersion() + 1);\n-                // Although committed version(hash) is not visible to user,\n-                // but they need to be synchronized among Frontends.\n-                // because we use committed version(hash) to create clone task, if the first Master FE\n-                // send clone task with committed version hash X, and than Master changed, the new Master FE\n-                // received the clone task report with version hash X, which not equals to it own committed\n-                // version hash, than the clone task is failed.\n-                partition.setNextVersionHash(Util.generateVersionHash() /* next version hash */,\n-                                             partitionCommitInfo.getVersionHash() /* committed version hash*/);\n-            }\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.deleteTransaction(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay delete transaction failed\", e);", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0OTY5Mw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421549693", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Long> dbIds = Lists.newArrayList();\n          \n          \n            \n                    List<Long> dbIds = Lists.newArrayList(dbIdToDatabaseTransactionMgrs.keySet());", "author": "morningman", "createdAt": "2020-05-07T14:29:30Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {\n+                try {\n+                    dbTransactionMgr.abortTransaction(txnId, \"timeout by txn manager\", null);\n+                    LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n+                } catch (UserException e) {\n+                    // abort may be failed. it is acceptable. just print a log\n+                    LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n                 }\n             }\n-        } finally {\n-            readUnlock();\n-        }\n \n-        // delete expired txns\n-        for (Long txnId : expiredTxns) {\n-            deleteTransaction(txnId);\n-            LOG.info(\"transaction [\" + txnId + \"] is expired, remove it from transaction manager\");\n-        }\n-\n-        // abort timeout txns\n-        for (Long txnId : timeoutTxns) {\n-            try {\n-                abortTransaction(txnId, \"timeout by txn manager\");\n-                LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n-            } catch (UserException e) {\n-                // abort may be failed. it is acceptable. just print a log\n-                LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n-            }\n         }\n     }\n \n-    public TransactionState getTransactionState(long transactionId) {\n-        readLock();\n-        try {\n-            return idToTransactionState.get(transactionId);\n-        } finally {\n-            readUnlock();\n-        }\n+    public TransactionState getTransactionState(long dbId, long transactionId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        return dbTransactionMgr.getTransactionState(transactionId);\n     }\n     \n     public void setEditLog(EditLog editLog) {\n-        this.editLog = editLog;\n         this.idGenerator.setEditLog(editLog);\n     }\n-    \n-    private void readLock() {\n-        this.transactionLock.readLock().lock();\n-    }\n-    \n-    private void readUnlock() {\n-        this.transactionLock.readLock().unlock();\n-    }\n-    \n-    private void writeLock() {\n-        this.transactionLock.writeLock().lock();\n-    }\n-    \n-    private void writeUnlock() {\n-        this.transactionLock.writeLock().unlock();\n-    }\n-    \n-    // for add/update/delete TransactionState\n-    private void unprotectUpsertTransactionState(TransactionState transactionState) {\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE\n-                || transactionState.getSourceType() == LoadJobSourceType.FRONTEND) {\n-            // if this is a prepare txn, and load source type is not FRONTEND\n-            // no need to persist it. if prepare txn lost, the following commit will just be failed.\n-            // user only need to retry this txn.\n-            // The FRONTEND type txn is committed and running asynchronously, so we have to persist it.\n-            editLog.logInsertTransactionState(transactionState);\n-        }\n-        idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-        updateTxnLabels(transactionState);\n-        updateDbRunningTxnNum(transactionState.getPreStatus(), transactionState);\n-    }\n-\n-    private void unprotectedCommitTransaction(TransactionState transactionState, Set<Long> errorReplicaIds,\n-                                              Map<Long, Set<Long>> tableToPartition, Set<Long> totalInvolvedBackends,\n-                                              Database db) {\n-        // transaction state is modified during check if the transaction could committed\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE) {\n-            return;\n-        }\n-        // update transaction state version\n-        transactionState.setCommitTime(System.currentTimeMillis());\n-        transactionState.setTransactionStatus(TransactionStatus.COMMITTED);\n-        transactionState.setErrorReplicas(errorReplicaIds);\n-        for (long tableId : tableToPartition.keySet()) {\n-            TableCommitInfo tableCommitInfo = new TableCommitInfo(tableId);\n-            for (long partitionId : tableToPartition.get(tableId)) {\n-                OlapTable table = (OlapTable) db.getTable(tableId);\n-                Partition partition = table.getPartition(partitionId);\n-                PartitionCommitInfo partitionCommitInfo = new PartitionCommitInfo(partitionId,\n-                                                                                  partition.getNextVersion(),\n-                                                                                  partition.getNextVersionHash());\n-                tableCommitInfo.addPartitionCommitInfo(partitionCommitInfo);\n-            }\n-            transactionState.putIdToTableCommitInfo(tableId, tableCommitInfo);\n-        }\n-        // persist transactionState\n-        unprotectUpsertTransactionState(transactionState);\n-\n-        // add publish version tasks. set task to null as a placeholder.\n-        // tasks will be created when publishing version.\n-        for (long backendId : totalInvolvedBackends) {\n-            transactionState.addPublishVersionTask(backendId, null);\n-        }\n-    }\n \n-    private boolean unprotectAbortTransaction(long transactionId, String reason)\n-            throws UserException {\n-        TransactionState transactionState = idToTransactionState.get(transactionId);\n-        if (transactionState == null) {\n-            throw new UserException(\"transaction not found\");\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n-            return false;\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED\n-                || transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-            throw new UserException(\"transaction's state is already \"\n-                    + transactionState.getTransactionStatus() + \", could not abort\");\n-        }\n-        transactionState.setFinishTime(System.currentTimeMillis());\n-        transactionState.setReason(reason);\n-        transactionState.setTransactionStatus(TransactionStatus.ABORTED);\n-        unprotectUpsertTransactionState(transactionState);\n-        for (PublishVersionTask task : transactionState.getPublishVersionTasks().values()) {\n-            AgentTaskQueue.removeTask(task.getBackendId(), TTaskType.PUBLISH_VERSION, task.getSignature());\n-        }\n-        return true;\n-    }\n-    \n     // for replay idToTransactionState\n     // check point also run transaction cleaner, the cleaner maybe concurrently modify id to \n     public void replayUpsertTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            // set transaction status will call txn state change listener\n-            transactionState.replaySetTransactionStatus();\n-            Database db = catalog.getDb(transactionState.getDbId());\n-            if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED) {\n-                LOG.info(\"replay a committed transaction {}\", transactionState);\n-                updateCatalogAfterCommitted(transactionState, db);\n-            } else if (transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.info(\"replay a visible transaction {}\", transactionState);\n-                updateCatalogAfterVisible(transactionState, db);\n-            }\n-            TransactionState preTxnState = idToTransactionState.get(transactionState.getTransactionId());\n-            idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-            updateTxnLabels(transactionState);\n-            updateDbRunningTxnNum(preTxnState == null ? null : preTxnState.getTransactionStatus(),\n-                                  transactionState);\n-        } finally {\n-            writeUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.replayUpsertTransactionState(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay upsert transaction failed\", e);\n         }\n+\n     }\n     \n     public void replayDeleteTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            idToTransactionState.remove(transactionState.getTransactionId());\n-            Set<Long> txnIds = dbIdToTxnLabels.get(transactionState.getDbId(), transactionState.getLabel());\n-            txnIds.remove(transactionState.getTransactionId());\n-            if (txnIds.isEmpty()) {\n-                dbIdToTxnLabels.remove(transactionState.getDbId(), transactionState.getLabel());\n-            }\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-    \n-    private void updateCatalogAfterCommitted(TransactionState transactionState, Database db) {\n-        Set<Long> errorReplicaIds = transactionState.getErrorReplicas();\n-        for (TableCommitInfo tableCommitInfo : transactionState.getIdToTableCommitInfos().values()) {\n-            long tableId = tableCommitInfo.getTableId();\n-            OlapTable table = (OlapTable) db.getTable(tableId);\n-            for (PartitionCommitInfo partitionCommitInfo : tableCommitInfo.getIdToPartitionCommitInfo().values()) {\n-                long partitionId = partitionCommitInfo.getPartitionId();\n-                Partition partition = table.getPartition(partitionId);\n-                List<MaterializedIndex> allIndices = partition.getMaterializedIndices(IndexExtState.ALL);\n-                for (MaterializedIndex index : allIndices) {\n-                    List<Tablet> tablets = index.getTablets();\n-                    for (Tablet tablet : tablets) {\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            if (errorReplicaIds.contains(replica.getId())) {\n-                                // should not use partition.getNextVersion and partition.getNextVersionHash because partition's next version hash is generated locally\n-                                // should get from transaction state\n-                                replica.updateLastFailedVersion(partitionCommitInfo.getVersion(),\n-                                                                partitionCommitInfo.getVersionHash());\n-                            }\n-                        }\n-                    }\n-                }\n-                partition.setNextVersion(partition.getNextVersion() + 1);\n-                // Although committed version(hash) is not visible to user,\n-                // but they need to be synchronized among Frontends.\n-                // because we use committed version(hash) to create clone task, if the first Master FE\n-                // send clone task with committed version hash X, and than Master changed, the new Master FE\n-                // received the clone task report with version hash X, which not equals to it own committed\n-                // version hash, than the clone task is failed.\n-                partition.setNextVersionHash(Util.generateVersionHash() /* next version hash */,\n-                                             partitionCommitInfo.getVersionHash() /* committed version hash*/);\n-            }\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.deleteTransaction(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay delete transaction failed\", e);\n         }\n     }\n-    \n-    private boolean updateCatalogAfterVisible(TransactionState transactionState, Database db) {\n-        Set<Long> errorReplicaIds = transactionState.getErrorReplicas();\n-        for (TableCommitInfo tableCommitInfo : transactionState.getIdToTableCommitInfos().values()) {\n-            long tableId = tableCommitInfo.getTableId();\n-            OlapTable table = (OlapTable) db.getTable(tableId);\n-            for (PartitionCommitInfo partitionCommitInfo : tableCommitInfo.getIdToPartitionCommitInfo().values()) {\n-                long partitionId = partitionCommitInfo.getPartitionId();\n-                long newCommitVersion = partitionCommitInfo.getVersion();\n-                long newCommitVersionHash = partitionCommitInfo.getVersionHash();\n-                Partition partition = table.getPartition(partitionId);\n-                List<MaterializedIndex> allIndices = partition.getMaterializedIndices(IndexExtState.ALL);\n-                for (MaterializedIndex index : allIndices) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long lastFailedVersion = replica.getLastFailedVersion();\n-                            long lastFailedVersionHash = replica.getLastFailedVersionHash();\n-                            long newVersion = newCommitVersion;\n-                            long newVersionHash = newCommitVersionHash;\n-                            long lastSucessVersion = replica.getLastSuccessVersion();\n-                            long lastSuccessVersionHash = replica.getLastSuccessVersionHash();\n-                            if (!errorReplicaIds.contains(replica.getId())) {\n-                                if (replica.getLastFailedVersion() > 0) {\n-                                    // if the replica is a failed replica, then not changing version and version hash\n-                                    newVersion = replica.getVersion();\n-                                    newVersionHash = replica.getVersionHash();\n-                                } else if (!replica.checkVersionCatchUp(partition.getVisibleVersion(),\n-                                        partition.getVisibleVersionHash(), true)) {\n-                                    // this means the replica has error in the past, but we did not observe it\n-                                    // during upgrade, one job maybe in quorum finished state, for example, A,B,C 3 replica\n-                                    // A,B 's version is 10, C's version is 10 but C' 10 is abnormal should be rollback\n-                                    // then we will detect this and set C's last failed version to 10 and last success version to 11\n-                                    // this logic has to be replayed in checkpoint thread\n-                                    lastFailedVersion = partition.getVisibleVersion();\n-                                    lastFailedVersionHash = partition.getVisibleVersionHash();\n-                                    newVersion = replica.getVersion();\n-                                    newVersionHash = replica.getVersionHash();\n-                                }\n \n-                                // success version always move forward\n-                                lastSucessVersion = newCommitVersion;\n-                                lastSuccessVersionHash = newCommitVersionHash;\n-                            } else {\n-                                // for example, A,B,C 3 replicas, B,C failed during publish version, then B C will be set abnormal\n-                                // all loading will failed, B,C will have to recovery by clone, it is very inefficient and maybe lost data\n-                                // Using this method, B,C will publish failed, and fe will publish again, not update their last failed version\n-                                // if B is publish successfully in next turn, then B is normal and C will be set abnormal so that quorum is maintained\n-                                // and loading will go on.\n-                                newVersion = replica.getVersion();\n-                                newVersionHash = replica.getVersionHash();\n-                                if (newCommitVersion > lastFailedVersion) {\n-                                    lastFailedVersion = newCommitVersion;\n-                                    lastFailedVersionHash = newCommitVersionHash;\n-                                }\n-                            }\n-                            replica.updateVersionInfo(newVersion, newVersionHash, lastFailedVersion, lastFailedVersionHash, lastSucessVersion, lastSuccessVersionHash);\n-                        }\n-                    }\n-                } // end for indices\n-                long version = partitionCommitInfo.getVersion();\n-                long versionHash = partitionCommitInfo.getVersionHash();\n-                partition.updateVisibleVersionAndVersionHash(version, versionHash);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"transaction state {} set partition {}'s version to [{}] and version hash to [{}]\",\n-                              transactionState, partition.getId(), version, versionHash);\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-    \n-    private void updateTxnLabels(TransactionState transactionState) {\n-        Set<Long> txnIds = dbIdToTxnLabels.get(transactionState.getDbId(), transactionState.getLabel());\n-        if (txnIds == null) {\n-            txnIds = Sets.newHashSet();\n-            dbIdToTxnLabels.put(transactionState.getDbId(), transactionState.getLabel(), txnIds);\n-        }\n-        txnIds.add(transactionState.getTransactionId());\n-    }\n-    \n-    private void updateDbRunningTxnNum(TransactionStatus preStatus, TransactionState curTxnState) {\n-        Map<Long, Integer> txnNumMap = null;\n-        if (curTxnState.getSourceType() == LoadJobSourceType.ROUTINE_LOAD_TASK) {\n-            txnNumMap = runningRoutineLoadTxnNums;\n-        } else {\n-            txnNumMap = runningTxnNums;\n-        }\n-\n-        int txnNum = txnNumMap.getOrDefault(curTxnState.getDbId(), 0);\n-        if (preStatus == null\n-                && (curTxnState.getTransactionStatus() == TransactionStatus.PREPARE\n-                || curTxnState.getTransactionStatus() == TransactionStatus.COMMITTED)) {\n-            ++txnNum;\n-        } else if ((preStatus == TransactionStatus.PREPARE\n-                || preStatus == TransactionStatus.COMMITTED)\n-                && (curTxnState.getTransactionStatus() == TransactionStatus.VISIBLE\n-                || curTxnState.getTransactionStatus() == TransactionStatus.ABORTED)) {\n-            --txnNum;\n-        }\n-\n-        if (txnNum < 1) {\n-            txnNumMap.remove(curTxnState.getDbId());\n-        } else {\n-            txnNumMap.put(curTxnState.getDbId(), txnNum);\n-        }\n-    }\n-    \n     public List<List<Comparable>> getDbInfo() {\n         List<List<Comparable>> infos = new ArrayList<List<Comparable>>();\n-        readLock();\n-        try {\n-            Set<Long> dbIds = new HashSet<>();\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                dbIds.add(transactionState.getDbId());\n-            }\n-            for (long dbId : dbIds) {\n-                List<Comparable> info = new ArrayList<Comparable>();\n-                info.add(dbId);\n-                Database db = Catalog.getInstance().getDb(dbId);\n-                if (db == null) {\n-                    continue;\n-                }\n-                info.add(db.getFullName());\n-                infos.add(info);\n+        List<Long> dbIds = Lists.newArrayList();", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1MTI3OA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421551278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        txnNum = txnNum + dbTransactionMgr.getTransactionNum();\n          \n          \n            \n                        txnNum += dbTransactionMgr.getTransactionNum();", "author": "morningman", "createdAt": "2020-05-07T14:31:34Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -851,493 +243,114 @@ public boolean isIntersectionNotEmpty(List<Long> sourceTableIdList, List<Long> t\n      */\n     public void removeExpiredAndTimeoutTxns() {\n         long currentMillis = System.currentTimeMillis();\n-\n-        List<Long> timeoutTxns = Lists.newArrayList();\n-        List<Long> expiredTxns = Lists.newArrayList();\n-        readLock();\n-        try {\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                if (transactionState.isExpired(currentMillis)) {\n-                    // remove the txn which labels are expired\n-                    expiredTxns.add(transactionState.getTransactionId());\n-                } else if (transactionState.isTimeout(currentMillis)) {\n-                    // txn is running but timeout, abort it.\n-                    timeoutTxns.add(transactionState.getTransactionId());\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.removeExpiredTxns();\n+            List<Long> timeoutTxns = dbTransactionMgr.getTimeoutTxns(currentMillis);\n+            // abort timeout txns\n+            for (Long txnId : timeoutTxns) {\n+                try {\n+                    dbTransactionMgr.abortTransaction(txnId, \"timeout by txn manager\", null);\n+                    LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n+                } catch (UserException e) {\n+                    // abort may be failed. it is acceptable. just print a log\n+                    LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n                 }\n             }\n-        } finally {\n-            readUnlock();\n-        }\n \n-        // delete expired txns\n-        for (Long txnId : expiredTxns) {\n-            deleteTransaction(txnId);\n-            LOG.info(\"transaction [\" + txnId + \"] is expired, remove it from transaction manager\");\n-        }\n-\n-        // abort timeout txns\n-        for (Long txnId : timeoutTxns) {\n-            try {\n-                abortTransaction(txnId, \"timeout by txn manager\");\n-                LOG.info(\"transaction [\" + txnId + \"] is timeout, abort it by transaction manager\");\n-            } catch (UserException e) {\n-                // abort may be failed. it is acceptable. just print a log\n-                LOG.warn(\"abort timeout txn {} failed. msg: {}\", txnId, e.getMessage());\n-            }\n         }\n     }\n \n-    public TransactionState getTransactionState(long transactionId) {\n-        readLock();\n-        try {\n-            return idToTransactionState.get(transactionId);\n-        } finally {\n-            readUnlock();\n-        }\n+    public TransactionState getTransactionState(long dbId, long transactionId) {\n+        DatabaseTransactionMgr dbTransactionMgr = dbIdToDatabaseTransactionMgrs.get(dbId);\n+        return dbTransactionMgr.getTransactionState(transactionId);\n     }\n     \n     public void setEditLog(EditLog editLog) {\n-        this.editLog = editLog;\n         this.idGenerator.setEditLog(editLog);\n     }\n-    \n-    private void readLock() {\n-        this.transactionLock.readLock().lock();\n-    }\n-    \n-    private void readUnlock() {\n-        this.transactionLock.readLock().unlock();\n-    }\n-    \n-    private void writeLock() {\n-        this.transactionLock.writeLock().lock();\n-    }\n-    \n-    private void writeUnlock() {\n-        this.transactionLock.writeLock().unlock();\n-    }\n-    \n-    // for add/update/delete TransactionState\n-    private void unprotectUpsertTransactionState(TransactionState transactionState) {\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE\n-                || transactionState.getSourceType() == LoadJobSourceType.FRONTEND) {\n-            // if this is a prepare txn, and load source type is not FRONTEND\n-            // no need to persist it. if prepare txn lost, the following commit will just be failed.\n-            // user only need to retry this txn.\n-            // The FRONTEND type txn is committed and running asynchronously, so we have to persist it.\n-            editLog.logInsertTransactionState(transactionState);\n-        }\n-        idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-        updateTxnLabels(transactionState);\n-        updateDbRunningTxnNum(transactionState.getPreStatus(), transactionState);\n-    }\n-\n-    private void unprotectedCommitTransaction(TransactionState transactionState, Set<Long> errorReplicaIds,\n-                                              Map<Long, Set<Long>> tableToPartition, Set<Long> totalInvolvedBackends,\n-                                              Database db) {\n-        // transaction state is modified during check if the transaction could committed\n-        if (transactionState.getTransactionStatus() != TransactionStatus.PREPARE) {\n-            return;\n-        }\n-        // update transaction state version\n-        transactionState.setCommitTime(System.currentTimeMillis());\n-        transactionState.setTransactionStatus(TransactionStatus.COMMITTED);\n-        transactionState.setErrorReplicas(errorReplicaIds);\n-        for (long tableId : tableToPartition.keySet()) {\n-            TableCommitInfo tableCommitInfo = new TableCommitInfo(tableId);\n-            for (long partitionId : tableToPartition.get(tableId)) {\n-                OlapTable table = (OlapTable) db.getTable(tableId);\n-                Partition partition = table.getPartition(partitionId);\n-                PartitionCommitInfo partitionCommitInfo = new PartitionCommitInfo(partitionId,\n-                                                                                  partition.getNextVersion(),\n-                                                                                  partition.getNextVersionHash());\n-                tableCommitInfo.addPartitionCommitInfo(partitionCommitInfo);\n-            }\n-            transactionState.putIdToTableCommitInfo(tableId, tableCommitInfo);\n-        }\n-        // persist transactionState\n-        unprotectUpsertTransactionState(transactionState);\n-\n-        // add publish version tasks. set task to null as a placeholder.\n-        // tasks will be created when publishing version.\n-        for (long backendId : totalInvolvedBackends) {\n-            transactionState.addPublishVersionTask(backendId, null);\n-        }\n-    }\n \n-    private boolean unprotectAbortTransaction(long transactionId, String reason)\n-            throws UserException {\n-        TransactionState transactionState = idToTransactionState.get(transactionId);\n-        if (transactionState == null) {\n-            throw new UserException(\"transaction not found\");\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.ABORTED) {\n-            return false;\n-        }\n-        if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED\n-                || transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-            throw new UserException(\"transaction's state is already \"\n-                    + transactionState.getTransactionStatus() + \", could not abort\");\n-        }\n-        transactionState.setFinishTime(System.currentTimeMillis());\n-        transactionState.setReason(reason);\n-        transactionState.setTransactionStatus(TransactionStatus.ABORTED);\n-        unprotectUpsertTransactionState(transactionState);\n-        for (PublishVersionTask task : transactionState.getPublishVersionTasks().values()) {\n-            AgentTaskQueue.removeTask(task.getBackendId(), TTaskType.PUBLISH_VERSION, task.getSignature());\n-        }\n-        return true;\n-    }\n-    \n     // for replay idToTransactionState\n     // check point also run transaction cleaner, the cleaner maybe concurrently modify id to \n     public void replayUpsertTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            // set transaction status will call txn state change listener\n-            transactionState.replaySetTransactionStatus();\n-            Database db = catalog.getDb(transactionState.getDbId());\n-            if (transactionState.getTransactionStatus() == TransactionStatus.COMMITTED) {\n-                LOG.info(\"replay a committed transaction {}\", transactionState);\n-                updateCatalogAfterCommitted(transactionState, db);\n-            } else if (transactionState.getTransactionStatus() == TransactionStatus.VISIBLE) {\n-                LOG.info(\"replay a visible transaction {}\", transactionState);\n-                updateCatalogAfterVisible(transactionState, db);\n-            }\n-            TransactionState preTxnState = idToTransactionState.get(transactionState.getTransactionId());\n-            idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-            updateTxnLabels(transactionState);\n-            updateDbRunningTxnNum(preTxnState == null ? null : preTxnState.getTransactionStatus(),\n-                                  transactionState);\n-        } finally {\n-            writeUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.replayUpsertTransactionState(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay upsert transaction failed\", e);\n         }\n+\n     }\n     \n     public void replayDeleteTransactionState(TransactionState transactionState) {\n-        writeLock();\n         try {\n-            idToTransactionState.remove(transactionState.getTransactionId());\n-            Set<Long> txnIds = dbIdToTxnLabels.get(transactionState.getDbId(), transactionState.getLabel());\n-            txnIds.remove(transactionState.getTransactionId());\n-            if (txnIds.isEmpty()) {\n-                dbIdToTxnLabels.remove(transactionState.getDbId(), transactionState.getLabel());\n-            }\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-    \n-    private void updateCatalogAfterCommitted(TransactionState transactionState, Database db) {\n-        Set<Long> errorReplicaIds = transactionState.getErrorReplicas();\n-        for (TableCommitInfo tableCommitInfo : transactionState.getIdToTableCommitInfos().values()) {\n-            long tableId = tableCommitInfo.getTableId();\n-            OlapTable table = (OlapTable) db.getTable(tableId);\n-            for (PartitionCommitInfo partitionCommitInfo : tableCommitInfo.getIdToPartitionCommitInfo().values()) {\n-                long partitionId = partitionCommitInfo.getPartitionId();\n-                Partition partition = table.getPartition(partitionId);\n-                List<MaterializedIndex> allIndices = partition.getMaterializedIndices(IndexExtState.ALL);\n-                for (MaterializedIndex index : allIndices) {\n-                    List<Tablet> tablets = index.getTablets();\n-                    for (Tablet tablet : tablets) {\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            if (errorReplicaIds.contains(replica.getId())) {\n-                                // should not use partition.getNextVersion and partition.getNextVersionHash because partition's next version hash is generated locally\n-                                // should get from transaction state\n-                                replica.updateLastFailedVersion(partitionCommitInfo.getVersion(),\n-                                                                partitionCommitInfo.getVersionHash());\n-                            }\n-                        }\n-                    }\n-                }\n-                partition.setNextVersion(partition.getNextVersion() + 1);\n-                // Although committed version(hash) is not visible to user,\n-                // but they need to be synchronized among Frontends.\n-                // because we use committed version(hash) to create clone task, if the first Master FE\n-                // send clone task with committed version hash X, and than Master changed, the new Master FE\n-                // received the clone task report with version hash X, which not equals to it own committed\n-                // version hash, than the clone task is failed.\n-                partition.setNextVersionHash(Util.generateVersionHash() /* next version hash */,\n-                                             partitionCommitInfo.getVersionHash() /* committed version hash*/);\n-            }\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+            dbTransactionMgr.deleteTransaction(transactionState);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"replay delete transaction failed\", e);\n         }\n     }\n-    \n-    private boolean updateCatalogAfterVisible(TransactionState transactionState, Database db) {\n-        Set<Long> errorReplicaIds = transactionState.getErrorReplicas();\n-        for (TableCommitInfo tableCommitInfo : transactionState.getIdToTableCommitInfos().values()) {\n-            long tableId = tableCommitInfo.getTableId();\n-            OlapTable table = (OlapTable) db.getTable(tableId);\n-            for (PartitionCommitInfo partitionCommitInfo : tableCommitInfo.getIdToPartitionCommitInfo().values()) {\n-                long partitionId = partitionCommitInfo.getPartitionId();\n-                long newCommitVersion = partitionCommitInfo.getVersion();\n-                long newCommitVersionHash = partitionCommitInfo.getVersionHash();\n-                Partition partition = table.getPartition(partitionId);\n-                List<MaterializedIndex> allIndices = partition.getMaterializedIndices(IndexExtState.ALL);\n-                for (MaterializedIndex index : allIndices) {\n-                    for (Tablet tablet : index.getTablets()) {\n-                        for (Replica replica : tablet.getReplicas()) {\n-                            long lastFailedVersion = replica.getLastFailedVersion();\n-                            long lastFailedVersionHash = replica.getLastFailedVersionHash();\n-                            long newVersion = newCommitVersion;\n-                            long newVersionHash = newCommitVersionHash;\n-                            long lastSucessVersion = replica.getLastSuccessVersion();\n-                            long lastSuccessVersionHash = replica.getLastSuccessVersionHash();\n-                            if (!errorReplicaIds.contains(replica.getId())) {\n-                                if (replica.getLastFailedVersion() > 0) {\n-                                    // if the replica is a failed replica, then not changing version and version hash\n-                                    newVersion = replica.getVersion();\n-                                    newVersionHash = replica.getVersionHash();\n-                                } else if (!replica.checkVersionCatchUp(partition.getVisibleVersion(),\n-                                        partition.getVisibleVersionHash(), true)) {\n-                                    // this means the replica has error in the past, but we did not observe it\n-                                    // during upgrade, one job maybe in quorum finished state, for example, A,B,C 3 replica\n-                                    // A,B 's version is 10, C's version is 10 but C' 10 is abnormal should be rollback\n-                                    // then we will detect this and set C's last failed version to 10 and last success version to 11\n-                                    // this logic has to be replayed in checkpoint thread\n-                                    lastFailedVersion = partition.getVisibleVersion();\n-                                    lastFailedVersionHash = partition.getVisibleVersionHash();\n-                                    newVersion = replica.getVersion();\n-                                    newVersionHash = replica.getVersionHash();\n-                                }\n \n-                                // success version always move forward\n-                                lastSucessVersion = newCommitVersion;\n-                                lastSuccessVersionHash = newCommitVersionHash;\n-                            } else {\n-                                // for example, A,B,C 3 replicas, B,C failed during publish version, then B C will be set abnormal\n-                                // all loading will failed, B,C will have to recovery by clone, it is very inefficient and maybe lost data\n-                                // Using this method, B,C will publish failed, and fe will publish again, not update their last failed version\n-                                // if B is publish successfully in next turn, then B is normal and C will be set abnormal so that quorum is maintained\n-                                // and loading will go on.\n-                                newVersion = replica.getVersion();\n-                                newVersionHash = replica.getVersionHash();\n-                                if (newCommitVersion > lastFailedVersion) {\n-                                    lastFailedVersion = newCommitVersion;\n-                                    lastFailedVersionHash = newCommitVersionHash;\n-                                }\n-                            }\n-                            replica.updateVersionInfo(newVersion, newVersionHash, lastFailedVersion, lastFailedVersionHash, lastSucessVersion, lastSuccessVersionHash);\n-                        }\n-                    }\n-                } // end for indices\n-                long version = partitionCommitInfo.getVersion();\n-                long versionHash = partitionCommitInfo.getVersionHash();\n-                partition.updateVisibleVersionAndVersionHash(version, versionHash);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"transaction state {} set partition {}'s version to [{}] and version hash to [{}]\",\n-                              transactionState, partition.getId(), version, versionHash);\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-    \n-    private void updateTxnLabels(TransactionState transactionState) {\n-        Set<Long> txnIds = dbIdToTxnLabels.get(transactionState.getDbId(), transactionState.getLabel());\n-        if (txnIds == null) {\n-            txnIds = Sets.newHashSet();\n-            dbIdToTxnLabels.put(transactionState.getDbId(), transactionState.getLabel(), txnIds);\n-        }\n-        txnIds.add(transactionState.getTransactionId());\n-    }\n-    \n-    private void updateDbRunningTxnNum(TransactionStatus preStatus, TransactionState curTxnState) {\n-        Map<Long, Integer> txnNumMap = null;\n-        if (curTxnState.getSourceType() == LoadJobSourceType.ROUTINE_LOAD_TASK) {\n-            txnNumMap = runningRoutineLoadTxnNums;\n-        } else {\n-            txnNumMap = runningTxnNums;\n-        }\n-\n-        int txnNum = txnNumMap.getOrDefault(curTxnState.getDbId(), 0);\n-        if (preStatus == null\n-                && (curTxnState.getTransactionStatus() == TransactionStatus.PREPARE\n-                || curTxnState.getTransactionStatus() == TransactionStatus.COMMITTED)) {\n-            ++txnNum;\n-        } else if ((preStatus == TransactionStatus.PREPARE\n-                || preStatus == TransactionStatus.COMMITTED)\n-                && (curTxnState.getTransactionStatus() == TransactionStatus.VISIBLE\n-                || curTxnState.getTransactionStatus() == TransactionStatus.ABORTED)) {\n-            --txnNum;\n-        }\n-\n-        if (txnNum < 1) {\n-            txnNumMap.remove(curTxnState.getDbId());\n-        } else {\n-            txnNumMap.put(curTxnState.getDbId(), txnNum);\n-        }\n-    }\n-    \n     public List<List<Comparable>> getDbInfo() {\n         List<List<Comparable>> infos = new ArrayList<List<Comparable>>();\n-        readLock();\n-        try {\n-            Set<Long> dbIds = new HashSet<>();\n-            for (TransactionState transactionState : idToTransactionState.values()) {\n-                dbIds.add(transactionState.getDbId());\n-            }\n-            for (long dbId : dbIds) {\n-                List<Comparable> info = new ArrayList<Comparable>();\n-                info.add(dbId);\n-                Database db = Catalog.getInstance().getDb(dbId);\n-                if (db == null) {\n-                    continue;\n-                }\n-                info.add(db.getFullName());\n-                infos.add(info);\n+        List<Long> dbIds = Lists.newArrayList();\n+        for (Long dbId : dbIdToDatabaseTransactionMgrs.keySet()) {\n+            dbIds.add(dbId);\n+        }\n+\n+        for (long dbId : dbIds) {\n+            List<Comparable> info = new ArrayList<Comparable>();\n+            info.add(dbId);\n+            Database db = Catalog.getInstance().getDb(dbId);\n+            if (db == null) {\n+                continue;\n             }\n-        } finally {\n-            readUnlock();\n+            info.add(db.getFullName());\n+            infos.add(info);\n         }\n         return infos;\n     }\n     \n     public List<List<String>> getDbTransStateInfo(long dbId) {\n-        List<List<String>> infos = Lists.newArrayList();\n-        readLock();\n         try {\n-            infos.add(Lists.newArrayList(\"running\", String.valueOf(\n-                    runningTxnNums.getOrDefault(dbId, 0) + runningRoutineLoadTxnNums.getOrDefault(dbId, 0))));\n-            long finishedNum = idToTransactionState.values().stream().filter(\n-                    t -> (t.getDbId() == dbId && t.getTransactionStatus().isFinalStatus())).count();\n-            infos.add(Lists.newArrayList(\"finished\", String.valueOf(finishedNum)));\n-        } finally {\n-            readUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+            return dbTransactionMgr.getDbTransStateInfo();\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"Get db transaction state info failed\", e);\n+            return Lists.newArrayList();\n         }\n-        return infos;\n     }\n \n     public List<List<String>> getDbTransInfo(long dbId, boolean running, int limit) throws AnalysisException {\n-        List<List<String>> infos = new ArrayList<>();\n-        readLock();\n-        try {\n-            Database db = Catalog.getInstance().getDb(dbId);\n-            if (db == null) {\n-                throw new AnalysisException(\"Database[\" + dbId + \"] does not exist\");\n-            }\n-\n-            // get transaction order by txn id desc limit 'limit'\n-            idToTransactionState.values().stream()\n-                    .filter(t -> (t.getDbId() == dbId && (running != t.getTransactionStatus().isFinalStatus())))\n-                    .sorted(TransactionState.TXN_ID_COMPARATOR)\n-                    .limit(limit)\n-                    .forEach(t -> {\n-                        List<String> info = Lists.newArrayList();\n-                        getTxnStateInfo(t, info);\n-                        infos.add(info);\n-                    });\n-        } finally {\n-            readUnlock();\n-        }\n-        return infos;\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+        return dbTransactionMgr.getTxnStateInfoList(running, limit);\n     }\n     \n     // get show info of a specified txnId\n     public List<List<String>> getSingleTranInfo(long dbId, long txnId) throws AnalysisException {\n-        List<List<String>> infos = new ArrayList<List<String>>();\n-        readLock();\n-        try {\n-            Database db = Catalog.getInstance().getDb(dbId);\n-            if (db == null) {\n-                throw new AnalysisException(\"Database[\" + dbId + \"] does not exist\");\n-            }\n-            \n-            TransactionState txnState = idToTransactionState.get(txnId);\n-            if (txnState == null) {\n-                throw new AnalysisException(\"transaction with id \" + txnId + \" does not exist\");\n-            }\n-            \n-            if (ConnectContext.get() != null) {\n-                // check auth\n-                Set<Long> tblIds = txnState.getIdToTableCommitInfos().keySet();\n-                for (Long tblId : tblIds) {\n-                    Table tbl = db.getTable(tblId);\n-                    if (tbl != null) {\n-                        if (!Catalog.getCurrentCatalog().getAuth().checkTblPriv(ConnectContext.get(), db.getFullName(),\n-                                tbl.getName(), PrivPredicate.SHOW)) {\n-                            ErrorReport.reportAnalysisException(ErrorCode.ERR_TABLEACCESS_DENIED_ERROR,\n-                                    \"SHOW TRANSACTION\",\n-                                    ConnectContext.get().getQualifiedUser(),\n-                                    ConnectContext.get().getRemoteIP(),\n-                                    tbl.getName());\n-                        }\n-                    }\n-                }\n-            }\n-            \n-            List<String> info = Lists.newArrayList();\n-            getTxnStateInfo(txnState, info);\n-            infos.add(info);\n-        } finally {\n-            readUnlock();\n-        }\n-        return infos;\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+        return dbTransactionMgr.getSingleTranInfo(dbId, txnId);\n     }\n-    \n-    private void getTxnStateInfo(TransactionState txnState, List<String> info) {\n-        info.add(String.valueOf(txnState.getTransactionId()));\n-        info.add(txnState.getLabel());\n-        info.add(txnState.getCoordinator().toString());\n-        info.add(txnState.getTransactionStatus().name());\n-        info.add(txnState.getSourceType().name());\n-        info.add(TimeUtils.longToTimeString(txnState.getPrepareTime()));\n-        info.add(TimeUtils.longToTimeString(txnState.getCommitTime()));\n-        info.add(TimeUtils.longToTimeString(txnState.getFinishTime()));\n-        info.add(txnState.getReason());\n-        info.add(String.valueOf(txnState.getErrorReplicas().size()));\n-        info.add(String.valueOf(txnState.getCallbackId()));\n-        info.add(String.valueOf(txnState.getTimeoutMs()));\n-    }\n-\n-    public List<List<Comparable>> getTableTransInfo(long txnId) throws AnalysisException {\n-        List<List<Comparable>> tableInfos = new ArrayList<>();\n-        readLock();\n-        try {\n-            TransactionState transactionState = idToTransactionState.get(txnId);\n-            if (null == transactionState) {\n-                throw new AnalysisException(\"Transaction[\" + txnId + \"] does not exist.\");\n-            }\n \n-            for (Map.Entry<Long, TableCommitInfo> entry : transactionState.getIdToTableCommitInfos().entrySet()) {\n-                List<Comparable> tableInfo = new ArrayList<>();\n-                tableInfo.add(entry.getKey());\n-                tableInfo.add(Joiner.on(\", \").join(entry.getValue().getIdToPartitionCommitInfo().values().stream().map(\n-                        PartitionCommitInfo::getPartitionId).collect(Collectors.toList())));\n-                tableInfos.add(tableInfo);\n-            }\n-        } finally {\n-            readUnlock();\n-        }\n-        return tableInfos;\n+    public List<List<Comparable>> getTableTransInfo(long dbId, long txnId) throws AnalysisException {\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+        return dbTransactionMgr.getTableTransInfo(txnId);\n     }\n     \n-    public List<List<Comparable>> getPartitionTransInfo(long tid, long tableId)\n+    public List<List<Comparable>> getPartitionTransInfo(long dbId, long tid, long tableId)\n             throws AnalysisException {\n-        List<List<Comparable>> partitionInfos = new ArrayList<List<Comparable>>();\n-        readLock();\n-        try {\n-            TransactionState transactionState = idToTransactionState.get(tid);\n-            if (null == transactionState) {\n-                throw new AnalysisException(\"Transaction[\" + tid + \"] does not exist.\");\n-            }\n-            TableCommitInfo tableCommitInfo = transactionState.getIdToTableCommitInfos().get(tableId);\n-            Map<Long, PartitionCommitInfo> idToPartitionCommitInfo = tableCommitInfo.getIdToPartitionCommitInfo();\n-            for (Map.Entry<Long, PartitionCommitInfo> entry : idToPartitionCommitInfo.entrySet()) {\n-                List<Comparable> partitionInfo = new ArrayList<Comparable>();\n-                partitionInfo.add(entry.getKey());\n-                partitionInfo.add(entry.getValue().getVersion());\n-                partitionInfo.add(entry.getValue().getVersionHash());\n-                partitionInfos.add(partitionInfo);\n-            }\n-        } finally {\n-            readUnlock();\n-        }\n-        return partitionInfos;\n+        DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+        return dbTransactionMgr.getPartitionTransInfo(tid, tableId);\n     }\n-    \n+\n+    /**\n+     * It is a non thread safe method, only invoked by checkpoint thread without any lock or image dump thread with db lock\n+     */\n     public int getTransactionNum() {\n-        return this.idToTransactionState.size();\n+        int txnNum = 0;\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            txnNum = txnNum + dbTransactionMgr.getTransactionNum();", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1NTk5NA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421555994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return txnInfos.size() > limit ? new ArrayList<>(txnInfos.subList(0, limit)) : txnInfos;\n          \n          \n            \n                    return txnInfos.size() > limit ? txnInfos.subList(0, limit) : txnInfos;", "author": "morningman", "createdAt": "2020-05-07T14:37:09Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -1346,81 +359,71 @@ public TransactionIdGenerator getTransactionIDGenerator() {\n \n     @Override\n     public void write(DataOutput out) throws IOException {\n-        int numTransactions = idToTransactionState.size();\n+        int numTransactions = getTransactionNum();\n         out.writeInt(numTransactions);\n-        for (Map.Entry<Long, TransactionState> entry : idToTransactionState.entrySet()) {\n-            entry.getValue().write(out);\n+        for (DatabaseTransactionMgr dbTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            dbTransactionMgr.unprotectWriteAllTransactionStates(out);\n         }\n         idGenerator.write(out);\n     }\n     \n     public void readFields(DataInput in) throws IOException {\n-        int numTransactions = in.readInt();\n-        for (int i = 0; i < numTransactions; ++i) {\n-            TransactionState transactionState = new TransactionState();\n-            transactionState.readFields(in);\n-            TransactionState preTxnState = idToTransactionState.get(transactionState.getTransactionId());\n-            idToTransactionState.put(transactionState.getTransactionId(), transactionState);\n-            updateTxnLabels(transactionState);\n-            updateDbRunningTxnNum(preTxnState == null ? null : preTxnState.getTransactionStatus(),\n-                                  transactionState);\n+        try {\n+            int numTransactions = in.readInt();\n+            for (int i = 0; i < numTransactions; ++i) {\n+                TransactionState transactionState = new TransactionState();\n+                transactionState.readFields(in);\n+                DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(transactionState.getDbId());\n+                dbTransactionMgr.unprotectUpsertTransactionState(transactionState, true);\n+            }\n+            idGenerator.readFields(in);\n+        } catch (AnalysisException e) {\n+            throw new IOException(\"Read transaction states failed\", e);\n         }\n-        idGenerator.readFields(in);\n+\n     }\n \n-    public TransactionState getTransactionStateByCallbackIdAndStatus(long callbackId, Set<TransactionStatus> status) {\n-        readLock();\n+    public TransactionState getTransactionStateByCallbackIdAndStatus(long dbId, long callbackId, Set<TransactionStatus> status) {\n         try {\n-            for (TransactionState txn : idToTransactionState.values()) {\n-                if (txn.getCallbackId() == callbackId && status.contains(txn.getTransactionStatus())) {\n-                    return txn;\n-                }\n-            }\n-        } finally {\n-            readUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+            return dbTransactionMgr.getTransactionStateByCallbackIdAndStatus(callbackId, status);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"Get transaction by callbackId and status failed\", e);\n+            return null;\n         }\n-        return null;\n     }\n \n-    public TransactionState getTransactionStateByCallbackId(long callbackId) {\n-        readLock();\n+    public TransactionState getTransactionStateByCallbackId(long dbId, long callbackId) {\n         try {\n-            for (TransactionState txn : idToTransactionState.values()) {\n-                if (txn.getCallbackId() == callbackId) {\n-                    return txn;\n-                }\n-            }\n-        } finally {\n-            readUnlock();\n+            DatabaseTransactionMgr dbTransactionMgr = getDatabaseTransactioMgr(dbId);\n+            return dbTransactionMgr.getTransactionStateByCallbackId(callbackId);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"Get transaction by callbackId failed\", e);\n+            return null;\n         }\n-        return null;\n     }\n \n-    public List<Long> getTransactionIdByCoordinateBe(String coordinateHost, int limit) {\n-        ArrayList<Long> txnIds = new ArrayList<>();\n-        readLock();\n-        try {\n-            idToTransactionState.values().stream()\n-                    .filter(t -> (t.getCoordinator().sourceType == TransactionState.TxnSourceType.BE\n-                            && t.getCoordinator().ip.equals(coordinateHost)\n-                            && (!t.getTransactionStatus().isFinalStatus())))\n-                    .limit(limit)\n-                    .forEach(t -> txnIds.add(t.getTransactionId()));\n-        } finally {\n-            readUnlock();\n+    public List<Pair<Long, Long>> getTransactionIdByCoordinateBe(String coordinateHost, int limit) {\n+        ArrayList<Pair<Long, Long>> txnInfos = new ArrayList<>();\n+        for (DatabaseTransactionMgr databaseTransactionMgr : dbIdToDatabaseTransactionMgrs.values()) {\n+            txnInfos.addAll(databaseTransactionMgr.getTransactionIdByCoordinateBe(coordinateHost, limit));\n+            if (txnInfos.size() > limit) {\n+                break;\n+            }\n         }\n-        return txnIds;\n+        return txnInfos.size() > limit ? new ArrayList<>(txnInfos.subList(0, limit)) : txnInfos;", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMDc0NA==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421610744", "bodyText": "@morningman  subList is a view of origin list, so is it a good way to directly return sublist?", "author": "caiconghui", "createdAt": "2020-05-07T15:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1NTk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxMjk1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r422612957", "bodyText": "I think it's OK, cause no one will modify that list.", "author": "morningman", "createdAt": "2020-05-10T08:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1NTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1NjU0Ng==", "url": "https://github.com/apache/incubator-doris/pull/3369#discussion_r421556546", "bodyText": "You can use org.apache.doris.common.Pair", "author": "morningman", "createdAt": "2020-05-07T14:37:50Z", "path": "fe/src/main/java/org/apache/doris/transaction/GlobalTransactionMgr.java", "diffHunk": "@@ -17,69 +17,33 @@\n \n package org.apache.doris.transaction;\n \n+import org.apache.commons.lang3.tuple.Pair;", "originalCommit": "6a2a0f488e46f078a4bcac7049844c572a1b2c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d9b4c526ce2963fe2a13e72695dbc885d19a2972", "url": "https://github.com/apache/incubator-doris/commit/d9b4c526ce2963fe2a13e72695dbc885d19a2972", "message": "Suppprt db level isolation for GloabalTransactionMgr", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "68437122c9e54f6d667380ff46fd4384ef0a7d87", "url": "https://github.com/apache/incubator-doris/commit/68437122c9e54f6d667380ff46fd4384ef0a7d87", "message": "fix", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "2b6e4a8b24a01dfe2721bfcbf457b6280d3e7a56", "url": "https://github.com/apache/incubator-doris/commit/2b6e4a8b24a01dfe2721bfcbf457b6280d3e7a56", "message": "fix compile error", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "805c81877087145525662defcc95328ac3b3e960", "url": "https://github.com/apache/incubator-doris/commit/805c81877087145525662defcc95328ac3b3e960", "message": "fix", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "c00640d7f4bcd111f823801353eea000233a4fd3", "url": "https://github.com/apache/incubator-doris/commit/c00640d7f4bcd111f823801353eea000233a4fd3", "message": "fix error", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "e0fd394eb7c4550889a42ebb6725efe763700a2a", "url": "https://github.com/apache/incubator-doris/commit/e0fd394eb7c4550889a42ebb6725efe763700a2a", "message": "fix unittest", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "eeb5c9df1931c2f55b6d10b5897da010322330f5", "url": "https://github.com/apache/incubator-doris/commit/eeb5c9df1931c2f55b6d10b5897da010322330f5", "message": "move some GlobalTransactionMgr function to DatabaseTransactionMgr", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "09b8a84aa50fa42e79e483e1b366b098eea576ef", "url": "https://github.com/apache/incubator-doris/commit/09b8a84aa50fa42e79e483e1b366b098eea576ef", "message": "fix unitest error", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "3d28a509164a86c49ae91ff69231de83158e0a8e", "url": "https://github.com/apache/incubator-doris/commit/3d28a509164a86c49ae91ff69231de83158e0a8e", "message": "Fix some bug and add DatabaseTransactionMgrTest", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "3c4f262184bb71870cfcf9bd4cdebc931c147125", "url": "https://github.com/apache/incubator-doris/commit/3c4f262184bb71870cfcf9bd4cdebc931c147125", "message": "Fix nullpointer exception and change AtomicInteger to int", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "61529150047d18b4723d31641e203e1185a58df6", "url": "https://github.com/apache/incubator-doris/commit/61529150047d18b4723d31641e203e1185a58df6", "message": "fix", "committedDate": "2020-05-10T10:08:54Z", "type": "commit"}, {"oid": "a7fb515b15f6a11c4892bc2dfa3caf0dd49ff6ae", "url": "https://github.com/apache/incubator-doris/commit/a7fb515b15f6a11c4892bc2dfa3caf0dd49ff6ae", "message": "fix", "committedDate": "2020-05-10T10:09:47Z", "type": "commit"}, {"oid": "573a624dfaa40f78b8f640874b273f9eee448f10", "url": "https://github.com/apache/incubator-doris/commit/573a624dfaa40f78b8f640874b273f9eee448f10", "message": "fix", "committedDate": "2020-05-10T10:09:47Z", "type": "commit"}, {"oid": "9d52bfebd01c1ce1efc4166e672e797fef09b2c0", "url": "https://github.com/apache/incubator-doris/commit/9d52bfebd01c1ce1efc4166e672e797fef09b2c0", "message": "change nullpointer exception for databaseTransMgr to analysis exception", "committedDate": "2020-05-10T10:09:47Z", "type": "commit"}, {"oid": "6994cfb50874d59b30753fd105cb65200f74971e", "url": "https://github.com/apache/incubator-doris/commit/6994cfb50874d59b30753fd105cb65200f74971e", "message": "fix", "committedDate": "2020-05-10T10:09:47Z", "type": "commit"}, {"oid": "6c07a1373a5ba9d34235dc454a29682ea04b602c", "url": "https://github.com/apache/incubator-doris/commit/6c07a1373a5ba9d34235dc454a29682ea04b602c", "message": "remove unused build contents", "committedDate": "2020-05-10T10:10:47Z", "type": "commit"}, {"oid": "87ac999d7d933400cc85b566941886bf8dccfff3", "url": "https://github.com/apache/incubator-doris/commit/87ac999d7d933400cc85b566941886bf8dccfff3", "message": "fix unittest error for DeleteHandlerTest", "committedDate": "2020-05-10T10:10:49Z", "type": "commit"}, {"oid": "c130a95ad87ad515f609cbd5ef470b5295e4822b", "url": "https://github.com/apache/incubator-doris/commit/c130a95ad87ad515f609cbd5ef470b5295e4822b", "message": "fix nullpointer exception", "committedDate": "2020-05-10T10:10:49Z", "type": "commit"}, {"oid": "c942e7543917818f2c01260d051e87708094dbed", "url": "https://github.com/apache/incubator-doris/commit/c942e7543917818f2c01260d051e87708094dbed", "message": "fix", "committedDate": "2020-05-10T10:10:49Z", "type": "commit"}, {"oid": "8024a10c74fb7aa73bcafe6490dd511f850ab7d8", "url": "https://github.com/apache/incubator-doris/commit/8024a10c74fb7aa73bcafe6490dd511f850ab7d8", "message": "fix some code", "committedDate": "2020-05-10T10:10:49Z", "type": "commit"}, {"oid": "8024a10c74fb7aa73bcafe6490dd511f850ab7d8", "url": "https://github.com/apache/incubator-doris/commit/8024a10c74fb7aa73bcafe6490dd511f850ab7d8", "message": "fix some code", "committedDate": "2020-05-10T10:10:49Z", "type": "forcePushed"}]}