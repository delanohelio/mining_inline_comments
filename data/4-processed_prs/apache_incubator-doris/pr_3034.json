{"pr_number": 3034, "pr_title": "implements intersect node", "pr_createdAt": "2020-03-04T11:02:05Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3034", "timeline": [{"oid": "6bb225b937bc5c646e66a5756b88688604ef42a0", "url": "https://github.com/apache/incubator-doris/commit/6bb225b937bc5c646e66a5756b88688604ef42a0", "message": "implements intersect node", "committedDate": "2020-03-04T11:10:51Z", "type": "forcePushed"}, {"oid": "28de5b1b605258ae28a7a51ba650b982ab0178c0", "url": "https://github.com/apache/incubator-doris/commit/28de5b1b605258ae28a7a51ba650b982ab0178c0", "message": "implements intersect node", "committedDate": "2020-03-04T11:13:46Z", "type": "forcePushed"}, {"oid": "c5e54241221f5f6a7f359d02ac273a22f59c9154", "url": "https://github.com/apache/incubator-doris/commit/c5e54241221f5f6a7f359d02ac273a22f59c9154", "message": "implements intersect node", "committedDate": "2020-03-04T11:17:45Z", "type": "forcePushed"}, {"oid": "ccd67794012aa0d39a18bff851e1c445c6924d57", "url": "https://github.com/apache/incubator-doris/commit/ccd67794012aa0d39a18bff851e1c445c6924d57", "message": "implements intersect node", "committedDate": "2020-03-04T11:56:50Z", "type": "forcePushed"}, {"oid": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "url": "https://github.com/apache/incubator-doris/commit/8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "message": "implements intersect node", "committedDate": "2020-03-04T12:01:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NDkwMA==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387644900", "bodyText": "Move the TODO?", "author": "morningman", "createdAt": "2020-03-04T12:50:00Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,23 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n // TODO(yangzhengguo) implememt this class", "originalCommit": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY0NzYyMw==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387647623", "bodyText": "What's this comment mean?", "author": "morningman", "createdAt": "2020-03-04T12:55:30Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row", "originalCommit": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1MTY2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387651669", "bodyText": "the _children.size() is 2, so is it possible to enter this else?", "author": "morningman", "createdAt": "2020-03-04T13:03:05Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {", "originalCommit": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NzIxNQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387657215", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");\n          \n          \n            \n                        RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while probing the hash table.\");", "author": "morningman", "createdAt": "2020-03-04T13:13:50Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +43,177 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    // pre-computeselect k4 from t where k4 <4 the tuple index of build tuples in the output row\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 1; i < _children.size(); ++i) {\n+        // build hash table\n+        HashTable* temp_tbl =\n+                new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size, false,\n+                              _find_nulls, id(), mem_tracker(), 1024);\n+        if (i == 1) {\n+            _hash_tbl.reset(temp_tbl);\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int i = 0; i < build_batch.num_rows(); ++i) {\n+                    _hash_tbl->insert(build_batch.get_row(i));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();\n+            }\n+            _hash_tbl->close();\n+            _hash_tbl.reset(temp_tbl);\n+        }\n+        // probe\n+        _probe_batch.reset(new RowBatch(child(i)->row_desc(), state->batch_size(), mem_tracker()));\n+        RETURN_IF_ERROR(child(i)->open(state));\n+        while (true) {\n+            RETURN_IF_CANCELLED(state);\n+            bool eos = true;\n+            RETURN_IF_ERROR(child(i)->get_next(state, _probe_batch.get(), &eos));\n+            RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect , while constructing the hash table.\");", "originalCommit": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTAzNg==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387659036", "bodyText": "Not used?", "author": "morningman", "createdAt": "2020-03-04T13:17:08Z", "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -38,61 +44,36 @@ class IntersectNode : public ExecNode {\n \n     virtual Status init(const TPlanNode& tnode, RuntimeState* state = nullptr);\n     virtual Status prepare(RuntimeState* state);\n-    virtual void codegen(RuntimeState* state);\n     virtual Status open(RuntimeState* state);\n     virtual Status get_next(RuntimeState* state, RowBatch* row_batch, bool* eos);\n     // virtual Status reset(RuntimeState* state);\n     virtual Status close(RuntimeState* state);\n \n private:\n-    /// Tuple id resolved in Prepare() to set tuple_desc_;\n-    const int _tuple_id;\n-\n-    /// Descriptor for tuples this union node constructs.\n-    const TupleDescriptor* _tuple_desc;\n-\n-    /// Index of the first non-passthrough child; i.e. a child that needs materialization.\n-    /// 0 when all children are materialized, '_children.size()' when no children are\n-    /// materialized.\n-    const int _first_materialized_child_idx;\n-\n-    /// Const exprs materialized by this node. These exprs don't refer to any children.\n-    /// Only materialized by the first fragment instance to avoid duplication.\n+    // Const exprs materialized by this node. These exprs don't refer to any children.\n+    // Only materialized by the first fragment instance to avoid duplication.\n     std::vector<std::vector<ExprContext*>> _const_expr_lists;\n \n-    /// Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n+    // Exprs materialized by this node. The i-th result expr list refers to the i-th child.\n     std::vector<std::vector<ExprContext*>> _child_expr_lists;\n \n-    /////////////////////////////////////////\n-    /// BEGIN: Members that must be Reset()\n-\n-    /// Index of current child.\n-    int _child_idx;\n-\n-    /// Current row batch of current child. We reset the pointer to a new RowBatch\n-    /// when switching to a different child.\n-    std::unique_ptr<RowBatch> _child_batch;\n-\n-    /// Index of current row in child_row_batch_.\n-    int _child_row_idx;\n-\n-    typedef void (*IntersectMaterializeBatchFn)(IntersectNode*, RowBatch*, uint8_t**);\n-    /// Vector of pointers to codegen'ed materialize_batch functions. The vector contains one\n-    /// function for each child. The size of the vector should be equal to the number of\n-    /// children. If a child is passthrough, there should be a NULL for that child. If\n-    /// Codegen is disabled, there should be a NULL for every child.\n-    std::vector<IntersectMaterializeBatchFn> _codegend_except_materialize_batch_fns;\n+    boost::scoped_ptr<HashTable> _hash_tbl;\n+    HashTable::Iterator _hash_tbl_iterator;\n+    boost::scoped_ptr<RowBatch> _probe_batch;\n \n-    /// Saved from the last to GetNext() on the current child.\n-    bool _child_eos;\n+    boost::scoped_ptr<MemPool> _build_pool;  // holds everything referenced in _hash_tbl\n \n-    /// Index of current const result expr list.\n-    int _const_expr_list_idx;\n+    // _build_tuple_idx[i] is the tuple index of child(1)'s tuple[i] in the output row\n+    std::vector<int> _build_tuple_idx;\n+    int _build_tuple_size;\n+    int _build_tuple_row_size;\n+    std::vector<bool> _find_nulls;\n \n-    /// Index of the child that needs to be closed on the next GetNext() call. Should be set\n-    /// to -1 if no child needs to be closed.\n-    int _to_close_child_idx;\n+    // for right outer joins, keep track of what's been joined\n+    typedef boost::unordered_set<TupleRow*> TempTupleRowSet;\n+    TempTupleRowSet _temp_rows;", "originalCommit": "8f51a58b3f7f0362cb06442ddac7f27aa8c2e55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5Nzg1NQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r387597855", "bodyText": "use std::unique_ptr and std::unordered_set instead.", "author": "chaoyli", "createdAt": "2020-03-04T11:09:01Z", "path": "be/src/exec/intersect_node.h", "diffHunk": "@@ -20,11 +20,17 @@\n #define  DORIS_BE_SRC_QUERY_EXEC_INTERSECT_NODE_H\n \n #include \"exec/exec_node.h\"\n-#include \"runtime/row_batch.h\"\n-#include \"runtime/runtime_state.h\"\n+\n+#include <boost/unordered_set.hpp>\n+#include <boost/scoped_ptr.hpp>", "originalCommit": "78da6934195e4aeb2824c7944019cb0ea13047d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "801566ebd3168ef2139df2cf05c7e8c91ad3583f", "url": "https://github.com/apache/incubator-doris/commit/801566ebd3168ef2139df2cf05c7e8c91ad3583f", "message": "implements intersect node", "committedDate": "2020-03-05T01:55:19Z", "type": "forcePushed"}, {"oid": "d2ed4b2d64761065251354d07691afee346ac8cb", "url": "https://github.com/apache/incubator-doris/commit/d2ed4b2d64761065251354d07691afee346ac8cb", "message": "implements intersect node", "committedDate": "2020-03-05T01:57:06Z", "type": "forcePushed"}, {"oid": "2b60dbd7e9bf3577332a7872013da8995da68459", "url": "https://github.com/apache/incubator-doris/commit/2b60dbd7e9bf3577332a7872013da8995da68459", "message": "implements intersect node", "committedDate": "2020-03-05T02:01:46Z", "type": "forcePushed"}, {"oid": "81028ef6ef59b4c7638810fce3e97a93865bd003", "url": "https://github.com/apache/incubator-doris/commit/81028ef6ef59b4c7638810fce3e97a93865bd003", "message": "implements intersect node", "committedDate": "2020-03-05T02:13:49Z", "type": "forcePushed"}, {"oid": "4e6832606a099154ab97ce0eb6638411a2ce9394", "url": "https://github.com/apache/incubator-doris/commit/4e6832606a099154ab97ce0eb6638411a2ce9394", "message": "implements intersect node", "committedDate": "2020-03-05T02:21:25Z", "type": "forcePushed"}, {"oid": "d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "url": "https://github.com/apache/incubator-doris/commit/d7ce5e40e033829dde8f12788b3a115cfac5cfb2", "message": "implements intersect node", "committedDate": "2020-03-05T03:04:48Z", "type": "forcePushed"}, {"oid": "1a988b39f3cde9261662b03e5bb615b2aab89c69", "url": "https://github.com/apache/incubator-doris/commit/1a988b39f3cde9261662b03e5bb615b2aab89c69", "message": "implements intersect node", "committedDate": "2020-03-05T03:55:38Z", "type": "forcePushed"}, {"oid": "43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "url": "https://github.com/apache/incubator-doris/commit/43b62c1e08a24c7b0ba9ae52984cfb1748d1fec9", "message": "implements intersect node", "committedDate": "2020-03-05T03:59:25Z", "type": "forcePushed"}, {"oid": "f08b227a6147a1e9e0fa01df13d8f77592f94467", "url": "https://github.com/apache/incubator-doris/commit/f08b227a6147a1e9e0fa01df13d8f77592f94467", "message": "implements intersect node", "committedDate": "2020-03-05T06:04:56Z", "type": "forcePushed"}, {"oid": "4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "url": "https://github.com/apache/incubator-doris/commit/4b321b6f168a3a6db70f341e2a47ad7ee875ef93", "message": "implements intersect node", "committedDate": "2020-03-05T06:10:50Z", "type": "forcePushed"}, {"oid": "b09c5b3b4e06e42a472358fedef026807a72f890", "url": "https://github.com/apache/incubator-doris/commit/b09c5b3b4e06e42a472358fedef026807a72f890", "message": "implements intersect node", "committedDate": "2020-03-05T07:30:59Z", "type": "forcePushed"}, {"oid": "62df2d6c12ac0b041f369482aecabe21fd8cc6be", "url": "https://github.com/apache/incubator-doris/commit/62df2d6c12ac0b041f369482aecabe21fd8cc6be", "message": "implements intersect node", "committedDate": "2020-03-05T07:58:21Z", "type": "forcePushed"}, {"oid": "0a32f411248c7bc802f4203331748146f26720b7", "url": "https://github.com/apache/incubator-doris/commit/0a32f411248c7bc802f4203331748146f26720b7", "message": "implements intersect node", "committedDate": "2020-03-05T08:27:16Z", "type": "forcePushed"}, {"oid": "4d5ef754170c2481ac9bfd03d352d461c3c367b4", "url": "https://github.com/apache/incubator-doris/commit/4d5ef754170c2481ac9bfd03d352d461c3c367b4", "message": "implements intersect node", "committedDate": "2020-03-05T08:31:11Z", "type": "forcePushed"}, {"oid": "588e3421afe47c8c0bdad520098165a2b30d2767", "url": "https://github.com/apache/incubator-doris/commit/588e3421afe47c8c0bdad520098165a2b30d2767", "message": "implements intersect node", "committedDate": "2020-03-05T09:43:27Z", "type": "forcePushed"}, {"oid": "890a10df8fedb10c85ab49e2edb34518f89ae68b", "url": "https://github.com/apache/incubator-doris/commit/890a10df8fedb10c85ab49e2edb34518f89ae68b", "message": "implements intersect node", "committedDate": "2020-03-05T09:49:18Z", "type": "forcePushed"}, {"oid": "3d9ce0d7a19cd42f4d35152553996d12075ae69b", "url": "https://github.com/apache/incubator-doris/commit/3d9ce0d7a19cd42f4d35152553996d12075ae69b", "message": "implements intersect node", "committedDate": "2020-03-06T01:44:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0ODY5NQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388748695", "bodyText": "const_expr_list not use? why not delete it?", "author": "wutiangan", "createdAt": "2020-03-06T07:29:52Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -17,36 +17,21 @@\n \n #include \"exec/intersect_node.h\"\n \n+#include \"exec/hash_table.hpp\"\n #include \"exprs/expr.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/runtime_state.h\"\n \n namespace doris {\n-// TODO(yangzhengguo) implememt this class\n-IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode,\n-    const DescriptorTbl& descs)\n-    : ExecNode(pool, tnode, descs),\n-      _tuple_id(tnode.intersect_node.tuple_id),\n-      _tuple_desc(nullptr),\n-      _first_materialized_child_idx(tnode.intersect_node.first_materialized_child_idx),\n-      _child_idx(0),\n-      _child_batch(nullptr),\n-      _child_row_idx(0),\n-      _child_eos(false),\n-      _const_expr_list_idx(0),\n-      _to_close_child_idx(-1) {\n-}\n+IntersectNode::IntersectNode(ObjectPool* pool, const TPlanNode& tnode, const DescriptorTbl& descs)\n+        : ExecNode(pool, tnode, descs) {}\n \n Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n-    // RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     RETURN_IF_ERROR(ExecNode::init(tnode, state));\n     DCHECK(tnode.__isset.intersect_node);\n     DCHECK_EQ(_conjunct_ctxs.size(), 0);\n-    // Create const_expr_ctx_lists_ from thrift exprs.\n-    auto& const_texpr_lists = tnode.intersect_node.const_expr_lists;\n-    for (auto& texprs : const_texpr_lists) {\n-        std::vector<ExprContext*> ctxs;\n-        RETURN_IF_ERROR(Expr::create_expr_trees(_pool, texprs, &ctxs));\n-        _const_expr_lists.push_back(ctxs);\n-    }\n+    DCHECK_GE(_children.size(), 2);\n+    DCHECK_EQ(tnode.intersect_node.const_expr_lists.size(), 0);", "originalCommit": "3d9ce0d7a19cd42f4d35152553996d12075ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MzE3OA==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388753178", "bodyText": "child\uff081\uff09\uff1f", "author": "wutiangan", "createdAt": "2020-03-06T07:43:48Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(1)->row_desc().tuple_descriptors()[i];", "originalCommit": "3d9ce0d7a19cd42f4d35152553996d12075ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "073464879d9d1cde63e99aafddbb3a2644a3425c", "url": "https://github.com/apache/incubator-doris/commit/073464879d9d1cde63e99aafddbb3a2644a3425c", "message": "implements intersect node", "committedDate": "2020-03-06T07:43:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTg2MQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388759861", "bodyText": "why use _build_tuple_size? if 100 table intersect, the build_tuple_size = 100?", "author": "wutiangan", "createdAt": "2020-03-06T08:04:01Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),", "originalCommit": "073464879d9d1cde63e99aafddbb3a2644a3425c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4NzkyMA==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388787920", "bodyText": "it means number of Tuples in the build tuple row  not table count", "author": "yangzhg", "createdAt": "2020-03-06T09:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjAwMQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762001", "bodyText": "if i > 0, we can also enter this branch,  child(0) may be wrong?", "author": "wutiangan", "createdAt": "2020-03-06T08:10:16Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());", "originalCommit": "073464879d9d1cde63e99aafddbb3a2644a3425c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4ODQ3NQ==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388788475", "bodyText": "no  it always use the first table\u2018s row desc", "author": "yangzhg", "createdAt": "2020-03-06T09:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MjU4Mw==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388762583", "bodyText": "when i = 0, the first table build  _hash_tbl , but you can't set matched() function.\nwhen i = 1, the _hash_tbl's \" _hash_tbl_iterator.matched() \"is true of false?", "author": "wutiangan", "createdAt": "2020-03-06T08:11:47Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {", "originalCommit": "073464879d9d1cde63e99aafddbb3a2644a3425c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MzM1Mg==", "url": "https://github.com/apache/incubator-doris/pull/3034#discussion_r388763352", "bodyText": "do you test the null value? can null  output.", "author": "wutiangan", "createdAt": "2020-03-06T08:14:00Z", "path": "be/src/exec/intersect_node.cpp", "diffHunk": "@@ -56,4 +41,164 @@ Status IntersectNode::init(const TPlanNode& tnode, RuntimeState* state) {\n     }\n     return Status::OK();\n }\n-}\n\\ No newline at end of file\n+\n+Status IntersectNode::prepare(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::prepare(state));\n+    _build_pool.reset(new MemPool(mem_tracker()));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    for (size_t i = 0; i < _child_expr_lists.size(); ++i) {\n+        RETURN_IF_ERROR(Expr::prepare(_child_expr_lists[i], state, child(i)->row_desc(),\n+                                      expr_mem_tracker()));\n+    }\n+    _build_tuple_size = child(0)->row_desc().tuple_descriptors().size();\n+    _build_tuple_row_size = _build_tuple_size * sizeof(Tuple*);\n+    _build_tuple_idx.reserve(_build_tuple_size);\n+\n+    for (int i = 0; i < _build_tuple_size; ++i) {\n+        TupleDescriptor* build_tuple_desc = child(0)->row_desc().tuple_descriptors()[i];\n+        _build_tuple_idx.push_back(_row_descriptor.get_tuple_idx(build_tuple_desc->id()));\n+    }\n+    _find_nulls = std::vector<bool>(_child_expr_lists.size(), true);\n+    return Status::OK();\n+}\n+\n+Status IntersectNode::close(RuntimeState* state) {\n+    if (is_closed()) {\n+        return Status::OK();\n+    }\n+    for (auto& exprs : _child_expr_lists) {\n+        Expr::close(exprs, state);\n+    }\n+\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::CLOSE));\n+    // Must reset _probe_batch in close() to release resources\n+    _probe_batch.reset(NULL);\n+\n+    if (_memory_used_counter != NULL && _hash_tbl.get() != NULL) {\n+        COUNTER_UPDATE(_memory_used_counter, _build_pool->peak_allocated_bytes());\n+        COUNTER_UPDATE(_memory_used_counter, _hash_tbl->byte_size());\n+    }\n+    if (_hash_tbl.get() != NULL) {\n+        _hash_tbl->close();\n+    }\n+    if (_build_pool.get() != NULL) {\n+        _build_pool->free_all();\n+    }\n+\n+    return ExecNode::close(state);\n+}\n+\n+Status IntersectNode::open(RuntimeState* state) {\n+    RETURN_IF_ERROR(ExecNode::open(state));\n+    RETURN_IF_ERROR(exec_debug_action(TExecNodePhase::OPEN));\n+    SCOPED_TIMER(_runtime_profile->total_time_counter());\n+    RETURN_IF_CANCELLED(state);\n+    // open result expr lists.\n+    for (const vector<ExprContext*>& exprs : _child_expr_lists) {\n+        RETURN_IF_ERROR(Expr::open(exprs, state));\n+    }\n+\n+    for (int i = 0; i < _children.size(); ++i) {\n+        // initial build hash table\n+        if (_hash_tbl.get() == nullptr || _hash_tbl->size() == 0) {\n+            _hash_tbl.reset(new HashTable(_child_expr_lists[0], _child_expr_lists[i],\n+                                          _build_tuple_size, false, _find_nulls, id(),\n+                                          mem_tracker(), 1024));\n+            RowBatch build_batch(child(0)->row_desc(), state->batch_size(), mem_tracker());\n+            RETURN_IF_ERROR(child(0)->open(state));\n+\n+            while (true) {\n+                RETURN_IF_CANCELLED(state);\n+                bool eos = true;\n+                RETURN_IF_ERROR(child(0)->get_next(state, &build_batch, &eos));\n+                // take ownership of tuple data of build_batch\n+                _build_pool->acquire_data(build_batch.tuple_data_pool(), false);\n+                RETURN_IF_LIMIT_EXCEEDED(state, \" Intersect, while constructing the hash table.\");\n+                for (int j = 0; j < build_batch.num_rows(); ++j) {\n+                    _hash_tbl->insert(build_batch.get_row(j));\n+                }\n+                VLOG_ROW << \"hash table content: \"\n+                         << _hash_tbl->debug_string(true, &child(0)->row_desc());\n+                build_batch.reset();\n+\n+                if (eos) {\n+                    break;\n+                }\n+            }\n+            // using next child to probe\n+            if (i < _children.size() - 1) {\n+                ++i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            // if this hash table is probed rebuild it\n+            std::unique_ptr<HashTable> temp_tbl(\n+                    new HashTable(_child_expr_lists[0], _child_expr_lists[i], _build_tuple_size,\n+                                  false, _find_nulls, id(), mem_tracker(), 1024));\n+            _hash_tbl_iterator = _hash_tbl->begin();\n+            while (_hash_tbl_iterator.has_next()) {\n+                if (_hash_tbl_iterator.matched()) {\n+                    temp_tbl->insert(_hash_tbl_iterator.get_row());\n+                }\n+                _hash_tbl_iterator.next<false>();", "originalCommit": "073464879d9d1cde63e99aafddbb3a2644a3425c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24e3ab3671a851023ea8a1297f923832d52710b7", "url": "https://github.com/apache/incubator-doris/commit/24e3ab3671a851023ea8a1297f923832d52710b7", "message": "implements intersect node", "committedDate": "2020-03-06T09:14:32Z", "type": "forcePushed"}, {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "url": "https://github.com/apache/incubator-doris/commit/d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "message": "implements intersect node", "committedDate": "2020-03-06T09:21:41Z", "type": "commit"}, {"oid": "d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "url": "https://github.com/apache/incubator-doris/commit/d77312b3aacd6cc7377ecaac5c925a5bb45b454b", "message": "implements intersect node", "committedDate": "2020-03-06T09:21:41Z", "type": "forcePushed"}]}