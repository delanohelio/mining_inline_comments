{"pr_number": 3637, "pr_title": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch", "pr_createdAt": "2020-05-20T03:27:25Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3637", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwMjA0Mw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428102043", "bodyText": "The abbreviation of transaction is Txn. So better rename to WriteTxn", "author": "morningman", "createdAt": "2020-05-20T15:24:54Z", "path": "be/src/olap/memory/write_tx.h", "diffHunk": "@@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class PartialRowBatch;\n+\n+// Class for write transaction\n+//\n+// Note: Currently it stores all its operations in memory, to make things simple,\n+// so we can quickly complete the whole create/read/write pipeline. The data structure may\n+// change as the project evolves.\n+//\n+// TODO: add write to/load from WritexTx files in future.\n+class WriteTx {", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyMjA2MQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428422061", "bodyText": "Both are valid abbreviations.", "author": "decster", "createdAt": "2020-05-21T03:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ0NDg3MQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428444871", "bodyText": "Alright. However, other parts of the code use txn as an abbreviation, so it is recommended to unify.", "author": "morningman", "createdAt": "2020-05-21T04:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNzY4Ng==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428507686", "bodyText": "OK", "author": "decster", "createdAt": "2020-05-21T08:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEwMjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjMzNg==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428412336", "bodyText": "Better to give a example about how to use this class.", "author": "imay", "createdAt": "2020-05-21T02:33:22Z", "path": "be/src/olap/memory/mem_sub_tablet.h", "diffHunk": "@@ -0,0 +1,101 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+class HashIndex;\n+class ColumnReader;\n+class PartialRowReader;\n+class Column;\n+class ColumnWriter;\n+\n+// A MemTablet can contain multiple MemSubTablets (currently only one).\n+// MemSubTablet hold a HashIndex and a collection of columns.\n+// It supports single-writer multi-reader concurrently.\n+class MemSubTablet {", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNjQ4NQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428526485", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-21T08:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMjMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNDAwOA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428414008", "bodyText": "Give an example about how to use this class", "author": "imay", "createdAt": "2020-05-21T02:40:01Z", "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,140 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    static const size_t DEFAULT_BYTE_CAPACITY = 1 << 20;\n+    static const size_t DEFAULT_ROW_CAPACIT = 1 << 16;\n+\n+    PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity = DEFAULT_BYTE_CAPACITY,\n+                    size_t row_capacity = DEFAULT_ROW_CAPACIT);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    size_t row_size() const { return _row_offsets.size(); }\n+    size_t row_capacity() const { return _row_capacity; }\n+    size_t byte_size() const { return _bsize; }\n+    size_t byte_capacity() const { return _byte_capacity; }\n+\n+    const uint8_t* get_row(size_t idx) const;\n+\n+private:\n+    friend class PartialRowWriter;\n+    friend class PartialRowReader;\n+    scoped_refptr<Schema> _schema;\n+    vector<uint32_t> _row_offsets;\n+    uint8_t* _data;\n+    size_t _bsize;\n+    size_t _byte_capacity;\n+    size_t _row_capacity;\n+};\n+\n+// Writer for PartialRowBatch", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNjUxMA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428526510", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-21T08:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNDAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTQyMw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428415423", "bodyText": "Seems the same with one in above function.", "author": "imay", "createdAt": "2020-05-21T02:45:42Z", "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMjc5MQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428532791", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-21T09:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNTQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjA4Mg==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428416082", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (_temp_cells[i].data) {\n          \n          \n            \n                    if (_temp_cells[i].data != nullptr) {\n          \n      \n    \n    \n  \n\nprefer ptr != nullptr for pointer type", "author": "imay", "createdAt": "2020-05-21T02:48:27Z", "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set_delete() {\n+    // TODO: support delete\n+    // _temp_cells[0].isset = 1;\n+    return Status::NotSupported(\"delete not supported\");\n+}\n+\n+size_t PartialRowWriter::byte_size() const {\n+    // TODO: support delete\n+    size_t bit_all_size = num_block(_bit_set_size + _bit_null_size, 8);\n+    size_t data_size = 2 + bit_all_size;\n+    for (size_t i = 1; i < _temp_cells.size(); i++) {\n+        if (_temp_cells[i].data) {", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMzE0MA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428533140", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-21T09:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjI2NA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428416264", "bodyText": "seems this can be done in constructor.", "author": "imay", "createdAt": "2020-05-21T02:49:05Z", "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(const string& col, const void* data) {\n+    auto cs = _schema.get_by_name(col);\n+    if (!cs) {\n+        return Status::NotFound(\"col name not found\");\n+    }\n+    if (cs->type() == ColumnType::OLAP_FIELD_TYPE_VARCHAR) {\n+        return Status::NotSupported(\"var length type not supported\");\n+    }\n+    uint32_t cid = cs->cid();\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set(uint32_t cid, const void* data) {\n+    auto cs = _schema.get_by_cid(cid);\n+    if (!cs) {\n+        return Status::NotFound(\"cid not found\");\n+    }\n+    if (cs->is_nullable() || data) {\n+        if (cs->is_nullable() && !_temp_cells[cid].isnullable) {\n+            _bit_null_size++;\n+        }\n+        _temp_cells[cid].isnullable = cs->is_nullable();\n+        _temp_cells[cid].isset = 1;\n+        _temp_cells[cid].data = reinterpret_cast<const uint8_t*>(data);\n+    } else {\n+        return Status::InvalidArgument(\"not nullable column set to null\");\n+    }\n+    return Status::OK();\n+}\n+\n+Status PartialRowWriter::set_delete() {\n+    // TODO: support delete\n+    // _temp_cells[0].isset = 1;\n+    return Status::NotSupported(\"delete not supported\");\n+}\n+\n+size_t PartialRowWriter::byte_size() const {\n+    // TODO: support delete\n+    size_t bit_all_size = num_block(_bit_set_size + _bit_null_size, 8);\n+    size_t data_size = 2 + bit_all_size;\n+    for (size_t i = 1; i < _temp_cells.size(); i++) {\n+        if (_temp_cells[i].data) {\n+            size_t bsize = _schema.get_column_byte_size(i);", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NjE1OA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429046158", "bodyText": "byte_size is already cached in schema, and get_column_byte_size is inlined.", "author": "decster", "createdAt": "2020-05-22T05:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxOTA0Ng==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r428419046", "bodyText": "Why not construct all items that the batch needs, and construct the batch. If then, the batch can be immutable and this class will not operate batch's private member.", "author": "imay", "createdAt": "2020-05-21T03:00:18Z", "path": "be/src/olap/memory/partial_row_batch.cpp", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/partial_row_batch.h\"\n+\n+#include \"util/bitmap.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// Methods for PartialRowBatch\n+\n+PartialRowBatch::PartialRowBatch(scoped_refptr<Schema>* schema, size_t byte_capacity,\n+                                 size_t row_capacity)\n+        : _schema(*schema) {\n+    _data = reinterpret_cast<uint8_t*>(aligned_malloc(byte_capacity, 64));\n+    _bsize = 0;\n+    if (!_data) {\n+        _byte_capacity = 0;\n+        _row_capacity = 0;\n+    }\n+    _byte_capacity = byte_capacity;\n+    _row_capacity = row_capacity;\n+}\n+\n+PartialRowBatch::~PartialRowBatch() {\n+    if (_data) {\n+        free(_data);\n+        _data = nullptr;\n+    }\n+    _bsize = 0;\n+    _byte_capacity = 0;\n+    _row_capacity = 0;\n+}\n+\n+const uint8_t* PartialRowBatch::get_row(size_t idx) const {\n+    if (!_data || idx >= _row_offsets.size()) {\n+        return nullptr;\n+    }\n+    return _data + _row_offsets[idx] + 4;\n+}\n+\n+// Methods for PartialRowWriter\n+\n+PartialRowWriter::PartialRowWriter(const Schema& schema)\n+        : _schema(schema), _bit_set_size(_schema.cid_size()), _bit_null_size(0) {\n+    _temp_cells.resize(_schema.cid_size());\n+}\n+\n+PartialRowWriter::~PartialRowWriter() {}\n+\n+void PartialRowWriter::start_row() {\n+    _bit_null_size = 0;\n+    memset(&(_temp_cells[0]), 0, sizeof(CellInfo) * _temp_cells.size());\n+}\n+\n+Status PartialRowWriter::write_row_to_batch(PartialRowBatch* batch) {\n+    if (batch->_row_offsets.size() >= batch->row_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    size_t row_byte_size = byte_size();\n+    if (batch->byte_size() + row_byte_size + 4 > batch->byte_capacity()) {\n+        return Status::InvalidArgument(\"over capacity\");\n+    }\n+    *reinterpret_cast<uint32_t*>(batch->_data + batch->_bsize) = row_byte_size;\n+    uint8_t* pos = batch->_data + batch->_bsize + 4;\n+    RETURN_IF_ERROR(write(&pos));\n+    batch->_row_offsets.push_back(batch->_bsize);\n+    batch->_bsize = pos - batch->_data;", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NjY4MQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429046681", "bodyText": "Fixed, writer serialize to a buffer, then PartialRowBatch can load/deserialize from this buffer, now PartialRowBatch includes reader functionality", "author": "decster", "createdAt": "2020-05-22T05:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxOTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NDQ5NA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429084494", "bodyText": "write_txn use txn abbreviation, so I think you can unify the name in this pull request.", "author": "chaoyli", "createdAt": "2020-05-22T07:22:55Z", "path": "be/src/olap/memory/CMakeLists.txt", "diffHunk": "@@ -29,5 +29,8 @@ add_library(Memory STATIC\n     delta_index.cpp\n     hash_index.cpp\n     mem_tablet.cpp\n+    mem_sub_tablet.cpp\n+    partial_row_batch.cpp\n     schema.cpp\n+    write_txn.cpp", "originalCommit": "ab209d1392c4d69252da3ddf3f3fdeb82346822a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI1MjkxNQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429252915", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-22T13:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NDQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMjM1NQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429122355", "bodyText": "If update failed, this place add the _num_update will be non-sense.\nI think it should be placed after success operation.", "author": "chaoyli", "createdAt": "2020-05-22T08:47:22Z", "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,235 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowReader& row) {\n+    DCHECK_GE(row.cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        _num_insert++;\n+        rid = _row_size;\n+        // add all columns\n+        //DLOG(INFO) << StringPrintf\"insert rid=%u\", rid);\n+        for (size_t i = 0; i < row.cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (!_writers[cid]) {\n+                RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+            }\n+            RETURN_IF_ERROR(_writers[cid]->insert(rid, data));\n+        }\n+        _write_index->set(newslot, hashcode, rid);\n+        _row_size++;\n+        if (_write_index->need_rebuild()) {\n+            scoped_refptr<HashIndex> new_index;\n+            // TODO: trace memory usage\n+            size_t new_capacity = _row_size * 2;\n+            while (true) {\n+                new_index = rebuild_hash_index(new_capacity);\n+                if (new_index) {\n+                    break;\n+                } else {\n+                    new_capacity += 1 << 16;\n+                }\n+            }\n+            _write_index = new_index;\n+        }\n+    } else {\n+        // rowkey found, do update\n+        _num_update++;", "originalCommit": "02df85c888bd2e2fd96c05279b3c8e4b24e4eb88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI1NjY2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429256669", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-22T13:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMjM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4Nzg0OA==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429187848", "bodyText": "finish_batch is the function name", "author": "chaoyli", "createdAt": "2020-05-22T11:15:35Z", "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+// User can iterate through all the partial rows, get each partial row's cells.\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Example usage:\n+// PartialRowBatch rb(&schema);\n+// rb.load(buffer);\n+// while (true) {\n+//     bool has;\n+//     rb.next(&has);\n+//     if (!has) break;\n+//     for (size_t j=0; j < reader.cell_size(); j++) {\n+//         const ColumnSchema* cs = nullptr;\n+//         const void* data = nullptr;\n+//         // get column cell type and data\n+//         rb.get_cell(j, &cs, &data);\n+//     }\n+// }\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    explicit PartialRowBatch(scoped_refptr<Schema>* schema);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    // Load from a serialized buffer\n+    Status load(std::vector<uint8_t>&& buffer);\n+\n+    // Return row count in this batch\n+    size_t row_size() const { return _row_size; }\n+\n+    // Iterate to next row, mark has_row to false if there is no more rows\n+    Status next_row(bool* has_row);\n+\n+    // Get row operation cell count\n+    size_t cur_row_cell_size() const { return _cells.size(); }\n+    // Get row operation cell by index idx, return ColumnSchema and data pointer\n+    Status cur_row_get_cell(size_t idx, const ColumnSchema** cs, const void** data) const;\n+\n+private:\n+    scoped_refptr<Schema> _schema;\n+\n+    bool _delete = false;\n+    size_t _bit_set_size = 0;\n+    struct CellInfo {\n+        CellInfo(uint32_t cid, const void* data)\n+                : cid(cid), data(reinterpret_cast<const uint8_t*>(data)) {}\n+        uint32_t cid = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _cells;\n+\n+    size_t _next_row = 0;\n+    size_t _row_size = 0;\n+    const uint8_t* _pos = nullptr;\n+    std::vector<uint8_t> _buffer;\n+};\n+\n+// Writer for PartialRowBatch\n+//\n+// Example usage:\n+// scoped_refptr<Schema> sc;\n+// Schema::create(\"id int,uv int,pv int,city tinyint null\", &sc);\n+// PartialRowWriter writer(*sc.get());\n+// writer.start_batch();\n+// for (auto& row : rows) {\n+//     writer.start_row();\n+//     writer.set(\"column_name\", value);\n+//     ...\n+//     writer.set(column_id, value);\n+//     writer.end_row();\n+// }\n+// vector<uint8_t> buffer;\n+// writer.end_batch(&buffer);", "originalCommit": "ab209d1392c4d69252da3ddf3f3fdeb82346822a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI1ODI4Ng==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429258286", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-22T13:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4Nzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5MDk5OQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429190999", "bodyText": "If insert failed, this place add the _num_insert will be non-sense.\nI think it should be placed after success operation.", "author": "chaoyli", "createdAt": "2020-05-22T11:23:49Z", "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {\n+    DCHECK_GE(row.cur_row_cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.cur_row_get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        _num_insert++;", "originalCommit": "ab209d1392c4d69252da3ddf3f3fdeb82346822a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI1ODE2Nw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429258167", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-22T13:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5MDk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNjk5Mw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429216993", "bodyText": "_bit_nullable_size", "author": "chaoyli", "createdAt": "2020-05-22T12:28:24Z", "path": "be/src/olap/memory/partial_row_batch.h", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"olap/memory/common.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+// A chunk of memory that stores a batch of serialized partial rows\n+// User can iterate through all the partial rows, get each partial row's cells.\n+//\n+// Serialization format for a batch:\n+// 4 byte len | serialized partial row\n+// 4 byte len | serialized partial row\n+// ...\n+// 4 byte len | serialized partial row\n+//\n+// Serialization format for a partial row\n+// bit vector(se + null) byte size (2 byte) |\n+// bit vector mark set cells |\n+// bit vector mark nullable cells' null value |\n+// 8bit padding\n+// serialized not null cells\n+//\n+// Example usage:\n+// PartialRowBatch rb(&schema);\n+// rb.load(buffer);\n+// while (true) {\n+//     bool has;\n+//     rb.next(&has);\n+//     if (!has) break;\n+//     for (size_t j=0; j < reader.cell_size(); j++) {\n+//         const ColumnSchema* cs = nullptr;\n+//         const void* data = nullptr;\n+//         // get column cell type and data\n+//         rb.get_cell(j, &cs, &data);\n+//     }\n+// }\n+//\n+// Note: currently only fixed length column types are supported. All length and scalar types store\n+// in native byte order(little endian in x86-64).\n+//\n+// Note: The serialization format is simple, it only provides basic functionalities\n+// so we can quickly complete the whole create/read/write pipeline. The format may change\n+// as the project evolves.\n+class PartialRowBatch {\n+public:\n+    explicit PartialRowBatch(scoped_refptr<Schema>* schema);\n+    ~PartialRowBatch();\n+\n+    const Schema& schema() const { return *_schema.get(); }\n+\n+    // Load from a serialized buffer\n+    Status load(std::vector<uint8_t>&& buffer);\n+\n+    // Return row count in this batch\n+    size_t row_size() const { return _row_size; }\n+\n+    // Iterate to next row, mark has_row to false if there is no more rows\n+    Status next_row(bool* has_row);\n+\n+    // Get row operation cell count\n+    size_t cur_row_cell_size() const { return _cells.size(); }\n+    // Get row operation cell by index idx, return ColumnSchema and data pointer\n+    Status cur_row_get_cell(size_t idx, const ColumnSchema** cs, const void** data) const;\n+\n+private:\n+    scoped_refptr<Schema> _schema;\n+\n+    bool _delete = false;\n+    size_t _bit_set_size = 0;\n+    struct CellInfo {\n+        CellInfo(uint32_t cid, const void* data)\n+                : cid(cid), data(reinterpret_cast<const uint8_t*>(data)) {}\n+        uint32_t cid = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _cells;\n+\n+    size_t _next_row = 0;\n+    size_t _row_size = 0;\n+    const uint8_t* _pos = nullptr;\n+    std::vector<uint8_t> _buffer;\n+};\n+\n+// Writer for PartialRowBatch\n+//\n+// Example usage:\n+// scoped_refptr<Schema> sc;\n+// Schema::create(\"id int,uv int,pv int,city tinyint null\", &sc);\n+// PartialRowWriter writer(*sc.get());\n+// writer.start_batch();\n+// for (auto& row : rows) {\n+//     writer.start_row();\n+//     writer.set(\"column_name\", value);\n+//     ...\n+//     writer.set(column_id, value);\n+//     writer.end_row();\n+// }\n+// vector<uint8_t> buffer;\n+// writer.end_batch(&buffer);\n+class PartialRowWriter {\n+public:\n+    static const size_t DEFAULT_BYTE_CAPACITY = 1 << 20;\n+    static const size_t DEFAULT_ROW_CAPACIT = 1 << 16;\n+\n+    explicit PartialRowWriter(scoped_refptr<Schema>* schema);\n+    ~PartialRowWriter();\n+\n+    Status start_batch(size_t row_capacity = DEFAULT_ROW_CAPACIT,\n+                       size_t byte_capacity = DEFAULT_BYTE_CAPACITY);\n+\n+    // Start writing a new row\n+    Status start_row();\n+\n+    // Set cell value by column name\n+    // param data's memory must remain valid before calling build\n+    Status set(const string& col, const void* data);\n+\n+    // Set cell value by column id\n+    // param data's memory must remain valid before calling build\n+    Status set(uint32_t cid, const void* data);\n+\n+    // set this row is delete operation\n+    Status set_delete();\n+\n+    // Finish writing a row\n+    Status end_row();\n+\n+    // Finish writing the whole ParitialRowBatch, return a serialized buffer\n+    Status finish_batch(vector<uint8_t>* buffer);\n+\n+private:\n+    Status set(const ColumnSchema* cs, uint32_t cid, const void* data);\n+    size_t byte_size() const;\n+    Status write(uint8_t** ppos);\n+\n+    scoped_refptr<Schema> _schema;\n+    struct CellInfo {\n+        CellInfo() = default;\n+        uint32_t isset = 0;\n+        uint32_t isnullable = 0;\n+        const uint8_t* data = nullptr;\n+    };\n+    vector<CellInfo> _temp_cells;\n+    size_t _bit_set_size = 0;\n+    size_t _bit_null_size = 0;", "originalCommit": "ab209d1392c4d69252da3ddf3f3fdeb82346822a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI2MDE1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r429260157", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-22T13:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNjk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExODQ0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430118442", "bodyText": "we prefer _writers[cid] == nullptr for pointer compare", "author": "imay", "createdAt": "2020-05-26T01:50:02Z", "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {\n+    DCHECK_GE(row.cur_row_cell_size(), 1);\n+    const ColumnSchema* dsc;\n+    const void* key;\n+    // get key column and find in hash index\n+    // TODO: support multi-column row key\n+    row.cur_row_get_cell(0, &dsc, &key);\n+    ColumnWriter* keyw = _writers[1].get();\n+    // find candidate rowids, and check equality\n+    uint64_t hashcode = keyw->hashcode(key, 0);\n+    _temp_hash_entries.clear();\n+    uint32_t newslot = _write_index->find(hashcode, &_temp_hash_entries);\n+    uint32_t rid = -1;\n+    for (size_t i = 0; i < _temp_hash_entries.size(); i++) {\n+        uint32_t test_rid = _temp_hash_entries[i];\n+        if (keyw->equals(test_rid, key, 0)) {\n+            rid = test_rid;\n+            break;\n+        }\n+    }\n+    // if rowkey not found, do insertion/append\n+    if (rid == -1) {\n+        rid = _row_size;\n+        // add all columns\n+        //DLOG(INFO) << StringPrintf\"insert rid=%u\", rid);\n+        for (size_t i = 0; i < row.cur_row_cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.cur_row_get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (!_writers[cid]) {\n+                RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+            }\n+            RETURN_IF_ERROR(_writers[cid]->insert(rid, data));\n+        }\n+        _write_index->set(newslot, hashcode, rid);\n+        _row_size++;\n+        if (_write_index->need_rebuild()) {\n+            scoped_refptr<HashIndex> new_index;\n+            // TODO: trace memory usage\n+            size_t new_capacity = _row_size * 2;\n+            while (true) {\n+                new_index = rebuild_hash_index(new_capacity);\n+                if (new_index) {\n+                    break;\n+                } else {\n+                    new_capacity += 1 << 16;\n+                }\n+            }\n+            _write_index = new_index;\n+        }\n+        _num_insert++;\n+    } else {\n+        // rowkey found, do update\n+        // add non-key columns\n+        for (size_t i = 1; i < row.cur_row_cell_size(); i++) {\n+            const void* data;\n+            RETURN_IF_ERROR(row.cur_row_get_cell(i, &dsc, &data));\n+            uint32_t cid = dsc->cid();\n+            if (cid > _schema->num_key_columns()) {\n+                if (!_writers[cid]) {", "originalCommit": "753de3c4509689b64b7fe09d7334e3abd7128e4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5OTQyNw==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430899427", "bodyText": "fixed", "author": "decster", "createdAt": "2020-05-27T07:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExODQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExOTQyMQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430119421", "bodyText": "Better to create a partial row to do this apply rather than PartialRowBatch", "author": "imay", "createdAt": "2020-05-26T01:54:41Z", "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {\n+    _schema = *schema;\n+    _row_size = latest_size();\n+    _write_index = _index;\n+    _writers.clear();\n+    _writers.resize(_columns.size());\n+    // precache key columns\n+    for (size_t i = 0; i < _schema->num_key_columns(); i++) {\n+        uint32_t cid = _schema->get(i)->cid();\n+        if (!_writers[cid]) {\n+            RETURN_IF_ERROR(_columns[cid]->create_writer(&_writers[cid]));\n+        }\n+    }\n+    _temp_hash_entries.reserve(8);\n+\n+    // setup stats\n+    _write_start = GetMonoTimeSecondsAsDouble();\n+    _num_insert = 0;\n+    _num_update = 0;\n+    _num_update_cell = 0;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row_batch(PartialRowBatch* batch) {\n+    while (true) {\n+        bool has_row = false;\n+        RETURN_IF_ERROR(batch->next_row(&has_row));\n+        if (!has_row) {\n+            break;\n+        }\n+        RETURN_IF_ERROR(apply_partial_row(*batch));\n+    }\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::apply_partial_row(const PartialRowBatch& row) {", "originalCommit": "753de3c4509689b64b7fe09d7334e3abd7128e4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4MTkzNQ==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430881935", "bodyText": "I thought about this, create a new partial row is not that efficient, will need to share some variables and make friend class, while the gain is little, better share variables and methods inside PartialRowBatch. If this method apply_partial_row(const PartialRowBatch& row) sounds weird, we can move the logic into apply_partial_row_batch", "author": "decster", "createdAt": "2020-05-27T06:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDExOTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyMDE1Mg==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430120152", "bodyText": "should add some method to avoid multiple write.\nFor example one try to begin_write while another writer is writing.", "author": "imay", "createdAt": "2020-05-26T01:58:00Z", "path": "be/src/olap/memory/mem_sub_tablet.cpp", "diffHunk": "@@ -0,0 +1,247 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"olap/memory/mem_sub_tablet.h\"\n+\n+#include \"olap/memory/column.h\"\n+#include \"olap/memory/column_reader.h\"\n+#include \"olap/memory/column_writer.h\"\n+#include \"olap/memory/hash_index.h\"\n+#include \"olap/memory/partial_row_batch.h\"\n+#include \"olap/memory/schema.h\"\n+\n+namespace doris {\n+namespace memory {\n+\n+Status MemSubTablet::create(uint64_t version, const Schema& schema,\n+                            std::unique_ptr<MemSubTablet>* ret) {\n+    std::unique_ptr<MemSubTablet> tmp(new MemSubTablet());\n+    tmp->_versions.reserve(64);\n+    tmp->_versions.emplace_back(version, 0);\n+    tmp->_columns.resize(schema.cid_size());\n+    for (size_t i = 0; i < schema.num_columns(); i++) {\n+        // TODO: support storage_type != c.type\n+        auto& c = *schema.get(i);\n+        if (!supported(c.type())) {\n+            return Status::NotSupported(\"column type not supported\");\n+        }\n+        tmp->_columns[c.cid()].reset(new Column(c, c.type(), version));\n+    }\n+    tmp.swap(*ret);\n+    return Status::OK();\n+}\n+\n+MemSubTablet::MemSubTablet() : _index(new HashIndex(1 << 16)) {}\n+\n+MemSubTablet::~MemSubTablet() {}\n+\n+Status MemSubTablet::get_size(uint64_t version, size_t* size) const {\n+    std::lock_guard<std::mutex> lg(_lock);\n+    if (version == static_cast<uint64_t>(-1)) {\n+        // get latest\n+        *size = _versions.back().size;\n+        return Status::OK();\n+    }\n+    if (_versions[0].version > version) {\n+        return Status::NotFound(\"get_size failed, version too old\");\n+    }\n+    for (size_t i = 1; i < _versions.size(); i++) {\n+        if (_versions[i].version > version) {\n+            *size = _versions[i - 1].size;\n+            return Status::OK();\n+        }\n+    }\n+    *size = _versions.back().size;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::read_column(uint64_t version, uint32_t cid,\n+                                 std::unique_ptr<ColumnReader>* reader) {\n+    scoped_refptr<Column> cl;\n+    {\n+        std::lock_guard<std::mutex> lg(_lock);\n+        if (cid < _columns.size()) {\n+            cl = _columns[cid];\n+        }\n+    }\n+    if (!cl) {\n+        return Status::NotFound(\"column not found\");\n+    }\n+    return cl->create_reader(version, reader);\n+}\n+\n+Status MemSubTablet::get_index_to_read(scoped_refptr<HashIndex>* index) {\n+    *index = _index;\n+    return Status::OK();\n+}\n+\n+Status MemSubTablet::begin_write(scoped_refptr<Schema>* schema) {", "originalCommit": "753de3c4509689b64b7fe09d7334e3abd7128e4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ4ODE2Mg==", "url": "https://github.com/apache/incubator-doris/pull/3637#discussion_r430488162", "bodyText": "This is handled in MemTablet write lock and no other class call those method , add another protection seems redundant.", "author": "decster", "createdAt": "2020-05-26T15:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyMDE1Mg=="}], "type": "inlineReview"}, {"oid": "8d11a2cb2360386003c286d93e3c4493715865ef", "url": "https://github.com/apache/incubator-doris/commit/8d11a2cb2360386003c286d93e3c4493715865ef", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "68cf5007be546133055b6c968761fefc1ed51c52", "url": "https://github.com/apache/incubator-doris/commit/68cf5007be546133055b6c968761fefc1ed51c52", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: refactor PartialRowBatch, add more comments", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "77d9c770710b488bae6990d0e2cc88f89e845929", "url": "https://github.com/apache/incubator-doris/commit/77d9c770710b488bae6990d0e2cc88f89e845929", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review issue", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "6cc653c2db2feb80645a3f31e46015c3182b0ae9", "url": "https://github.com/apache/incubator-doris/commit/6cc653c2db2feb80645a3f31e46015c3182b0ae9", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: fix compile Werror", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "73c9b07e9cb26ef3491b5a1b9c6b9a58fed9babe", "url": "https://github.com/apache/incubator-doris/commit/73c9b07e9cb26ef3491b5a1b9c6b9a58fed9babe", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "url": "https://github.com/apache/incubator-doris/commit/e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment", "committedDate": "2020-05-29T06:52:33Z", "type": "commit"}, {"oid": "e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "url": "https://github.com/apache/incubator-doris/commit/e0637fb5f25697e5cb3ebd410b9b01e342c1ffdd", "message": "[Memory Engine] Add MemSubTablet, MemTablet, WriteTx, PartialRowBatch: address review comment", "committedDate": "2020-05-29T06:52:33Z", "type": "forcePushed"}]}