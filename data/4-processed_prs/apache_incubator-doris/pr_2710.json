{"pr_number": 2710, "pr_title": "use cgroups memory limit and cpu cores in container", "pr_createdAt": "2020-01-08T11:58:48Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2710", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMjc4NA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364202784", "bodyText": "there may be tab", "author": "imay", "createdAt": "2020-01-08T12:16:30Z", "path": "be/src/util/mem_info.cpp", "diffHunk": "@@ -59,6 +60,11 @@ void MemInfo::init() {\n         if (result == StringParser::PARSE_SUCCESS) {\n             // Entries in /proc/meminfo are in KB.\n             _s_physical_mem = mem_total_kb * 1024L;\n+\t    int64_t cgroup_mem_limit;", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMzQ2Ng==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364203466", "bodyText": "You can try split in gutil which is easier to use", "author": "imay", "createdAt": "2020-01-08T12:18:30Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwMzgwMw==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364203803", "bodyText": "give some comments for this function? What does it do", "author": "imay", "createdAt": "2020-01-08T12:19:33Z", "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,62 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#include <cstdint>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/status.h\"\n+namespace doris {\n+class CGroupUtil {\n+  public:\n+    // Determines the CGroup memory limit from the current processes' cgroup.\n+    // If the limit is more than INT64_MAX, INT64_MAX is returned (since that is\n+    // effectively unlimited anyway). Does not take into account memory limits\n+    // set on any ancestor CGroups.\n+    static Status find_cgroup_mem_limit(int64_t* bytes);\n+\n+    // Determines the CGroup cpu cores limit from the current processes' cgroup.\n+    static Status find_cgroup_cpu_limit(float* cpu_count);\n+\n+    // Returns a human-readable string with information about CGroups.\n+    static std::string debug_string();\n+\n+    // detect if cgroup is enabled\n+    static bool enable();\n+\n+  private:\n+    static Status find_global_cgroup(const std::string& subsystem, std::string* path);", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjE5Mg==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364206192", "bodyText": "Is this file written by yourself? If it is not, is it OK to use this license?", "author": "imay", "createdAt": "2020-01-08T12:26:17Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyNzc4OQ==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364527789", "bodyText": "some functions from impala", "author": "yangzhg", "createdAt": "2020-01-09T01:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjkzMw==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364206933", "bodyText": "!= 3?", "author": "imay", "createdAt": "2020-01-08T12:28:18Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyOTAwMg==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364529002", "bodyText": "line formate like 4:memory:/user.slice split by :, so size  is 3", "author": "yangzhg", "createdAt": "2020-01-09T01:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwNzUyMg==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364207522", "bodyText": "better to use FileUtils", "author": "imay", "createdAt": "2020-01-08T12:30:04Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\" \"), token_compress_on);\n+        DCHECK_GE(fields.size(), 7);\n+\n+        if (fields[fields.size() - 3] != \"cgroup\") continue;\n+        // This is a cgroup mount. Check if it's the mount we're looking for.\n+        vector<string> cgroup_opts;\n+        split(cgroup_opts, fields[fields.size() - 1], is_any_of(\",\"), token_compress_on);\n+        auto it = std::find(cgroup_opts.begin(), cgroup_opts.end(), subsystem);\n+        if (it == cgroup_opts.end()) continue;\n+        // This is the right mount.\n+        string mount_path, system_path;\n+        RETURN_IF_ERROR(unescape_path(fields[4], &mount_path));\n+        RETURN_IF_ERROR(unescape_path(fields[3], &system_path));\n+        // Strip trailing \"/\" so that both returned paths match in whether they have a\n+        // trailing \"/\".\n+        if (system_path[system_path.size() - 1] == '/') system_path.pop_back();\n+        *result = {mount_path, system_path};\n+        return Status::OK();\n+    }\n+}\n+\n+Status CGroupUtil::find_abs_cgroup_path(const string& subsystem, string* path) {\n+    RETURN_IF_ERROR(find_global_cgroup(subsystem, path));\n+    pair<string, string> paths;\n+    RETURN_IF_ERROR(find_cgroup_mounts(subsystem, &paths));\n+    const string& mount_path = paths.first;\n+    const string& system_path = paths.second;\n+    if (path->compare(0, system_path.size(), system_path) != 0) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Expected CGroup path '$0' to start with '$1'\",\n+                              *path, system_path));\n+    }\n+    path->replace(0, system_path.size(), mount_path);\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mem_limit(int64_t* bytes) {\n+    if (!enable()) {\n+        *bytes = INT64_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");\n+    }\n+    string cgroup_path;\n+    RETURN_IF_ERROR(find_abs_cgroup_path(\"memory\", &cgroup_path));\n+    string limit_file_path = cgroup_path + \"/memory.limit_in_bytes\";\n+    return read_cgroup_value(limit_file_path, bytes);\n+}\n+Status CGroupUtil::find_cgroup_cpu_limit(float* cpu_count) {\n+    if (!enable()) {\n+        *cpu_count = FLT_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");\n+    }\n+    int64_t quota;\n+    int64_t period;\n+    string cgroup_path;\n+    if (!find_abs_cgroup_path(\"cpu\", &cgroup_path).ok()) {\n+        RETURN_IF_ERROR(find_abs_cgroup_path(\"cpuacct\", &cgroup_path));\n+    }\n+    string cfs_quota_filename = cgroup_path + \"/cpu.cfs_quota_us\";\n+    RETURN_IF_ERROR(read_cgroup_value(cfs_quota_filename, &quota));\n+    if (quota <= 0) {\n+        *cpu_count = -1;\n+        return Status::OK();\n+    }\n+    string cfs_period_filename = cgroup_path + \"/cfs_period_us\";\n+    RETURN_IF_ERROR(read_cgroup_value(cfs_period_filename, &period));\n+    if (quota <= period) {\n+        *cpu_count = -1;\n+        return Status::InvalidArgument(\"quota <= period\");\n+    }\n+    *cpu_count = float(quota) / float(period);\n+    if (*cpu_count >= FLT_MAX) {\n+        *cpu_count = -1;\n+        return Status::InvalidArgument(\"unknown\");\n+    }\n+    return Status::OK();\n+}\n+\n+std::string CGroupUtil::debug_string() {\n+    if (!enable()) {\n+        return std::string(\"cgroup is not enabled!\");\n+    }\n+    string mem_limit_str;\n+    int64_t mem_limit;\n+    Status status = find_cgroup_mem_limit(&mem_limit);\n+    if (status.ok()) {\n+        mem_limit_str = Substitute(\"$0\", mem_limit);\n+    } else {\n+        mem_limit_str = status.get_error_msg();\n+    }\n+    string cpu_limit_str;\n+    float cpu_limit;\n+    status = find_cgroup_cpu_limit(&cpu_limit);\n+    if (status.ok()) {\n+        if (cpu_limit >0) {\n+            std::stringstream stream;\n+            stream << std::fixed << std::setprecision(1) << cpu_limit;\n+            cpu_limit_str = stream.str();\n+        } else {\n+            cpu_limit_str = \"unlimited\";\n+        }\n+    } else {\n+        cpu_limit_str = status.get_error_msg();\n+    }\n+    return Substitute(\"Process CGroup Info: memory.limit_in_bytes=$0, cpu cfs limits: $1\", mem_limit_str, cpu_limit_str);\n+}\n+\n+bool CGroupUtil::enable() {\n+    return boost::filesystem::exists(\"/proc/cgroups\");", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwOTYyNw==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364209627", "bodyText": "If return error, why do you change the return value?", "author": "imay", "createdAt": "2020-01-08T12:36:11Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\" \"), token_compress_on);\n+        DCHECK_GE(fields.size(), 7);\n+\n+        if (fields[fields.size() - 3] != \"cgroup\") continue;\n+        // This is a cgroup mount. Check if it's the mount we're looking for.\n+        vector<string> cgroup_opts;\n+        split(cgroup_opts, fields[fields.size() - 1], is_any_of(\",\"), token_compress_on);\n+        auto it = std::find(cgroup_opts.begin(), cgroup_opts.end(), subsystem);\n+        if (it == cgroup_opts.end()) continue;\n+        // This is the right mount.\n+        string mount_path, system_path;\n+        RETURN_IF_ERROR(unescape_path(fields[4], &mount_path));\n+        RETURN_IF_ERROR(unescape_path(fields[3], &system_path));\n+        // Strip trailing \"/\" so that both returned paths match in whether they have a\n+        // trailing \"/\".\n+        if (system_path[system_path.size() - 1] == '/') system_path.pop_back();\n+        *result = {mount_path, system_path};\n+        return Status::OK();\n+    }\n+}\n+\n+Status CGroupUtil::find_abs_cgroup_path(const string& subsystem, string* path) {\n+    RETURN_IF_ERROR(find_global_cgroup(subsystem, path));\n+    pair<string, string> paths;\n+    RETURN_IF_ERROR(find_cgroup_mounts(subsystem, &paths));\n+    const string& mount_path = paths.first;\n+    const string& system_path = paths.second;\n+    if (path->compare(0, system_path.size(), system_path) != 0) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Expected CGroup path '$0' to start with '$1'\",\n+                              *path, system_path));\n+    }\n+    path->replace(0, system_path.size(), mount_path);\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mem_limit(int64_t* bytes) {\n+    if (!enable()) {\n+        *bytes = INT64_MAX;\n+        return Status::InvalidArgument(\"cgroup is not enabled!\");", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIwOTgwMQ==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364209801", "bodyText": "give some comments for this function.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {\n          \n          \n            \n            static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {", "author": "imay", "createdAt": "2020-01-08T12:36:43Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,236 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/filesystem.hpp>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"util/error_util.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using boost::algorithm::is_any_of;\n+using boost::algorithm::split;\n+using boost::algorithm::token_compress_on;\n+using strings::CUnescape;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) continue;\n+        vector<string> fields;\n+        split(fields, line, is_any_of(\":\"));\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() > 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems;\n+        split(subsystems, fields[1], is_any_of(\",\"));\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string &limit_file_path, int64_t* val) {", "originalCommit": "60560dc675c0e62c5e203ad43c91d6530675b27d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4822cd6314dcb212a840ea32b4316815517fe4c9", "url": "https://github.com/apache/incubator-doris/commit/4822cd6314dcb212a840ea32b4316815517fe4c9", "message": "use cgroups memory limit and cpu cores in container", "committedDate": "2020-01-09T03:42:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MTE3OA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364571178", "bodyText": "Better to remove this, because we should not assert the input content.", "author": "imay", "createdAt": "2020-01-09T06:04:29Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3MzM0OA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573348", "bodyText": "No DCHECK", "author": "imay", "createdAt": "2020-01-09T06:15:17Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() != 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems = Split(fields[1], \",\");\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);\n+    string line;\n+    while (true) {\n+        if (mountinfo.fail() || mountinfo.bad()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/mountinfo: $0\", get_str_err_msg()));\n+        } else if (mountinfo.eof()) {\n+            return Status::NotFound(\n+                       Substitute(\"Could not find subsystem $0 in /proc/self/mountinfo\", subsystem));\n+        }\n+        // The relevant lines look like below (see proc manpage for full documentation). The\n+        // first example is running outside of a container, the second example is running\n+        // inside a docker container. Field 3 is the path relative to the root CGroup on\n+        // the host and Field 4 is the mount point from this process's point of view.\n+        // 34 29 0:28 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:15 -\n+        //    cgroup cgroup rw,memory\n+        // 275 271 0:28 /docker/f23eee6f88c2ba99fcce /sys/fs/cgroup/memory\n+        //    ro,nosuid,nodev,noexec,relatime master:15 - cgroup cgroup rw,memory\n+        getline(mountinfo, line);\n+        if (!mountinfo.good()) continue;\n+        vector<string> fields = Split(line, \" \", SkipWhitespace());\n+        DCHECK_GE(fields.size(), 7);", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3Mzg4Mg==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573882", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public:\n          \n          \n            \n            public:", "author": "imay", "createdAt": "2020-01-09T06:17:45Z", "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#include <cstdint>\n+#include <string>\n+#include <utility>\n+\n+#include \"common/status.h\"\n+namespace doris {\n+class CGroupUtil {\n+  public:", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3Mzk2OA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364573968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n          \n          \n            \n            #pragma once", "author": "imay", "createdAt": "2020-01-09T06:18:01Z", "path": "be/src/util/cgroup_util.h", "diffHunk": "@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H\n+#define DORIS_BE_SRC_UTIL_CGROUPING_UTIL_H", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NDU5OA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364574598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int64_t cgroup_mem_limit;\n          \n          \n            \n                        int64_t cgroup_mem_limit = 0;\n          \n      \n    \n    \n  \n\nbetter to give a default value", "author": "imay", "createdAt": "2020-01-09T06:21:10Z", "path": "be/src/util/mem_info.cpp", "diffHunk": "@@ -59,6 +60,11 @@ void MemInfo::init() {\n         if (result == StringParser::PARSE_SUCCESS) {\n             // Entries in /proc/meminfo are in KB.\n             _s_physical_mem = mem_total_kb * 1024L;\n+            int64_t cgroup_mem_limit;", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTA0MQ==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364575041", "bodyText": "seems better to move this out of while block.", "author": "imay", "createdAt": "2020-01-09T06:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NDU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTMxMA==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364575310", "bodyText": "Is there any resouce leak if ifstream.close is not called?", "author": "imay", "createdAt": "2020-01-09T06:24:23Z", "path": "be/src/util/cgroup_util.cpp", "diffHunk": "@@ -0,0 +1,229 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"util/cgroup_util.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <iostream>\n+#include <utility>\n+\n+#include \"gutil/strings/escaping.h\"\n+#include \"gutil/strings/substitute.h\"\n+#include \"gutil/strings/split.h\"\n+#include \"util/error_util.h\"\n+#include \"util/file_utils.h\"\n+#include \"util/string_parser.hpp\"\n+\n+#include \"common/names.h\"\n+\n+using strings::CUnescape;\n+using strings::Split;\n+using strings::SkipWhitespace;\n+using std::pair;\n+\n+namespace doris {\n+\n+Status CGroupUtil::find_global_cgroup(const string& subsystem, string* path) {\n+    ifstream proc_cgroups(\"/proc/self/cgroup\", ios::in);\n+    string line;\n+    while (true) {\n+        if (proc_cgroups.fail()) {\n+            return Status::IOError(Substitute(\"Error reading /proc/self/cgroup: $0\", get_str_err_msg()));\n+        } else if (proc_cgroups.peek() == std::ifstream::traits_type::eof()) {\n+            return Status::NotFound(Substitute(\"Could not find subsystem $0 in /proc/self/cgroup\", subsystem));\n+        }\n+        // The line format looks like this:\n+        // 4:memory:/user.slice\n+        // 9:cpu,cpuacct:/user.slice\n+        // so field size will be 3\n+        getline(proc_cgroups, line);\n+        if (!proc_cgroups.good()) {\n+            continue;\n+        }\n+        vector<string> fields = Split(line, \":\");\n+        DCHECK_GE(fields.size(), 3);\n+        // \":\" in the path does not appear to be escaped - bail in the unusual case that\n+        // we get too many tokens.\n+        if (fields.size() != 3) {\n+            return Status::InvalidArgument(Substitute(\n+                                               \"Could not parse line from /proc/self/cgroup - had $0 > 3 tokens: '$1'\",\n+                                               fields.size(), line));\n+        }\n+        vector<string> subsystems = Split(fields[1], \",\");\n+        auto it = std::find(subsystems.begin(), subsystems.end(), subsystem);\n+        if (it != subsystems.end()) {\n+            *path = move(fields[2]);\n+            return Status::OK();\n+        }\n+    }\n+}\n+\n+static Status unescape_path(const string& escaped, string* unescaped) {\n+    string err;\n+    if (!CUnescape(escaped, unescaped, &err)) {\n+        return Status::InvalidArgument(Substitute(\"Could not unescape path '$0': $1\", escaped, err));\n+    }\n+    return Status::OK();\n+}\n+\n+static Status read_cgroup_value(const string& limit_file_path, int64_t* val) {\n+    ifstream limit_file(limit_file_path, ios::in);\n+    string line;\n+    getline(limit_file, line);\n+    if (limit_file.fail() || limit_file.bad()) {\n+        return Status::IOError(Substitute(\"Error reading $0: $1\", limit_file_path, get_str_err_msg()));\n+    }\n+    StringParser::ParseResult pr;\n+    // Parse into an an int64_t If it overflows, returning the max value of int64_t is ok because that\n+    // is effectively unlimited.\n+    *val = StringParser::string_to_int<int64_t>(line.c_str(), line.size(), &pr);\n+    if ((pr != StringParser::PARSE_SUCCESS && pr != StringParser::PARSE_OVERFLOW)) {\n+        return Status::InvalidArgument(\n+                   Substitute(\"Failed to parse $0 as int64: '$1'\", limit_file_path, line));\n+    }\n+    return Status::OK();\n+}\n+\n+Status CGroupUtil::find_cgroup_mounts(\n+    const string& subsystem, pair<string, string>* result) {\n+    ifstream mountinfo(\"/proc/self/mountinfo\", ios::in);", "originalCommit": "4822cd6314dcb212a840ea32b4316815517fe4c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU4MTQzNw==", "url": "https://github.com/apache/incubator-doris/pull/2710#discussion_r364581437", "bodyText": "this is done automatically by the ifstream destructor.", "author": "yangzhg", "createdAt": "2020-01-09T06:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NTMxMA=="}], "type": "inlineReview"}, {"oid": "d6df6bd56595f5d43207e0ff115efa7eeec53a51", "url": "https://github.com/apache/incubator-doris/commit/d6df6bd56595f5d43207e0ff115efa7eeec53a51", "message": "use cgroups memory limit and cpu cores in container", "committedDate": "2020-01-09T07:00:56Z", "type": "commit"}, {"oid": "d6df6bd56595f5d43207e0ff115efa7eeec53a51", "url": "https://github.com/apache/incubator-doris/commit/d6df6bd56595f5d43207e0ff115efa7eeec53a51", "message": "use cgroups memory limit and cpu cores in container", "committedDate": "2020-01-09T07:00:56Z", "type": "forcePushed"}]}