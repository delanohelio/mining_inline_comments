{"pr_number": 3553, "pr_title": "Support load json-data into Doris by RoutineLoad or StreamLoad", "pr_createdAt": "2020-05-11T13:10:07Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3553", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxNzg4Nw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r423417887", "bodyText": "what does simple imports mean? Should specify that jsonpaths is only valid when format is json", "author": "imay", "createdAt": "2020-05-12T01:54:52Z", "path": "docs/en/sql-reference/sql-statements/Data Manipulation/ROUTINE LOAD.md", "diffHunk": "@@ -163,10 +163,21 @@ FROM data_source\n \n         Whether to enable strict mode, the default is on. If turned on, the column type transformation of non-null raw data is filtered if the result is NULL. Specified as \"strict_mode\" = \"true\"\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n-    5. timezone\n+    5. `timezone`\n \n         Specifies the time zone in which the job will be loaded. The default by using session variable's timezone. This parameter affects all function results related to the time zone involved in the load.\n \n+    6. `format`\n+\n+        Specifies the format of the imported data. Support csv and json, the default is csv.\n+\n+    7. `jsonpaths`\n+\n+        Set jsonpath for precise imports, otherwise simple imports.", "originalCommit": "2ee9f68d7c34d5abef0a9a800a8860cb08264b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDY2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427114669", "bodyText": "i had add more comment", "author": "worker24h", "createdAt": "2020-05-19T08:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxNzg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxODA1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r423418057", "bodyText": "what is the default value?", "author": "imay", "createdAt": "2020-05-12T01:55:25Z", "path": "docs/en/sql-reference/sql-statements/Data Manipulation/ROUTINE LOAD.md", "diffHunk": "@@ -163,10 +163,21 @@ FROM data_source\n \n         Whether to enable strict mode, the default is on. If turned on, the column type transformation of non-null raw data is filtered if the result is NULL. Specified as \"strict_mode\" = \"true\"\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n-    5. timezone\n+    5. `timezone`\n \n         Specifies the time zone in which the job will be loaded. The default by using session variable's timezone. This parameter affects all function results related to the time zone involved in the load.\n \n+    6. `format`\n+\n+        Specifies the format of the imported data. Support csv and json, the default is csv.\n+\n+    7. `jsonpaths`\n+\n+        Set jsonpath for precise imports, otherwise simple imports.\n+\n+    8. `strip_outer_array`\n+        Boolean type, true to indicate that json data starts with an array object and flattens objects in the array object.", "originalCommit": "2ee9f68d7c34d5abef0a9a800a8860cb08264b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDczNw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427114737", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxODA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxODIyMw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r423418223", "bodyText": "same with routine load", "author": "imay", "createdAt": "2020-05-12T01:56:05Z", "path": "docs/en/sql-reference/sql-statements/Data Manipulation/STREAM LOAD.md", "diffHunk": "@@ -111,6 +111,15 @@ Specifies the time zone used for this load. The default is East Eight District.\n \n Memory limit. Default is 2GB. Unit is Bytes.\n \n+`format`\n+Specifies the format of the imported data. Support csv and json, the default is csv.\n+\n+`jsonpaths`\n+Set jsonpath for precise imports, otherwise simple imports.\n+\n+`strip_outer_array`\n+Boolean type, true to indicate that json data starts with an array object and flattens objects in the array object.", "originalCommit": "2ee9f68d7c34d5abef0a9a800a8860cb08264b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDgyOA==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427114828", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxODIyMw=="}], "type": "inlineReview"}, {"oid": "78fb5723bba9dc31856830ffbf8387668e01f7ba", "url": "https://github.com/apache/incubator-doris/commit/78fb5723bba9dc31856830ffbf8387668e01f7ba", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-12T03:30:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MjQxNA==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r423462414", "bodyText": "\u6211\u89c9\u5f97\u8fd9\u91cc\u8fd8\u662f\u8981\u89e3\u91ca\u4e00\u4e0b\u4ec0\u4e48\u662f\u7b80\u5355\u6a21\u5f0f\uff0c\u4ec0\u4e48\u662f\u7cbe\u51c6\u6a21\u5f0f\uff0c\u8fd9\u6837\u80fd\u591f\u66f4\u597d\u7684\u8ba9\u7528\u6237\u7406\u89e3\u8fd9\u4e24\u79cd\u6a21\u5f0f\u7684\u533a\u522b\u3002", "author": "imay", "createdAt": "2020-05-12T04:58:57Z", "path": "docs/zh-CN/sql-reference/sql-statements/Data Manipulation/ROUTINE LOAD.md", "diffHunk": "@@ -137,15 +137,27 @@ under the License.\n             \u91c7\u6837\u7a97\u53e3\u5185\uff0c\u5141\u8bb8\u7684\u6700\u5927\u9519\u8bef\u884c\u6570\u3002\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e0\u3002\u9ed8\u8ba4\u662f 0\uff0c\u5373\u4e0d\u5141\u8bb8\u6709\u9519\u8bef\u884c\u3002\n             \u91c7\u6837\u7a97\u53e3\u4e3a max_batch_rows * 10\u3002\u5373\u5982\u679c\u5728\u91c7\u6837\u7a97\u53e3\u5185\uff0c\u9519\u8bef\u884c\u6570\u5927\u4e8e max_error_number\uff0c\u5219\u4f1a\u5bfc\u81f4\u4f8b\u884c\u4f5c\u4e1a\u88ab\u6682\u505c\uff0c\u9700\u8981\u4eba\u5de5\u4ecb\u5165\u68c0\u67e5\u6570\u636e\u8d28\u91cf\u95ee\u9898\u3002\n             \u88ab where \u6761\u4ef6\u8fc7\u6ee4\u6389\u7684\u884c\u4e0d\u7b97\u9519\u8bef\u884c\u3002\n-        \n+\n         4. strict_mode\n \n             \u662f\u5426\u5f00\u542f\u4e25\u683c\u6a21\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u5f00\u542f\u3002\u5982\u679c\u5f00\u542f\u540e\uff0c\u975e\u7a7a\u539f\u59cb\u6570\u636e\u7684\u5217\u7c7b\u578b\u53d8\u6362\u5982\u679c\u7ed3\u679c\u4e3a NULL\uff0c\u5219\u4f1a\u88ab\u8fc7\u6ee4\u3002\u6307\u5b9a\u65b9\u5f0f\u4e3a \"strict_mode\" = \"true\"\n \n         5. timezone\n-            \n+\n             \u6307\u5b9a\u5bfc\u5165\u4f5c\u4e1a\u6240\u4f7f\u7528\u7684\u65f6\u533a\u3002\u9ed8\u8ba4\u4e3a\u4f7f\u7528 Session \u7684 timezone \u53c2\u6570\u3002\u8be5\u53c2\u6570\u4f1a\u5f71\u54cd\u6240\u6709\u5bfc\u5165\u6d89\u53ca\u7684\u548c\u65f6\u533a\u6709\u5173\u7684\u51fd\u6570\u7ed3\u679c\u3002\n \n+        6. format\n+\n+            \u6307\u5b9a\u5bfc\u5165\u6570\u636e\u683c\u5f0f\uff0c\u9ed8\u8ba4\u662fcsv\uff0c\u652f\u6301json\u683c\u5f0f\u3002\n+\n+        7. jsonpaths\n+\n+            jsonpaths: \u5bfc\u5165json\u65b9\u5f0f\u5206\u4e3a\uff1a\u7b80\u5355\u6a21\u5f0f\u548c\u7cbe\u51c6\u6a21\u5f0f\u3002\u5982\u679c\u8bbe\u7f6e\u4e86jsonpath\u5219\u4e3a\u7cbe\u51c6\u6a21\u5f0f\u5bfc\u5165\uff0c\u5426\u5219\u4e3a\u7b80\u5355\u6a21\u5f0f\u5bfc\u5165\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u793a\u4f8b\u3002", "originalCommit": "78fb5723bba9dc31856830ffbf8387668e01f7ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDk0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427114942", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MjQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MjkzMQ==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r423462931", "bodyText": "\u7ed9\u4e2a\u4f8b\u5b50\u5c31\u80fd\u591f\u8ba9\u7528\u6237\u66f4\u597d\u7406\u89e3\u4e86\uff0c\u6bd4\u5982\u4e0b\u9762\u7684\u6570\u636e\uff0c\u5982\u679c\u8fd9\u4e2a\u503c\u8bbe\u7f6e\u4e3atrue\uff0c\u90a3\u4e48\u5c31\u4f1a\u5bfc\u5165\u4e24\u6761\u6570\u636e\u3002\u5982\u679c\u8bbe\u7f6e\u4e3afalse\uff0c\u5c31\u4f1a\u6309\u7167\u7ed9\u5b9a\u7684jsonpaths\u6765\u62bd\u53d6\u5b57\u6bb5\u8fdb\u884c\u5bfc\u5165\u3002\n[\n    {\"k1\" : 1, \"v1\" : 2},\n    {\"k1\" : 3, \"v1\" : 4},\n]", "author": "imay", "createdAt": "2020-05-12T05:00:53Z", "path": "docs/zh-CN/sql-reference/sql-statements/Data Manipulation/ROUTINE LOAD.md", "diffHunk": "@@ -137,15 +137,27 @@ under the License.\n             \u91c7\u6837\u7a97\u53e3\u5185\uff0c\u5141\u8bb8\u7684\u6700\u5927\u9519\u8bef\u884c\u6570\u3002\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e0\u3002\u9ed8\u8ba4\u662f 0\uff0c\u5373\u4e0d\u5141\u8bb8\u6709\u9519\u8bef\u884c\u3002\n             \u91c7\u6837\u7a97\u53e3\u4e3a max_batch_rows * 10\u3002\u5373\u5982\u679c\u5728\u91c7\u6837\u7a97\u53e3\u5185\uff0c\u9519\u8bef\u884c\u6570\u5927\u4e8e max_error_number\uff0c\u5219\u4f1a\u5bfc\u81f4\u4f8b\u884c\u4f5c\u4e1a\u88ab\u6682\u505c\uff0c\u9700\u8981\u4eba\u5de5\u4ecb\u5165\u68c0\u67e5\u6570\u636e\u8d28\u91cf\u95ee\u9898\u3002\n             \u88ab where \u6761\u4ef6\u8fc7\u6ee4\u6389\u7684\u884c\u4e0d\u7b97\u9519\u8bef\u884c\u3002\n-        \n+\n         4. strict_mode\n \n             \u662f\u5426\u5f00\u542f\u4e25\u683c\u6a21\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u5f00\u542f\u3002\u5982\u679c\u5f00\u542f\u540e\uff0c\u975e\u7a7a\u539f\u59cb\u6570\u636e\u7684\u5217\u7c7b\u578b\u53d8\u6362\u5982\u679c\u7ed3\u679c\u4e3a NULL\uff0c\u5219\u4f1a\u88ab\u8fc7\u6ee4\u3002\u6307\u5b9a\u65b9\u5f0f\u4e3a \"strict_mode\" = \"true\"\n \n         5. timezone\n-            \n+\n             \u6307\u5b9a\u5bfc\u5165\u4f5c\u4e1a\u6240\u4f7f\u7528\u7684\u65f6\u533a\u3002\u9ed8\u8ba4\u4e3a\u4f7f\u7528 Session \u7684 timezone \u53c2\u6570\u3002\u8be5\u53c2\u6570\u4f1a\u5f71\u54cd\u6240\u6709\u5bfc\u5165\u6d89\u53ca\u7684\u548c\u65f6\u533a\u6709\u5173\u7684\u51fd\u6570\u7ed3\u679c\u3002\n \n+        6. format\n+\n+            \u6307\u5b9a\u5bfc\u5165\u6570\u636e\u683c\u5f0f\uff0c\u9ed8\u8ba4\u662fcsv\uff0c\u652f\u6301json\u683c\u5f0f\u3002\n+\n+        7. jsonpaths\n+\n+            jsonpaths: \u5bfc\u5165json\u65b9\u5f0f\u5206\u4e3a\uff1a\u7b80\u5355\u6a21\u5f0f\u548c\u7cbe\u51c6\u6a21\u5f0f\u3002\u5982\u679c\u8bbe\u7f6e\u4e86jsonpath\u5219\u4e3a\u7cbe\u51c6\u6a21\u5f0f\u5bfc\u5165\uff0c\u5426\u5219\u4e3a\u7b80\u5355\u6a21\u5f0f\u5bfc\u5165\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u793a\u4f8b\u3002\n+\n+        8. strip_outer_array\n+\n+            \u5e03\u5c14\u7c7b\u578b\uff0c\u4e3atrue\u8868\u793ajson\u6570\u636e\u4ee5\u6570\u7ec4\u5bf9\u8c61\u5f00\u59cb\u4e14\u5c06\u6570\u7ec4\u5bf9\u8c61\u4e2d\u8fdb\u884c\u5c55\u5e73\uff0c\u9ed8\u8ba4\u503c\u662ffalse\u3002", "originalCommit": "78fb5723bba9dc31856830ffbf8387668e01f7ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTA4Mw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115083", "bodyText": "yes\uff0c i changed", "author": "worker24h", "createdAt": "2020-05-19T08:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MjkzMQ=="}], "type": "inlineReview"}, {"oid": "7002fe2c551185ca521740cfa8ce2317575ca820", "url": "https://github.com/apache/incubator-doris/commit/7002fe2c551185ca521740cfa8ce2317575ca820", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-12T06:31:15Z", "type": "forcePushed"}, {"oid": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "url": "https://github.com/apache/incubator-doris/commit/81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-13T10:35:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA5Nw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r426156097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Status::InternalError(\"JSON ROOT node is array-object, `json_unnest` must be TRUE.\");\n          \n          \n            \n                    return Status::InternalError(\"JSON ROOT node is array-object, `strip_outer_array ` must be TRUE.\");", "author": "morningman", "createdAt": "2020-05-16T14:00:41Z", "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -0,0 +1,546 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+\n+#include \"exec/json_scanner.h\"\n+#include <algorithm>\n+#include \"gutil/strings/split.h\"\n+#include \"runtime/exec_env.h\"\n+#include \"runtime/mem_tracker.h\"\n+#include \"runtime/raw_value.h\"\n+#include \"runtime/runtime_state.h\"\n+#include \"exprs/expr.h\"\n+#include \"env/env.h\"\n+#include \"exec/local_file_reader.h\"\n+#include \"exec/broker_reader.h\"\n+#include \"exprs/json_functions.h\"\n+\n+namespace doris {\n+\n+JsonScanner::JsonScanner(RuntimeState* state,\n+                         RuntimeProfile* profile,\n+                         const TBrokerScanRangeParams& params,\n+                         const std::vector<TBrokerRangeDesc>& ranges,\n+                         const std::vector<TNetworkAddress>& broker_addresses,\n+                         ScannerCounter* counter) : BaseScanner(state, profile, params, counter),\n+                          _ranges(ranges),\n+                          _broker_addresses(broker_addresses),\n+                          _cur_file_reader(nullptr),\n+                          _next_range(0),\n+                          _cur_file_eof(false),\n+                          _scanner_eof(false) {\n+\n+}\n+\n+JsonScanner::~JsonScanner() {\n+    close();\n+}\n+\n+Status JsonScanner::open() {\n+    return BaseScanner::open();\n+}\n+\n+Status JsonScanner::get_next(Tuple* tuple, MemPool* tuple_pool, bool* eof) {\n+    SCOPED_TIMER(_read_timer);\n+    // Get one line\n+    while (!_scanner_eof) {\n+        if (_cur_file_reader == nullptr || _cur_file_eof) {\n+            RETURN_IF_ERROR(open_next_reader());\n+            // If there isn't any more reader, break this\n+            if (_scanner_eof) {\n+                break;\n+            }\n+            _cur_file_eof = false;\n+        }\n+        RETURN_IF_ERROR(_cur_file_reader->read(_src_tuple, _src_slot_descs, tuple_pool, &_cur_file_eof));\n+\n+        if (_cur_file_eof) {\n+            continue; // read next file\n+        }\n+        COUNTER_UPDATE(_rows_read_counter, 1);\n+        SCOPED_TIMER(_materialize_timer);\n+        if (fill_dest_tuple(Slice(), tuple, tuple_pool)) {\n+            break;// break if true\n+        }\n+    }\n+    if (_scanner_eof) {\n+        *eof = true;\n+    } else {\n+        *eof = false;\n+    }\n+    return Status::OK();\n+}\n+\n+Status JsonScanner::open_next_reader() {\n+    if (_cur_file_reader != nullptr) {\n+        delete _cur_file_reader;\n+        _cur_file_reader = nullptr;\n+        if (_stream_load_pipe != nullptr) {\n+            _stream_load_pipe.reset();\n+        }\n+    }\n+    if (_next_range >= _ranges.size()) {\n+        _scanner_eof = true;\n+        return Status::OK();\n+    }\n+    const TBrokerRangeDesc& range = _ranges[_next_range++];\n+    int64_t start_offset = range.start_offset;\n+    if (start_offset != 0) {\n+        start_offset -= 1;\n+    }\n+    FileReader *file = nullptr;\n+    switch (range.file_type) {\n+    case TFileType::FILE_LOCAL: {\n+        LocalFileReader* file_reader = new LocalFileReader(range.path, start_offset);\n+        RETURN_IF_ERROR(file_reader->open());\n+        file = file_reader;\n+        break;\n+    }\n+    case TFileType::FILE_BROKER: {\n+        BrokerReader* broker_reader = new BrokerReader(\n+            _state->exec_env(), _broker_addresses, _params.properties, range.path, start_offset);\n+        RETURN_IF_ERROR(broker_reader->open());\n+        file = broker_reader;\n+        break;\n+    }\n+\n+    case TFileType::FILE_STREAM: {\n+        _stream_load_pipe = _state->exec_env()->load_stream_mgr()->get(range.load_id);\n+        if (_stream_load_pipe == nullptr) {\n+            VLOG(3) << \"unknown stream load id: \" << UniqueId(range.load_id);\n+            return Status::InternalError(\"unknown stream load id\");\n+        }\n+        file = _stream_load_pipe.get();\n+        break;\n+    }\n+    default: {\n+        std::stringstream ss;\n+        ss << \"Unknown file type, type=\" << range.file_type;\n+        return Status::InternalError(ss.str());\n+    }\n+    }\n+\n+    std::string jsonpath = \"\";\n+    bool strip_outer_array = false;\n+    if (range.__isset.jsonpaths) {\n+        jsonpath = range.jsonpaths;\n+    }\n+    if (range.__isset.strip_outer_array) {\n+        strip_outer_array = range.strip_outer_array;\n+    }\n+    _cur_file_reader = new JsonReader(_state, _counter, _profile, file, jsonpath, strip_outer_array);\n+\n+    return Status::OK();\n+}\n+\n+void JsonScanner::close() {\n+    if (_cur_file_reader != nullptr) {\n+        delete _cur_file_reader;\n+        _cur_file_reader = nullptr;\n+        if (_stream_load_pipe != nullptr) {\n+            _stream_load_pipe.reset();\n+        }\n+    }\n+}\n+\n+////// class JsonDataInternal\n+JsonDataInternal::JsonDataInternal(rapidjson::Value* v) :\n+        _json_values(v), _iterator(v->Begin()) {\n+}\n+\n+JsonDataInternal::~JsonDataInternal() {\n+\n+}\n+\n+rapidjson::Value::ConstValueIterator JsonDataInternal::get_next() {\n+    if (_json_values->End() == _iterator) {\n+        return nullptr;\n+    }\n+    return _iterator++;\n+}\n+\n+\n+////// class JsonReader\n+JsonReader::JsonReader(\n+        RuntimeState* state, ScannerCounter* counter,\n+        RuntimeProfile* profile,\n+        FileReader* file_reader,\n+        std::string& jsonpath,\n+        bool strip_outer_array) :\n+            _next_line(0),\n+            _total_lines(0),\n+            _state(state),\n+            _counter(counter),\n+            _profile(profile),\n+            _file_reader(file_reader),\n+            _closed(false),\n+            _strip_outer_array(strip_outer_array) {\n+    _bytes_read_counter = ADD_COUNTER(_profile, \"BytesRead\", TUnit::BYTES);\n+    _read_timer = ADD_TIMER(_profile, \"FileReadTime\");\n+\n+    init_jsonpath(jsonpath);\n+}\n+\n+JsonReader::~JsonReader() {\n+    close();\n+}\n+\n+void JsonReader::init_jsonpath(std::string& jsonpath) {\n+    //parse jsonpath\n+    if (!jsonpath.empty()) {\n+        if (!_jsonpaths_doc.Parse(jsonpath.c_str()).HasParseError()) {\n+            if (!_jsonpaths_doc.IsArray()) {\n+                _parse_jsonpath_flag = -1;// failed, has none object\n+            } else {\n+                _parse_jsonpath_flag = 1;// success\n+            }\n+        } else {\n+            _parse_jsonpath_flag = -1;// parse failed\n+        }\n+    } else {\n+        _parse_jsonpath_flag = 0;\n+    }\n+    return ;\n+}\n+\n+void JsonReader::close() {\n+    if (_closed) {\n+        return;\n+    }\n+    if (typeid(*_file_reader) == typeid(doris::BrokerReader) || typeid(*_file_reader) == typeid(doris::LocalFileReader)) {\n+        _file_reader->close();\n+        delete _file_reader;\n+    }\n+    _closed = true;\n+}\n+\n+Status JsonReader::parse_json_doc(bool* eof) {\n+    // read a whole message, must be delete json_str by `delete[]`\n+    uint8_t* json_str = nullptr;\n+    size_t length = 0;\n+    RETURN_IF_ERROR(_file_reader->read_one_message(&json_str, &length));\n+    if (length == 0) {\n+        *eof = true;\n+        return Status::OK();\n+    }\n+    //  parse jsondata to JsonDoc\n+    if (_json_doc.Parse((char*)json_str, length).HasParseError()) {\n+        delete[] json_str;\n+        std::stringstream str_error;\n+        str_error << \"Parse json data for JsonDoc is failed. code = \" << _json_doc.GetParseError()\n+                << \", error-info:\" << rapidjson::GetParseError_En(_json_doc.GetParseError());\n+        return Status::InternalError(str_error.str());\n+    }\n+\n+    if (!_json_doc.IsArray() && _strip_outer_array) {\n+        delete[] json_str;\n+        return Status::InternalError(\"JSON ROOT node is array-object, `json_unnest` must be TRUE.\");", "originalCommit": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTE1OQ==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115159", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjcxOA==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r426156718", "bodyText": "if nullcount == _jsonpaths_doc.Size(), the _counter->num_rows_filtered++ should be called, and the error line should be recorded in runtime state.", "author": "morningman", "createdAt": "2020-05-16T14:08:25Z", "path": "be/src/exec/json_scanner.cpp", "diffHunk": "@@ -0,0 +1,546 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+\n+#include \"exec/json_scanner.h\"\n+#include <algorithm>\n+#include \"gutil/strings/split.h\"\n+#include \"runtime/exec_env.h\"\n+#include \"runtime/mem_tracker.h\"\n+#include \"runtime/raw_value.h\"\n+#include \"runtime/runtime_state.h\"\n+#include \"exprs/expr.h\"\n+#include \"env/env.h\"\n+#include \"exec/local_file_reader.h\"\n+#include \"exec/broker_reader.h\"\n+#include \"exprs/json_functions.h\"\n+\n+namespace doris {\n+\n+JsonScanner::JsonScanner(RuntimeState* state,\n+                         RuntimeProfile* profile,\n+                         const TBrokerScanRangeParams& params,\n+                         const std::vector<TBrokerRangeDesc>& ranges,\n+                         const std::vector<TNetworkAddress>& broker_addresses,\n+                         ScannerCounter* counter) : BaseScanner(state, profile, params, counter),\n+                          _ranges(ranges),\n+                          _broker_addresses(broker_addresses),\n+                          _cur_file_reader(nullptr),\n+                          _next_range(0),\n+                          _cur_file_eof(false),\n+                          _scanner_eof(false) {\n+\n+}\n+\n+JsonScanner::~JsonScanner() {\n+    close();\n+}\n+\n+Status JsonScanner::open() {\n+    return BaseScanner::open();\n+}\n+\n+Status JsonScanner::get_next(Tuple* tuple, MemPool* tuple_pool, bool* eof) {\n+    SCOPED_TIMER(_read_timer);\n+    // Get one line\n+    while (!_scanner_eof) {\n+        if (_cur_file_reader == nullptr || _cur_file_eof) {\n+            RETURN_IF_ERROR(open_next_reader());\n+            // If there isn't any more reader, break this\n+            if (_scanner_eof) {\n+                break;\n+            }\n+            _cur_file_eof = false;\n+        }\n+        RETURN_IF_ERROR(_cur_file_reader->read(_src_tuple, _src_slot_descs, tuple_pool, &_cur_file_eof));\n+\n+        if (_cur_file_eof) {\n+            continue; // read next file\n+        }\n+        COUNTER_UPDATE(_rows_read_counter, 1);\n+        SCOPED_TIMER(_materialize_timer);\n+        if (fill_dest_tuple(Slice(), tuple, tuple_pool)) {\n+            break;// break if true\n+        }\n+    }\n+    if (_scanner_eof) {\n+        *eof = true;\n+    } else {\n+        *eof = false;\n+    }\n+    return Status::OK();\n+}\n+\n+Status JsonScanner::open_next_reader() {\n+    if (_cur_file_reader != nullptr) {\n+        delete _cur_file_reader;\n+        _cur_file_reader = nullptr;\n+        if (_stream_load_pipe != nullptr) {\n+            _stream_load_pipe.reset();\n+        }\n+    }\n+    if (_next_range >= _ranges.size()) {\n+        _scanner_eof = true;\n+        return Status::OK();\n+    }\n+    const TBrokerRangeDesc& range = _ranges[_next_range++];\n+    int64_t start_offset = range.start_offset;\n+    if (start_offset != 0) {\n+        start_offset -= 1;\n+    }\n+    FileReader *file = nullptr;\n+    switch (range.file_type) {\n+    case TFileType::FILE_LOCAL: {\n+        LocalFileReader* file_reader = new LocalFileReader(range.path, start_offset);\n+        RETURN_IF_ERROR(file_reader->open());\n+        file = file_reader;\n+        break;\n+    }\n+    case TFileType::FILE_BROKER: {\n+        BrokerReader* broker_reader = new BrokerReader(\n+            _state->exec_env(), _broker_addresses, _params.properties, range.path, start_offset);\n+        RETURN_IF_ERROR(broker_reader->open());\n+        file = broker_reader;\n+        break;\n+    }\n+\n+    case TFileType::FILE_STREAM: {\n+        _stream_load_pipe = _state->exec_env()->load_stream_mgr()->get(range.load_id);\n+        if (_stream_load_pipe == nullptr) {\n+            VLOG(3) << \"unknown stream load id: \" << UniqueId(range.load_id);\n+            return Status::InternalError(\"unknown stream load id\");\n+        }\n+        file = _stream_load_pipe.get();\n+        break;\n+    }\n+    default: {\n+        std::stringstream ss;\n+        ss << \"Unknown file type, type=\" << range.file_type;\n+        return Status::InternalError(ss.str());\n+    }\n+    }\n+\n+    std::string jsonpath = \"\";\n+    bool strip_outer_array = false;\n+    if (range.__isset.jsonpaths) {\n+        jsonpath = range.jsonpaths;\n+    }\n+    if (range.__isset.strip_outer_array) {\n+        strip_outer_array = range.strip_outer_array;\n+    }\n+    _cur_file_reader = new JsonReader(_state, _counter, _profile, file, jsonpath, strip_outer_array);\n+\n+    return Status::OK();\n+}\n+\n+void JsonScanner::close() {\n+    if (_cur_file_reader != nullptr) {\n+        delete _cur_file_reader;\n+        _cur_file_reader = nullptr;\n+        if (_stream_load_pipe != nullptr) {\n+            _stream_load_pipe.reset();\n+        }\n+    }\n+}\n+\n+////// class JsonDataInternal\n+JsonDataInternal::JsonDataInternal(rapidjson::Value* v) :\n+        _json_values(v), _iterator(v->Begin()) {\n+}\n+\n+JsonDataInternal::~JsonDataInternal() {\n+\n+}\n+\n+rapidjson::Value::ConstValueIterator JsonDataInternal::get_next() {\n+    if (_json_values->End() == _iterator) {\n+        return nullptr;\n+    }\n+    return _iterator++;\n+}\n+\n+\n+////// class JsonReader\n+JsonReader::JsonReader(\n+        RuntimeState* state, ScannerCounter* counter,\n+        RuntimeProfile* profile,\n+        FileReader* file_reader,\n+        std::string& jsonpath,\n+        bool strip_outer_array) :\n+            _next_line(0),\n+            _total_lines(0),\n+            _state(state),\n+            _counter(counter),\n+            _profile(profile),\n+            _file_reader(file_reader),\n+            _closed(false),\n+            _strip_outer_array(strip_outer_array) {\n+    _bytes_read_counter = ADD_COUNTER(_profile, \"BytesRead\", TUnit::BYTES);\n+    _read_timer = ADD_TIMER(_profile, \"FileReadTime\");\n+\n+    init_jsonpath(jsonpath);\n+}\n+\n+JsonReader::~JsonReader() {\n+    close();\n+}\n+\n+void JsonReader::init_jsonpath(std::string& jsonpath) {\n+    //parse jsonpath\n+    if (!jsonpath.empty()) {\n+        if (!_jsonpaths_doc.Parse(jsonpath.c_str()).HasParseError()) {\n+            if (!_jsonpaths_doc.IsArray()) {\n+                _parse_jsonpath_flag = -1;// failed, has none object\n+            } else {\n+                _parse_jsonpath_flag = 1;// success\n+            }\n+        } else {\n+            _parse_jsonpath_flag = -1;// parse failed\n+        }\n+    } else {\n+        _parse_jsonpath_flag = 0;\n+    }\n+    return ;\n+}\n+\n+void JsonReader::close() {\n+    if (_closed) {\n+        return;\n+    }\n+    if (typeid(*_file_reader) == typeid(doris::BrokerReader) || typeid(*_file_reader) == typeid(doris::LocalFileReader)) {\n+        _file_reader->close();\n+        delete _file_reader;\n+    }\n+    _closed = true;\n+}\n+\n+Status JsonReader::parse_json_doc(bool* eof) {\n+    // read a whole message, must be delete json_str by `delete[]`\n+    uint8_t* json_str = nullptr;\n+    size_t length = 0;\n+    RETURN_IF_ERROR(_file_reader->read_one_message(&json_str, &length));\n+    if (length == 0) {\n+        *eof = true;\n+        return Status::OK();\n+    }\n+    //  parse jsondata to JsonDoc\n+    if (_json_doc.Parse((char*)json_str, length).HasParseError()) {\n+        delete[] json_str;\n+        std::stringstream str_error;\n+        str_error << \"Parse json data for JsonDoc is failed. code = \" << _json_doc.GetParseError()\n+                << \", error-info:\" << rapidjson::GetParseError_En(_json_doc.GetParseError());\n+        return Status::InternalError(str_error.str());\n+    }\n+\n+    if (!_json_doc.IsArray() && _strip_outer_array) {\n+        delete[] json_str;\n+        return Status::InternalError(\"JSON ROOT node is array-object, `json_unnest` must be TRUE.\");\n+    }\n+\n+    delete[] json_str;\n+    return Status::OK();\n+}\n+\n+size_t JsonReader::get_data_by_jsonpath(const std::vector<SlotDescriptor*>& slot_descs) {\n+    size_t max_lines = 0;\n+    //iterator jsonpath to find object and save it to Map\n+    _jmap.clear();\n+\n+    for (int i = 0; i < _jsonpaths_doc.Size(); i++) {\n+        const rapidjson::Value& path = _jsonpaths_doc[i];\n+        if (!path.IsString()) {\n+            return -1;\n+        }\n+\n+        // if jsonValues is null, because not match in jsondata.\n+        rapidjson::Value* json_values = JsonFunctions::get_json_object_from_parsed_json(path.GetString(), &_json_doc, _json_doc.GetAllocator());\n+        if (json_values == nullptr) {\n+            return -1;\n+        }\n+        if (json_values->IsArray()) {\n+            max_lines = std::max(max_lines, (size_t)json_values->Size());\n+        } else {\n+            max_lines = std::max(max_lines, (size_t)1);\n+        }\n+        _jmap.emplace(slot_descs[i]->col_name(), json_values);\n+    }\n+\n+    return max_lines;\n+}\n+\n+void JsonReader::fill_slot(Tuple* tuple, SlotDescriptor* slot_desc, MemPool* mem_pool, const uint8_t* value, int32_t len) {\n+    tuple->set_not_null(slot_desc->null_indicator_offset());\n+    void* slot = tuple->get_slot(slot_desc->tuple_offset());\n+    StringValue* str_slot = reinterpret_cast<StringValue*>(slot);\n+    str_slot->ptr = reinterpret_cast<char*>(mem_pool->allocate(len));\n+    memcpy(str_slot->ptr, value, len);\n+    str_slot->len = len;\n+    return;\n+}\n+\n+Status JsonReader::write_data_to_tuple(rapidjson::Value::ConstValueIterator value, SlotDescriptor* desc, Tuple* tuple, MemPool* tuple_pool) {\n+    const char* str_value = nullptr;\n+    uint8_t tmp_buf[128] = {0};\n+    int32_t wbytes = 0;\n+    switch (value->GetType()) {\n+        case rapidjson::Type::kStringType:\n+            str_value = value->GetString();\n+            fill_slot(tuple, desc, tuple_pool, (uint8_t*)str_value, strlen(str_value));\n+            break;\n+        case rapidjson::Type::kNumberType:\n+            if (value->IsUint()) {\n+                wbytes = sprintf((char*)tmp_buf, \"%u\", value->GetUint());\n+                fill_slot(tuple, desc, tuple_pool, tmp_buf, wbytes);\n+            } else if (value->IsInt()) {\n+                wbytes = sprintf((char*)tmp_buf, \"%d\", value->GetInt());\n+                fill_slot(tuple, desc, tuple_pool, tmp_buf, wbytes);\n+            } else if (value->IsUint64()) {\n+                wbytes = sprintf((char*)tmp_buf, \"%lu\", value->GetUint64());\n+                fill_slot(tuple, desc, tuple_pool, tmp_buf, wbytes);\n+            } else if (value->IsInt64()) {\n+                wbytes = sprintf((char*)tmp_buf, \"%ld\", value->GetInt64());\n+                fill_slot(tuple, desc, tuple_pool, tmp_buf, wbytes);\n+            } else {\n+                wbytes = sprintf((char*)tmp_buf, \"%f\", value->GetDouble());\n+                fill_slot(tuple, desc, tuple_pool, tmp_buf, wbytes);\n+            }\n+            break;\n+        case rapidjson::Type::kFalseType:\n+            fill_slot(tuple, desc, tuple_pool, (uint8_t*)\"0\", 1);\n+            break;\n+        case rapidjson::Type::kTrueType:\n+            fill_slot(tuple, desc, tuple_pool, (uint8_t*)\"1\", 1);\n+            break;\n+        case rapidjson::Type::kNullType:\n+            if (desc->is_nullable()) {\n+                tuple->set_null(desc->null_indicator_offset());\n+            } else  {\n+                std::stringstream str_error;\n+                str_error << \"Json value is null, but the column `\" << desc->col_name() << \"` is not nullable.\";\n+                return Status::RuntimeError(str_error.str());\n+            }\n+            break;\n+        default:\n+            std::stringstream str_error;\n+            str_error << \"Invalid JsonType \" << value->GetType() << \", Column Name `\" << desc->col_name() << \"`.\";\n+            return Status::RuntimeError(str_error.str());\n+    }\n+    return Status::OK();\n+}\n+\n+Status JsonReader::set_tuple_value(rapidjson::Value& objectValue, Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n+    int nullcount = 0;\n+    for (auto v : slot_descs) {\n+        if (objectValue.HasMember(v->col_name().c_str())) {\n+            rapidjson::Value& value = objectValue[v->col_name().c_str()];\n+            RETURN_IF_ERROR(write_data_to_tuple(&value, v, tuple, tuple_pool));\n+        } else {\n+            if (v->is_nullable()) {\n+                tuple->set_null(v->null_indicator_offset());\n+                nullcount++;\n+            } else  {\n+                std::stringstream str_error;\n+                str_error << \"The column `\" << v->col_name() << \"` is not nullable, but it's not found in jsondata.\";\n+                _state->append_error_msg_to_file(\"\", str_error.str());\n+                _counter->num_rows_filtered++;\n+                *valid = false; // current row is invalid\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (nullcount == slot_descs.size()) {\n+        _state->append_error_msg_to_file(\"\", \"The all fields is null, this is a invalid row.\");\n+        _counter->num_rows_filtered++;\n+        *valid = false;\n+        return Status::OK();\n+    }\n+    *valid = true;\n+    return Status::OK();\n+}\n+\n+/**\n+ * handle input a simple json\n+ * For example:\n+ *  case 1. {\"RECORDS\": [{\"colunm1\":\"value1\", \"colunm2\":10}, {\"colunm1\":\"value2\", \"colunm2\":30}]}\n+ *  case 2. {\"colunm1\":\"value1\", \"colunm2\":10}\n+ */\n+Status JsonReader::handle_simple_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+    do {\n+        bool valid = false;\n+        if (_next_line >= _total_lines) {//parse json and generic document\n+            RETURN_IF_ERROR(parse_json_doc(eof));\n+            if (*eof) {// read all data, then return\n+                return Status::OK();\n+            }\n+            if (_json_doc.HasMember(JsonReader::DORIS_RECORDS) && _json_doc[JsonReader::DORIS_RECORDS].IsArray() ) {\n+                _total_lines = _json_doc[JsonReader::DORIS_RECORDS].Size();\n+            } else {\n+                _total_lines = 1; // only one row\n+            }\n+            _next_line = 0;\n+        }\n+\n+        if (_json_doc.HasMember(JsonReader::DORIS_RECORDS) && _json_doc[JsonReader::DORIS_RECORDS].IsArray()) {//handle case 1\n+            rapidjson::Value& values = _json_doc[JsonReader::DORIS_RECORDS];\n+            rapidjson::Value& objectValue = values[_next_line];// json object\n+            RETURN_IF_ERROR(set_tuple_value(objectValue, tuple, slot_descs, tuple_pool, &valid));\n+        } else {// handle case 2\n+            RETURN_IF_ERROR(set_tuple_value(_json_doc, tuple, slot_descs, tuple_pool, &valid));\n+        }\n+        _next_line++;\n+        if (!valid) {\n+            continue;\n+        }\n+        break; // get a valid row, then break\n+    } while (_next_line <= _total_lines);\n+    return Status::OK();\n+}\n+\n+Status JsonReader::set_tuple_value_from_map(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool *valid) {\n+    std::unordered_map<std::string, JsonDataInternal>::iterator it_map;\n+    for (auto v : slot_descs) {\n+        it_map = _jmap.find(v->col_name());\n+        if (it_map == _jmap.end()) {\n+            return Status::RuntimeError(\"The column name of table is not foud in jsonpath.\");\n+        }\n+        rapidjson::Value::ConstValueIterator value = it_map->second.get_next();\n+        if (value == nullptr) {\n+            if (v->is_nullable()) {\n+                tuple->set_null(v->null_indicator_offset());\n+            } else  {\n+                std::stringstream str_error;\n+                str_error << \"The column `\" << it_map->first << \"` is not nullable, but it's not found in jsondata.\";\n+                _state->append_error_msg_to_file(\"\", str_error.str());\n+                _counter->num_rows_filtered++;\n+                *valid = false; // current row is invalid\n+                break;\n+            }\n+        } else {\n+            RETURN_IF_ERROR(write_data_to_tuple(value, v, tuple, tuple_pool));\n+        }\n+    }\n+    *valid = true;\n+    return Status::OK();\n+}\n+\n+Status JsonReader::handle_nest_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+    do {\n+        bool valid = false;\n+        if (_next_line >= _total_lines) {\n+            RETURN_IF_ERROR(parse_json_doc(eof));\n+            if (*eof) {\n+                return Status::OK();\n+            }\n+            _total_lines = get_data_by_jsonpath(slot_descs);\n+            if (_total_lines == -1) {\n+                return Status::InternalError(\"Parse json data is failed.\");\n+            } else if (_total_lines == 0) {\n+                *eof = true;\n+                return Status::OK();\n+            }\n+            _next_line = 0;\n+        }\n+\n+        RETURN_IF_ERROR(set_tuple_value_from_map(tuple, slot_descs, tuple_pool, &valid));\n+        _next_line++;\n+        if (!valid) {// read a invalid row, then read next one\n+            continue;\n+        }\n+        break; // read a valid row, then break\n+    } while (_next_line <= _total_lines);\n+    return Status::OK();\n+}\n+\n+/**\n+ * flat array for json\n+ * For example:\n+ *  [{\"colunm1\":\"value1\", \"colunm2\":10}, {\"colunm1\":\"value2\", \"colunm2\":30}]\n+ * Result:\n+ *      colunm1    colunm2\n+ *      ------------------\n+ *      value1     10\n+ *      value2     30\n+ */\n+Status JsonReader::handle_flat_array_complex_json(Tuple* tuple, const std::vector<SlotDescriptor*>& slot_descs, MemPool* tuple_pool, bool* eof) {\n+    do {\n+        if (_next_line >= _total_lines) {//parse json and generic document\n+            RETURN_IF_ERROR(parse_json_doc(eof));\n+            if (*eof) {// read all data, then return\n+                return Status::OK();\n+            }\n+            _total_lines = _json_doc.Size();\n+            _next_line = 0;\n+        }\n+        int nullcount = 0;\n+        bool valid = true;\n+        size_t limit = std::min(slot_descs.size(), (size_t)_jsonpaths_doc.Size());\n+        rapidjson::Value& objectValue = _json_doc[_next_line];\n+\n+        for (size_t i = 0; i < limit; i++) {\n+            const rapidjson::Value& path = _jsonpaths_doc[i];\n+            if (!path.IsString()) {\n+                return Status::InternalError(\"Jsonpath is not string.\");\n+            }\n+\n+            // if jsonValues is null, because not match in jsondata.\n+            rapidjson::Value* json_values = JsonFunctions::get_json_object_from_parsed_json(path.GetString(), &objectValue, _json_doc.GetAllocator());\n+            if (json_values == nullptr) {\n+                if (slot_descs[i]->is_nullable()) {\n+                    tuple->set_null(slot_descs[i]->null_indicator_offset());\n+                    nullcount++;\n+                } else  {\n+                    std::stringstream str_error;\n+                    str_error << \"The column `\" << slot_descs[i]->col_name() << \"` is not nullable, but it's not found in jsondata.\";\n+                    _state->append_error_msg_to_file(\"\", str_error.str());\n+                    _counter->num_rows_filtered++;\n+                    valid = false; // current row is invalid\n+                    break;\n+                }\n+            } else {\n+                RETURN_IF_ERROR(write_data_to_tuple(json_values, slot_descs[i], tuple, tuple_pool));\n+            }\n+        }\n+        _next_line++;\n+        if (!valid || nullcount == _jsonpaths_doc.Size()) {", "originalCommit": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTIzMg==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115232", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTM5NQ==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r426329395", "bodyText": "\u6211\u7406\u89e3\u4e0d\u5e94\u8be5\u662f\u8fd9\u6837\u7684\u683c\u5f0f\uff0c\u800c\u5e94\u8be5\u662f\u4e0b\u9762\u7684\u683c\u5f0f:\n[\n{\"category\":\"C++\",\"author\":\"avc\",\"title\":\"C++ primer\",\"price\":89.5},\n{\"category\":\"Java\",\"author\":\"avc\",\"title\":\"Effective Java\",\"price\":95},\n{\"category\":\"Linux\",\"author\":\"avc\",\"title\":\"Linux kernel\",\"price\":195}\n]", "author": "imay", "createdAt": "2020-05-18T01:15:39Z", "path": "docs/zh-CN/sql-reference/sql-statements/Data Manipulation/STREAM LOAD.md", "diffHunk": "@@ -127,7 +142,35 @@ under the License.\n     9. \u5bfc\u5165\u542b\u6709BITMAP\u5217\u7684\u8868\uff0c\u53ef\u4ee5\u662f\u8868\u4e2d\u7684\u5217\u6216\u8005\u6570\u636e\u4e2d\u7684\u5217\u7528\u4e8e\u751f\u6210BITMAP\u5217\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528bitmap_empty\u586b\u5145\u7a7a\u7684Bitmap\n         curl --location-trusted -u root -H \"columns: k1, k2, v1=to_bitmap(k1), v2=bitmap_empty()\" -T testData http://host:port/api/testDb/testTbl/_stream_load\n \n- \n+    10. \u7b80\u5355\u6a21\u5f0f\uff0c\u5bfc\u5165json\u6570\u636e\n+         \u8868\u7ed3\u6784\uff1a \n+           `category` varchar(512) NULL COMMENT \"\",\n+           `author` varchar(512) NULL COMMENT \"\",\n+           `title` varchar(512) NULL COMMENT \"\",\n+           `price` double NULL COMMENT \"\"\n+       json\u6570\u636e\u683c\u5f0f\uff1a\n+           {\"category\":\"C++\",\"author\":\"avc\",\"title\":\"C++ primer\",\"price\":895}\n+         \u5bfc\u5165\u547d\u4ee4\uff1a\n+           curl --location-trusted -u root  -H \"label:123\" -H \"format: json\" -T testData http://host:port/api/testDb/testTbl/_stream_load\n+         \u4e3a\u4e86\u63d0\u5347\u541e\u5410\u91cf\uff0c\u652f\u6301\u4e00\u6b21\u6027\u5bfc\u5165\u6761\u6570\u636e\uff0cjson\u6570\u636e\u683c\u5f0f\u5982\u4e0b\uff1a\n+           {\"RECORDS\":[\n+               {\"category\":\"C++\",\"author\":\"avc\",\"title\":\"C++ primer\",\"price\":89.5},\n+               {\"category\":\"Java\",\"author\":\"avc\",\"title\":\"Effective Java\",\"price\":95},\n+               {\"category\":\"Linux\",\"author\":\"avc\",\"title\":\"Linux kernel\",\"price\":195}\n+              ]}", "originalCommit": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTM0Nw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115347", "bodyText": "ok\uff0c i changed", "author": "worker24h", "createdAt": "2020-05-19T08:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTYzMQ==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r426329631", "bodyText": "\u611f\u89c9\u7cbe\u51c6\u7528\u5728\u8fd9\u91cc\u4e0d\u592a\u9002\u5408\u3002\u8fd9\u91cc\u5b8c\u6210\u7684\u5e94\u8be5\u662f\u5339\u914d\uff0c\u6620\u5c04\u5de5\u4f5c\u5427\uff1f", "author": "imay", "createdAt": "2020-05-18T01:17:26Z", "path": "docs/zh-CN/sql-reference/sql-statements/Data Manipulation/STREAM LOAD.md", "diffHunk": "@@ -67,13 +67,28 @@ under the License.\n         \u6bd4\u5982\u6307\u5b9a\u5bfc\u5165\u5230p1, p2\u5206\u533a\uff0c-H \"partitions: p1, p2\"\n \n         timeout: \u6307\u5b9a\u5bfc\u5165\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u5355\u4f4d\u79d2\u3002\u9ed8\u8ba4\u662f 600 \u79d2\u3002\u53ef\u8bbe\u7f6e\u8303\u56f4\u4e3a 1 \u79d2 ~ 259200 \u79d2\u3002\n-        \n+\n         strict_mode: \u7528\u6237\u6307\u5b9a\u6b64\u6b21\u5bfc\u5165\u662f\u5426\u5f00\u542f\u4e25\u683c\u6a21\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u5f00\u542f\u3002\u5173\u95ed\u65b9\u5f0f\u4e3a -H \"strict_mode: false\"\u3002\n \n         timezone: \u6307\u5b9a\u672c\u6b21\u5bfc\u5165\u6240\u4f7f\u7528\u7684\u65f6\u533a\u3002\u9ed8\u8ba4\u4e3a\u4e1c\u516b\u533a\u3002\u8be5\u53c2\u6570\u4f1a\u5f71\u54cd\u6240\u6709\u5bfc\u5165\u6d89\u53ca\u7684\u548c\u65f6\u533a\u6709\u5173\u7684\u51fd\u6570\u7ed3\u679c\u3002\n-        \n+\n         exec_mem_limit: \u5bfc\u5165\u5185\u5b58\u9650\u5236\u3002\u9ed8\u8ba4\u4e3a 2GB\u3002\u5355\u4f4d\u4e3a\u5b57\u8282\u3002\n \n+        format: \u6307\u5b9a\u5bfc\u5165\u6570\u636e\u683c\u5f0f\uff0c\u9ed8\u8ba4\u662fcsv\uff0c\u652f\u6301json\u683c\u5f0f\u3002\n+\n+        jsonpaths: \u5bfc\u5165json\u65b9\u5f0f\u5206\u4e3a\uff1a\u7b80\u5355\u6a21\u5f0f\u548c\u7cbe\u51c6\u6a21\u5f0f\u3002\n+              \u7b80\u5355\u6a21\u5f0f\uff1a\u6ca1\u6709\u8bbe\u7f6ejsonpaths\u53c2\u6570\u5373\u4e3a\u7b80\u5355\u6a21\u5f0f\uff0c\u8fd9\u79cd\u6a21\u5f0f\u4e0b\u8981\u6c42json\u6570\u636e\u662f\u5bf9\u8c61\u7c7b\u578b\uff0c\u4f8b\u5982\uff1a\n+              {\"k1\":1, \"k2\":2, \"k3\":\"hello\"}\uff0c\u5176\u4e2dk1\uff0ck2\uff0ck3\u662f\u5217\u540d\u5b57\u3002\n+\n+              \u7cbe\u51c6\u6a21\u5f0f\uff1a\u7528\u4e8ejson\u6570\u636e\u76f8\u5bf9\u590d\u6742\uff0c\u9700\u8981\u901a\u8fc7jsonpaths\u53c2\u6570\u83b7\u53d6\u76f8\u5e94value\u3002", "originalCommit": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTQxMA==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115410", "bodyText": "ok", "author": "worker24h", "createdAt": "2020-05-19T08:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTcwNw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r426329707", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    2\uff09{\n          \n          \n            \n                        \"RECORDS\":[\n          \n          \n            \n                            {\"category\":\"a9jadhx\",\"author\":\"test\",\"price\":895},\n          \n          \n            \n                            {\"category\":\"axdfa1\",\"author\":\"EvelynWaugh\",\"price\":1299}\n          \n          \n            \n                        ]\n          \n          \n            \n                    2\uff09[\n          \n          \n            \n                            {\"category\":\"a9jadhx\",\"author\":\"test\",\"price\":895},\n          \n          \n            \n                            {\"category\":\"axdfa1\",\"author\":\"EvelynWaugh\",\"price\":1299}\n          \n          \n            \n                        ]", "author": "imay", "createdAt": "2020-05-18T01:17:56Z", "path": "docs/zh-CN/sql-reference/sql-statements/Data Manipulation/ROUTINE LOAD.md", "diffHunk": "@@ -309,6 +321,84 @@ under the License.\n             \"property.ssl.key.password\" = \"abcdefg\",\n             \"property.client.id\" = \"my_client_id\"\n         );\n+    4. \u7b80\u5355\u6a21\u5f0f\u5bfc\u5165json\n+        CREATE ROUTINE LOAD example_db.test_json_label_1 ON table1\n+        COLUMNS(category,price,author)\n+        PROPERTIES\n+        (\n+        \"desired_concurrent_number\"=\"3\",\n+        \"max_batch_interval\" = \"20\",\n+        \"max_batch_rows\" = \"300000\",\n+        \"max_batch_size\" = \"209715200\",\n+        \"strict_mode\" = \"false\",\n+        \"format\" = \"json\"\n+        )\n+        FROM KAFKA\n+        (\n+        \"kafka_broker_list\" = \"broker1:9092,broker2:9092,broker3:9092\",\n+        \"kafka_topic\" = \"my_topic\",\n+        \"kafka_partitions\" = \"0,1,2\",\n+        \"kafka_offsets\" = \"0,0,0\"\n+        );\n+        \u652f\u6301\u4e24\u79cdjson\u6570\u636e\u683c\u5f0f\uff1a\n+      1\uff09{\"category\":\"a9jadhx\",\"author\":\"test\",\"price\":895}\n+        2\uff09{\n+            \"RECORDS\":[\n+                {\"category\":\"a9jadhx\",\"author\":\"test\",\"price\":895},\n+                {\"category\":\"axdfa1\",\"author\":\"EvelynWaugh\",\"price\":1299}\n+            ]", "originalCommit": "81adc03cc58ea8595e12d26a1ac21caa7dea1ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTUwNw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427115507", "bodyText": "i changed", "author": "worker24h", "createdAt": "2020-05-19T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyOTcwNw=="}], "type": "inlineReview"}, {"oid": "ba96988c59284a972cde107e1d2fb40859cbe0f8", "url": "https://github.com/apache/incubator-doris/commit/ba96988c59284a972cde107e1d2fb40859cbe0f8", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-18T03:10:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5NjY0Mw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427396643", "bodyText": "What's the meaning of json_scanner_test2? Why do we both need json_scanner_test and json_scanner_test2?", "author": "kangkaisen", "createdAt": "2020-05-19T15:31:54Z", "path": "be/test/exec/json_scanner_test2.cpp", "diffHunk": "@@ -0,0 +1,426 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"exec/broker_scan_node.h\"\n+\n+#include <string>\n+#include <map>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+#include <time.h>\n+#include \"common/object_pool.h\"\n+#include \"runtime/tuple.h\"\n+#include \"exec/local_file_reader.h\"\n+#include \"exprs/cast_functions.h\"\n+#include \"runtime/descriptors.h\"\n+#include \"runtime/exec_env.h\"\n+#include \"runtime/runtime_state.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/user_function_cache.h\"\n+#include \"gen_cpp/Descriptors_types.h\"\n+#include \"gen_cpp/PlanNodes_types.h\"\n+\n+namespace doris {\n+\n+class JsonSannerTest : public testing::Test {", "originalCommit": "ba96988c59284a972cde107e1d2fb40859cbe0f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNzA2Nw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427717067", "bodyText": "there are two senses, i had change the file name", "author": "worker24h", "createdAt": "2020-05-20T03:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5NjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5NzE5Mw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427397193", "bodyText": "All comments should use english.", "author": "kangkaisen", "createdAt": "2020-05-19T15:32:43Z", "path": "be/test/exec/json_scanner_test.cpp", "diffHunk": "@@ -0,0 +1,445 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"exec/broker_scan_node.h\"\n+\n+#include <string>\n+#include <map>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+#include <time.h>\n+#include \"common/object_pool.h\"\n+#include \"runtime/tuple.h\"\n+#include \"exec/local_file_reader.h\"\n+#include \"exprs/cast_functions.h\"\n+#include \"runtime/descriptors.h\"\n+#include \"runtime/exec_env.h\"\n+#include \"runtime/runtime_state.h\"\n+#include \"runtime/row_batch.h\"\n+#include \"runtime/user_function_cache.h\"\n+#include \"gen_cpp/Descriptors_types.h\"\n+#include \"gen_cpp/PlanNodes_types.h\"\n+\n+namespace doris {\n+\n+class JsonSannerTest : public testing::Test {\n+public:\n+    JsonSannerTest() : _runtime_state(TQueryGlobals()) {\n+        init();\n+        _runtime_state._instance_mem_tracker.reset(new MemTracker());\n+        _runtime_state._exec_env = ExecEnv::GetInstance();\n+    }\n+    void init();\n+    static void SetUpTestCase() {\n+        UserFunctionCache::instance()->init(\"./be/test/runtime/test_data/user_function_cache/normal\");\n+        CastFunctions::init();\n+    }\n+\n+protected:\n+    virtual void SetUp() {\n+    }\n+    virtual void TearDown() {\n+    }\n+private:\n+    int create_src_tuple(TDescriptorTable& t_desc_table, int next_slot_id);\n+    int create_dst_tuple(TDescriptorTable& t_desc_table, int next_slot_id);\n+    void create_expr_info();\n+    void init_desc_table();\n+    RuntimeState _runtime_state;\n+    ObjectPool _obj_pool;\n+    std::map<std::string, SlotDescriptor*> _slots_map;\n+    TBrokerScanRangeParams _params;\n+    DescriptorTbl* _desc_tbl;\n+    TPlanNode _tnode;\n+};\n+\n+#define TUPLE_ID_DST 0\n+#define TUPLE_ID_SRC 1\n+#define CLOMN_NUMBERS 4\n+#define DST_TUPLE_SLOT_ID_START 1\n+#define SRC_TUPLE_SLOT_ID_START 5\n+int JsonSannerTest::create_src_tuple(TDescriptorTable& t_desc_table, int next_slot_id) {\n+    const char *clomnNames[] = {\"category\",\"author\",\"title\",\"price\"};\n+    for (int i = 0; i < CLOMN_NUMBERS; i++)\n+    {\n+        TSlotDescriptor slot_desc;\n+\n+        slot_desc.id = next_slot_id++;\n+        slot_desc.parent = 1;\n+        TTypeDesc type;\n+        {\n+            TTypeNode node;\n+            node.__set_type(TTypeNodeType::SCALAR);\n+            TScalarType scalar_type;\n+            scalar_type.__set_type(TPrimitiveType::VARCHAR);\n+            scalar_type.__set_len(65535);\n+            node.__set_scalar_type(scalar_type);\n+            type.types.push_back(node);\n+        }\n+        slot_desc.slotType = type;\n+        slot_desc.columnPos = i;\n+        slot_desc.byteOffset = i*16+8; // \u8df3\u8fc7\u524d8\u4e2a\u5b57\u8282 \u8fd98\u4e2a\u5b57\u8282\u7528\u4e8e\u8868\u793a\u5b57\u6bb5\u662f\u5426\u4e3anull\u503c\n+        slot_desc.nullIndicatorByte = i/8;\n+        slot_desc.nullIndicatorBit = i%8;\n+        slot_desc.colName = clomnNames[i];\n+        slot_desc.slotIdx = i + 1;\n+        slot_desc.isMaterialized = true;\n+\n+        t_desc_table.slotDescriptors.push_back(slot_desc);\n+    }\n+\n+    {\n+        // TTupleDescriptor source\n+        TTupleDescriptor t_tuple_desc;\n+        t_tuple_desc.id = TUPLE_ID_SRC;\n+        t_tuple_desc.byteSize = CLOMN_NUMBERS*16+8;//\u6b64\u59048\u5b57\u8282\u4e3a\u4e86\u5904\u7406null\u503c\n+        t_tuple_desc.numNullBytes = 0;\n+        t_tuple_desc.tableId = 0;\n+        t_tuple_desc.__isset.tableId = true;\n+        t_desc_table.tupleDescriptors.push_back(t_tuple_desc);\n+    }\n+    return next_slot_id;\n+}\n+\n+int JsonSannerTest::create_dst_tuple(TDescriptorTable& t_desc_table, int next_slot_id) {\n+    int32_t byteOffset = 8; // \u8df3\u8fc7\u524d8\u4e2a\u5b57\u8282 \u8fd98\u4e2a\u5b57\u8282\u7528\u4e8e\u8868\u793a\u5b57\u6bb5\u662f\u5426\u4e3anull\u503c\n+    {//category\n+        TSlotDescriptor slot_desc;\n+        slot_desc.id = next_slot_id++;\n+        slot_desc.parent = 0;\n+        TTypeDesc type;\n+        {\n+            TTypeNode node;\n+            node.__set_type(TTypeNodeType::SCALAR);\n+            TScalarType scalar_type;\n+            scalar_type.__set_type(TPrimitiveType::VARCHAR);\n+            scalar_type.__set_len(65535);\n+            node.__set_scalar_type(scalar_type);\n+            type.types.push_back(node);\n+        }\n+        slot_desc.slotType = type;\n+        slot_desc.columnPos = 0;\n+        slot_desc.byteOffset = byteOffset;\n+        slot_desc.nullIndicatorByte = 0;\n+        slot_desc.nullIndicatorBit = 0;\n+        slot_desc.colName = \"category\";\n+        slot_desc.slotIdx = 1;\n+        slot_desc.isMaterialized = true;\n+\n+        t_desc_table.slotDescriptors.push_back(slot_desc);\n+    }\n+    byteOffset += 16;\n+    {// author\n+        TSlotDescriptor slot_desc;\n+\n+        slot_desc.id = next_slot_id++;\n+        slot_desc.parent = 0;\n+        TTypeDesc type;\n+        {\n+            TTypeNode node;\n+            node.__set_type(TTypeNodeType::SCALAR);\n+            TScalarType scalar_type;\n+            scalar_type.__set_type(TPrimitiveType::VARCHAR);\n+            scalar_type.__set_len(65535);\n+            node.__set_scalar_type(scalar_type);\n+            type.types.push_back(node);\n+        }\n+        slot_desc.slotType = type;\n+        slot_desc.columnPos = 1;\n+        slot_desc.byteOffset = byteOffset;\n+        slot_desc.nullIndicatorByte = 0;\n+        slot_desc.nullIndicatorBit = 1;\n+        slot_desc.colName = \"author\";\n+        slot_desc.slotIdx = 2;\n+        slot_desc.isMaterialized = true;\n+\n+        t_desc_table.slotDescriptors.push_back(slot_desc);\n+    }\n+    byteOffset += 16;\n+    {// title\n+        TSlotDescriptor slot_desc;\n+\n+        slot_desc.id = next_slot_id++;\n+        slot_desc.parent = 0;\n+        TTypeDesc type;\n+        {\n+            TTypeNode node;\n+            node.__set_type(TTypeNodeType::SCALAR);\n+            TScalarType scalar_type;\n+            scalar_type.__set_type(TPrimitiveType::VARCHAR);\n+            scalar_type.__set_len(65535);\n+            node.__set_scalar_type(scalar_type);\n+            type.types.push_back(node);\n+        }\n+        slot_desc.slotType = type;\n+        slot_desc.columnPos = 2;\n+        slot_desc.byteOffset = byteOffset;\n+        slot_desc.nullIndicatorByte = 0;\n+        slot_desc.nullIndicatorBit = 2;\n+        slot_desc.colName = \"title\";\n+        slot_desc.slotIdx = 3;\n+        slot_desc.isMaterialized = true;\n+\n+        t_desc_table.slotDescriptors.push_back(slot_desc);\n+    }\n+    byteOffset += 16;\n+    {// price\n+        TSlotDescriptor slot_desc;\n+\n+        slot_desc.id = next_slot_id++;\n+        slot_desc.parent = 0;\n+        TTypeDesc type;\n+        {\n+            TTypeNode node;\n+            node.__set_type(TTypeNodeType::SCALAR);\n+            TScalarType scalar_type;\n+            scalar_type.__set_type(TPrimitiveType::DOUBLE);\n+            node.__set_scalar_type(scalar_type);\n+            type.types.push_back(node);\n+        }\n+        slot_desc.slotType = type;\n+        slot_desc.columnPos = 3;\n+        slot_desc.byteOffset = byteOffset;\n+        slot_desc.nullIndicatorByte = 0;\n+        slot_desc.nullIndicatorBit = 3;\n+        slot_desc.colName = \"price\";\n+        slot_desc.slotIdx = 4;\n+        slot_desc.isMaterialized = true;\n+\n+        t_desc_table.slotDescriptors.push_back(slot_desc);\n+    }\n+    byteOffset += 8;\n+    t_desc_table.__isset.slotDescriptors = true;\n+    {\n+        // TTupleDescriptor dest\n+        TTupleDescriptor t_tuple_desc;\n+        t_tuple_desc.id = TUPLE_ID_DST;\n+        t_tuple_desc.byteSize = byteOffset+8;//\u6b64\u59048\u5b57\u8282\u4e3a\u4e86\u5904\u7406null\u503c", "originalCommit": "ba96988c59284a972cde107e1d2fb40859cbe0f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNjkzMw==", "url": "https://github.com/apache/incubator-doris/pull/3553#discussion_r427716933", "bodyText": "ok, i remove it", "author": "worker24h", "createdAt": "2020-05-20T03:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5NzE5Mw=="}], "type": "inlineReview"}, {"oid": "a0bcb8df610b60cac782b220023f95193ad2f7e3", "url": "https://github.com/apache/incubator-doris/commit/a0bcb8df610b60cac782b220023f95193ad2f7e3", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-20T03:08:35Z", "type": "forcePushed"}, {"oid": "5c229d3cf32f1598e1bc0a1bee86ce6a4a3999b5", "url": "https://github.com/apache/incubator-doris/commit/5c229d3cf32f1598e1bc0a1bee86ce6a4a3999b5", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-21T02:42:54Z", "type": "commit"}, {"oid": "5c229d3cf32f1598e1bc0a1bee86ce6a4a3999b5", "url": "https://github.com/apache/incubator-doris/commit/5c229d3cf32f1598e1bc0a1bee86ce6a4a3999b5", "message": "Support load json-data into Doris by RoutineLoad or StreamLoad", "committedDate": "2020-05-21T02:42:54Z", "type": "forcePushed"}]}