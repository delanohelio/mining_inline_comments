{"pr_number": 2983, "pr_title": "Add block layer to storage-engine", "pr_createdAt": "2020-02-24T12:16:18Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2983", "timeline": [{"oid": "4fbe345a4d0fdd2f9cc420a5d5429f6fee982f42", "url": "https://github.com/apache/incubator-doris/commit/4fbe345a4d0fdd2f9cc420a5d5429f6fee982f42", "message": "Add block layer to storage-engine\n\nThe abstraction of the Block layer, inspired by Kudu, lies between the \"business\nlayer\" and the \"underlying file storage layer\" (`Env`), making them no longer\nstrongly coupled.\n\nIn this way, for the business layer (such as `SegmentWriter`),\nthere is no need to directly do the file operation, which will bring better\nencapsulation. An ideal situation in the future is: when we need to support a\nnew file storage system, we only need to add a corresponding type of\nBlockManager without modifying the business code (such as `SegmentWriter`).\n\nWith the Block layer, there are some benefits:\n\n1. First and foremost, the mapping relationship between data and `Env` is more\n   flexible. For example, in the storage engine, the data of the tablet can be\n   placed in multiple file systems (`Env`) at the same time. That is, one-to-many\n   relationships can be supported. For example: one on the local and one on the\n   remote storage.\n2. The mapping relationship between blocks and files can be adjusted, for example,\n   it may not be a one-to-one relationship. For example, the data of multiple\n   blocks can be stored in a physical file, which can reduce the number of files\n   that need to be opened during querying. It is like `LogBlockManager` in Kudu.\n3. We can move the opened-file-cache under the Block layer, which can automatically\n   close and open the files used by the upper layer, so that the upper business\n   level does not need to be aware of the restrictions of the file handle at all\n   (This problem is often encountered online now).\n4. Better automatic cleanup logic when there are exceptions. For example, a block\n   that is not closed explicitly can automatically clean up its corresponding file,\n   thereby avoiding generating most garbage files.\n5. More convenient for batch file creation and deletion. Some business operations\n   create multiple files, such as compaction. At present, the processing flow that\n   these files go through is executed one by one: 1) creation; 2) writing data;\n   3) fsync to disk. But in fact, this is not necessary, we only need to fsync this\n   batch of files at the end. The advantage is that it can give the operating system\n   more opportunities to perform IO merge, thereby improving performance. However,\n   this operation is relatively tedious, there is no need to be coupled in the\n   business code, it is an ideal place to put it in the Block layer.\n\nThis is the first patch, just add related classes, laying the groundwork for later\nswitching of read and write logic.", "committedDate": "2020-02-24T12:12:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjUxMg==", "url": "https://github.com/apache/incubator-doris/pull/2983#discussion_r386032512", "bodyText": "Why there is a private env() method?", "author": "morningman", "createdAt": "2020-02-29T14:42:26Z", "path": "be/src/olap/fs/file_block_manager.h", "diffHunk": "@@ -0,0 +1,119 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"common/status.h\"\n+#include \"olap/fs/block_manager.h\"\n+\n+namespace doris {\n+\n+class BlockId;\n+class Env;\n+class MemTracker;\n+class RandomAccessFile;\n+\n+namespace fs {\n+namespace internal {\n+\n+class FileReadableBlock;\n+class FileWritableBlock;\n+struct BlockManagerMetrics;\n+\n+} // namespace internal\n+\n+// TODO(lingbin): When we create a batch of blocks(blocks are created one by one),\n+// eg, when we do a compaction,  multiple files will be generated in sequence.\n+// For this scenario, we should have a mechanism that can give the Operating System\n+// more opportunities to perform IO merge.\n+\n+// A file-backed block storage implementation.\n+//\n+// This is a naive block implementation which maps each block to its own\n+// file on disk.\n+//\n+// The block manager can take advantage of multiple filesystem paths.\n+//\n+// When creating blocks, the block manager will place blocks based on the\n+// provided CreateBlockOptions.\n+\n+// The file-backed block manager.\n+class FileBlockManager : public BlockManager {\n+public:\n+    // Note: all objects passed as pointers should remain alive for the lifetime\n+    // of the block manager.\n+    FileBlockManager(Env* env, BlockManagerOptions opts);\n+    virtual ~FileBlockManager();\n+\n+    Status open() override;\n+\n+    Status create_block(const CreateBlockOptions& opts,\n+                        std::unique_ptr<WritableBlock>* block) override;\n+    Status open_block(const std::string& path, std::unique_ptr<ReadableBlock>* block) override;\n+\n+    Status get_all_block_ids(std::vector<BlockId>* block_ids) override {\n+        // TODO(lingbin): to be implemented after we assign each block an id\n+        return Status::OK();\n+    };\n+\n+private:\n+    friend class internal::FileReadableBlock;\n+    friend class internal::FileWritableBlock;\n+\n+    // Deletes an existing block, allowing its space to be reclaimed by the\n+    // filesystem. The change is immediately made durable.\n+    //\n+    // Blocks may be deleted while they are open for reading or writing;\n+    // the actual deletion will take place after the last open reader or\n+    // writer is closed.\n+    Status _delete_block(const std::string& path);\n+\n+    // Synchronizes the metadata for a block with the given location.\n+    Status _sync_metadata(const std::string& path);\n+\n+    Env* env() const { return _env; }", "originalCommit": "4fbe345a4d0fdd2f9cc420a5d5429f6fee982f42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}