{"pr_number": 2931, "pr_title": "Use ThreadPool to refactor MemTableFlushExecutor", "pr_createdAt": "2020-02-18T08:02:04Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2931", "timeline": [{"oid": "abcadc2d5a8fac68c2ec3ea68f8ac06176fddac9", "url": "https://github.com/apache/incubator-doris/commit/abcadc2d5a8fac68c2ec3ea68f8ac06176fddac9", "message": "Use ThreadPool to refactor MemTableFlushExecutor\n1. MemTableFlushExecutor maintain a ThreadPool to receive FlushTask.\n2. FlushToken is used to seperate different tasks from different tablets.\n   Every DeltaWriter of tablet constructs a FlushToken,\n   task in FlushToken are handle serially, task between FlushToken are\n   handle concurrently.\n3. I have remove thread limit on data_dir, because of I/O is not the main\n   timer consumer of Flush thread. Much of time is consumed in CPU decoding\n   and compress.", "committedDate": "2020-02-18T07:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MzU4MA==", "url": "https://github.com/apache/incubator-doris/pull/2931#discussion_r380573580", "bodyText": "Could you please use std::bind instead?", "author": "lingbin", "createdAt": "2020-02-18T10:08:01Z", "path": "be/src/olap/memtable_flush_executor.cpp", "diffHunk": "@@ -24,146 +24,62 @@\n #include \"olap/memtable.h\"\n #include \"runtime/exec_env.h\"\n #include \"runtime/mem_tracker.h\"\n+#include \"util/scoped_cleanup.h\"\n \n namespace doris {\n \n-OLAPStatus FlushHandler::submit(std::shared_ptr<MemTable> memtable) {\n-    RETURN_NOT_OK(_last_flush_status.load());\n-    MemTableFlushContext ctx;\n-    ctx.memtable = std::move(memtable);\n-    ctx.flush_handler = this->shared_from_this();\n-    _counter_cond.inc();\n-    VLOG(5) << \"submitting \" << *(ctx.memtable) << \" to flush queue \" << _flush_queue_idx;\n-    RETURN_NOT_OK(_flush_executor->_push_memtable(_flush_queue_idx, ctx));\n-    return OLAP_SUCCESS;\n-}\n-\n-OLAPStatus FlushHandler::wait() {\n-    // wait all submitted tasks to be finished or cancelled\n-    _counter_cond.block_wait();\n-    return _last_flush_status.load();\n-}\n-\n-void FlushHandler::on_flush_finished(const FlushResult& res) {\n-    if (res.flush_status != OLAP_SUCCESS) {\n-        _last_flush_status.store(res.flush_status);\n-    } else {\n-        _stats.flush_time_ns.fetch_add(res.flush_time_ns);\n-        _stats.flush_count.fetch_add(1);\n-    }\n-    _counter_cond.dec();\n+std::ostream& operator<<(std::ostream& os, const FlushStatistic& stat) {\n+    os << \"(flush time(ms)=\" << stat.flush_time_ns / 1000 / 1000\n+       << \", flush count=\" << stat.flush_count << \")\";\n+    return os;\n }\n \n-OLAPStatus MemTableFlushExecutor::create_flush_handler(\n-        size_t path_hash, std::shared_ptr<FlushHandler>* flush_handler) {\n-    size_t flush_queue_idx = _get_queue_idx(path_hash);\n-    flush_handler->reset(new FlushHandler(flush_queue_idx, this));\n+OLAPStatus FlushToken::submit(std::shared_ptr<MemTable> memtable) {\n+    _flush_token->submit_func(boost::bind(boost::mem_fn(&FlushToken::_flush_memtable), this, memtable));", "originalCommit": "abcadc2d5a8fac68c2ec3ea68f8ac06176fddac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NjczOA==", "url": "https://github.com/apache/incubator-doris/pull/2931#discussion_r380576738", "bodyText": "The only class the user needs to know is FlushToken.\nSo maybe we should hide the implementation of MemTableFlushExecutor in .cpp file, because the user does not need to directly know it.  But this can be refactored later.", "author": "lingbin", "createdAt": "2020-02-18T10:13:37Z", "path": "be/src/olap/memtable_flush_executor.h", "diffHunk": "@@ -38,132 +32,65 @@ class DeltaWriter;\n class ExecEnv;\n class MemTable;\n \n-// The context for a memtable to be flushed.\n-class FlushHandler;\n-struct MemTableFlushContext {\n-    // memtable to be flushed\n-    std::shared_ptr<MemTable> memtable;\n-    // flush handler from a delta writer.\n-    // use shared ptr because flush_handler may be deleted before this\n-    // memtable being flushed. so we need to make sure the flush_handler\n-    // is alive until this memtable being flushed.\n-    std::shared_ptr<FlushHandler> flush_handler;\n-};\n-\n-// the flush result of a single memtable flush\n-struct FlushResult {\n-    OLAPStatus flush_status;\n-    int64_t flush_time_ns = 0;\n-    int64_t flush_size_bytes = 0;\n-};\n-\n // the statistic of a certain flush handler.\n // use atomic because it may be updated by multi threads\n struct FlushStatistic {\n-    std::atomic<std::int64_t> flush_time_ns = {0};\n-    std::atomic<std::int64_t> flush_count= {0};\n+    int64_t flush_time_ns = 0;\n+    int64_t flush_count= 0;\n+    int64_t flush_size_bytes = 0;\n };\n \n std::ostream& operator<<(std::ostream& os, const FlushStatistic& stat);\n \n-class MemTableFlushExecutor;\n-\n-// flush handler is for flushing memtables in a delta writer\n-// This class must be wrapped by std::shared_ptr, or you will get bad_weak_ptr exception\n-// when calling submit();\n-class FlushHandler : public std::enable_shared_from_this<FlushHandler> {\n+// A thin wrapper of ThreadPoolToken to submit task.\n+class FlushToken {\n public:\n-    FlushHandler(int32_t flush_queue_idx, MemTableFlushExecutor* flush_executor) :\n-            _flush_queue_idx(flush_queue_idx),\n-            _last_flush_status(OLAP_SUCCESS),\n-            _counter_cond(0),\n-            _flush_executor(flush_executor),\n-            _is_cancelled(false) {\n-    }\n-\n-    // submit a memtable to flush. return error if some previous submitted MemTable has failed\n-    OLAPStatus submit(std::shared_ptr<MemTable> memtable);\n-    // wait for all memtables submitted by itself to be finished.\n+    explicit FlushToken(std::unique_ptr<ThreadPoolToken> flush_pool_token)\n+        : _flush_status(OLAP_SUCCESS),\n+          _flush_token(std::move(flush_pool_token)) {}\n+\n+    OLAPStatus submit(std::shared_ptr<MemTable> mem_table);\n+\n+    // error has happpens, so we cancel this token\n+    // And remove all tasks in the queue.\n+    void cancel();\n+\n+    // wait all tasks in token to be completed.\n     OLAPStatus wait();\n+\n     // get flush operations' statistics\n     const FlushStatistic& get_stats() const { return _stats; }\n \n-    bool is_cancelled() {\n-        return _last_flush_status.load() != OLAP_SUCCESS || _is_cancelled.load();\n-    }\n-    void cancel() { _is_cancelled.store(true); }\n-\n-    // These on_xxx() methods are callback when flush finishes or cancels, user should\n-    // not call them directly.\n-    // called when a memtable is finished by executor.\n-    void on_flush_finished(const FlushResult& res);\n-    // called when a flush memtable execution is cancelled\n-    void on_flush_cancelled() {\n-        _counter_cond.dec();\n-    }\n-\n private:\n-    // flush queue idx in memtable flush executor\n-    int32_t _flush_queue_idx;\n-    // the flush status of last memtable\n-    std::atomic<OLAPStatus> _last_flush_status;\n-    // used to wait/notify the memtable flush execution\n-    CounterCondVariable _counter_cond;\n+    void _flush_memtable(std::shared_ptr<MemTable> mem_table);\n \n+    OLAPStatus _flush_status;\n+    std::unique_ptr<ThreadPoolToken> _flush_token;\n     FlushStatistic _stats;\n-    MemTableFlushExecutor* _flush_executor;\n-\n-    // the caller of the flush handler can set this variable to notify that the\n-    // uppper application is already cancelled.\n-    std::atomic<bool> _is_cancelled;\n };\n \n // MemTableFlushExecutor is responsible for flushing memtables to disk.\n-// Each data directory has a specified number of worker threads and each thread will correspond\n-// to a queue. The only job of each worker thread is to take memtable from its corresponding\n-// flush queue and writes the data to disk.\n-//\n-// NOTE: User SHOULD NOT call method of this class directly, use pattern should be:\n+// It encapsulate a ThreadPool to handle all tasks.\n+// Usage Example:\n //      ...\n //      std::shared_ptr<FlushHandler> flush_handler;\n-//      memTableFlushExecutor.create_flush_handler(path_hash, &flush_handler);\n+//      memTableFlushExecutor.create_flush_token(path_hash, &flush_handler);\n //      ...\n-//      flush_handler->submit(memtable)\n+//      flush_token->submit(memtable)\n //      ...\n class MemTableFlushExecutor {", "originalCommit": "abcadc2d5a8fac68c2ec3ea68f8ac06176fddac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}