{"pr_number": 3150, "pr_title": "Support non-correlated subquery in having clause", "pr_createdAt": "2020-03-19T12:06:57Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3150", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUwNTQ0Ng==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r395505446", "bodyText": "what if  the origin query is\nselect cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk\n     having sum(cs_sales_price) >\n     (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk) limit 1;\n\non limit after rewrite\nwhat about order by ?", "author": "yangzhg", "createdAt": "2020-03-20T08:58:24Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -97,8 +103,128 @@ private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             }\n             rewriteWhereClauseSubqueries(stmt, analyzer);\n         }\n+        // Rewrite all subquery in the having clause\n+        if (stmt.getHavingPred() != null && stmt.getHavingPred().getSubquery() != null) {\n+            stmt = rewriteHavingClauseSubqueries(stmt, analyzer);\n+        }\n         stmt.sqlString_ = null;\n         if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        return stmt;\n+    }\n+\n+    /**\n+     * Rewrite having subquery.\n+     * Step1: rewrite having subquery to where subquery\n+     * Step2: rewrite where subquery\n+     * <p>\n+     * For example:\n+     * select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk\n+     * having sum(cs_sales_price) >\n+     *        (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+     * <p>\n+     * Step1: rewrite having subquery to where subquery\n+     * Outer query is changed to inline view in rewritten query\n+     * Inline view of outer query:\n+     *     from (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     * Rewritten subquery of expr:\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * Rewritten query:\n+     *     select cs_item_sk, a.sum_cs_sales_price from\n+     *     (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * <p>\n+     * Step2: rewrite where subquery\n+     * Inline view of subquery:\n+     *     from (select b.cs_item_sk, min(cs_sales_price) from catalog_sales b group by cs_item_sk) c\n+     * Rewritten correlated predicate:\n+     *     where c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min(cs_sales_price)\n+     *\n+     * @param stmt\n+     * @param analyzer\n+     */\n+    private static SelectStmt rewriteHavingClauseSubqueries(SelectStmt stmt, Analyzer analyzer) throws AnalysisException {\n+        // extract having predicate\n+        Expr havingPredicate = stmt.getHavingPred();\n+        Preconditions.checkState(havingPredicate != null);\n+        Preconditions.checkState(havingPredicate.getSubquery() != null);\n+        // extract result of stmt\n+        List<Expr> leftExprList = stmt.getResultExprs();\n+        // extract table alias generator\n+        TableAliasGenerator tableAliasGenerator = stmt.getTableAliasGenerator();\n+\n+        /*\n+         * The outer query is changed to inline view without having predicate\n+         * For example:\n+         * Query: select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk having ...;\n+         * Inline view:\n+         *     from (select cs_item_sk $ColumnA, sum(cs_sales_price) $ColumnB from catalog_sales a group by cs_item_sk) $TableA\n+         */\n+        SelectStmt inlineViewQuery = (SelectStmt) stmt.clone();\n+        inlineViewQuery.reset();\n+        inlineViewQuery.removeHavingClause();\n+        // add a new alias for all of columns in subquery\n+        List<String> colAliasOfInlineView = Lists.newArrayList();\n+        for (int i = 0; i < inlineViewQuery.getSelectList().getItems().size(); ++i) {\n+            colAliasOfInlineView.add(inlineViewQuery.getColumnAliasGenerator().getNextAlias());\n+        }\n+        InlineViewRef inlineViewRef = new InlineViewRef(tableAliasGenerator.getNextAlias(), inlineViewQuery,\n+                colAliasOfInlineView);\n+        try {\n+            inlineViewRef.analyze(analyzer);\n+        } catch (UserException e) {\n+            throw new AnalysisException(e.getMessage());\n+        }\n+        LOG.debug(\"Outer query is changed to \" + inlineViewRef.tableRefToSql());\n+\n+        /*\n+         * Columns which belong to outer query can substitute for output columns of inline view\n+         * For example:\n+         * Having predicate: sum(cs_sales_price) >\n+         *                   (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+         * Columns which belong to outer query: sum(cs_sales_price), a.cs_item_sk\n+         * SMap: <cs_item_sk $ColumnA> <sum(cs_sales_price) $ColumnB>\n+         * After substitute: $ColumnB >\n+         *                   (select min(cs_sales_price) from catalog_sales b where $ColumnA = b.cs_item_sk)\n+         */\n+        /*\n+         * Prepare select list of new query.\n+         * Generate a new select item for each original columns in select list\n+         */\n+        havingPredicate.reset();\n+        ExprSubstitutionMap smap = new ExprSubstitutionMap();\n+        SelectList newSelectList = new SelectList();\n+        for (int i = 0; i < inlineViewQuery.getSelectList().getItems().size(); i++) {\n+            Expr leftExpr = leftExprList.get(i);\n+            Expr rightExpr = new SlotRef(inlineViewRef.getAliasAsName(), colAliasOfInlineView.get(i));\n+            rightExpr.analyze(analyzer);\n+            smap.put(leftExpr, rightExpr);\n+            // construct outer query select list\n+            SelectListItem selectListItem = new SelectListItem(rightExpr, stmt.getColLabels().get(i));\n+            newSelectList.addItem(selectListItem);\n+        }\n+        Expr newWherePredicate = havingPredicate.substitute(smap, analyzer,false);\n+        LOG.debug(\"Having predicate is changed to \" + newWherePredicate.toSql());\n+\n+        // construct rewritten query\n+        List<TableRef> newTableRefList = Lists.newArrayList();\n+        newTableRefList.add(inlineViewRef);\n+        FromClause newFromClause = new FromClause(newTableRefList);\n+        SelectStmt result = new SelectStmt(newSelectList, newFromClause, newWherePredicate, null, null, null,\n+                LimitElement.NO_LIMIT);", "originalCommit": "df4ea36c2bcb7f56e095b8095b7bd470a863c466", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f40c631927ecfc5326249a4ec60170dcff20f88b", "url": "https://github.com/apache/incubator-doris/commit/f40c631927ecfc5326249a4ec60170dcff20f88b", "message": "Add assert number of rows element in binary predicates", "committedDate": "2020-03-20T09:39:30Z", "type": "commit"}, {"oid": "dad963bfdb9e7531ffed00723926d48066ed8ace", "url": "https://github.com/apache/incubator-doris/commit/dad963bfdb9e7531ffed00723926d48066ed8ace", "message": "Support non-correlated subquery in having clause\n\nThis commit support the non-correlated subquery in having clause.\nFor example:\nselect k1, sum(k2) from table group by k1 having sum(k2) > (select avg(k1) from table)\n\nAlso the non-scalar subquery is supportted in Doris.\nFor example:\nselect k1, sum(k2) from table group by k1 having sum(k2) > (select avg(k1) from table group by k2)\nDoris will check the result row numbers of subquery in executing.\nIf more then one row returned by subquery, the query will thrown exception.\n\nThe implement method:\nThe entire outer query is regarded as inline view of new query.\nThe subquery in having clause is changed to the where predicate in this new query.\n\nAfter this commit, tpc-ds 23,24,44 are supported.\n\nThis commit also support the subquery in ArithmeticExpr.\nFor example:\nselect k1  from table where k1=0.9*(select k1 from t);", "committedDate": "2020-03-20T09:39:30Z", "type": "commit"}, {"oid": "13c8799f01e4b8cb423698c0eface113c846abef", "url": "https://github.com/apache/incubator-doris/commit/13c8799f01e4b8cb423698c0eface113c846abef", "message": "Move order by and limit into outer query", "committedDate": "2020-03-20T09:39:30Z", "type": "commit"}, {"oid": "1581b3df31710ca8041737a32f056ecb8c2ea3cc", "url": "https://github.com/apache/incubator-doris/commit/1581b3df31710ca8041737a32f056ecb8c2ea3cc", "message": "Fix ut", "committedDate": "2020-03-20T10:14:50Z", "type": "commit"}, {"oid": "1581b3df31710ca8041737a32f056ecb8c2ea3cc", "url": "https://github.com/apache/incubator-doris/commit/1581b3df31710ca8041737a32f056ecb8c2ea3cc", "message": "Fix ut", "committedDate": "2020-03-20T10:14:50Z", "type": "forcePushed"}, {"oid": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "url": "https://github.com/apache/incubator-doris/commit/bf7c45aa22580ddf4859d7ff1812ed4482a74108", "message": "Fix ut", "committedDate": "2020-03-23T02:09:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NTIxMQ==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396195211", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if children has subquery, it will be written and reanalyzed in the future.\n          \n          \n            \n                    // if children has subquery, it will be rewritten and reanalyzed in the future.", "author": "morningman", "createdAt": "2020-03-23T03:18:37Z", "path": "fe/src/main/java/org/apache/doris/analysis/ArithmeticExpr.java", "diffHunk": "@@ -231,6 +231,12 @@ public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n             return;\n         }\n \n+        analyzeSubqueryInChildren();\n+        // if children has subquery, it will be written and reanalyzed in the future.", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NTczMg==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396195732", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if children has subquery, it will be written and reanalyzed in the future.\n          \n          \n            \n                    // if children has subquery, it will be rewritten and reanalyzed in the future.", "author": "morningman", "createdAt": "2020-03-23T03:21:13Z", "path": "fe/src/main/java/org/apache/doris/analysis/BinaryPredicate.java", "diffHunk": "@@ -313,14 +314,30 @@ public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         super.analyzeImpl(analyzer);\n \n         for (Expr expr : children) {\n-            if (expr instanceof Subquery && !((Subquery) expr).returnsScalarColumn()) {\n-                String msg = \"Subquery of binary predicate must return a single column: \" + expr.toSql();\n-                throw new AnalysisException(msg);\n+            if (expr instanceof Subquery) {\n+                Subquery subquery = (Subquery) expr;\n+                if (!subquery.returnsScalarColumn()) {\n+                    String msg = \"Subquery of binary predicate must return a single column: \" + expr.toSql();\n+                    throw new AnalysisException(msg);\n+                }\n+                /**\n+                 * Situation: The expr is a binary predicate and the type of subquery is not scalar type.\n+                 * Add assert: The stmt of subquery is added an assert condition (return error if row count > 1).\n+                 * Input params:\n+                 *     expr: k1=(select k1 from t2)\n+                 *     subquery stmt: select k1 from t2\n+                 * Output params:\n+                 *     new expr: k1 = (select k1 from t2 (assert row count: return error if row count > 1 ))\n+                 *     subquery stmt: select k1 from t2 (assert row count: return error if row count > 1 )\n+                 */\n+                if (!subquery.getType().isScalarType()) {\n+                    subquery.getStatement().setAssertNumRowsElement(1);\n+                }\n             }\n         }\n \n         // if children has subquery, it will be written and reanalyzed in the future.", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NzI4OA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396197288", "bodyText": "Better to use a new local variable and return it. Not to return a parameter variable.\nAnd I think you can just return here.\nreturn rewriteQueryStatement(analyzedStmt, analyzer);", "author": "morningman", "createdAt": "2020-03-23T03:30:03Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -43,47 +45,52 @@\n      * Rewrite the statement of an analysis result. The unanalyzed rewritten\n      * statement is returned.\n      */\n-    public static void rewrite(Analyzer analyzer, StatementBase parsedStmt)\n+    public static StatementBase rewrite(Analyzer analyzer, StatementBase parsedStmt)\n             throws AnalysisException {\n         if (parsedStmt instanceof QueryStmt) {\n             QueryStmt analyzedStmt = (QueryStmt) parsedStmt;\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            parsedStmt = rewriteQueryStatement(analyzedStmt, analyzer);", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NzUyNQ==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396197525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stmt = rewriteSelectStatement((SelectStmt) stmt, analyzer);\n          \n          \n            \n                        return rewriteSelectStatement((SelectStmt) stmt, analyzer);", "author": "morningman", "createdAt": "2020-03-23T03:31:01Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -43,47 +45,52 @@\n      * Rewrite the statement of an analysis result. The unanalyzed rewritten\n      * statement is returned.\n      */\n-    public static void rewrite(Analyzer analyzer, StatementBase parsedStmt)\n+    public static StatementBase rewrite(Analyzer analyzer, StatementBase parsedStmt)\n             throws AnalysisException {\n         if (parsedStmt instanceof QueryStmt) {\n             QueryStmt analyzedStmt = (QueryStmt) parsedStmt;\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            parsedStmt = rewriteQueryStatement(analyzedStmt, analyzer);\n         } else if (parsedStmt instanceof InsertStmt) {\n             final InsertStmt insertStmt = (InsertStmt)parsedStmt;\n             final QueryStmt analyzedStmt = (QueryStmt)insertStmt.getQueryStmt();\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(analyzedStmt, analyzer);\n+            insertStmt.setQueryStmt(rewrittenQueryStmt);\n         } else {\n             throw new AnalysisException(\"Unsupported statement containing subqueries: \"\n                     + parsedStmt.toSql());\n         }\n+        return parsedStmt;\n     }\n \n   /**\n    *  Calls the appropriate rewrite method based on the specific type of query stmt. See\n    *  rewriteSelectStatement() and rewriteUnionStatement() documentation.\n    */\n-    public static void rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n+    public static QueryStmt rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n         Preconditions.checkNotNull(stmt);\n         if (stmt instanceof SelectStmt) {\n-            rewriteSelectStatement((SelectStmt) stmt, analyzer);\n+            stmt = rewriteSelectStatement((SelectStmt) stmt, analyzer);", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5ODA0OA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396198048", "bodyText": "Not returning the parameter, use local variable instead.", "author": "morningman", "createdAt": "2020-03-23T03:33:43Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -97,8 +104,142 @@ private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             }\n             rewriteWhereClauseSubqueries(stmt, analyzer);\n         }\n+        // Rewrite all subquery in the having clause\n+        if (stmt.getHavingPred() != null && stmt.getHavingPred().getSubquery() != null) {\n+            stmt = rewriteHavingClauseSubqueries(stmt, analyzer);\n+        }\n         stmt.sqlString_ = null;\n         if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        return stmt;", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMDEyNQ==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396200125", "bodyText": "How about adding a final stmt? Is that\nselect cs_item_sk, a.sum_cs_sales_price from\n(select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\njoin\n(select b.cs_item_sk, min(cs_sales_price) from catalog_sales b group by cs_item_sk) c\nwhere c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min(cs_sales_price);", "author": "morningman", "createdAt": "2020-03-23T03:45:14Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -97,8 +104,142 @@ private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             }\n             rewriteWhereClauseSubqueries(stmt, analyzer);\n         }\n+        // Rewrite all subquery in the having clause\n+        if (stmt.getHavingPred() != null && stmt.getHavingPred().getSubquery() != null) {\n+            stmt = rewriteHavingClauseSubqueries(stmt, analyzer);\n+        }\n         stmt.sqlString_ = null;\n         if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        return stmt;\n+    }\n+\n+    /**\n+     * Rewrite having subquery.\n+     * Step1: rewrite having subquery to where subquery\n+     * Step2: rewrite where subquery\n+     * <p>\n+     * For example:\n+     * select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk\n+     * having sum(cs_sales_price) >\n+     *        (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+     * <p>\n+     * Step1: rewrite having subquery to where subquery\n+     * Outer query is changed to inline view in rewritten query\n+     * Inline view of outer query:\n+     *     from (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     * Rewritten subquery of expr:\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * Rewritten query:\n+     *     select cs_item_sk, a.sum_cs_sales_price from\n+     *     (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * <p>\n+     * Step2: rewrite where subquery\n+     * Inline view of subquery:\n+     *     from (select b.cs_item_sk, min(cs_sales_price) from catalog_sales b group by cs_item_sk) c\n+     * Rewritten correlated predicate:\n+     *     where c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min(cs_sales_price)", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMDg2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396200869", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"The final stmt is \" + result.toSql());\n          \n          \n            \n                    LOG.debug(\"The final stmt is \" + result.toSql());", "author": "morningman", "createdAt": "2020-03-23T03:49:06Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -97,8 +104,142 @@ private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             }\n             rewriteWhereClauseSubqueries(stmt, analyzer);\n         }\n+        // Rewrite all subquery in the having clause\n+        if (stmt.getHavingPred() != null && stmt.getHavingPred().getSubquery() != null) {\n+            stmt = rewriteHavingClauseSubqueries(stmt, analyzer);\n+        }\n         stmt.sqlString_ = null;\n         if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        return stmt;\n+    }\n+\n+    /**\n+     * Rewrite having subquery.\n+     * Step1: rewrite having subquery to where subquery\n+     * Step2: rewrite where subquery\n+     * <p>\n+     * For example:\n+     * select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk\n+     * having sum(cs_sales_price) >\n+     *        (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+     * <p>\n+     * Step1: rewrite having subquery to where subquery\n+     * Outer query is changed to inline view in rewritten query\n+     * Inline view of outer query:\n+     *     from (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     * Rewritten subquery of expr:\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * Rewritten query:\n+     *     select cs_item_sk, a.sum_cs_sales_price from\n+     *     (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * <p>\n+     * Step2: rewrite where subquery\n+     * Inline view of subquery:\n+     *     from (select b.cs_item_sk, min(cs_sales_price) from catalog_sales b group by cs_item_sk) c\n+     * Rewritten correlated predicate:\n+     *     where c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min(cs_sales_price)\n+     *\n+     * @param stmt\n+     * @param analyzer\n+     */\n+    private static SelectStmt rewriteHavingClauseSubqueries(SelectStmt stmt, Analyzer analyzer) throws AnalysisException {\n+        // extract having predicate\n+        Expr havingPredicate = stmt.getHavingPred();\n+        Preconditions.checkState(havingPredicate != null);\n+        Preconditions.checkState(havingPredicate.getSubquery() != null);\n+        // extract limit\n+        long limit = stmt.getLimit();\n+        // extract order by element\n+        ArrayList<OrderByElement> orderByElements = stmt.getOrderByElements();\n+        // extract result of stmt\n+        List<Expr> leftExprList = stmt.getResultExprs();\n+        // extract table alias generator\n+        TableAliasGenerator tableAliasGenerator = stmt.getTableAliasGenerator();\n+\n+        /*\n+         * The outer query is changed to inline view without having predicate\n+         * For example:\n+         * Query: select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk having ...;\n+         * Inline view:\n+         *     from (select cs_item_sk $ColumnA, sum(cs_sales_price) $ColumnB from catalog_sales a group by cs_item_sk) $TableA\n+         */\n+        SelectStmt inlineViewQuery = (SelectStmt) stmt.clone();\n+        inlineViewQuery.reset();\n+        // the having, order by and limit should be move to outer query\n+        inlineViewQuery.removeHavingClause();\n+        inlineViewQuery.removeOrderByElements();\n+        inlineViewQuery.removeLimitElement();\n+        // add a new alias for all of columns in subquery\n+        List<String> colAliasOfInlineView = Lists.newArrayList();\n+        for (int i = 0; i < inlineViewQuery.getSelectList().getItems().size(); ++i) {\n+            colAliasOfInlineView.add(inlineViewQuery.getColumnAliasGenerator().getNextAlias());\n+        }\n+        InlineViewRef inlineViewRef = new InlineViewRef(tableAliasGenerator.getNextAlias(), inlineViewQuery,\n+                colAliasOfInlineView);\n+        try {\n+            inlineViewRef.analyze(analyzer);\n+        } catch (UserException e) {\n+            throw new AnalysisException(e.getMessage());\n+        }\n+        LOG.debug(\"Outer query is changed to \" + inlineViewRef.tableRefToSql());\n+\n+        /*\n+         * Columns which belong to outer query can substitute for output columns of inline view\n+         * For example:\n+         * Having predicate: sum(cs_sales_price) >\n+         *                   (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+         * Order by: sum(cs_sales_price), a.cs_item_sk\n+         * Columns which belong to outer query: sum(cs_sales_price), a.cs_item_sk\n+         * SMap: <cs_item_sk $ColumnA> <sum(cs_sales_price) $ColumnB>\n+         * After substitute: $ColumnB >\n+         *                   (select min(cs_sales_price) from catalog_sales b where $ColumnA = b.cs_item_sk)\n+         * Order by: $ColumnB, $ColumnA\n+         */\n+        /*\n+         * Prepare select list of new query.\n+         * Generate a new select item for each original columns in select list\n+         */\n+        ExprSubstitutionMap smap = new ExprSubstitutionMap();\n+        SelectList newSelectList = new SelectList();\n+        for (int i = 0; i < inlineViewQuery.getSelectList().getItems().size(); i++) {\n+            Expr leftExpr = leftExprList.get(i);\n+            Expr rightExpr = new SlotRef(inlineViewRef.getAliasAsName(), colAliasOfInlineView.get(i));\n+            rightExpr.analyze(analyzer);\n+            smap.put(leftExpr, rightExpr);\n+            // construct outer query select list\n+            SelectListItem selectListItem = new SelectListItem(rightExpr, stmt.getColLabels().get(i));\n+            newSelectList.addItem(selectListItem);\n+        }\n+        havingPredicate.reset();\n+        Expr newWherePredicate = havingPredicate.substitute(smap, analyzer,false);\n+        LOG.debug(\"Having predicate is changed to \" + newWherePredicate.toSql());\n+        ArrayList<OrderByElement> newOrderByElements = null;\n+        if (orderByElements != null) {\n+            newOrderByElements = OrderByElement.substitute(orderByElements, smap, analyzer);\n+            LOG.debug(\"Order by is changed to \" + Joiner.on(\",\").join(newOrderByElements));\n+        }\n+\n+        // construct rewritten query\n+        List<TableRef> newTableRefList = Lists.newArrayList();\n+        newTableRefList.add(inlineViewRef);\n+        FromClause newFromClause = new FromClause(newTableRefList);\n+        SelectStmt result = new SelectStmt(newSelectList, newFromClause, newWherePredicate, null, null,\n+                newOrderByElements, new LimitElement(limit));\n+        result.setTableAliasGenerator(tableAliasGenerator);\n+        try {\n+            result.analyze(analyzer);\n+        } catch (UserException e) {\n+            throw new AnalysisException(e.getMessage());\n+        }\n+        LOG.info(\"New stmt {} is constructed after rewritten subquery of having clause.\", result.toSql());\n+\n+        // rewrite where subquery\n+        result = rewriteSelectStatement(result, analyzer);\n+        LOG.info(\"The final stmt is \" + result.toSql());", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMTI1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r396201257", "bodyText": "Add this case to the queryPlanTest to reduce the running time of FE ut.\nAnd how about adding more tests to cover this case? such as query with limit ?\nAnd could you add the final rewritten stmt in comment:\nselect empid, x from\n(select empid, sum(salary) x from tbl group by empid) v\nwhere v.x > (select avg(salary) from tbl);", "author": "morningman", "createdAt": "2020-03-23T03:51:19Z", "path": "fe/src/test/java/org/apache/doris/analysis/StmtRewriterTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.analysis;\n+\n+import org.apache.doris.common.FeConstants;\n+import org.apache.doris.utframe.DorisAssert;\n+import org.apache.doris.utframe.UtFrameUtils;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.UUID;\n+\n+public class StmtRewriterTest {\n+\n+    private static String baseDir = \"fe\";\n+    private static String runningDir = baseDir + \"/mocked/StmtRewriterTest/\"\n+            + UUID.randomUUID().toString() + \"/\";\n+    private static final String TABLE_NAME = \"table1\";\n+    private static final String DB_NAME = \"db1\";\n+    private static DorisAssert dorisAssert;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception{\n+        FeConstants.runningUnitTest = true;\n+        UtFrameUtils.createMinDorisCluster(runningDir);\n+        dorisAssert = new DorisAssert();\n+        dorisAssert.withDatabase(DB_NAME).useDatabase(DB_NAME);\n+        String createTableSQL = \"create table \" + DB_NAME + \".\" + TABLE_NAME + \" (empid int, name varchar, \" +\n+                \"deptno int, salary int, commission int) \"\n+                + \"distributed by hash(empid) buckets 3 properties('replication_num' = '1');\";\n+        dorisAssert.withTable(createTableSQL);\n+    }\n+\n+    @Test\n+    public void testRewriteHavingClauseSubqueries() throws Exception {", "originalCommit": "bf7c45aa22580ddf4859d7ff1812ed4482a74108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "665f69e4d96250ce813c18d592e747d94f0b4c4e", "url": "https://github.com/apache/incubator-doris/commit/665f69e4d96250ce813c18d592e747d94f0b4c4e", "message": "Update fe/src/main/java/org/apache/doris/analysis/BinaryPredicate.java\n\nCo-Authored-By: Mingyu Chen <morningman.cmy@gmail.com>", "committedDate": "2020-03-23T10:56:58Z", "type": "commit"}, {"oid": "ea1c2b0f46624b46bdbcd67b0c0fe16a75fcac1e", "url": "https://github.com/apache/incubator-doris/commit/ea1c2b0f46624b46bdbcd67b0c0fe16a75fcac1e", "message": "Update fe/src/main/java/org/apache/doris/analysis/ArithmeticExpr.java\n\nCo-Authored-By: Mingyu Chen <morningman.cmy@gmail.com>", "committedDate": "2020-03-23T11:07:09Z", "type": "commit"}, {"oid": "be86912ee67ed8b07c2f6259893ddf1dc7944130", "url": "https://github.com/apache/incubator-doris/commit/be86912ee67ed8b07c2f6259893ddf1dc7944130", "message": "Add commit of ut", "committedDate": "2020-03-23T11:37:48Z", "type": "commit"}, {"oid": "745a1f6853c7a28c6097147b23b096bdb0f761cd", "url": "https://github.com/apache/incubator-doris/commit/745a1f6853c7a28c6097147b23b096bdb0f761cd", "message": "Merge branch 'subquery_in_having' of https://github.com/EmmyMiao87/incubator-doris into subquery_in_having", "committedDate": "2020-03-23T11:38:43Z", "type": "commit"}, {"oid": "866e075f2dcebcb4069ac638082546c66c588a65", "url": "https://github.com/apache/incubator-doris/commit/866e075f2dcebcb4069ac638082546c66c588a65", "message": "Substitute order by", "committedDate": "2020-03-24T09:47:06Z", "type": "commit"}, {"oid": "d069b5cbe86f2737411a76f018eadca5b9ee8a5e", "url": "https://github.com/apache/incubator-doris/commit/d069b5cbe86f2737411a76f018eadca5b9ee8a5e", "message": "Fix error", "committedDate": "2020-03-24T11:05:12Z", "type": "commit"}, {"oid": "469662c3a201c28492cbafaa8d86d023fd354013", "url": "https://github.com/apache/incubator-doris/commit/469662c3a201c28492cbafaa8d86d023fd354013", "message": "Fix error", "committedDate": "2020-03-24T11:11:23Z", "type": "commit"}, {"oid": "7efe3750910ad80fdbfef307df21406f3ac13ab4", "url": "https://github.com/apache/incubator-doris/commit/7efe3750910ad80fdbfef307df21406f3ac13ab4", "message": "Fix error", "committedDate": "2020-03-24T11:20:40Z", "type": "commit"}, {"oid": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "url": "https://github.com/apache/incubator-doris/commit/b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "message": "Fix error", "committedDate": "2020-03-24T12:41:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNTc3Ng==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397235776", "bodyText": "why you add \u201cthis instanceof BinaryPredicate \u201d\uff1f\nonly slotref has override isBoundByTupleIds function.", "author": "wutiangan", "createdAt": "2020-03-24T15:19:38Z", "path": "fe/src/main/java/org/apache/doris/analysis/Expr.java", "diffHunk": "@@ -1462,6 +1462,18 @@ public Subquery getSubquery() {\n         return subqueries.get(0);\n     }\n \n+    public boolean isCorrelatedPredicate(List<TupleId> tupleIdList) {\n+        if ((this instanceof BinaryPredicate || this instanceof SlotRef) && !this.isBoundByTupleIds(tupleIdList)) {\n+            return true;\n+        }", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NTE3NA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397245174", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // this parameter: having sum(t.k2) > 1\n          \n          \n            \n                // this parameter:  sum(t.k2) > 1", "author": "wutiangan", "createdAt": "2020-03-24T15:31:33Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -95,13 +95,21 @@\n     // if we have grouping extensions like cube or rollup or grouping sets\n     private GroupingInfo groupingInfo;\n \n+    // having clause which has been analyzed\n+    // For example: select k1, sum(k2) a from t group by k1 having a>1;\n+    // this parameter: having sum(t.k2) > 1", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDA2MA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397250060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                         * TODO(ml): support substitute outer column in subquery\n          \n          \n            \n                         * TODO(ml): support substitute outer column in correlated subquery", "author": "wutiangan", "createdAt": "2020-03-24T15:37:44Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -839,19 +861,32 @@ private Expr rewriteCountDistinctForBitmapOrHLL(Expr expr, Analyzer analyzer) {\n     private void analyzeAggregation(Analyzer analyzer) throws AnalysisException {\n         // check having clause\n         if (havingClause != null) {\n-            if (havingClause.contains(Predicates.instanceOf(Subquery.class))) {\n-                throw new AnalysisException(\n-                        \"Subqueries are not supported in the HAVING clause.\");\n-            }\n             Expr ambiguousAlias = getFirstAmbiguousAlias(havingClause);\n             if (ambiguousAlias != null) {\n                 ErrorReport.reportAnalysisException(ErrorCode.ERR_NON_UNIQ_ERROR, ambiguousAlias.toColumnLabel());\n             }\n-            // substitute aliases in place (ordinals not allowed in having clause)\n-            havingPred = havingClause.substitute(aliasSMap, analyzer, false);\n-            havingPred.checkReturnsBool(\"HAVING clause\", true);\n+            /*\n+             * The having clause need to be substitute by aliasSMap.\n+             * And it is analyzed after substitute.\n+             * For example:\n+             * Query: select k1 a, sum(k2) b from table group by k1 having a > 1;\n+             * Having clause: a > 1\n+             * aliasSMap: <a, table.k1> <b, sum(table.k2)>\n+             * After substitute: a > 1 changed to table.k1 > 1\n+             * Analyzer: check column and other subquery in having clause\n+             * having predicate: table.k1 > 1\n+             */\n+            /*\n+             * TODO(ml): support substitute outer column in subquery", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1NTMzNA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397255334", "bodyText": "why do you add FunctionCall to decorate sum(SlotRef(k2))\uff1fAnd There is no function at below \u201cAfter rewritten\u201d \u3002", "author": "wutiangan", "createdAt": "2020-03-24T15:44:21Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -974,16 +1009,24 @@ private void analyzeAggregation(Analyzer analyzer) throws AnalysisException {\n             LOG.debug(\"desctbl: \" + analyzer.getDescTbl().debugString());\n             LOG.debug(\"resultexprs: \" + Expr.debugString(resultExprs));\n         }\n+        /*\n+         * All of columns of result and having clause are replaced by new slot ref which is bound by top tuple of agg info.\n+         * For example:\n+         * ResultExprs: SlotRef(k1), FunctionCall(sum(SlotRef(k2)))", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NTgwOA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397575808", "bodyText": "Em...The \"after rewritten\" is mean that after Expr.substitueList  as following. This commit is used to analyze what happen with this line resultExprs = Expr.substituteList(resultExprs, combinedSmap, analyzer, false);", "author": "EmmyMiao87", "createdAt": "2020-03-25T02:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1NTMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTI3NQ==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397259275", "bodyText": "why do you only analyze where clause\uff1f what other clasue\uff1ffor example having clasue\uff0cselectList\u3002", "author": "wutiangan", "createdAt": "2020-03-24T15:49:11Z", "path": "fe/src/main/java/org/apache/doris/analysis/SelectStmt.java", "diffHunk": "@@ -1438,6 +1476,22 @@ public boolean returnsSingleRow() {\n         return false;\n     }\n \n+    @Override\n+    public boolean containsCorrelatedPredicate() {\n+        // check inline view\n+        for (TableRef tableRef : fromClause_.getTableRefs()) {\n+            if (tableRef instanceof InlineViewRef) {\n+                if (((InlineViewRef) tableRef).getViewStmt().containsCorrelatedPredicate()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        if (whereClause == null) {\n+            return false;\n+        }\n+        return whereClause.isCorrelatedPredicate(getTableRefIds());", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3Njk2Nw==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397576967", "bodyText": "This function has been removed.", "author": "EmmyMiao87", "createdAt": "2020-03-25T02:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1OTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2MzYyMA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397263620", "bodyText": "what\u2018s the difference between 70 line and 74 line \uff1f why 70 line add return\uff0c and 74 line not return\uff1f", "author": "wutiangan", "createdAt": "2020-03-24T15:54:37Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -43,62 +44,260 @@\n      * Rewrite the statement of an analysis result. The unanalyzed rewritten\n      * statement is returned.\n      */\n-    public static void rewrite(Analyzer analyzer, StatementBase parsedStmt)\n+    public static StatementBase rewrite(Analyzer analyzer, StatementBase parsedStmt)\n             throws AnalysisException {\n         if (parsedStmt instanceof QueryStmt) {\n             QueryStmt analyzedStmt = (QueryStmt) parsedStmt;\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            return rewriteQueryStatement(analyzedStmt, analyzer);\n         } else if (parsedStmt instanceof InsertStmt) {\n             final InsertStmt insertStmt = (InsertStmt)parsedStmt;\n             final QueryStmt analyzedStmt = (QueryStmt)insertStmt.getQueryStmt();\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(analyzedStmt, analyzer);\n+            insertStmt.setQueryStmt(rewrittenQueryStmt);\n         } else {\n             throw new AnalysisException(\"Unsupported statement containing subqueries: \"\n                     + parsedStmt.toSql());\n         }\n+        return parsedStmt;\n     }\n \n   /**\n    *  Calls the appropriate rewrite method based on the specific type of query stmt. See\n    *  rewriteSelectStatement() and rewriteUnionStatement() documentation.\n    */\n-    public static void rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n+    public static QueryStmt rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n         Preconditions.checkNotNull(stmt);\n         if (stmt instanceof SelectStmt) {\n-            rewriteSelectStatement((SelectStmt) stmt, analyzer);\n+            return rewriteSelectStatement((SelectStmt) stmt, analyzer);\n         } else if (stmt instanceof SetOperationStmt) {\n             rewriteUnionStatement((SetOperationStmt) stmt, analyzer);", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NzI0NA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397577244", "bodyText": "The rewriteUnionStatement is a function without return parameters.", "author": "EmmyMiao87", "createdAt": "2020-03-25T02:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2MzYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MzE5NA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397273194", "bodyText": "you\u2019d better add \u201ccorelated having subqueries are not supported\u201d here\u3002", "author": "wutiangan", "createdAt": "2020-03-24T16:06:34Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -43,62 +44,260 @@\n      * Rewrite the statement of an analysis result. The unanalyzed rewritten\n      * statement is returned.\n      */\n-    public static void rewrite(Analyzer analyzer, StatementBase parsedStmt)\n+    public static StatementBase rewrite(Analyzer analyzer, StatementBase parsedStmt)\n             throws AnalysisException {\n         if (parsedStmt instanceof QueryStmt) {\n             QueryStmt analyzedStmt = (QueryStmt) parsedStmt;\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            return rewriteQueryStatement(analyzedStmt, analyzer);\n         } else if (parsedStmt instanceof InsertStmt) {\n             final InsertStmt insertStmt = (InsertStmt)parsedStmt;\n             final QueryStmt analyzedStmt = (QueryStmt)insertStmt.getQueryStmt();\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(analyzedStmt, analyzer);\n+            insertStmt.setQueryStmt(rewrittenQueryStmt);\n         } else {\n             throw new AnalysisException(\"Unsupported statement containing subqueries: \"\n                     + parsedStmt.toSql());\n         }\n+        return parsedStmt;\n     }\n \n   /**\n    *  Calls the appropriate rewrite method based on the specific type of query stmt. See\n    *  rewriteSelectStatement() and rewriteUnionStatement() documentation.\n    */\n-    public static void rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n+    public static QueryStmt rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n         Preconditions.checkNotNull(stmt);\n         if (stmt instanceof SelectStmt) {\n-            rewriteSelectStatement((SelectStmt) stmt, analyzer);\n+            return rewriteSelectStatement((SelectStmt) stmt, analyzer);\n         } else if (stmt instanceof SetOperationStmt) {\n             rewriteUnionStatement((SetOperationStmt) stmt, analyzer);\n         } else {\n             throw new AnalysisException(\"Subqueries not supported for \"\n                     + stmt.getClass().getSimpleName() + \" statements\");\n         }\n+        return stmt;\n     }\n \n-    private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n+    private static SelectStmt rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n+        SelectStmt result = stmt;\n         // Rewrite all the subqueries in the FROM clause.\n-        for (TableRef tblRef: stmt.fromClause_) {\n+        for (TableRef tblRef: result.fromClause_) {\n             if (!(tblRef instanceof InlineViewRef)) continue;\n             InlineViewRef inlineViewRef = (InlineViewRef)tblRef;\n-            rewriteQueryStatement(inlineViewRef.getViewStmt(), inlineViewRef.getAnalyzer());\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(inlineViewRef.getViewStmt(),\n+                    inlineViewRef.getAnalyzer());\n+            inlineViewRef.setViewStmt(rewrittenQueryStmt);\n         }\n         // Rewrite all the subqueries in the WHERE clause.\n-        if (stmt.hasWhereClause()) {\n+        if (result.hasWhereClause()) {\n             // Push negation to leaf operands.\n-            stmt.whereClause = Expr.pushNegationToOperands(stmt.whereClause);\n+            result.whereClause = Expr.pushNegationToOperands(result.whereClause);\n             // Check if we can rewrite the subqueries in the WHERE clause. OR predicates with\n             // subqueries are not supported.\n-            if (hasSubqueryInDisjunction(stmt.whereClause)) {\n+            if (hasSubqueryInDisjunction(result.whereClause)) {\n                 throw new AnalysisException(\"Subqueries in OR predicates are not supported: \"\n-                        + stmt.whereClause.toSql());\n+                        + result.whereClause.toSql());\n             }\n-            rewriteWhereClauseSubqueries(stmt, analyzer);\n+            rewriteWhereClauseSubqueries(result, analyzer);\n         }\n-        stmt.sqlString_ = null;\n-        if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        // Rewrite all subquery in the having clause\n+        if (result.getHavingPred() != null && result.getHavingPred().getSubquery() != null) {\n+            result = rewriteHavingClauseSubqueries(result, analyzer);\n+        }\n+        result.sqlString_ = null;\n+        if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + result.toSql());\n+        return result;\n+    }\n+\n+    /**", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3NDAxNw==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397274017", "bodyText": "Inline view does not need to write the \u2018from\u2019 keyword", "author": "wutiangan", "createdAt": "2020-03-24T16:07:42Z", "path": "fe/src/main/java/org/apache/doris/analysis/StmtRewriter.java", "diffHunk": "@@ -43,62 +44,260 @@\n      * Rewrite the statement of an analysis result. The unanalyzed rewritten\n      * statement is returned.\n      */\n-    public static void rewrite(Analyzer analyzer, StatementBase parsedStmt)\n+    public static StatementBase rewrite(Analyzer analyzer, StatementBase parsedStmt)\n             throws AnalysisException {\n         if (parsedStmt instanceof QueryStmt) {\n             QueryStmt analyzedStmt = (QueryStmt) parsedStmt;\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            return rewriteQueryStatement(analyzedStmt, analyzer);\n         } else if (parsedStmt instanceof InsertStmt) {\n             final InsertStmt insertStmt = (InsertStmt)parsedStmt;\n             final QueryStmt analyzedStmt = (QueryStmt)insertStmt.getQueryStmt();\n             Preconditions.checkNotNull(analyzedStmt.analyzer);\n-            rewriteQueryStatement(analyzedStmt, analyzer);\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(analyzedStmt, analyzer);\n+            insertStmt.setQueryStmt(rewrittenQueryStmt);\n         } else {\n             throw new AnalysisException(\"Unsupported statement containing subqueries: \"\n                     + parsedStmt.toSql());\n         }\n+        return parsedStmt;\n     }\n \n   /**\n    *  Calls the appropriate rewrite method based on the specific type of query stmt. See\n    *  rewriteSelectStatement() and rewriteUnionStatement() documentation.\n    */\n-    public static void rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n+    public static QueryStmt rewriteQueryStatement(QueryStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n         Preconditions.checkNotNull(stmt);\n         if (stmt instanceof SelectStmt) {\n-            rewriteSelectStatement((SelectStmt) stmt, analyzer);\n+            return rewriteSelectStatement((SelectStmt) stmt, analyzer);\n         } else if (stmt instanceof SetOperationStmt) {\n             rewriteUnionStatement((SetOperationStmt) stmt, analyzer);\n         } else {\n             throw new AnalysisException(\"Subqueries not supported for \"\n                     + stmt.getClass().getSimpleName() + \" statements\");\n         }\n+        return stmt;\n     }\n \n-    private static void rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n+    private static SelectStmt rewriteSelectStatement(SelectStmt stmt, Analyzer analyzer)\n             throws AnalysisException {\n+        SelectStmt result = stmt;\n         // Rewrite all the subqueries in the FROM clause.\n-        for (TableRef tblRef: stmt.fromClause_) {\n+        for (TableRef tblRef: result.fromClause_) {\n             if (!(tblRef instanceof InlineViewRef)) continue;\n             InlineViewRef inlineViewRef = (InlineViewRef)tblRef;\n-            rewriteQueryStatement(inlineViewRef.getViewStmt(), inlineViewRef.getAnalyzer());\n+            QueryStmt rewrittenQueryStmt = rewriteQueryStatement(inlineViewRef.getViewStmt(),\n+                    inlineViewRef.getAnalyzer());\n+            inlineViewRef.setViewStmt(rewrittenQueryStmt);\n         }\n         // Rewrite all the subqueries in the WHERE clause.\n-        if (stmt.hasWhereClause()) {\n+        if (result.hasWhereClause()) {\n             // Push negation to leaf operands.\n-            stmt.whereClause = Expr.pushNegationToOperands(stmt.whereClause);\n+            result.whereClause = Expr.pushNegationToOperands(result.whereClause);\n             // Check if we can rewrite the subqueries in the WHERE clause. OR predicates with\n             // subqueries are not supported.\n-            if (hasSubqueryInDisjunction(stmt.whereClause)) {\n+            if (hasSubqueryInDisjunction(result.whereClause)) {\n                 throw new AnalysisException(\"Subqueries in OR predicates are not supported: \"\n-                        + stmt.whereClause.toSql());\n+                        + result.whereClause.toSql());\n             }\n-            rewriteWhereClauseSubqueries(stmt, analyzer);\n+            rewriteWhereClauseSubqueries(result, analyzer);\n         }\n-        stmt.sqlString_ = null;\n-        if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + stmt.toSql());\n+        // Rewrite all subquery in the having clause\n+        if (result.getHavingPred() != null && result.getHavingPred().getSubquery() != null) {\n+            result = rewriteHavingClauseSubqueries(result, analyzer);\n+        }\n+        result.sqlString_ = null;\n+        if (LOG.isDebugEnabled()) LOG.debug(\"rewritten stmt: \" + result.toSql());\n+        return result;\n+    }\n+\n+    /**\n+     * Rewrite having subquery.\n+     * Step1: rewrite having subquery to where subquery\n+     * Step2: rewrite where subquery\n+     * <p>\n+     * For example:\n+     * select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk\n+     * having sum(cs_sales_price) >\n+     *        (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk);\n+     * <p>\n+     * Step1: rewrite having subquery to where subquery\n+     * Outer query is changed to inline view in rewritten query\n+     * Inline view of outer query:\n+     *     from (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     * Rewritten subquery of expr:\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * Rewritten query:\n+     *     select cs_item_sk, a.sum_cs_sales_price from\n+     *     (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     *     where a.sum_cs_sales_price >\n+     *           (select min(cs_sales_price) from catalog_sales b where a.cs_item_sk = b.cs_item_sk)\n+     * <p>\n+     * Step2: rewrite where subquery\n+     * Inline view of subquery:\n+     *     from (select b.cs_item_sk, min(cs_sales_price) from catalog_sales b group by cs_item_sk) c\n+     * Rewritten correlated predicate:\n+     *     where c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min(cs_sales_price)\n+     * The final stmt:\n+     * select a.cs_item_sk, a.sum_cs_sales_price from\n+     *     (select cs_item_sk, sum(cs_sales_price) sum_cs_sales_price from catalog_sales group by cs_item_sk) a\n+     *     join\n+     *     (select b.cs_item_sk, min(b.cs_sales_price) min_cs_sales_price from catalog_sales b group by b.cs_item_sk) c\n+     * where c.cs_item_sk = a.cs_item_sk and a.sum_cs_sales_price > c.min_cs_sales_price;\n+     *\n+     * @param stmt\n+     * @param analyzer\n+     */\n+    private static SelectStmt rewriteHavingClauseSubqueries(SelectStmt stmt, Analyzer analyzer) throws AnalysisException {\n+        // prepare parameters\n+        SelectList selectList = stmt.getSelectList();\n+        List<String> columnLables = stmt.getColLabels();\n+        Expr havingClause = stmt.getHavingClauseAfterAnaylzed();\n+        List<FunctionCallExpr> aggregateExprs = stmt.getAggInfo().getAggregateExprs();\n+        Preconditions.checkState(havingClause != null);\n+        Preconditions.checkState(havingClause.getSubquery() != null);\n+        List<OrderByElement> orderByElements = stmt.getOrderByElementsAfterAnalyzed();\n+        long limit = stmt.getLimit();\n+        TableAliasGenerator tableAliasGenerator = stmt.getTableAliasGenerator();\n+\n+        /*\n+         * The outer query is changed to inline view without having predicate\n+         * For example:\n+         * Query: select cs_item_sk, sum(cs_sales_price) from catalog_sales a group by cs_item_sk having ...;\n+         * Inline view:\n+         *     from (select cs_item_sk $ColumnA, sum(cs_sales_price) $ColumnB from catalog_sales a group by cs_item_sk) $TableA", "originalCommit": "b31a9ee2d4a5fce35b8fc237a66a1f03bbdbd8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3Nzg4NA==", "url": "https://github.com/apache/incubator-doris/pull/3150#discussion_r397577884", "bodyText": "I am afraid of missing understanding.", "author": "EmmyMiao87", "createdAt": "2020-03-25T02:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3NDAxNw=="}], "type": "inlineReview"}, {"oid": "726c078a08575ddecf10f8427588b158f8ac509f", "url": "https://github.com/apache/incubator-doris/commit/726c078a08575ddecf10f8427588b158f8ac509f", "message": "Remove is correlated predicate function in query stmt", "committedDate": "2020-03-25T03:22:52Z", "type": "commit"}]}