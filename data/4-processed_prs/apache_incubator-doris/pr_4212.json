{"pr_number": 4212, "pr_title": "Compaction rules optimization", "pr_createdAt": "2020-07-30T05:04:08Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4212", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MDAyNw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r462750027", "bodyText": "ordinary and universal  naming both meaningless and general, we need a concrete and intuitive naming. You could refer to HBase.", "author": "kangkaisen", "createdAt": "2020-07-30T05:49:29Z", "path": "be/src/common/config.h", "diffHunk": "@@ -265,6 +265,27 @@ namespace config {\n     CONF_mInt64(base_compaction_interval_seconds_since_last_operation, \"86400\");\n     CONF_mInt32(base_compaction_write_mbytes_per_sec, \"5\");\n \n+    // config the cumulative compaction policy\n+    // Valid configs: ordinary, universal", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MDIyNw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r462750227", "bodyText": "would better mark class final.", "author": "kangkaisen", "createdAt": "2020-07-30T05:50:12Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param kInvalidCumulativePoint, the value to represent whether the cumulative point is initialized\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            const int64_t kInvalidCumulativePoint,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    Tablet* _tablet;\n+};\n+\n+/// Original cumulative compcation policy implemention. Original policy which derives CumulativeCompactionPolicy is early \n+/// basic algorithm. This policy uses linear structure to compact rowsets. The cumulative rowsets compact only once and \n+/// then the output will do base compaction. It can make segments of rowsets in order and compact small rowsets to a bigger one.\n+class OriginalCumulativeCompactionPolicy : public CumulativeCompactionPolicy {", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MDgxMg==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r462750812", "bodyText": "We prefer return std::unique_ptr from factory method.", "author": "kangkaisen", "createdAt": "2020-07-30T05:52:10Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param kInvalidCumulativePoint, the value to represent whether the cumulative point is initialized\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            const int64_t kInvalidCumulativePoint,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    Tablet* _tablet;\n+};\n+\n+/// Original cumulative compcation policy implemention. Original policy which derives CumulativeCompactionPolicy is early \n+/// basic algorithm. This policy uses linear structure to compact rowsets. The cumulative rowsets compact only once and \n+/// then the output will do base compaction. It can make segments of rowsets in order and compact small rowsets to a bigger one.\n+class OriginalCumulativeCompactionPolicy : public CumulativeCompactionPolicy {\n+    \n+public:\n+    /// Constructor function of OriginalCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    OriginalCumulativeCompactionPolicy(Tablet* tablet)\n+            : CumulativeCompactionPolicy(tablet){}\n+\n+    /// Destructor function of OriginalCumulativeCompactionPolicy.\n+    ~OriginalCumulativeCompactionPolicy() {}\n+\n+    /// Original cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score and\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset.\n+    int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// Original cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is using the last input version to update the cumulative point. It aims that every rowsets only \n+    /// do compact once.\n+    void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset,\n+                                 Version& last_delete_version) override;\n+\n+    /// Original cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which is segments_overlapping type, it represent this rowset is not compacted and use this version as cumulative point. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                     const int64_t kInvalidCumulativePoint,\n+                                     int64_t current_cumulative_point,\n+                                     int64_t* cumulative_point) override;\n+\n+    /// Original cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+};\n+\n+/// Universal cumulative compcation policy implemention. Universal policy which derives CumulativeCompactionPolicy is a optimized\n+/// version of Original cumulative compcation policy. This policy alos uses linear structure to compact rowsets. The cumulative rowsets \n+/// can do compaction when they are in same level size. And when output rowset exceeds the promotion radio of base size or min promotion\n+/// size, it will do base compaction. This policy is targeting the use cases requiring lower write amplification, trading off read \n+/// amplification and space amplification.\n+class UniversalCumulativeCompactionPolicy : public CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of UniversalCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method.\n+    /// param tablet, the shared pointer of tablet \n+    UniversalCumulativeCompactionPolicy(\n+            Tablet* tablet,\n+            int64_t universal_promotion_size =\n+                    config::cumulative_compaction_universal_promotion_size_mbytes * 1024 * 1024,\n+            double universal_promotion_ratio =\n+                    config::cumulative_compaction_universal_promotion_ratio,\n+            int64_t universal_promotion_min_size =\n+                    config::cumulative_compaction_universal_promotion_min_size_mbytes * 1024 * 1024,\n+            int64_t universal_compaction_lower_bound_size =\n+                    config::cumulative_compaction_universal_compaction_lower_bound_size_mbytes * 1024 * 1024);\n+    \n+    /// Destructor function of UniversalCumulativeCompactionPolicy.\n+    ~UniversalCumulativeCompactionPolicy() {}\n+\n+    /// Universal cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which does not satifie the promotion conditions. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                    const int64_t kInvalidCumulativePoint,\n+                                    int64_t current_cumulative_point,\n+                                    int64_t* cumulative_point) override;\n+\n+    /// Universal cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score,\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset,\n+    /// and choose those rowset in the same level to do cumulative compaction.\n+    int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// Universal cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is judging the output rowset size whether satifies the promotion size.\n+    /// If it satified, this policy will update the cumulative point.\n+    void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset, Version& last_delete_version);\n+\n+    /// Original cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+private:\n+    /// calculate promotion size using current base rowset meta size and promition configs\n+    void _calc_promotion_size(RowsetMetaSharedPtr base_rowset_meta, int64_t* promotion_size);\n+\n+    /// calculate the disk size belong to which level, the level is divide by power of 2\n+    /// between cumulative_compaction_universal_promotion_min_size_mbytes\n+    /// and cumulative_compaction_universal_promotion_size_mbytes\n+    int _level_size(const int64_t size);\n+\n+    /// when policy calcalute cumulative_compaction_score, update promotion size at the same time\n+    void _refresh_tablet_universal_promotion_size(int64_t promotion_size);\n+\n+private:\n+    /// cumulative compaction promotion size, unit is byte.\n+    int64_t _universal_promotion_size;\n+    /// cumulative compaction promotion ratio of base rowset total disk size.\n+    double _universal_promotion_ratio;\n+    /// cumulative compaction promotion min size, unit is byte.\n+    int64_t _universal_promotion_min_size;\n+    /// lower bound size to do compaction compaction.\n+    int64_t _universal_compaction_lower_bound_size;\n+    /// record tablet promotion size, it is updated each time when calculate cumulative_compaction_score \n+    int64_t _tablet_universal_promotion_size;\n+    /// levels division of disk size, same level rowsets can do compaction\n+    std::vector<int64_t> _levels;\n+};\n+\n+/// The factory of CumulativeCompactionPolicy, it can product diffrent policy according to the `policy` parameter.\n+class CumulativeCompactionPolicyFactory {\n+\n+public:\n+    /// Static factory function. It can product diffrent policy according to the `policy` parameter and use tablet ptr \n+    /// to construct the policy. Now it can product universal and original policies.\n+    static std::shared_ptr<CumulativeCompactionPolicy> create_cumulative_compaction_policy(", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0Nzc3MQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465747771", "bodyText": "Is raw pointer safe here? Why not using shared ptr?", "author": "morningman", "createdAt": "2020-08-05T14:00:07Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0OTgxNw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465749817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n          \n          \n            \n                /// This base class gives a unified implementation. Its derived classes also can override this function each other.", "author": "morningman", "createdAt": "2020-08-05T14:03:04Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDM5MA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465750390", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n          \n          \n            \n                        const std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,", "author": "morningman", "createdAt": "2020-08-05T14:03:51Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MTUxNA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465751514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n          \n          \n            \n                virtual int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,", "author": "morningman", "createdAt": "2020-08-05T14:05:23Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MjEzNg==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465752136", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n          \n          \n            \n                virtual void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,", "author": "morningman", "createdAt": "2020-08-05T14:06:11Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MzM5OA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465753398", "bodyText": "kInvalidCumulativePoint, this param name is weird.", "author": "morningman", "createdAt": "2020-08-05T14:08:03Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param kInvalidCumulativePoint, the value to represent whether the cumulative point is initialized\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            const int64_t kInvalidCumulativePoint,", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1OTM1Mg==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465759352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /// version of Original cumulative compcation policy. This policy alos uses linear structure to compact rowsets. The cumulative rowsets \n          \n          \n            \n            /// version of Original cumulative compaction policy. This policy also uses linear structure to compact rowsets. The cumulative rowsets", "author": "morningman", "createdAt": "2020-08-05T14:16:09Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_ORIGINAL_POLICY and CUMULATIVE_UNIVERSAL_POLICY.\n+/// CUMULATIVE_ORIGINAL_POLICY means current compaction policy implemented by original policy.\n+/// CUMULATIVE_UNIVERSAL_POLICY means current comapction policy implemented by universal policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_ORIGINAL_POLICY = 0,\n+    CUMULATIVE_UNIVERSAL_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_ORIGINAL_POLICY_TYPE = \"ORIGINAL\";\n+const static std::string CUMULATIVE_UNIVERSAL_POLICY_TYPE = \"UNIVERSAL\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(Tablet* tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implemention. Its derived classes also can overide this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param kInvalidCumulativePoint, the value to represent whether the cumulative point is initialized\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            const int64_t kInvalidCumulativePoint,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    Tablet* _tablet;\n+};\n+\n+/// Original cumulative compcation policy implemention. Original policy which derives CumulativeCompactionPolicy is early \n+/// basic algorithm. This policy uses linear structure to compact rowsets. The cumulative rowsets compact only once and \n+/// then the output will do base compaction. It can make segments of rowsets in order and compact small rowsets to a bigger one.\n+class OriginalCumulativeCompactionPolicy : public CumulativeCompactionPolicy {\n+    \n+public:\n+    /// Constructor function of OriginalCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    OriginalCumulativeCompactionPolicy(Tablet* tablet)\n+            : CumulativeCompactionPolicy(tablet){}\n+\n+    /// Destructor function of OriginalCumulativeCompactionPolicy.\n+    ~OriginalCumulativeCompactionPolicy() {}\n+\n+    /// Original cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score and\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset.\n+    int pick_input_rowsets(std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// Original cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is using the last input version to update the cumulative point. It aims that every rowsets only \n+    /// do compact once.\n+    void update_cumulative_point(std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset,\n+                                 Version& last_delete_version) override;\n+\n+    /// Original cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which is segments_overlapping type, it represent this rowset is not compacted and use this version as cumulative point. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                     const int64_t kInvalidCumulativePoint,\n+                                     int64_t current_cumulative_point,\n+                                     int64_t* cumulative_point) override;\n+\n+    /// Original cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+};\n+\n+/// Universal cumulative compcation policy implemention. Universal policy which derives CumulativeCompactionPolicy is a optimized\n+/// version of Original cumulative compcation policy. This policy alos uses linear structure to compact rowsets. The cumulative rowsets ", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2MjEwMA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465762100", "bodyText": "This check should be done when starting BE process.", "author": "morningman", "createdAt": "2020-08-05T14:19:51Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NDI0Nw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465764247", "bodyText": "kInvalidCumulativePoint can be a const static field, no need to be an input param", "author": "morningman", "createdAt": "2020-08-05T14:22:38Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2ODg5NQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465768895", "bodyText": "how to make sure that the first rowset is the base rowset which version is start from 0?\nI suggest to add a check.", "author": "morningman", "createdAt": "2020-08-05T14:28:49Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,\n+        int64_t current_cumulative_point, int64_t* ret_cumulative_point) {\n+\n+    *ret_cumulative_point = kInvalidCumulativePoint;\n+    if (current_cumulative_point != kInvalidCumulativePoint) {\n+        // only calculate the point once.\n+        // after that, cumulative point will be updated along with compaction process.\n+        return;\n+    }\n+    // empty return\n+    if (all_metas.empty()) {\n+        return;\n+    }\n+\n+    std::list<RowsetMetaSharedPtr> existing_rss;\n+    for (auto& rs : all_metas) {\n+        existing_rss.emplace_back(rs);\n+    }\n+\n+    // sort the existing rowsets by version in ascending order\n+    existing_rss.sort([](const RowsetMetaSharedPtr& a, const RowsetMetaSharedPtr& b) {\n+        // simple because 2 versions are certainly not overlapping\n+        return a->version().first < b->version().first;\n+    });\n+\n+    // calculate promotion size\n+    auto base_rowset_meta = existing_rss.begin();", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3MDYwOQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465770609", "bodyText": "Continue if the singletion rowset is a delete version?", "author": "morningman", "createdAt": "2020-08-05T14:31:13Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,\n+        int64_t current_cumulative_point, int64_t* ret_cumulative_point) {\n+\n+    *ret_cumulative_point = kInvalidCumulativePoint;\n+    if (current_cumulative_point != kInvalidCumulativePoint) {\n+        // only calculate the point once.\n+        // after that, cumulative point will be updated along with compaction process.\n+        return;\n+    }\n+    // empty return\n+    if (all_metas.empty()) {\n+        return;\n+    }\n+\n+    std::list<RowsetMetaSharedPtr> existing_rss;\n+    for (auto& rs : all_metas) {\n+        existing_rss.emplace_back(rs);\n+    }\n+\n+    // sort the existing rowsets by version in ascending order\n+    existing_rss.sort([](const RowsetMetaSharedPtr& a, const RowsetMetaSharedPtr& b) {\n+        // simple because 2 versions are certainly not overlapping\n+        return a->version().first < b->version().first;\n+    });\n+\n+    // calculate promotion size\n+    auto base_rowset_meta = existing_rss.begin();\n+    int64_t promotion_size = 0;\n+    _calc_promotion_size(*base_rowset_meta, &promotion_size);\n+\n+    int64_t prev_version = -1;\n+    for (const RowsetMetaSharedPtr& rs : existing_rss) {\n+        if (rs->version().first > prev_version + 1) {\n+            // There is a hole, do not continue\n+            break;\n+        }\n+\n+        // break the loop if segments in this rowset is overlapping, or is a singleton.\n+        if (rs->is_segments_overlapping() || rs->is_singleton_delta()) {", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3Mjc2OA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465772768", "bodyText": "There may be hundreds of thousands of tablets on a BE, which will cause too many logs.", "author": "morningman", "createdAt": "2020-08-05T14:34:19Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,\n+        int64_t current_cumulative_point, int64_t* ret_cumulative_point) {\n+\n+    *ret_cumulative_point = kInvalidCumulativePoint;\n+    if (current_cumulative_point != kInvalidCumulativePoint) {\n+        // only calculate the point once.\n+        // after that, cumulative point will be updated along with compaction process.\n+        return;\n+    }\n+    // empty return\n+    if (all_metas.empty()) {\n+        return;\n+    }\n+\n+    std::list<RowsetMetaSharedPtr> existing_rss;\n+    for (auto& rs : all_metas) {\n+        existing_rss.emplace_back(rs);\n+    }\n+\n+    // sort the existing rowsets by version in ascending order\n+    existing_rss.sort([](const RowsetMetaSharedPtr& a, const RowsetMetaSharedPtr& b) {\n+        // simple because 2 versions are certainly not overlapping\n+        return a->version().first < b->version().first;\n+    });\n+\n+    // calculate promotion size\n+    auto base_rowset_meta = existing_rss.begin();\n+    int64_t promotion_size = 0;\n+    _calc_promotion_size(*base_rowset_meta, &promotion_size);\n+\n+    int64_t prev_version = -1;\n+    for (const RowsetMetaSharedPtr& rs : existing_rss) {\n+        if (rs->version().first > prev_version + 1) {\n+            // There is a hole, do not continue\n+            break;\n+        }\n+\n+        // break the loop if segments in this rowset is overlapping, or is a singleton.\n+        if (rs->is_segments_overlapping() || rs->is_singleton_delta()) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        // check the rowset is whether less than promotion size\n+        if (rs->version().first != 0 && rs->total_disk_size() < promotion_size) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        prev_version = rs->version().second;\n+        *ret_cumulative_point = prev_version + 1;\n+    }\n+    LOG(INFO) << \"cumulative compaction universal policy, calculate cumulative point value = \"", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3NDMzMQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465774331", "bodyText": "What is the difference between _tablet_universal_promotion_size and the promotion_size calculated in method _calc_promotion_size()?", "author": "morningman", "createdAt": "2020-08-05T14:36:31Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,\n+        int64_t current_cumulative_point, int64_t* ret_cumulative_point) {\n+\n+    *ret_cumulative_point = kInvalidCumulativePoint;\n+    if (current_cumulative_point != kInvalidCumulativePoint) {\n+        // only calculate the point once.\n+        // after that, cumulative point will be updated along with compaction process.\n+        return;\n+    }\n+    // empty return\n+    if (all_metas.empty()) {\n+        return;\n+    }\n+\n+    std::list<RowsetMetaSharedPtr> existing_rss;\n+    for (auto& rs : all_metas) {\n+        existing_rss.emplace_back(rs);\n+    }\n+\n+    // sort the existing rowsets by version in ascending order\n+    existing_rss.sort([](const RowsetMetaSharedPtr& a, const RowsetMetaSharedPtr& b) {\n+        // simple because 2 versions are certainly not overlapping\n+        return a->version().first < b->version().first;\n+    });\n+\n+    // calculate promotion size\n+    auto base_rowset_meta = existing_rss.begin();\n+    int64_t promotion_size = 0;\n+    _calc_promotion_size(*base_rowset_meta, &promotion_size);\n+\n+    int64_t prev_version = -1;\n+    for (const RowsetMetaSharedPtr& rs : existing_rss) {\n+        if (rs->version().first > prev_version + 1) {\n+            // There is a hole, do not continue\n+            break;\n+        }\n+\n+        // break the loop if segments in this rowset is overlapping, or is a singleton.\n+        if (rs->is_segments_overlapping() || rs->is_singleton_delta()) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        // check the rowset is whether less than promotion size\n+        if (rs->version().first != 0 && rs->total_disk_size() < promotion_size) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        prev_version = rs->version().second;\n+        *ret_cumulative_point = prev_version + 1;\n+    }\n+    LOG(INFO) << \"cumulative compaction universal policy, calculate cumulative point value = \"\n+              << *ret_cumulative_point << \", calc promotion size value = \" << promotion_size\n+              << \" tablet = \" << _tablet->full_name();\n+}\n+\n+void UniversalCumulativeCompactionPolicy::_calc_promotion_size(RowsetMetaSharedPtr base_rowset_meta,\n+                                                               int64_t* promotion_size) {\n+    int64_t base_size = base_rowset_meta->total_disk_size();\n+    *promotion_size = base_size * _universal_promotion_ratio;\n+\n+    // promotion_size is between _universal_promotion_size and _universal_promotion_min_size\n+    if (*promotion_size >= _universal_promotion_size) {\n+        *promotion_size = _universal_promotion_size;\n+    } else if (*promotion_size <= _universal_promotion_min_size) {\n+        *promotion_size = _universal_promotion_min_size;\n+    }\n+    _refresh_tablet_universal_promotion_size(*promotion_size);\n+}\n+\n+void UniversalCumulativeCompactionPolicy::_refresh_tablet_universal_promotion_size(\n+        int64_t promotion_size) {\n+    _tablet_universal_promotion_size = promotion_size;\n+}\n+\n+void UniversalCumulativeCompactionPolicy::update_cumulative_point(\n+        std::vector<RowsetSharedPtr>& input_rowsets, RowsetSharedPtr output_rowset,\n+        Version& last_delete_version) {\n+\n+    // if rowsets have delete version, move to the last directly\n+    if (last_delete_version.first != -1) {\n+        _tablet->set_cumulative_layer_point(output_rowset->end_version() + 1);\n+    } else {\n+        // if rowsets have not delete version, check output_rowset total disk size \n+        // satisfies promotion size.\n+        size_t total_size = output_rowset->rowset_meta()->total_disk_size();\n+        if (total_size >= _tablet_universal_promotion_size) {", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3NzcxMw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465777713", "bodyText": "better use end_version() here to check?", "author": "morningman", "createdAt": "2020-08-05T14:41:14Z", "path": "be/src/olap/cumulative_compaction_policy.cpp", "diffHunk": "@@ -0,0 +1,469 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+\n+#include \"olap/cumulative_compaction_policy.h\"\n+#include \"util/time.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+\n+namespace doris {\n+\n+UniversalCumulativeCompactionPolicy::UniversalCumulativeCompactionPolicy(\n+        Tablet* tablet, int64_t universal_promotion_size, double universal_promotion_ratio,\n+        int64_t universal_promotion_min_size, int64_t universal_compaction_lower_bound_size)\n+        : CumulativeCompactionPolicy(tablet),\n+          _universal_promotion_size(universal_promotion_size),\n+          _universal_promotion_ratio(universal_promotion_ratio),\n+          _universal_promotion_min_size(universal_promotion_min_size),\n+          _universal_compaction_lower_bound_size(universal_compaction_lower_bound_size) {\n+\n+    // check universal_promotion_size must be greater than universal_promotion_min_size\n+    CHECK(universal_promotion_size >= universal_promotion_min_size);\n+    // check universal_promotion_size must be greater than universal_compaction_lower_bound_size twice \n+    CHECK(universal_promotion_size >= 2 * universal_compaction_lower_bound_size);\n+\n+    // init _levels by divide 2 between universal_promotion_size and universal_compaction_lower_bound_size\n+    int64_t i_size = universal_promotion_size / 2;\n+\n+    while (i_size >= universal_compaction_lower_bound_size) {\n+        _levels.push_back(i_size);\n+        i_size /= 2;\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calculate_cumulative_point(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, const int64_t kInvalidCumulativePoint,\n+        int64_t current_cumulative_point, int64_t* ret_cumulative_point) {\n+\n+    *ret_cumulative_point = kInvalidCumulativePoint;\n+    if (current_cumulative_point != kInvalidCumulativePoint) {\n+        // only calculate the point once.\n+        // after that, cumulative point will be updated along with compaction process.\n+        return;\n+    }\n+    // empty return\n+    if (all_metas.empty()) {\n+        return;\n+    }\n+\n+    std::list<RowsetMetaSharedPtr> existing_rss;\n+    for (auto& rs : all_metas) {\n+        existing_rss.emplace_back(rs);\n+    }\n+\n+    // sort the existing rowsets by version in ascending order\n+    existing_rss.sort([](const RowsetMetaSharedPtr& a, const RowsetMetaSharedPtr& b) {\n+        // simple because 2 versions are certainly not overlapping\n+        return a->version().first < b->version().first;\n+    });\n+\n+    // calculate promotion size\n+    auto base_rowset_meta = existing_rss.begin();\n+    int64_t promotion_size = 0;\n+    _calc_promotion_size(*base_rowset_meta, &promotion_size);\n+\n+    int64_t prev_version = -1;\n+    for (const RowsetMetaSharedPtr& rs : existing_rss) {\n+        if (rs->version().first > prev_version + 1) {\n+            // There is a hole, do not continue\n+            break;\n+        }\n+\n+        // break the loop if segments in this rowset is overlapping, or is a singleton.\n+        if (rs->is_segments_overlapping() || rs->is_singleton_delta()) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        // check the rowset is whether less than promotion size\n+        if (rs->version().first != 0 && rs->total_disk_size() < promotion_size) {\n+            *ret_cumulative_point = rs->version().first;\n+            break;\n+        }\n+\n+        prev_version = rs->version().second;\n+        *ret_cumulative_point = prev_version + 1;\n+    }\n+    LOG(INFO) << \"cumulative compaction universal policy, calculate cumulative point value = \"\n+              << *ret_cumulative_point << \", calc promotion size value = \" << promotion_size\n+              << \" tablet = \" << _tablet->full_name();\n+}\n+\n+void UniversalCumulativeCompactionPolicy::_calc_promotion_size(RowsetMetaSharedPtr base_rowset_meta,\n+                                                               int64_t* promotion_size) {\n+    int64_t base_size = base_rowset_meta->total_disk_size();\n+    *promotion_size = base_size * _universal_promotion_ratio;\n+\n+    // promotion_size is between _universal_promotion_size and _universal_promotion_min_size\n+    if (*promotion_size >= _universal_promotion_size) {\n+        *promotion_size = _universal_promotion_size;\n+    } else if (*promotion_size <= _universal_promotion_min_size) {\n+        *promotion_size = _universal_promotion_min_size;\n+    }\n+    _refresh_tablet_universal_promotion_size(*promotion_size);\n+}\n+\n+void UniversalCumulativeCompactionPolicy::_refresh_tablet_universal_promotion_size(\n+        int64_t promotion_size) {\n+    _tablet_universal_promotion_size = promotion_size;\n+}\n+\n+void UniversalCumulativeCompactionPolicy::update_cumulative_point(\n+        std::vector<RowsetSharedPtr>& input_rowsets, RowsetSharedPtr output_rowset,\n+        Version& last_delete_version) {\n+\n+    // if rowsets have delete version, move to the last directly\n+    if (last_delete_version.first != -1) {\n+        _tablet->set_cumulative_layer_point(output_rowset->end_version() + 1);\n+    } else {\n+        // if rowsets have not delete version, check output_rowset total disk size \n+        // satisfies promotion size.\n+        size_t total_size = output_rowset->rowset_meta()->total_disk_size();\n+        if (total_size >= _tablet_universal_promotion_size) {\n+            _tablet->set_cumulative_layer_point(output_rowset->end_version() + 1);\n+        }\n+    }\n+}\n+\n+void UniversalCumulativeCompactionPolicy::calc_cumulative_compaction_score(\n+        const std::vector<RowsetMetaSharedPtr>& all_metas, int64_t current_cumulative_point,\n+        uint32_t* score) {\n+\n+    bool base_rowset_exist = false;\n+    const int64_t point = current_cumulative_point;\n+    int64_t promotion_size = 0;\n+    \n+    std::vector<RowsetMetaSharedPtr> rowset_to_compact;\n+    int64_t total_size = 0;\n+\n+    // check the base rowset and collect the rowsets of cumulative part \n+    auto rs_meta_iter = all_metas.begin();\n+    for (; rs_meta_iter != all_metas.end(); rs_meta_iter++) {\n+        auto rs_meta = *rs_meta_iter;\n+        // check base rowset\n+        if (rs_meta->start_version() == 0) {\n+            base_rowset_exist = true;\n+            _calc_promotion_size(rs_meta, &promotion_size);\n+        }\n+        if (rs_meta->start_version() < point) {", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MzMwMw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465793303", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           std::string cumulative_compaction_type) :\n          \n          \n            \n                           const std::string& cumulative_compaction_type) :", "author": "morningman", "createdAt": "2020-08-05T15:02:08Z", "path": "be/src/olap/tablet.cpp", "diffHunk": "@@ -53,14 +53,16 @@ TabletSharedPtr Tablet::create_tablet_from_meta(TabletMetaSharedPtr tablet_meta,\n     return std::make_shared<Tablet>(tablet_meta, data_dir);\n }\n \n-Tablet::Tablet(TabletMetaSharedPtr tablet_meta, DataDir* data_dir) :\n+Tablet::Tablet(TabletMetaSharedPtr tablet_meta, DataDir* data_dir,\n+               std::string cumulative_compaction_type) :", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NTM3Mw==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r465795373", "bodyText": "These compaction config is not mutable at runtime because you init the compaction policy only once when initializing the tablet. So modify these configs makes no effect at runtime.\nBut I think we should find a way to make it mutable at runtime.", "author": "morningman", "createdAt": "2020-08-05T15:04:59Z", "path": "be/src/common/config.h", "diffHunk": "@@ -265,6 +265,27 @@ namespace config {\n     CONF_mInt64(base_compaction_interval_seconds_since_last_operation, \"86400\");\n     CONF_mInt32(base_compaction_write_mbytes_per_sec, \"5\");\n \n+    // config the cumulative compaction policy\n+    // Valid configs: ordinary, universal\n+    // ordinary policy, the original version of cumulative compaction, cumulative version compaction once.\n+    // universal policy, a optimization version of cumulative compaction, targeting the use cases requiring \n+    // lower write amplification, trading off read amplification and space amplification.\n+    CONF_String(cumulative_compaction_policy, \"original\");\n+\n+    // In universal policy, output rowset of cumulative compaction total disk size exceed this config size, \n+    // this rowset will be given to base compaction, unit is m byte.\n+    CONF_mInt64(cumulative_compaction_universal_promotion_size_mbytes, \"1024\");", "originalCommit": "54817b98e938a6c1d09d083bd7c27257911ad7eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "345d2b41c1510de0a99d01972b181011fb7c8711", "url": "https://github.com/apache/incubator-doris/commit/345d2b41c1510de0a99d01972b181011fb7c8711", "message": "compaction_rules_optimization", "committedDate": "2020-08-06T06:46:31Z", "type": "forcePushed"}, {"oid": "3c3d44140590f83685f5872c9a994c7fc7167d96", "url": "https://github.com/apache/incubator-doris/commit/3c3d44140590f83685f5872c9a994c7fc7167d96", "message": "compaction_rules_optimization", "committedDate": "2020-08-07T02:06:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4ODgxMg==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471988812", "bodyText": "those config was too can we make it more shorter", "author": "yangzhg", "createdAt": "2020-08-18T07:57:54Z", "path": "be/src/common/config.h", "diffHunk": "@@ -265,6 +265,27 @@ namespace config {\n     CONF_mInt64(base_compaction_interval_seconds_since_last_operation, \"86400\");\n     CONF_mInt32(base_compaction_write_mbytes_per_sec, \"5\");\n \n+    // config the cumulative compaction policy\n+    // Valid configs: num_base, size_based\n+    // num_based policy, the original version of cumulative compaction, cumulative version compaction once.\n+    // size_based policy, a optimization version of cumulative compaction, targeting the use cases requiring \n+    // lower write amplification, trading off read amplification and space amplification.\n+    CONF_String(cumulative_compaction_policy, \"num_based\");\n+\n+    // In size_based policy, output rowset of cumulative compaction total disk size exceed this config size, \n+    // this rowset will be given to base compaction, unit is m byte.\n+    CONF_mInt64(cumulative_compaction_size_based_promotion_size_mbytes, \"1024\");\n+    // In size_based policy, output rowset of cumulative compaction total disk size exceed this config ratio of\n+    // base rowset's total disk size, this rowset will be given to base compaction. The value must be between \n+    // 0 and 1.\n+    CONF_mDouble(cumulative_compaction_size_based_promotion_ratio, \"0.05\");\n+    // In size_based policy, the smallest size of rowset promotion. When the rowset is less than this config, this \n+    // rowset will be not given to base compaction. The unit is m byte.\n+    CONF_mInt64(cumulative_compaction_size_based_promotion_min_size_mbytes, \"64\");\n+    // The lower bound size to do cumulative compaction. When total disk size of candidate rowsets is less than \n+    // this size, size_based policy also does cumulative compaction. The unit is m byte.\n+    CONF_mInt64(cumulative_compaction_size_based_compaction_lower_bound_size_mbytes, \"64\");", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MDQ0MA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471990440", "bodyText": "I think Policy and Type is duplicated in meaning", "author": "yangzhg", "createdAt": "2020-08-18T08:00:36Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MTIxMQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471991211", "bodyText": "you can  use NUM_BASED directly, CUMULATIVE is in the class name, POLICY is in the enum name", "author": "yangzhg", "createdAt": "2020-08-18T08:02:01Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MjUyMQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471992521", "bodyText": "same problem as above", "author": "yangzhg", "createdAt": "2020-08-18T08:04:26Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,\n+    CUMULATIVE_SIZE_BASED_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_NUM_BASED_POLICY_TYPE = \"NUM_BASED\";\n+const static std::string CUMULATIVE_SIZE_BASED_POLICY_TYPE = \"SIZE_BASED\";", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MzE1Mg==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471993152", "bodyText": "why  use /// ?", "author": "yangzhg", "createdAt": "2020-08-18T08:05:32Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,\n+    CUMULATIVE_SIZE_BASED_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_NUM_BASED_POLICY_TYPE = \"NUM_BASED\";\n+const static std::string CUMULATIVE_SIZE_BASED_POLICY_TYPE = \"SIZE_BASED\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e74e08a3014e682c8e3e8764d7bc6ac405be7b39", "url": "https://github.com/apache/incubator-doris/commit/e74e08a3014e682c8e3e8764d7bc6ac405be7b39", "message": "Fix alter schema add key column bug in agg module", "committedDate": "2020-08-18T08:06:51Z", "type": "commit"}, {"oid": "8b399e51829adf8c1bf89c65e7998dede18021a2", "url": "https://github.com/apache/incubator-doris/commit/8b399e51829adf8c1bf89c65e7998dede18021a2", "message": "Fix alter schema add key column bug in agg model", "committedDate": "2020-08-18T08:06:51Z", "type": "commit"}, {"oid": "c82ffdccb8556b73aa8b98b115cfea38090ebfbf", "url": "https://github.com/apache/incubator-doris/commit/c82ffdccb8556b73aa8b98b115cfea38090ebfbf", "message": "Fix alter schema add key column bug in agg model", "committedDate": "2020-08-18T08:06:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5NDQ4NA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471994484", "bodyText": "OLAP_CUMULATIVE_COMPACTION_POLICY_H is enough", "author": "yangzhg", "createdAt": "2020-08-18T08:07:51Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,\n+    CUMULATIVE_SIZE_BASED_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_NUM_BASED_POLICY_TYPE = \"NUM_BASED\";\n+const static std::string CUMULATIVE_SIZE_BASED_POLICY_TYPE = \"SIZE_BASED\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(std::shared_ptr<Tablet> tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implementation. Its derived classes also can override this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            const std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    std::shared_ptr<Tablet> _tablet;\n+};\n+\n+/// Num based cumulative compcation policy implemention. Num based policy which derives CumulativeCompactionPolicy is early \n+/// basic algorithm. This policy uses linear structure to compact rowsets. The cumulative rowsets compact only once and \n+/// then the output will do base compaction. It can make segments of rowsets in order and compact small rowsets to a bigger one.\n+class NumBasedCumulativeCompactionPolicy final : public CumulativeCompactionPolicy {\n+    \n+public:\n+    /// Constructor function of NumBasedCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    NumBasedCumulativeCompactionPolicy(std::shared_ptr<Tablet> tablet)\n+            : CumulativeCompactionPolicy(tablet){}\n+\n+    /// Destructor function of NumBasedCumulativeCompactionPolicy.\n+    ~NumBasedCumulativeCompactionPolicy() {}\n+\n+    /// Num based cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score and\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset.\n+    int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// Num based cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is using the last input version to update the cumulative point. It aims that every rowsets only \n+    /// do compact once.\n+    void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset,\n+                                 Version& last_delete_version) override;\n+\n+    /// Num based cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which is segments_overlapping type, it represent this rowset is not compacted and use this version as cumulative point. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                     int64_t current_cumulative_point,\n+                                     int64_t* cumulative_point) override;\n+\n+    /// Num based cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+};\n+\n+/// SizeBased cumulative compcation policy implemention. SizeBased policy which derives CumulativeCompactionPolicy is a optimized\n+/// version of num based cumulative compaction policy. This policy also uses linear structure to compact rowsets. The cumulative rowsets \n+/// can do compaction when they are in same level size. And when output rowset exceeds the promotion radio of base size or min promotion\n+/// size, it will do base compaction. This policy is targeting the use cases requiring lower write amplification, trading off read \n+/// amplification and space amplification.\n+class SizeBasedCumulativeCompactionPolicy final : public CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of SizeBasedCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method.\n+    /// param tablet, the shared pointer of tablet \n+    SizeBasedCumulativeCompactionPolicy(\n+            std::shared_ptr<Tablet> tablet,\n+            int64_t size_based_promotion_size =\n+                    config::cumulative_compaction_size_based_promotion_size_mbytes * 1024 * 1024,\n+            double size_based_promotion_ratio =\n+                    config::cumulative_compaction_size_based_promotion_ratio,\n+            int64_t size_based_promotion_min_size =\n+                    config::cumulative_compaction_size_based_promotion_min_size_mbytes * 1024 * 1024,\n+            int64_t size_based_compaction_lower_bound_size =\n+                    config::cumulative_compaction_size_based_compaction_lower_bound_size_mbytes * 1024 * 1024);\n+    \n+    /// Destructor function of SizeBasedCumulativeCompactionPolicy.\n+    ~SizeBasedCumulativeCompactionPolicy() {}\n+\n+    /// SizeBased cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which does not satifie the promotion conditions. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                    int64_t current_cumulative_point,\n+                                    int64_t* cumulative_point) override;\n+\n+    /// SizeBased cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score,\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset,\n+    /// and choose those rowset in the same level to do cumulative compaction.\n+    int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// SizeBased cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is judging the output rowset size whether satifies the promotion size.\n+    /// If it satified, this policy will update the cumulative point.\n+    void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset, Version& last_delete_version);\n+\n+    /// Num based cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+private:\n+    /// calculate promotion size using current base rowset meta size and promition configs\n+    void _calc_promotion_size(RowsetMetaSharedPtr base_rowset_meta, int64_t* promotion_size);\n+\n+    /// calculate the disk size belong to which level, the level is divide by power of 2\n+    /// between cumulative_compaction_size_based_promotion_min_size_mbytes\n+    /// and cumulative_compaction_size_based_promotion_size_mbytes\n+    int _level_size(const int64_t size);\n+\n+    /// when policy calcalute cumulative_compaction_score, update promotion size at the same time\n+    void _refresh_tablet_size_based_promotion_size(int64_t promotion_size);\n+\n+private:\n+    /// cumulative compaction promotion size, unit is byte.\n+    int64_t _size_based_promotion_size;\n+    /// cumulative compaction promotion ratio of base rowset total disk size.\n+    double _size_based_promotion_ratio;\n+    /// cumulative compaction promotion min size, unit is byte.\n+    int64_t _size_based_promotion_min_size;\n+    /// lower bound size to do compaction compaction.\n+    int64_t _size_based_compaction_lower_bound_size;\n+    /// record tablet promotion size, it is updated each time when calculate cumulative_compaction_score \n+    int64_t _tablet_size_based_promotion_size;\n+    /// levels division of disk size, same level rowsets can do compaction\n+    std::vector<int64_t> _levels;\n+};\n+\n+/// The factory of CumulativeCompactionPolicy, it can product diffrent policy according to the `policy` parameter.\n+class CumulativeCompactionPolicyFactory {\n+\n+public:\n+    /// Static factory function. It can product diffrent policy according to the `policy` parameter and use tablet ptr \n+    /// to construct the policy. Now it can product size based and num based policies.\n+    static std::unique_ptr<CumulativeCompactionPolicy> create_cumulative_compaction_policy(\n+            std::string policy, std::shared_ptr<Tablet> tablet);\n+\n+private:\n+    /// It is a static function to help to check the policy config and convert to CompactionPolicyType enum variable\n+    static void _parse_cumulative_compaction_policy(std::string policy,\n+                                                    CompactionPolicyType* policy_type);\n+};\n+\n+}\n+#endif // DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29ab6074b2fa197b143307192d6811e7f7a480d5", "url": "https://github.com/apache/incubator-doris/commit/29ab6074b2fa197b143307192d6811e7f7a480d5", "message": "Compaction_rules_optimization commit compaction configurable policy", "committedDate": "2020-08-18T08:09:40Z", "type": "commit"}, {"oid": "e21e969ed3d0b3b09a279448171e11253062b30c", "url": "https://github.com/apache/incubator-doris/commit/e21e969ed3d0b3b09a279448171e11253062b30c", "message": "Compaction_rules_optimization commit compaction universal  policy", "committedDate": "2020-08-18T08:09:42Z", "type": "commit"}, {"oid": "3efddd1547a573b07649ed7a96249911c5670103", "url": "https://github.com/apache/incubator-doris/commit/3efddd1547a573b07649ed7a96249911c5670103", "message": "Compaction_rules_optimization commit compaction universal  policy", "committedDate": "2020-08-18T08:09:42Z", "type": "commit"}, {"oid": "be4552c863f47e53bee8d47427099e4652c40b95", "url": "https://github.com/apache/incubator-doris/commit/be4552c863f47e53bee8d47427099e4652c40b95", "message": "add final", "committedDate": "2020-08-18T08:09:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5NjkzNQ==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r471996935", "bodyText": "It is better to set to min size instead of usingf check here", "author": "yangzhg", "createdAt": "2020-08-18T08:12:04Z", "path": "be/src/olap/olap_server.cpp", "diffHunk": "@@ -277,6 +281,27 @@ void* StorageEngine::_disk_stat_monitor_thread_callback(void* arg) {\n     return nullptr;\n }\n \n+void StorageEngine::_check_cumulative_compaction_config() {\n+\n+    std::string cumulative_compaction_type = config::cumulative_compaction_policy;\n+    boost::to_upper(cumulative_compaction_type);\n+\n+    // if size_based policy is used, check size_based policy configs\n+    if (cumulative_compaction_type == CUMULATIVE_SIZE_BASED_POLICY_TYPE) {\n+        int64_t size_based_promotion_size =\n+                config::cumulative_compaction_size_based_promotion_size_mbytes;\n+        int64_t size_based_promotion_min_size =\n+                config::cumulative_compaction_size_based_promotion_min_size_mbytes;\n+        int64_t size_based_compaction_lower_bound_size =\n+                config::cumulative_compaction_size_based_compaction_lower_bound_size_mbytes;\n+\n+        // check size_based_promotion_size must be greater than size_based_promotion_min_size\n+        CHECK(size_based_promotion_size >= size_based_promotion_min_size);", "originalCommit": "3c3d44140590f83685f5872c9a994c7fc7167d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8aabf6a1d6c51b8bb741efe38b42f4949a1f4b1c", "url": "https://github.com/apache/incubator-doris/commit/8aabf6a1d6c51b8bb741efe38b42f4949a1f4b1c", "message": "compaction_rules_optimization", "committedDate": "2020-08-18T08:12:10Z", "type": "commit"}, {"oid": "0d2a83b46750998cb29997bb852c789070a8d9ad", "url": "https://github.com/apache/incubator-doris/commit/0d2a83b46750998cb29997bb852c789070a8d9ad", "message": "compaction_rules_optimization", "committedDate": "2020-08-18T08:12:12Z", "type": "commit"}, {"oid": "0d2a83b46750998cb29997bb852c789070a8d9ad", "url": "https://github.com/apache/incubator-doris/commit/0d2a83b46750998cb29997bb852c789070a8d9ad", "message": "compaction_rules_optimization", "committedDate": "2020-08-18T08:12:12Z", "type": "forcePushed"}, {"oid": "57e2eb246a108647f0cfbf8b997254d521ee09b7", "url": "https://github.com/apache/incubator-doris/commit/57e2eb246a108647f0cfbf8b997254d521ee09b7", "message": "fix", "committedDate": "2020-08-18T08:55:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNjEwOA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r472006108", "bodyText": "why there is two private", "author": "yangzhg", "createdAt": "2020-08-18T08:27:12Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,\n+    CUMULATIVE_SIZE_BASED_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_NUM_BASED_POLICY_TYPE = \"NUM_BASED\";\n+const static std::string CUMULATIVE_SIZE_BASED_POLICY_TYPE = \"SIZE_BASED\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(std::shared_ptr<Tablet> tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implementation. Its derived classes also can override this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            const std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    std::shared_ptr<Tablet> _tablet;\n+};\n+\n+/// Num based cumulative compcation policy implemention. Num based policy which derives CumulativeCompactionPolicy is early \n+/// basic algorithm. This policy uses linear structure to compact rowsets. The cumulative rowsets compact only once and \n+/// then the output will do base compaction. It can make segments of rowsets in order and compact small rowsets to a bigger one.\n+class NumBasedCumulativeCompactionPolicy final : public CumulativeCompactionPolicy {\n+    \n+public:\n+    /// Constructor function of NumBasedCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    NumBasedCumulativeCompactionPolicy(std::shared_ptr<Tablet> tablet)\n+            : CumulativeCompactionPolicy(tablet){}\n+\n+    /// Destructor function of NumBasedCumulativeCompactionPolicy.\n+    ~NumBasedCumulativeCompactionPolicy() {}\n+\n+    /// Num based cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score and\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset.\n+    int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// Num based cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is using the last input version to update the cumulative point. It aims that every rowsets only \n+    /// do compact once.\n+    void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset,\n+                                 Version& last_delete_version) override;\n+\n+    /// Num based cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which is segments_overlapping type, it represent this rowset is not compacted and use this version as cumulative point. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                     int64_t current_cumulative_point,\n+                                     int64_t* cumulative_point) override;\n+\n+    /// Num based cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+};\n+\n+/// SizeBased cumulative compcation policy implemention. SizeBased policy which derives CumulativeCompactionPolicy is a optimized\n+/// version of num based cumulative compaction policy. This policy also uses linear structure to compact rowsets. The cumulative rowsets \n+/// can do compaction when they are in same level size. And when output rowset exceeds the promotion radio of base size or min promotion\n+/// size, it will do base compaction. This policy is targeting the use cases requiring lower write amplification, trading off read \n+/// amplification and space amplification.\n+class SizeBasedCumulativeCompactionPolicy final : public CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of SizeBasedCumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method.\n+    /// param tablet, the shared pointer of tablet \n+    SizeBasedCumulativeCompactionPolicy(\n+            std::shared_ptr<Tablet> tablet,\n+            int64_t size_based_promotion_size =\n+                    config::cumulative_compaction_size_based_promotion_size_mbytes * 1024 * 1024,\n+            double size_based_promotion_ratio =\n+                    config::cumulative_compaction_size_based_promotion_ratio,\n+            int64_t size_based_promotion_min_size =\n+                    config::cumulative_compaction_size_based_promotion_min_size_mbytes * 1024 * 1024,\n+            int64_t size_based_compaction_lower_bound_size =\n+                    config::cumulative_compaction_size_based_compaction_lower_bound_size_mbytes * 1024 * 1024);\n+    \n+    /// Destructor function of SizeBasedCumulativeCompactionPolicy.\n+    ~SizeBasedCumulativeCompactionPolicy() {}\n+\n+    /// SizeBased cumulative compaction policy implements calculate cumulative point function.\n+    /// When the first time the tablet does compact, this calculation is executed. Its main policy is to find first rowset\n+    /// which does not satifie the promotion conditions. \n+    void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                    int64_t current_cumulative_point,\n+                                    int64_t* cumulative_point) override;\n+\n+    /// SizeBased cumulative compaction policy implements pick input rowsets function.\n+    /// Its main policy is picking rowsets from candidate rowsets by comparing accumulative compaction_score,\n+    /// max_cumulative_compaction_num_singleton_deltas or checking whether there is delete version rowset,\n+    /// and choose those rowset in the same level to do cumulative compaction.\n+    int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                            const int64_t max_compaction_score,\n+                            const int64_t min_compaction_score,\n+                            std::vector<RowsetSharedPtr>* input_rowsets,\n+                            Version* last_delete_version, size_t* compaction_score) override;\n+\n+    /// SizeBased cumulative compaction policy implements update cumulative point function.\n+    /// Its main policy is judging the output rowset size whether satifies the promotion size.\n+    /// If it satified, this policy will update the cumulative point.\n+    void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                 RowsetSharedPtr _output_rowset, Version& last_delete_version);\n+\n+    /// Num based cumulative compaction policy implements calc cumulative compaction score function.\n+    /// Its main policy is calculating the accumulative compaction score after current cumulative_point in tablet.\n+    void calc_cumulative_compaction_score(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                          int64_t current_cumulative_point,\n+                                          uint32_t* score) override;\n+\n+private:\n+    /// calculate promotion size using current base rowset meta size and promition configs\n+    void _calc_promotion_size(RowsetMetaSharedPtr base_rowset_meta, int64_t* promotion_size);\n+\n+    /// calculate the disk size belong to which level, the level is divide by power of 2\n+    /// between cumulative_compaction_size_based_promotion_min_size_mbytes\n+    /// and cumulative_compaction_size_based_promotion_size_mbytes\n+    int _level_size(const int64_t size);\n+\n+    /// when policy calcalute cumulative_compaction_score, update promotion size at the same time\n+    void _refresh_tablet_size_based_promotion_size(int64_t promotion_size);\n+\n+private:", "originalCommit": "0d2a83b46750998cb29997bb852c789070a8d9ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNjY1MA==", "url": "https://github.com/apache/incubator-doris/pull/4212#discussion_r472006650", "bodyText": "this may be using a reference \uff1f", "author": "yangzhg", "createdAt": "2020-08-18T08:28:02Z", "path": "be/src/olap/cumulative_compaction_policy.h", "diffHunk": "@@ -0,0 +1,263 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+#define DORIS_BE_SRC_OLAP_CUMULATIVE_COMPACTION_POLICY_H\n+\n+#include <string>\n+\n+#include \"olap/utils.h\"\n+#include \"olap/tablet.h\"\n+#include \"olap/tablet_meta.h\"\n+#include \"olap/rowset/rowset_meta.h\"\n+#include \"olap/rowset/rowset.h\"\n+\n+namespace doris {\n+\n+class Tablet;\n+\n+/// This CompactionPolicyType enum is used to represent the type of compaction policy.\n+/// Now it has two values, CUMULATIVE_NUM_BASED_POLICY and CUMULATIVE_SIZE_BASED_POLICY.\n+/// CUMULATIVE_NUM_BASED_POLICY means current compaction policy implemented by num based policy.\n+/// CUMULATIVE_SIZE_BASED_POLICY means current comapction policy implemented by size_based policy.\n+enum CompactionPolicyType {\n+    CUMULATIVE_NUM_BASED_POLICY = 0,\n+    CUMULATIVE_SIZE_BASED_POLICY = 1,\n+};\n+\n+const static std::string CUMULATIVE_NUM_BASED_POLICY_TYPE = \"NUM_BASED\";\n+const static std::string CUMULATIVE_SIZE_BASED_POLICY_TYPE = \"SIZE_BASED\";\n+/// This class CumulativeCompactionPolicy is the base class of cumulative compaction policy.\n+/// It \bdefines the policy to do cumulative compaction. It has different derived classes, which implements \n+/// concrete cumulative compaction algorithm. The policy is configured by conf::cumulative_compaction_policy.\n+/// The policy functions is the main steps to do cumulative compaction. For example, how to pick candicate \n+/// rowsets from tablet using current policy, how to calculate the cumulative point and how to calculate\n+/// the tablet cumulative compcation score and so on.\n+class CumulativeCompactionPolicy {\n+\n+public:\n+    /// Constructor function of CumulativeCompactionPolicy, \n+    /// it needs tablet pointer to access tablet method. \n+    /// param tablet, the shared pointer of tablet\n+    CumulativeCompactionPolicy(std::shared_ptr<Tablet> tablet) : _tablet(tablet){}\n+\n+    /// Destructor function of CumulativeCompactionPolicy.\n+    virtual ~CumulativeCompactionPolicy() {}\n+\n+    /// Calculate the cumulative compaction score of the tablet. This function uses rowsets meta and current \n+    /// cumulative point to calculative the score of tablet. The score depends on the concrete algorithm of policy.\n+    /// In general, the score represents the segments nums to do cumulative compaction in total rowsets. The more\n+    /// score tablet gets, the earlier it can do  cumulative compaction.\n+    /// param all_rowsets, all rowsets in tablet.\n+    /// param current_cumulative_point, current cumulative point value.\n+    /// return score, the result score after calculate.\n+    virtual void calc_cumulative_compaction_score(\n+            const std::vector<RowsetMetaSharedPtr>& all_rowsets, int64_t current_cumulative_point,\n+            uint32_t* score) = 0;\n+\n+    /// This function implements the policy which represents how to pick the candicate rowsets for compaction. \n+    /// This base class gives a unified implementation. Its derived classes also can override this function each other.\n+    /// param skip_window_sec, it means skipping the rowsets which use create time plus skip_window_sec is greater than now.\n+    /// param rs_version_map, mapping from version to rowset\n+    /// param cumulative_point,  current cumulative point of tablet\n+    /// return candidate_rowsets, the container of candidate rowsets \n+    virtual void pick_candicate_rowsets(\n+            int64_t skip_window_sec,\n+            const std::unordered_map<Version, RowsetSharedPtr, HashOfVersion>& rs_version_map,\n+            int64_t cumulative_point, std::vector<RowsetSharedPtr>* candidate_rowsets);\n+    \n+    /// Pick input rowsets from candidate rowsets for compaction. This function is pure virtual function. \n+    /// Its implemention depands on concrete compaction policy.\n+    /// param candidate_rowsets, the candidate_rowsets vector container to pick input rowsets\n+    /// return input_rowsets, the vector container as return\n+    /// return last_delete_version, if has delete rowset, record the delete version from input_rowsets\n+    /// return compaction_score, calculate the compaction score of picked input rowset\n+    virtual int pick_input_rowsets(const std::vector<RowsetSharedPtr>& candidate_rowsets,\n+                                    const int64_t max_compaction_score,\n+                                    const int64_t min_compaction_score,\n+                                    std::vector<RowsetSharedPtr>* input_rowsets,\n+                                    Version* last_delete_version, size_t* compaction_score) = 0;\n+\n+    /// Update tablet's cumulative point after cumulative compaction finished. This function is pure virtual function.\n+    /// Each derived has its own update policy which deponds on its concrete algorithm. When the cumulative point moves \n+    /// after output rowset, then output rowset will do base compaction next time.\n+    /// param input_rowsets, the picked input rowset to do compaction just now\n+    /// param output_rowset, the result rowset after compaction\n+    virtual void update_cumulative_point(const std::vector<RowsetSharedPtr>& input_rowsets,\n+                                         RowsetSharedPtr output_rowset,\n+                                         Version& last_delete_version) = 0;\n+\n+    /// Calculate tablet's cumulatvie point before compaction. This calculation just executes once when the tablet compacts\n+    /// first time after BE initialization and then motion of cumulatvie point depends on update_cumulative_point policy.\n+    /// This function is pure virtual function. In genaral, the cumulative point splits the rowsets into two parts:\n+    /// base rowsets, cumulative rowsets.\n+    /// param all_rowsets, all rowsets in the tablet\n+    /// param current_cumulative_point, current cumulative position\n+    /// return cumulative_point, the result of calculating cumulative point position\n+    virtual void calculate_cumulative_point(const std::vector<RowsetMetaSharedPtr>& all_rowsets,\n+                                            int64_t current_cumulative_point,\n+                                            int64_t* cumulative_point) = 0;\n+\n+protected:\n+    /// tablet pointer\n+    std::shared_ptr<Tablet> _tablet;", "originalCommit": "0d2a83b46750998cb29997bb852c789070a8d9ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}