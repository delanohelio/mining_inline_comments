{"pr_number": 1783, "pr_title": "Parallelize index rebuilding", "pr_createdAt": "2020-10-23T21:08:42Z", "pr_url": "https://github.com/fcrepo/fcrepo/pull/1783", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMTI2Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512621262", "bodyText": "Is there a reason this can't be wired and injected by spring?", "author": "pwinckles", "createdAt": "2020-10-27T11:43:07Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMTcwMg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512621702", "bodyText": "Milliseconds might be an optimistic unit...", "author": "pwinckles", "createdAt": "2020-10-27T11:44:00Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n+                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                true, reindexBatchSize);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            throw new RuntimeException(e);\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getResultStates().keySet().size();\n+        LOGGER.info(\"Index rebuild complete {} objects in {} milliseconds\", count,", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyMzk2Nw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512623967", "bodyText": "You should keep a handle to the id stream. The stream should be closed when you're done with it.", "author": "pwinckles", "createdAt": "2020-10-27T11:46:44Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512624837", "bodyText": "This should be configurable. Are you planning on saving that for a different PR?", "author": "pwinckles", "createdAt": "2020-10-27T11:47:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = batchSize;\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjE1Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515102156", "bodyText": "I can make this configurable but then what should be the default? Single threaded?", "author": "whikloj", "createdAt": "2020-10-30T13:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTY2MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515105660", "bodyText": "Also are you thinking this is specifically configurable w/r/t reindexing?", "author": "whikloj", "createdAt": "2020-10-30T13:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjI3Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515106272", "bodyText": "You can have the default be exactly what you have here. There are a number of ways that you could write it. Probably the easiest is to write a static function that does the thread computation and then write something like this is in the config:\n@Value(\"${fcrepo.reindex.threads:\" + computeDefaultThreads() + \"}\")\nprivate int reindexThreads;", "author": "pwinckles", "createdAt": "2020-10-30T13:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzM3Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515107376", "bodyText": "Also are you thinking this is specifically configurable w/r/t reindexing?\n\nNot sure", "author": "pwinckles", "createdAt": "2020-10-30T13:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNDgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYyNjU2Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512626563", "bodyText": "Any reason to not just pass this into the worker in the constructor?", "author": "pwinckles", "createdAt": "2020-10-27T11:49:06Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();\n+\n+    private final ReindexService reindexService;\n+\n+    private final int batchSize;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether to have threads fail on an error or log and continue.\n+     * @param batchSize number of ids to distribute per request.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final boolean failOnError,\n+                          final int batchSize) {\n+        this.ocflIter = ids.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = batchSize;\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        final int availableProcessors = Runtime.getRuntime().availableProcessors();\n+        final int threads = availableProcessors > 1 ? availableProcessors - 1 : 1;\n+        for (var foo = 0; foo < threads; foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Get the transaction id for the reindexing run.\n+     * @return the transaction id.\n+     */\n+    public String getTransactionId() {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNDc4NQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512634785", "bodyText": "This seems to be less of a state map and more of a map of errors, the successes have an empty value. It also has the potential to grow very large. How are we planning on using these results? For me, what makes sense is to have a count of the objects that were successfully processed, and either a collection or a map of exceptions that occurred during processing. Or, we could just keep a count of both and immediately log errors so that we do not need to collect them. I think keeping the counts is worth while because it will allow us to do periodic reporting during the processing.", "author": "pwinckles", "createdAt": "2020-10-27T12:00:48Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Map<String, String> resultStates = new HashMap<>();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512637807", "bodyText": "What happens on failure? Isn't this going to leave the db transaction in place?", "author": "pwinckles", "createdAt": "2020-10-27T12:06:03Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -120,148 +117,40 @@ private void rebuild() {\n         referenceService.reset();\n         membershipService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final var reindexService = new ReindexService(persistentStorageSessionManager, objectSessionFactory, ocflIndex,\n+                containmentIndex, searchIndex, referenceService, membershipService, membershipPageSize);\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                true, reindexBatchSize);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMzQ5Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515103493", "bodyText": "No, ReindexManager.commit() calls ReindexService.commit() which does the commit and rollback on failure work.", "author": "whikloj", "createdAt": "2020-10-30T13:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODQyOA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515108428", "bodyText": "Right, but what happens if the call to reindexManager.start() throws an exception?", "author": "pwinckles", "createdAt": "2020-10-30T13:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwNDM4Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515204383", "bodyText": "Ok I see what you're saying the DB transaction would just sit there.", "author": "whikloj", "createdAt": "2020-10-30T15:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzNzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYzOTA0OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512639049", "bodyText": "Indexing the membership does seem like a distinct operation from committing the db transactions. Perhaps there could be a method for committing the db transactions, one for rolling back the db transactions, and another that kicks of the membership indexing? I haven't looked at it in detail, but does the membership indexing use much of else that's in this class? It the surface it seems like it could easily go into its own class.", "author": "pwinckles", "createdAt": "2020-10-27T12:08:05Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+public class ReindexService {\n+\n+    private final PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    private final OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    private final FedoraToOcflObjectIndex ocflIndex;\n+\n+    private final ContainmentIndex containmentIndex;\n+\n+    private final SearchIndex searchIndex;\n+\n+    private final ReferenceService referenceService;\n+\n+    private final MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private final int membershipPageSize;\n+\n+    public ReindexService(final PersistentStorageSessionManager sessionManager,\n+                          final OcflObjectSessionFactory sessionFactory,\n+                          final FedoraToOcflObjectIndex fedoraToOcflObjectIndex,\n+                          final ContainmentIndex containmentIdx,\n+                          final SearchIndex searchIdx,\n+                          final ReferenceService referenceSrvc,\n+                          final MembershipService memberService,\n+                          final int membershipPageSize) {\n+        this.persistentStorageSessionManager = sessionManager;\n+        this.ocflObjectSessionFactory = sessionFactory;\n+        this.ocflIndex = fedoraToOcflObjectIndex;\n+        this.containmentIndex = containmentIdx;\n+        this.searchIndex = searchIdx;\n+        this.referenceService = referenceSrvc;\n+        this.membershipService = memberService;\n+        this.membershipPageSize = membershipPageSize;\n+    }\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            indexMembership(transactionId);", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0MTQ0NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512641444", "bodyText": "You should have a check in this loop to see if the thread should stop.", "author": "pwinckles", "createdAt": "2020-10-27T12:12:11Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            final Map<String, String> states = new HashMap<>();\n+            for (final var id : ids) {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r512643954", "bodyText": "The problem with this behavior is that it will only ever stop this thread on error. The rest of the threads will proceed. One solution to this problem is to change the status reporting, as previously discussed, and have the updateComplete method trigger stopping all of the threads when an error is reported and failOnError is true.", "author": "pwinckles", "createdAt": "2020-10-27T12:16:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            final Map<String, String> states = new HashMap<>();\n+            for (final var id : ids) {\n+                try {\n+                    service.indexOcflObject(manager.getTransactionId(), id);\n+                    states.put(id, \"\");\n+                } catch (final Exception e) {\n+                    states.put(id, e.getMessage());\n+                    if (failOnError) {", "originalCommit": "b52064cde1fa5e5684ae194b61ea9c25c2512c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA4MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515105081", "bodyText": "Because each worker has a reference to the ReindexManager, I was just going to add a call to ReindexManager.stop() which stops all the threads. Do you see any problems there?", "author": "whikloj", "createdAt": "2020-10-30T13:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTExMTU5Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515111592", "bodyText": "Yes, that should be fine", "author": "pwinckles", "createdAt": "2020-10-30T13:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0Mzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NDM3OA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515944378", "bodyText": "Does it make sense to report the failure count here too?", "author": "pwinckles", "createdAt": "2020-11-02T12:41:34Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,44 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        LOGGER.info(\"Index rebuild complete {} objects in {} \", count,", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NDY0OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515944649", "bodyText": "Nice!", "author": "pwinckles", "createdAt": "2020-11-02T12:42:05Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -289,25 +149,14 @@ private boolean repoContainsObjects() {\n         return ocflRepository.listObjectIds().findFirst().isPresent();\n     }\n \n-    private static RdfStream parseRdf(final FedoraId fedoraIdentifier, final InputStream inputStream) {\n-        final Model model = createDefaultModel();\n-        RDFDataMgr.read(model, inputStream, getRdfFormat().getLang());\n-        final FedoraId topic = (fedoraIdentifier.isDescription() ? fedoraIdentifier.asBaseId() : fedoraIdentifier);\n-        return DefaultRdfStream.fromModel(createURI(topic.getFullId()), model);\n-    }\n-\n-    /**\n-     * Executes the closure, capturing all exceptions, and logging them as errors.\n-     *\n-     * @param failureMessage what to print if the closure fails\n-     * @param callable closure to execute\n-     */\n-    private void execQuietly(final String failureMessage, final Callable<Void> callable) {\n-        try {\n-            callable.call();\n-        } catch (final Exception e) {\n-            LOGGER.error(failureMessage, e);\n+    private String getDurationMessage(final Duration duration) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NjYzOA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515946638", "bodyText": "Minor optimization, this list could be initialized to batchSize", "author": "pwinckles", "createdAt": "2020-11-02T12:46:00Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ * @since 6.0.0\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Stream<String> ocflStream;\n+\n+    private int completedCount;\n+\n+    private int errorCount;\n+\n+    private final ReindexService reindexService;\n+\n+    private final long batchSize;\n+\n+    private final boolean failOnError;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param config OCFL property config object.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n+        this.ocflStream = ids;\n+        this.ocflIter = ocflStream.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = config.getReindexBatchSize();\n+        this.failOnError = config.isReindexFailOnError();\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Start reindexing.\n+     * @throws InterruptedException on an indexing error in a thread.\n+     */\n+    public void start() throws InterruptedException {\n+        try {\n+            workers.forEach(ReindexWorker::start);\n+            for (final var worker : workers) {\n+                worker.join();\n+            }\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Error while rebuilding index\", e);\n+            stop();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Stop all threads.\n+     */\n+    public void stop() {\n+        workers.forEach(ReindexWorker::stopThread);\n+    }\n+\n+    /**\n+     * Return a batch of OCFL ids to reindex.\n+     * @return list of OCFL ids.\n+     */\n+    public synchronized List<String> getIds() {\n+        int counter = 0;\n+        final List<String> ids = new ArrayList<>();", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NzQyMA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515947420", "bodyText": "Either this method needs to be synchronized or the counts need to be Atomic", "author": "pwinckles", "createdAt": "2020-11-02T12:47:32Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexManager.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.fcrepo.config.OcflPropsConfig;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Class to coordinate the index rebuilding tasks.\n+ * @author whikloj\n+ * @since 6.0.0\n+ */\n+public class ReindexManager {\n+\n+    private static final Logger LOGGER = getLogger(ReindexManager.class);\n+\n+    private final String transactionId;\n+\n+    private final List<ReindexWorker> workers;\n+\n+    private final Iterator<String> ocflIter;\n+\n+    private final Stream<String> ocflStream;\n+\n+    private int completedCount;\n+\n+    private int errorCount;\n+\n+    private final ReindexService reindexService;\n+\n+    private final long batchSize;\n+\n+    private final boolean failOnError;\n+\n+    /**\n+     * Basic constructor\n+     * @param ids stream of ocfl ids.\n+     * @param reindexService the reindexing service.\n+     * @param config OCFL property config object.\n+     */\n+    public ReindexManager(final Stream<String> ids, final ReindexService reindexService, final OcflPropsConfig config) {\n+        this.ocflStream = ids;\n+        this.ocflIter = ocflStream.iterator();\n+        this.reindexService = reindexService;\n+        this.batchSize = config.getReindexBatchSize();\n+        this.failOnError = config.isReindexFailOnError();\n+        transactionId = UUID.randomUUID().toString();\n+        workers = new ArrayList<>();\n+        for (var foo = 0; foo < config.getReindexingThreads(); foo += 1) {\n+            workers.add(new ReindexWorker(this, this.reindexService, transactionId, this.failOnError));\n+        }\n+    }\n+\n+    /**\n+     * Start reindexing.\n+     * @throws InterruptedException on an indexing error in a thread.\n+     */\n+    public void start() throws InterruptedException {\n+        try {\n+            workers.forEach(ReindexWorker::start);\n+            for (final var worker : workers) {\n+                worker.join();\n+            }\n+        } catch (final Exception e) {\n+            LOGGER.error(\"Error while rebuilding index\", e);\n+            stop();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Stop all threads.\n+     */\n+    public void stop() {\n+        workers.forEach(ReindexWorker::stopThread);\n+    }\n+\n+    /**\n+     * Return a batch of OCFL ids to reindex.\n+     * @return list of OCFL ids.\n+     */\n+    public synchronized List<String> getIds() {\n+        int counter = 0;\n+        final List<String> ids = new ArrayList<>();\n+        while (ocflIter.hasNext() && counter < batchSize) {\n+            ids.add(ocflIter.next());\n+            counter += 1;\n+        }\n+        return ids;\n+    }\n+\n+    /**\n+     * Update the master list of reindexing states.\n+     * @param batchSuccessful how many items were completed successfully in the last batch.\n+     * @param batchErrors how many items had an error in the last batch.\n+     */\n+    public void updateComplete(final int batchSuccessful, final int batchErrors) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1MDQxMg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515950412", "bodyText": "I think the body of this method needs to be same as the catch block in the commit method. That is to say, each rollback needs to be called so that if it fails it doesn't prevent the subsequent rollbacks from executing.", "author": "pwinckles", "createdAt": "2020-11-02T12:53:01Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");\n+        } catch (final RuntimeException e) {\n+            execQuietly(\"Failed to reset searchIndex\", () -> {\n+                searchIndex.reset();\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback containment index transaction \" + transactionId, () -> {\n+                containmentIndex.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            execQuietly(\"Failed to rollback OCFL index transaction \" + transactionId, () -> {\n+                ocflIndex.rollback(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback the reference index transaction \" + transactionId, () -> {\n+                referenceService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback membership index transaction \" + transactionId, () -> {\n+                membershipService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            throw e;\n+        }\n+    }\n+\n+    public void rollback(final String transactionId) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1MTA4Mg==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515951082", "bodyText": "Maybe have a DEBUG log when the membership indexing starts?", "author": "pwinckles", "createdAt": "2020-11-02T12:54:14Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");\n+        } catch (final RuntimeException e) {\n+            execQuietly(\"Failed to reset searchIndex\", () -> {\n+                searchIndex.reset();\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback containment index transaction \" + transactionId, () -> {\n+                containmentIndex.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            execQuietly(\"Failed to rollback OCFL index transaction \" + transactionId, () -> {\n+                ocflIndex.rollback(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback the reference index transaction \" + transactionId, () -> {\n+                referenceService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+\n+            execQuietly(\"Failed to rollback membership index transaction \" + transactionId, () -> {\n+                membershipService.rollbackTransaction(transactionId);\n+                return null;\n+            });\n+            throw e;\n+        }\n+    }\n+\n+    public void rollback(final String transactionId) {\n+        searchIndex.reset();\n+        containmentIndex.rollbackTransaction(transactionId);\n+        referenceService.rollbackTransaction(transactionId);\n+        ocflIndex.rollback(transactionId);\n+        membershipService.rollbackTransaction(transactionId);\n+    }\n+\n+    /**\n+     * Index all membership properties by querying for Direct containers, and then\n+     * trying population of the membership index for each one\n+     * @param txId the transaction id.\n+     */\n+    public void indexMembership(final String txId) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NTQ1NA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r515955454", "bodyText": "If failOnError is not set, I think it might make sense to WARN/ERROR the exception here", "author": "pwinckles", "createdAt": "2020-11-02T13:01:56Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import java.util.List;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private String transactionId;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor\n+     * @param reindexManager the manager service.\n+     * @param reindexService the reindexing service.\n+     * @param txId the transaction id.\n+     * @param failOnError whether the thread should fail on an error or log and continue.\n+     */\n+    public ReindexWorker(final ReindexManager reindexManager, final ReindexService reindexService,\n+                         final String txId, final boolean failOnError) {\n+        manager = reindexManager;\n+        service = reindexService;\n+        transactionId = txId;\n+        this.failOnError = failOnError;\n+        t = new Thread(this, \"ReindexWorker\");\n+    }\n+\n+    /**\n+     * Join the thread.\n+     * @throws InterruptedException if the current thread is interrupted.\n+     */\n+    public void join() throws InterruptedException {\n+        t.join();\n+    }\n+\n+    /**\n+     * Start the thread with this Runnable\n+     */\n+    public void start() {\n+        t.start();\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (running) {\n+            final List<String> ids = manager.getIds();\n+            if (ids.isEmpty()) {\n+                stopThread();\n+                break;\n+            }\n+            int completed = 0;\n+            int errors = 0;\n+            for (final var id : ids) {\n+                if (!running) {\n+                    break;\n+                }\n+                try {\n+                    service.indexOcflObject(transactionId, id);\n+                    completed += 1;\n+                } catch (final Exception e) {\n+                    errors += 1;\n+                    if (failOnError) {", "originalCommit": "ab6f2a8ad0fb4f1672c93729071b61689fa72625", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "url": "https://github.com/fcrepo/fcrepo/commit/feaa3f4726ddfb66d2e88c222aa2045a59f78c17", "message": "Parallelize index rebuilding", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "b01c34d51c9300baaef7c023b4c6348da5dcaed0", "url": "https://github.com/fcrepo/fcrepo/commit/b01c34d51c9300baaef7c023b4c6348da5dcaed0", "message": "Make workers request ids from manager", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "ddf0941f13992ad7205421dfdf74ad9dfd00113a", "url": "https://github.com/fcrepo/fcrepo/commit/ddf0941f13992ad7205421dfdf74ad9dfd00113a", "message": "Remove unneeded class and return state for each batch", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "ce4779b94792265e6ae29db1f4d1d1d55e307890", "url": "https://github.com/fcrepo/fcrepo/commit/ce4779b94792265e6ae29db1f4d1d1d55e307890", "message": "Make reindex configurable, only track counts, rollback on error if failOnError=true", "committedDate": "2020-11-02T15:39:06Z", "type": "commit"}, {"oid": "25cc72fe7158bcc8e9e70839072cc9ce92782f43", "url": "https://github.com/fcrepo/fcrepo/commit/25cc72fe7158bcc8e9e70839072cc9ce92782f43", "message": "Code review", "committedDate": "2020-11-02T15:39:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTk1OQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516061959", "bodyText": "Can you change this to:\nLOGGER.error(\"Reindexing of OCFL id {} failed\", id, e);\nIt'll make it a lot easier to figure out what went wrong", "author": "pwinckles", "createdAt": "2020-11-02T15:43:20Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -89,6 +94,7 @@ public void run() {\n                         service.cleanupSession(transactionId);\n                         throw e;\n                     }\n+                    LOGGER.error(\"Reindexing of OCFL id {} failed: {}\", id, e.getMessage());", "originalCommit": "1fe0c30fa7831993e150de5a3a0882e77f1a1f1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25cc72fe7158bcc8e9e70839072cc9ce92782f43", "url": "https://github.com/fcrepo/fcrepo/commit/25cc72fe7158bcc8e9e70839072cc9ce92782f43", "message": "Code review", "committedDate": "2020-11-02T15:39:07Z", "type": "forcePushed"}, {"oid": "3629680e291ce63441702130eb925b9f4448576f", "url": "https://github.com/fcrepo/fcrepo/commit/3629680e291ce63441702130eb925b9f4448576f", "message": "Log full stacktrace", "committedDate": "2020-11-02T16:17:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExMTUzOQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516111539", "bodyText": "We will need to either document these configuration elements in the wiki now, or as a follow-on ticket.", "author": "awoods", "createdAt": "2020-11-02T16:51:41Z", "path": "fcrepo-configs/src/main/java/org/fcrepo/config/OcflPropsConfig.java", "diffHunk": "@@ -92,12 +92,31 @@\n     @Value(\"${fcrepo.resource-header-cache.expire-after-seconds:600}\")\n     private long resourceHeadersCacheExpireAfterSeconds;\n \n+    @Value(\"${fcrepo.ocfl.reindex.threads:-1}\")", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MTM4MQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516161381", "bodyText": "Updated\nhttps://wiki.lyrasis.org/display/FEDORA6x/Configuration+Options+Inventory#ConfigurationOptionsInventory-RebuildfromOCFLpersistentstorage", "author": "whikloj", "createdAt": "2020-11-02T18:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExMTUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NDk2Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516164966", "bodyText": "Is this method ever used?", "author": "awoods", "createdAt": "2020-11-02T18:11:37Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,45 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        final var errors = reindexManager.getErrorCount();\n+        LOGGER.info(\"Index rebuild completed {} objects successfully and {} objects had errors in {} \", count, errors,\n+                getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-    private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        final var rootId = new AtomicReference<FedoraId>();\n-        final var fedoraIds = new ArrayList<FedoraId>();\n-        final var headersList = new ArrayList<ResourceHeaders>();\n-\n-        session.streamResourceHeaders().forEach(storageHeaders -> {\n-            final var headers = new ResourceHeadersAdapter(storageHeaders);\n-\n-            final var fedoraId = headers.getId();\n-            fedoraIds.add(fedoraId);\n-            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                rootId.set(fedoraId);\n-            }\n-\n-            if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n-                var parentId = headers.getParent();\n-\n-                if (headers.getParent() == null) {\n-                    if (headers.isObjectRoot()) {\n-                        parentId = FedoraId.getRepositoryRootId();\n-                    } else {\n-                        throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n-                                fedoraId.getFullId()));\n-                    }\n-                }\n-                if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n-                    final Optional<InputStream> content = session.readContent(fedoraId.getFullId()).getContentStream();\n-                    if (content.isPresent()) {\n-                        final RdfStream rdf = parseRdf(fedoraId, content.get());\n-                        this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n-                    }\n-                }\n-\n-                this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n-                headersList.add(headers.asKernelHeaders());\n-            }\n-        });\n-\n-        if (rootId.get() == null) {\n-            throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n-        }\n-\n-        fedoraIds.forEach(fedoraIdentifier -> {\n-            final var rootFedoraIdentifier = rootId.get();\n-            ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-        });\n-\n-        headersList.forEach(headers -> {\n-            searchIndex.addUpdateIndex(txId, headers);\n-            LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-        });\n-    }\n \n     /**\n-     * Index all membership properties by querying for Direct containers, and then\n-     * trying population of the membership index for each one\n-     * @param txId\n+     * Pass this along to the ReindexService\n+     * @param pageSize number of results to use when querying for membership producing resources\n      */\n-    private void indexMembership(final String txId) {\n-        final var fields = List.of(Condition.Field.FEDORA_ID);\n-        final var conditions = List.of(Condition.fromEnums(Field.RDF_TYPE, Operator.EQ,\n-                RdfLexicon.DIRECT_CONTAINER.getURI()));\n-        int offset = 0;\n-\n-        try {\n-            int numResults = membershipPageSize;\n-            do {\n-                final var params = new SearchParameters(fields, conditions, membershipPageSize,\n-                        offset, Field.FEDORA_ID, \"asc\");\n-\n-                final var searchResult = searchIndex.doSearch(params);\n-                final var resultList = searchResult.getItems();\n-                numResults = resultList.size();\n-\n-                resultList.stream()\n-                    .map(entry -> FedoraId.create((String) entry.get(Condition.Field.FEDORA_ID.toString())))\n-                    .forEach(containerId -> membershipService.populateMembershipHistory(txId, containerId));\n-\n-                // Results are paged, so step through pages until we reach the last one\n-                offset += membershipPageSize;\n-            } while (numResults == membershipPageSize);\n-\n-        } catch (final InvalidQueryException e) {\n-            throw new RepositoryRuntimeException(\"Failed to repopulate membership history\", e);\n-        }\n-        membershipService.commitTransaction(txId);\n+    public void setMembershipQueryPageSize(final int pageSize) {", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NTA3Mw==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516165073", "bodyText": "Is this method ever used?", "author": "awoods", "createdAt": "2020-11-02T18:11:49Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/IndexBuilderImpl.java", "diffHunk": "@@ -114,154 +84,45 @@ public void rebuildIfNecessary() {\n     private void rebuild() {\n         LOGGER.info(\"Initiating index rebuild.\");\n \n-        ocflIndex.reset();\n-        containmentIndex.reset();\n-        searchIndex.reset();\n-        referenceService.reset();\n-        membershipService.reset();\n+        reindexService.reset();\n \n-        final var txId = UUID.randomUUID().toString();\n+        final ReindexManager reindexManager = new ReindexManager(ocflRepository.listObjectIds(), reindexService,\n+                ocflPropsConfig);\n \n+        LOGGER.debug(\"Reading object ids...\");\n+        final var startTime = Instant.now();\n         try {\n-            LOGGER.debug(\"Reading object ids...\");\n-\n-            try (final var ocflIds = ocflRepository.listObjectIds()) {\n-                ocflIds.forEach(ocflId -> {\n-                    LOGGER.debug(\"Reading {}\", ocflId);\n-                    try (final var session = objectSessionFactory.newSession(ocflId)) {\n-                        indexOcflObject(ocflId, txId, session);\n-                    } catch (final Exception e) {\n-                        // The session's close method signature throws Exception\n-                        if (e instanceof RuntimeException) {\n-                            throw (RuntimeException) e;\n-                        }\n-                        throw new RuntimeException(e);\n-                    }\n-                });\n-            }\n-\n-            containmentIndex.commitTransaction(txId);\n-            ocflIndex.commit(txId);\n-            referenceService.commitTransaction(txId);\n-            indexMembership(txId);\n-            LOGGER.info(\"Index rebuild complete\");\n-        } catch (final RuntimeException e) {\n-            execQuietly(\"Failed to reset searchIndex\", () -> {\n-                searchIndex.reset();\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback containment index transaction \" + txId, () -> {\n-                containmentIndex.rollbackTransaction(txId);\n-                return null;\n-            });\n-            execQuietly(\"Failed to rollback OCFL index transaction \" + txId, () -> {\n-                ocflIndex.rollback(txId);\n-                return null;\n-            });\n-\n-            execQuietly(\"Failed to rollback membership index transaction \" + txId, () -> {\n-                membershipService.rollbackTransaction(txId);\n-                return null;\n-            });\n-            throw e;\n+            reindexManager.start();\n+            reindexManager.commit();\n+            LOGGER.info(\"Reindexing complete.\");\n+        } catch (final InterruptedException e) {\n+            reindexManager.rollback();\n+            throw new RuntimeException(e);\n+        } finally {\n+            reindexManager.shutdown();\n         }\n+        final var endTime = Instant.now();\n+        final var count = reindexManager.getCompletedCount();\n+        final var errors = reindexManager.getErrorCount();\n+        LOGGER.info(\"Index rebuild completed {} objects successfully and {} objects had errors in {} \", count, errors,\n+                getDurationMessage(Duration.between(startTime, endTime)));\n     }\n \n-    private void indexOcflObject(final String ocflId, final String txId, final OcflObjectSession session) {\n-        final var rootId = new AtomicReference<FedoraId>();\n-        final var fedoraIds = new ArrayList<FedoraId>();\n-        final var headersList = new ArrayList<ResourceHeaders>();\n-\n-        session.streamResourceHeaders().forEach(storageHeaders -> {\n-            final var headers = new ResourceHeadersAdapter(storageHeaders);\n-\n-            final var fedoraId = headers.getId();\n-            fedoraIds.add(fedoraId);\n-            if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n-                rootId.set(fedoraId);\n-            }\n-\n-            if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n-                var parentId = headers.getParent();\n-\n-                if (headers.getParent() == null) {\n-                    if (headers.isObjectRoot()) {\n-                        parentId = FedoraId.getRepositoryRootId();\n-                    } else {\n-                        throw new IllegalStateException(String.format(\"Resource %s must have a parent defined\",\n-                                fedoraId.getFullId()));\n-                    }\n-                }\n-                if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n-                    final Optional<InputStream> content = session.readContent(fedoraId.getFullId()).getContentStream();\n-                    if (content.isPresent()) {\n-                        final RdfStream rdf = parseRdf(fedoraId, content.get());\n-                        this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n-                    }\n-                }\n-\n-                this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n-                headersList.add(headers.asKernelHeaders());\n-            }\n-        });\n-\n-        if (rootId.get() == null) {\n-            throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n-        }\n-\n-        fedoraIds.forEach(fedoraIdentifier -> {\n-            final var rootFedoraIdentifier = rootId.get();\n-            ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n-            LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n-        });\n-\n-        headersList.forEach(headers -> {\n-            searchIndex.addUpdateIndex(txId, headers);\n-            LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n-        });\n-    }\n \n     /**\n-     * Index all membership properties by querying for Direct containers, and then\n-     * trying population of the membership index for each one\n-     * @param txId\n+     * Pass this along to the ReindexService\n+     * @param pageSize number of results to use when querying for membership producing resources\n      */\n-    private void indexMembership(final String txId) {\n-        final var fields = List.of(Condition.Field.FEDORA_ID);\n-        final var conditions = List.of(Condition.fromEnums(Field.RDF_TYPE, Operator.EQ,\n-                RdfLexicon.DIRECT_CONTAINER.getURI()));\n-        int offset = 0;\n-\n-        try {\n-            int numResults = membershipPageSize;\n-            do {\n-                final var params = new SearchParameters(fields, conditions, membershipPageSize,\n-                        offset, Field.FEDORA_ID, \"asc\");\n-\n-                final var searchResult = searchIndex.doSearch(params);\n-                final var resultList = searchResult.getItems();\n-                numResults = resultList.size();\n-\n-                resultList.stream()\n-                    .map(entry -> FedoraId.create((String) entry.get(Condition.Field.FEDORA_ID.toString())))\n-                    .forEach(containerId -> membershipService.populateMembershipHistory(txId, containerId));\n-\n-                // Results are paged, so step through pages until we reach the last one\n-                offset += membershipPageSize;\n-            } while (numResults == membershipPageSize);\n-\n-        } catch (final InvalidQueryException e) {\n-            throw new RepositoryRuntimeException(\"Failed to repopulate membership history\", e);\n-        }\n-        membershipService.commitTransaction(txId);\n+    public void setMembershipQueryPageSize(final int pageSize) {\n+        reindexService.setMembershipPageSize(pageSize);\n     }\n \n     /**\n-     * @param pageSize number of results to use when querying for membership producing resources\n+     * Change the number of OCFL ids given out to workers at a time.\n+     * @param batchSize number of OCFL ids per batch.\n      */\n-    public void setMembershipQueryPageSize(final int pageSize) {\n-        this.membershipPageSize = pageSize;\n+    public void setReindexBatchSize(final int batchSize) {", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "023f69b2c776c563c07bfc24e039917ccac6618d", "url": "https://github.com/fcrepo/fcrepo/commit/023f69b2c776c563c07bfc24e039917ccac6618d", "message": "Remove ununsed functions", "committedDate": "2020-11-02T18:23:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MzQ5NQ==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516173495", "bodyText": "typo: 'Constuctor'", "author": "awoods", "createdAt": "2020-11-02T18:27:08Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexWorker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+\n+/**\n+ * A reindexing worker thread.\n+ * @author whikloj\n+ */\n+public class ReindexWorker implements Runnable {\n+\n+    private static final Logger LOGGER = getLogger(ReindexWorker.class);\n+    private Thread t;\n+    private ReindexManager manager;\n+    private ReindexService service;\n+    private String transactionId;\n+    private boolean running = true;\n+    private boolean failOnError;\n+\n+    /**\n+     * Basic Constuctor", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NDM5Ng==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516174396", "bodyText": "Maybe include the txnId in the log message?", "author": "awoods", "createdAt": "2020-11-02T18:28:44Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NDQ2MA==", "url": "https://github.com/fcrepo/fcrepo/pull/1783#discussion_r516174460", "bodyText": "Maybe include the txnId in the log message?", "author": "awoods", "createdAt": "2020-11-02T18:28:51Z", "path": "fcrepo-persistence-ocfl/src/main/java/org/fcrepo/persistence/ocfl/impl/ReindexService.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to DuraSpace under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional information\n+ * regarding copyright ownership.\n+ *\n+ * DuraSpace licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.fcrepo.persistence.ocfl.impl;\n+\n+import static org.apache.jena.graph.NodeFactory.createURI;\n+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;\n+import static org.fcrepo.kernel.api.RdfLexicon.NON_RDF_SOURCE;\n+import static org.fcrepo.persistence.ocfl.impl.OcflPersistentStorageUtils.getRdfFormat;\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import javax.inject.Inject;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.jena.rdf.model.Model;\n+import org.apache.jena.riot.RDFDataMgr;\n+import org.fcrepo.kernel.api.ContainmentIndex;\n+import org.fcrepo.kernel.api.RdfLexicon;\n+import org.fcrepo.kernel.api.RdfStream;\n+import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;\n+import org.fcrepo.kernel.api.identifiers.FedoraId;\n+import org.fcrepo.kernel.api.models.ResourceHeaders;\n+import org.fcrepo.kernel.api.rdf.DefaultRdfStream;\n+import org.fcrepo.kernel.api.services.MembershipService;\n+import org.fcrepo.kernel.api.services.ReferenceService;\n+import org.fcrepo.persistence.api.PersistentStorageSessionManager;\n+import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;\n+import org.fcrepo.search.api.Condition;\n+import org.fcrepo.search.api.InvalidQueryException;\n+import org.fcrepo.search.api.SearchIndex;\n+import org.fcrepo.search.api.SearchParameters;\n+import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * Service that does the reindexing for one OCFL object.\n+ * @author whikloj\n+ */\n+@Component\n+public class ReindexService {\n+\n+    @Inject\n+    private PersistentStorageSessionManager persistentStorageSessionManager;\n+\n+    @Inject\n+    private OcflObjectSessionFactory ocflObjectSessionFactory;\n+\n+    @Autowired\n+    @Qualifier(\"ocflIndex\")\n+    private FedoraToOcflObjectIndex ocflIndex;\n+\n+    @Autowired\n+    @Qualifier(\"containmentIndex\")\n+    private ContainmentIndex containmentIndex;\n+\n+    @Autowired\n+    @Qualifier(\"searchIndex\")\n+    private SearchIndex searchIndex;\n+\n+    @Autowired\n+    @Qualifier(\"referenceService\")\n+    private ReferenceService referenceService;\n+\n+    @Inject\n+    private MembershipService membershipService;\n+\n+    private static final Logger LOGGER = getLogger(ReindexService.class);\n+\n+    private int membershipPageSize = 500;\n+\n+    public void indexOcflObject(final String txId, final String ocflId) {\n+        LOGGER.debug(\"Indexing ocflId {} in transaction {}\", ocflId, txId);\n+        try (final var session = ocflObjectSessionFactory.newSession(ocflId)) {\n+            final var rootId = new AtomicReference<FedoraId>();\n+            final var fedoraIds = new ArrayList<FedoraId>();\n+            final var headersList = new ArrayList<ResourceHeaders>();\n+\n+            session.streamResourceHeaders().forEach(storageHeaders -> {\n+                final var headers = new ResourceHeadersAdapter(storageHeaders);\n+\n+                final var fedoraId = headers.getId();\n+                fedoraIds.add(fedoraId);\n+                if (headers.isArchivalGroup() || headers.isObjectRoot()) {\n+                    rootId.set(fedoraId);\n+                }\n+\n+                if (!headers.isDeleted() && !fedoraId.isRepositoryRoot()) {\n+                    var parentId = headers.getParent();\n+\n+                    if (headers.getParent() == null) {\n+                        if (headers.isObjectRoot()) {\n+                            parentId = FedoraId.getRepositoryRootId();\n+                        } else {\n+                            throw new IllegalStateException(\n+                                    String.format(\"Resource %s must have a parent defined\", fedoraId.getFullId()));\n+                        }\n+                    }\n+                    if (!headers.getInteractionModel().equals(NON_RDF_SOURCE.toString())) {\n+                        final Optional<InputStream> content = session.readContent(fedoraId.getFullId())\n+                                .getContentStream();\n+                        if (content.isPresent()) {\n+                            final RdfStream rdf = parseRdf(fedoraId, content.get());\n+                            this.referenceService.updateReferences(txId, fedoraId, null, rdf);\n+                        }\n+                    }\n+\n+                    this.containmentIndex.addContainedBy(txId, parentId, fedoraId);\n+                    headersList.add(headers.asKernelHeaders());\n+                }\n+            });\n+\n+            if (rootId.get() == null) {\n+                throw new IllegalStateException(String.format(\"Failed to find root resource in object %s\", ocflId));\n+            }\n+\n+            fedoraIds.forEach(fedoraIdentifier -> {\n+                final var rootFedoraIdentifier = rootId.get();\n+                ocflIndex.addMapping(txId, fedoraIdentifier, rootFedoraIdentifier, ocflId);\n+                LOGGER.debug(\"Rebuilt fedora-to-ocfl object index entry for {}\", fedoraIdentifier);\n+            });\n+\n+            headersList.forEach(headers -> {\n+                searchIndex.addUpdateIndex(txId, headers);\n+                LOGGER.debug(\"Rebuilt searchIndex for {}\", headers.getId());\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Remove persistent sessions for a transaction to avoid memory leaks.\n+     * @param transactionId the transaction id.\n+     */\n+    public void cleanupSession(final String transactionId) {\n+        persistentStorageSessionManager.removeSession(transactionId);\n+    }\n+\n+    /**\n+     * Set the membership page size.\n+     * @param pageSize the new page size.\n+     */\n+    public void setMembershipPageSize(final int pageSize) {\n+        membershipPageSize = pageSize;\n+    }\n+\n+    /**\n+     * Reset all the indexes.\n+     */\n+    public void reset() {\n+        ocflIndex.reset();\n+        containmentIndex.reset();\n+        searchIndex.reset();\n+        referenceService.reset();\n+        membershipService.reset();\n+    }\n+\n+    /**\n+     * Commit the records added from transaction.\n+     * @param transactionId the id of the transaction.\n+     */\n+    public void commit(final String transactionId) {\n+        try {\n+            LOGGER.debug(\"Performing commit\");\n+            containmentIndex.commitTransaction(transactionId);\n+            ocflIndex.commit(transactionId);\n+            referenceService.commitTransaction(transactionId);\n+            LOGGER.debug(\"Finished commit\");", "originalCommit": "3629680e291ce63441702130eb925b9f4448576f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee644d819c37026c2c6f45881bf22700285807c3", "url": "https://github.com/fcrepo/fcrepo/commit/ee644d819c37026c2c6f45881bf22700285807c3", "message": "Code review", "committedDate": "2020-11-02T18:46:05Z", "type": "commit"}]}