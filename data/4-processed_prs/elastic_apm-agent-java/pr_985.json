{"pr_number": 985, "pr_title": "Reduce startup costs for AsyncHttpClient instrumentation", "pr_createdAt": "2020-01-08T10:12:24Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/985", "timeline": [{"oid": "f7e47b2e0b4474ac4fac7f7735577aee53d3a948", "url": "https://github.com/elastic/apm-agent-java/commit/f7e47b2e0b4474ac4fac7f7735577aee53d3a948", "message": "Reduce startup costs for AsyncHttpClient instrumentation", "committedDate": "2020-01-06T14:37:59Z", "type": "commit"}, {"oid": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "url": "https://github.com/elastic/apm-agent-java/commit/a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "message": "Reduce number of lookups and ResettableClassFileTransformers", "committedDate": "2020-01-08T15:26:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyMzYzMA==", "url": "https://github.com/elastic/apm-agent-java/pull/985#discussion_r364723630", "bodyText": "Another non-supported case- an instrumentation that matches multiple methods (or multiple method overloads), that are not implemented at the same class in the hierarchy. Consider the StatementInstrumentation for example, where the method matching can apply to a class AND its superclass.\nNot a deal breaker, but can be overcome if instead of returning here, you would chain all matchers this method returns throughout the class inheritance (ie until classToInstrument.getSuperclass() == null)", "author": "eyalkoren", "createdAt": "2020-01-09T12:56:58Z", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -394,4 +407,79 @@ public boolean matches(TypeDescription target) {\n     public static String getAgentHome() {\n         return agentJarFile == null ? null : agentJarFile.getParent();\n     }\n+\n+    public static void ensureInstrumented(Class<?> classToInstrument, Collection<Class<? extends ElasticApmInstrumentation>> instrumentationClasses) {\n+        Set<Collection<Class<? extends ElasticApmInstrumentation>>> appliedInstrumentations = getOrCreate(classToInstrument);\n+\n+        if (!appliedInstrumentations.contains(instrumentationClasses)) {\n+            synchronized (ElasticApmAgent.class) {\n+                ElasticApmTracer tracer = ElasticApmInstrumentation.tracer;\n+                if (tracer == null || instrumentation == null) {\n+                    throw new IllegalStateException(\"Agent is not initialized\");\n+                }\n+\n+                if (!appliedInstrumentations.contains(instrumentationClasses)) {\n+                    appliedInstrumentations = new HashSet<>(appliedInstrumentations);\n+                    appliedInstrumentations.add(instrumentationClasses);\n+                    // immutability guards against race conditions (for example concurrent rehash due to add and lookup)\n+                    appliedInstrumentations = Collections.unmodifiableSet(appliedInstrumentations);\n+                    dynamicallyInstrumentedClasses.put(classToInstrument, appliedInstrumentations);\n+\n+                    CoreConfiguration config = tracer.getConfig(CoreConfiguration.class);\n+                    final Logger logger = LoggerFactory.getLogger(ElasticApmAgent.class);\n+                    final ByteBuddy byteBuddy = new ByteBuddy()\n+                        .with(TypeValidation.of(logger.isDebugEnabled()))\n+                        .with(FailSafeDeclaredMethodsCompiler.INSTANCE);\n+                    AgentBuilder agentBuilder = getAgentBuilder(byteBuddy, config, logger, AgentBuilder.DescriptionStrategy.Default.HYBRID);\n+                    for (Class<? extends ElasticApmInstrumentation> instrumentationClass : instrumentationClasses) {\n+                        ElasticApmInstrumentation apmInstrumentation = instantiate(instrumentationClass);\n+                        ElementMatcher.Junction<TypeDescription> typeMatcher = getTypeMatcher(classToInstrument, apmInstrumentation.getMethodMatcher());\n+                        if (typeMatcher != null && isIncluded(apmInstrumentation, config)) {\n+                            agentBuilder = applyAdvice(tracer, agentBuilder, apmInstrumentation, typeMatcher.and(apmInstrumentation.getTypeMatcher()));\n+                        }\n+                    }\n+                    dynamicClassFileTransformers.add(agentBuilder.installOn(instrumentation));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Set<Collection<Class<? extends ElasticApmInstrumentation>>> getOrCreate(Class<?> classToInstrument) {\n+        Set<Collection<Class<? extends ElasticApmInstrumentation>>> instrumentedClasses = dynamicallyInstrumentedClasses.get(classToInstrument);\n+        if (instrumentedClasses == null) {\n+            instrumentedClasses = new HashSet<Collection<Class<? extends ElasticApmInstrumentation>>>();\n+            Set<Collection<Class<? extends ElasticApmInstrumentation>>> racy = dynamicallyInstrumentedClasses.put(classToInstrument, instrumentedClasses);\n+            if (racy != null) {\n+                instrumentedClasses = racy;\n+            }\n+        }\n+        return instrumentedClasses;\n+    }\n+\n+    @Nullable\n+    private static ElementMatcher.Junction<TypeDescription> getTypeMatcher(Class<?> classToInstrument, ElementMatcher<? super MethodDescription> methodMatcher) {\n+\n+        MethodList<MethodDescription.InDefinedShape> matchingMethods = TypeDescription.ForLoadedType.of(classToInstrument).getDeclaredMethods().filter(methodMatcher);\n+        if (!matchingMethods.isEmpty()) {\n+            return is(classToInstrument);", "originalCommit": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MzA1NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/985#discussion_r371273055", "bodyText": "maybe add a comment why it's safe to do with any() here", "author": "SylvainJuge", "createdAt": "2020-01-27T14:33:11Z", "path": "apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java", "diffHunk": "@@ -123,7 +132,7 @@ protected AbstractAsyncHandlerInstrumentation(ElementMatcher<? super MethodDescr\n \n         @Override\n         public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n-            return hasSuperType(named(\"org.asynchttpclient.AsyncHandler\"));\n+            return any()/*.and(ElasticApmAgent.getTypeMatcher(asyncHandler.getClass()))*/;", "originalCommit": "a9ecafa89caaa6180b1c02bbb1e07a718f9d4b94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81b07fd422f7d680d390bdc967874bf9a1724f4d", "url": "https://github.com/elastic/apm-agent-java/commit/81b07fd422f7d680d390bdc967874bf9a1724f4d", "message": "Apply suggestions from code review", "committedDate": "2020-01-29T13:04:25Z", "type": "commit"}, {"oid": "13ea3462da0d3ff6eb17c6fe84f4d6d0a43673ea", "url": "https://github.com/elastic/apm-agent-java/commit/13ea3462da0d3ff6eb17c6fe84f4d6d0a43673ea", "message": "Merge remote-tracking branch 'origin/master' into improve-async-http-client-startup-overhead", "committedDate": "2020-01-29T13:33:37Z", "type": "commit"}]}