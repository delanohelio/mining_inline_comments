{"pr_number": 1048, "pr_title": "Add Scala concurrent plugin", "pr_createdAt": "2020-02-22T21:05:45Z", "pr_url": "https://github.com/elastic/apm-agent-java/pull/1048", "timeline": [{"oid": "404f6fb364eab81b066483af102a2685da3fc6ac", "url": "https://github.com/elastic/apm-agent-java/commit/404f6fb364eab81b066483af102a2685da3fc6ac", "message": "WIP", "committedDate": "2020-02-16T18:45:04Z", "type": "commit"}, {"oid": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "url": "https://github.com/elastic/apm-agent-java/commit/9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "message": "Add initial scala instrumentation for Future", "committedDate": "2020-02-22T12:17:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MTY1MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r383281651", "bodyText": "agent plugins do not need to rely on apm-agent-api and should use internal API instead, dependency is provided implicitly by apm-agent-plugins parent module.", "author": "SylvainJuge", "createdAt": "2020-02-24T14:03:39Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.13.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>${project.groupId}</groupId>\n+            <artifactId>apm-agent-api</artifactId>", "originalCommit": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "url": "https://github.com/elastic/apm-agent-java/commit/e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "message": "Remove test-dependency", "committedDate": "2020-02-24T15:14:44Z", "type": "commit"}, {"oid": "e57e2d8c03b2a972a805498b59d5467701c24dd1", "url": "https://github.com/elastic/apm-agent-java/commit/e57e2d8c03b2a972a805498b59d5467701c24dd1", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-03-29T10:17:17Z", "type": "commit"}, {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad", "url": "https://github.com/elastic/apm-agent-java/commit/3ef57c0f45f274926c314413454cc35ed8e141ad", "message": "Add first test approach", "committedDate": "2020-03-29T19:50:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNjQyOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406106428", "bodyText": "The type matchers should not refer to classes as that would cause loading these classes. Instead, use the named matcher, like named(\"scala.util.Try\")", "author": "felixbarny", "createdAt": "2020-04-09T10:22:15Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/scala/co/elastic/apm/agent/concurrent/FutureInstrumentation.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation\n+import net.bytebuddy.asm.Advice\n+import net.bytebuddy.description.`type`.TypeDescription\n+import net.bytebuddy.description.method.MethodDescription\n+import net.bytebuddy.matcher.ElementMatcher\n+import net.bytebuddy.matcher.ElementMatchers._\n+\n+import scala.collection.JavaConverters._\n+import scala.util.Try\n+\n+class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+  override def getTypeMatcher: ElementMatcher[_ >: TypeDescription] =\n+    hasSuperType[TypeDescription](named(\"scala.concurrent.Future\"))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+      .or(hasSuperType(named(\"scala.concurrent.Future$\")))\n+\n+  override def getMethodMatcher: ElementMatcher[_ >: MethodDescription] =\n+    named[MethodDescription](\"onComplete\").and(returns(classOf[Unit])).and(takesArguments(classOf[Try[_] => _]))", "originalCommit": "3ef57c0f45f274926c314413454cc35ed8e141ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExNjU2Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406116562", "bodyText": "The executor service instrumentations can only be applied in the tests if you have a dependency on that module:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                <dependencies>\n          \n          \n            \n                    <dependency>\n          \n          \n            \n                        <groupId>${project.groupId}</groupId>\n          \n          \n            \n                        <artifactId>apm-java-concurrent-plugin</artifactId>\n          \n          \n            \n                        <version>${project.version}</version>\n          \n          \n            \n                        <scope>test</scope>\n          \n          \n            \n                    </dependency>\n          \n          \n            \n                    <dependency>\n          \n          \n            \n                        <groupId>${project.groupId}</groupId>\n          \n          \n            \n                        <artifactId>apm-java-concurrent-plugin</artifactId>\n          \n          \n            \n                        <version>${project.version}</version>\n          \n          \n            \n                        <type>test-jar</type>\n          \n          \n            \n                        <scope>test</scope>\n          \n          \n            \n                    </dependency>\n          \n          \n            \n                </dependencies>\n          \n      \n    \n    \n  \n\nAdd this snippet to the concurrent plugin in order to be able to access its test classes, in particular WrappedExecutorService (see also comment further below)>\n    <build>\n        <plugins>\n            <plugin>\n                <artifactId>maven-jar-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>test-jar</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>", "author": "felixbarny", "createdAt": "2020-04-09T10:42:05Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.15.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <build>\n+        <sourceDirectory>src/main/scala</sourceDirectory>\n+        <testSourceDirectory>src/test/scala</testSourceDirectory>\n+        <plugins>\n+            <plugin>\n+                <groupId>net.alchim31.maven</groupId>\n+                <artifactId>scala-maven-plugin</artifactId>\n+                <version>4.3.0</version>\n+                <configuration>\n+                    <scalaVersion>2.12.10</scalaVersion>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+", "originalCommit": "3ef57c0f45f274926c314413454cc35ed8e141ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExOTMxMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406119312", "bodyText": "Maybe here's something going wrong with the instrumentation. One limitation of the unit tests is that you can't test instrumenting classes from the bootstrap class loader. ThreadPoolExecutor, which is returned from Executors.newFixedThreadPool(1) is such a class.\nTo work around this, we use co.elastic.apm.agent.concurrent.ExecutorServiceWrapper in our tests. This is a class that the agent can instrument in tests that just delegates to the wrapped ExecutorService.\nFor the built-in executor service instrumentation to work, you also have to declare a test dependency to the java-concurrent-plugin (see comment on pom.xml).\nTo access the ExecutorServiceWrapper class, you either need to copy/paste it to your module or build a test jar from the java-concurrent-plugin and add it as a test dependency as well (see comment on pom.xml).", "author": "felixbarny", "createdAt": "2020-04-09T10:47:38Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,64 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest\n+import org.assertj.core.api.Assertions.assertThat\n+import org.junit.jupiter.api.Test\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, Future}\n+\n+class FutureInstrumentationSpec extends AbstractInstrumentationTest {\n+\n+  @Test\n+  def testWithDefaultConfig(): Unit = {\n+    new TestFutureTraceMethods().invokeAsync()\n+    assertThat(AbstractInstrumentationTest.reporter.getTransactions().toArray).hasSize(1)\n+    assertThat(AbstractInstrumentationTest.reporter.getSpans().toArray).hasSize(4)\n+  }\n+\n+  private class TestFutureTraceMethods {\n+\n+    /**\n+     * Calling this method results in this method call tree:\n+     *\n+     *                      main thread                         |           worker thread\n+     * -------------------------------------------------------------------------------------------\n+     * invokeAsync                                              |\n+     *      |                                                   |\n+     *      --- blockingMethodOnMainThread                      |\n+     *                     |                                    |\n+     *                     --- nonBlockingMethodOnMainThread    |\n+     *                                      |                   |\n+     *                                      --------------------------> methodOnWorkerThread\n+     *                                                          |                |\n+     *                                                          |                --- longMethod\n+     *                                                          |\n+     */\n+    def invokeAsync(): Unit = blockingMethodOnMainThread()\n+\n+    private def blockingMethodOnMainThread(): Unit = {\n+      try {\n+        Await.result(nonBlockingMethodOnMainThread(), 10.seconds)\n+      } catch {\n+        case e: Exception => e.printStackTrace()\n+      }\n+    }\n+\n+    private def nonBlockingMethodOnMainThread(): Future[Unit] =\n+      Future(methodOnWorkerThread())(ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1)))", "originalCommit": "3ef57c0f45f274926c314413454cc35ed8e141ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMTYwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406121605", "bodyText": "What are you trying to achieve by instrumenting the onComplete method?\nIs the onComplete executed in the context of the Runnable from the Executor that is used within the ExecutionContext.fromExecutor?", "author": "felixbarny", "createdAt": "2020-04-09T10:52:23Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/scala/co/elastic/apm/agent/concurrent/FutureInstrumentation.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation\n+import net.bytebuddy.asm.Advice\n+import net.bytebuddy.description.`type`.TypeDescription\n+import net.bytebuddy.description.method.MethodDescription\n+import net.bytebuddy.matcher.ElementMatcher\n+import net.bytebuddy.matcher.ElementMatchers._\n+\n+import scala.collection.JavaConverters._\n+import scala.util.Try\n+\n+class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+  override def getTypeMatcher: ElementMatcher[_ >: TypeDescription] =\n+    hasSuperType[TypeDescription](named(\"scala.concurrent.Future\"))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+      .or(hasSuperType(named(\"scala.concurrent.Future$\")))\n+\n+  override def getMethodMatcher: ElementMatcher[_ >: MethodDescription] =\n+    named[MethodDescription](\"onComplete\").and(returns(classOf[Unit])).and(takesArguments(classOf[Try[_] => _]))\n+//    .or(named[MethodDescription](\"transform\").and(returns(classOf[Future[_]])).and(takesArguments(classOf[Try[_] => Try[_]])))\n+//    .or(named[MethodDescription](\"transformWith\").and(returns(classOf[Future[_]])).and(takesArguments(classOf[Try[_] => Future[_]])))\n+    .and(not(isTypeInitializer[MethodDescription]()))\n+\n+  override def getInstrumentationGroupNames: util.Collection[String] = List(\"concurrent\", \"future\").asJavaCollection\n+\n+  @Advice.OnMethodEnter(suppress = classOf[Throwable])\n+  def onComplete(@Advice.Argument(value = 0, readOnly = true) callback: Try[_] => _): Unit = {", "originalCommit": "3ef57c0f45f274926c314413454cc35ed8e141ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTk0MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406375941", "bodyText": "What should happen is when a Future is created, it should have the trace information. When a Future finishes its task, the method onComplete will be called on that same Future. Based on the trace information on the creation, it should then close the correct spans.", "author": "milanvdm", "createdAt": "2020-04-09T17:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyODk0OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406428949", "bodyText": "Another remark on using Java to write the Scala instrumentation. For example, this method would need to be replaced with some custom code to correctly close tracing contexts.\nWhen writing all of this in Java, I don't immediately see a way to write the correct Scala code to replace the original method?\nI know understand that this method is not replacing the matched method but only being called before it executes the matched one.", "author": "milanvdm", "createdAt": "2020-04-09T19:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMTYwNQ=="}], "type": "inlineReview"}, {"oid": "2dd336d4fad4ed76beacccad038b8bd7f864adc7", "url": "https://github.com/elastic/apm-agent-java/commit/2dd336d4fad4ed76beacccad038b8bd7f864adc7", "message": "Use Java for method matching", "committedDate": "2020-04-09T19:17:01Z", "type": "commit"}, {"oid": "167ecde0806ada0f1454bc806e84a2499d700b25", "url": "https://github.com/elastic/apm-agent-java/commit/167ecde0806ada0f1454bc806e84a2499d700b25", "message": "Add dummy test using Scala", "committedDate": "2020-04-14T15:56:37Z", "type": "commit"}, {"oid": "90d0b6f227399923a3a3ce2271dae8db32df44fe", "url": "https://github.com/elastic/apm-agent-java/commit/90d0b6f227399923a3a3ce2271dae8db32df44fe", "message": "Add java-version", "committedDate": "2020-04-14T20:36:16Z", "type": "commit"}, {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "url": "https://github.com/elastic/apm-agent-java/commit/1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "message": "Add first matching instrumentation test", "committedDate": "2020-04-14T20:37:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408420779", "bodyText": "Currently, disabling this dependency since adding it not only brings in the Wrapper classes, but for some reason also pulls in the JavaInstrumentation and method-matchers from the java-concurrent-plugin.\nComments welcome on how to prevent that :)", "author": "milanvdm", "createdAt": "2020-04-14T20:39:14Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.15.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+        <maven.compiler.target>9</maven.compiler.target>\n+        <maven.compiler.testTarget>9</maven.compiler.testTarget>\n+    </properties>\n+\n+    <dependencies>\n+<!--        <dependency>-->\n+<!--            <groupId>${project.groupId}</groupId>-->\n+<!--            <artifactId>apm-java-concurrent-plugin</artifactId>-->\n+<!--            <version>${project.version}</version>-->\n+<!--            <scope>test</scope>-->\n+<!--        </dependency>-->\n+<!--        <dependency>-->\n+<!--            <groupId>${project.groupId}</groupId>-->\n+<!--            <artifactId>apm-java-concurrent-plugin</artifactId>-->\n+<!--            <version>${project.version}</version>-->\n+<!--            <type>test-jar</type>-->\n+<!--            <scope>test</scope>-->\n+<!--        </dependency>-->", "originalCommit": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjg0MA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408906840", "bodyText": "Why would you want to prevent that?", "author": "felixbarny", "createdAt": "2020-04-15T14:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODc2Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408928762", "bodyText": "Shouldn't the unit test only test the Scala instrumentation? If now the JavaConcurrent instrumentation also starts running, it makes it more difficult to for example check the debug logs of the tests since it gets 'polluted' with the JavaConcurrent instrumentation.", "author": "milanvdm", "createdAt": "2020-04-15T15:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3NzQ1NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408977455", "bodyText": "I was under the impression that you were trying to leverage the executor instrumentation from the java concurrent plugin?", "author": "felixbarny", "createdAt": "2020-04-15T16:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3OTM4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408979381", "bodyText": "Still unsure about it to be honest.\nMy question was mainly pointed towards you and the expectations around how plugins get tested and if there are any restrictions on how to test it properly.", "author": "milanvdm", "createdAt": "2020-04-15T16:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjA2MA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408422060", "bodyText": "I'm unsure on how to start the initial transaction for every test. Since the FutureInstrumentation doesn't create any transactions, I expect that I manually need to activate it here.\nAlthough, I cannot find a similar thing in the AsyncTraceMethodInstrumentationTest of the java-concurrent plugin.", "author": "milanvdm", "createdAt": "2020-04-14T20:41:34Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,91 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.scalatest.BeforeAndAfterEach\n+import org.scalatest.flatspec.AnyFlatSpec\n+import org.scalatest.matchers.should.Matchers\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future}\n+\n+class FutureInstrumentationSpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {\n+\n+  implicit def executionContext: ExecutionContextExecutor =\n+    ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach: Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()", "originalCommit": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwOTgxNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408909815", "bodyText": "Starting the transaction like you did looks good. The AsyncTraceMethodInstrumentationTest relies on the trace_methods function to create a Transaction for all methods in TestAsyncTraceMethodsClass", "author": "felixbarny", "createdAt": "2020-04-15T14:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzE0Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408423147", "bodyText": "I see the FutureInstrumentation match correctly on this method-call which I find good progress :)\nIm confused on why the test is not passing due to not having any transactions in the reporter although I manually create that root-transaction.\nAny reason why it is not getting this root-transaction that gets created before every test?", "author": "milanvdm", "createdAt": "2020-04-14T20:43:31Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,91 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.scalatest.BeforeAndAfterEach\n+import org.scalatest.flatspec.AnyFlatSpec\n+import org.scalatest.matchers.should.Matchers\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future}\n+\n+class FutureInstrumentationSpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {\n+\n+  implicit def executionContext: ExecutionContextExecutor =\n+    ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach: Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach: Unit = {\n+    transaction.deactivate().end()\n+    ElasticApmAgent.reset()\n+  }\n+\n+  \"test\" should \"test\" in {\n+    new TestFutureTraceMethods().invokeAsync()", "originalCommit": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkxMTg5Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408911896", "bodyText": "That is because you are ending the transaction after the test has run (afterEach runs after \"test\"). Transactions are reported only after they are ended.", "author": "felixbarny", "createdAt": "2020-04-15T15:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzE0Nw=="}], "type": "inlineReview"}, {"oid": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "url": "https://github.com/elastic/apm-agent-java/commit/f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "message": "WIP", "committedDate": "2020-04-18T08:54:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r410672663", "bodyText": "Im currently trying out to create a first real test to see how everything works.\nIm currently stuck on why ByteBuddy is not executing this onEnter function even though I see method-matches on DEBUG level:\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final void scala.concurrent.impl.Promise$DefaultPromise.onComplete(scala.Function1,scala.concurrent.ExecutionContext)\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final java.lang.Object scala.concurrent.impl.Promise$DefaultPromise.result(scala.concurrent.duration.Duration,scala.concurrent.CanAwait) throws java.lang.Exception\n\nI see that the log also mentions throws java.lang.Exception but it is unclear on how and when that Exception is thrown.\n@felixbarny Any idea on what I'm missing on why onEnter is not being called even though there is a method match?", "author": "milanvdm", "createdAt": "2020-04-18T09:11:40Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.Future\"))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+            .or(hasSuperType(named(\"scala.concurrent.Future$\")));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"onComplete\").and(returns(void.class))\n+            .or(named(\"transform\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"transformWith\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"result\"));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @VisibleForAdvice\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void onEnter() {\n+        System.out.println(\"DEBUG2\");", "originalCommit": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzQ4Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r411117482", "bodyText": "Have you tried setting a breakpoint at Promise$DefaultPromise.onComplete or a method breakpoint for Promise.onComplete to see if the methods get called at all?\n\nI see that the log also mentions throws java.lang.Exception but it is unclear on how and when that Exception is thrown.\n\nThis is just a part of the method signature to indicate this method may throw any java.lang.Exception.", "author": "felixbarny", "createdAt": "2020-04-20T06:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NDQ3OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412494478", "bodyText": "Thanks for the tip, this helped me figure out the underlying process a lot better :)\nStruggling with ByteBuddy now to figure out how I could add a transaction-id to a matched class as a field.\nFrom my current understanding, a Promise will be created and at some point, the run method will be called on that Promise. Since the call on that run could happen on a different thread, I think it would make sense to somehow store the original context on that Promise and make sure to activate it again before the run.\nI've tried working with @Advice.FieldValue and @Advice.Local but I'm not sure if those values are really kept on the Promise itself.", "author": "milanvdm", "createdAt": "2020-04-21T21:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNTk5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412725998", "bodyText": "Our agent supports to be attached at runtime. One of the limitations when instrumenting classes that are already loaded is that you can't change the class file format. That means you can't add interfaces, methods or fields.\nA common technique we use to overcome this is to put things like a Promise as the key of a WeakConcurrentMap and the corresponding Span as the value.\nExample:\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-redis-plugin/apm-lettuce-plugin/src/main/java/co/elastic/apm/agent/redis/lettuce/Lettuce5StartSpanInstrumentation.java\n    \n    \n         Line 57\n      in\n      8421856\n    \n    \n    \n    \n\n        \n          \n           public static final WeakConcurrentMap<RedisCommand, Span> commandToSpan = new WeakConcurrentMap.WithInlinedExpunction<RedisCommand, Span>();", "author": "felixbarny", "createdAt": "2020-04-22T07:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczNDk5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412734994", "bodyText": "What if it is a Scala Promise? I remember a comment that we should prevent loading Scala classes since they would not be available on all code-bases.\nEspecially, I'm not sure if Java has any Scala interop.", "author": "milanvdm", "createdAt": "2020-04-22T07:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1ODY3OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r412958679", "bodyText": "Defining a WeakConcurrentMap<Promise, Span> does not cause loading/linking the Promise.  That's because the javac compiler erases the generic arguments. We only put promises in at runtime as we encounter these promises so they are guaranteed to already have been loaded.", "author": "felixbarny", "createdAt": "2020-04-22T12:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw=="}], "type": "inlineReview"}, {"oid": "b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "url": "https://github.com/elastic/apm-agent-java/commit/b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "message": "Use MUnit", "committedDate": "2020-04-20T21:09:56Z", "type": "commit"}, {"oid": "2feb98fdbd6dde9243158d7928fb5b954398d835", "url": "https://github.com/elastic/apm-agent-java/commit/2feb98fdbd6dde9243158d7928fb5b954398d835", "message": "Cleanup pom", "committedDate": "2020-04-22T20:23:52Z", "type": "commit"}, {"oid": "0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "url": "https://github.com/elastic/apm-agent-java/commit/0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "message": "Add Future instrumentation", "committedDate": "2020-04-22T20:24:05Z", "type": "commit"}, {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b", "url": "https://github.com/elastic/apm-agent-java/commit/f97b0b10f431f082307efcc3160e6d10146c862b", "message": "Add tests", "committedDate": "2020-04-22T20:24:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwOTc1Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r413309753", "bodyText": "Had to upgrade versions to be able to work with the Scala Munit test-framework.", "author": "milanvdm", "createdAt": "2020-04-22T20:33:47Z", "path": "pom.xml", "diffHunk": "@@ -420,13 +420,8 @@\n                 </plugin>\n                 <plugin>\n                     <artifactId>maven-surefire-plugin</artifactId>\n-                    <version>2.19.1</version>\n+                    <version>2.22.2</version>", "originalCommit": "f97b0b10f431f082307efcc3160e6d10146c862b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxMDAxMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r413310010", "bodyText": "Needed to match Scala *Spec.scala test files", "author": "milanvdm", "createdAt": "2020-04-22T20:34:11Z", "path": "pom.xml", "diffHunk": "@@ -438,6 +433,11 @@\n                             <version>${version.junit-jupiter}</version>\n                         </dependency>\n                     </dependencies>\n+                    <configuration>\n+                        <includes>\n+                            <include>**/*Spec.*</include>", "originalCommit": "f97b0b10f431f082307efcc3160e6d10146c862b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "649207b84ef4a73c923569193fde0f94df62efbd", "url": "https://github.com/elastic/apm-agent-java/commit/649207b84ef4a73c923569193fde0f94df62efbd", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-04-23T15:47:31Z", "type": "commit"}, {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "url": "https://github.com/elastic/apm-agent-java/commit/324ce67e0f9648e7f95fe86416ee6d0807be635b", "message": "Add plugin to release process", "committedDate": "2020-04-23T20:47:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyMzE0NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414323144", "bodyText": "Don't forget to deactivate the context.", "author": "felixbarny", "createdAt": "2020-04-24T06:19:37Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNDU5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414324594", "bodyText": "Catch thrown exceptions @Thrown @Nullable Throwable t and captureException(t)", "author": "felixbarny", "createdAt": "2020-04-24T06:23:01Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414325356", "bodyText": "Promises could be created outside a transaction but used in the context of a transaction at the point a promise is scheduled.\nIs there a canonical place where promises are scheduled? Maybe something equivalent to Executor#execute(Runnable)?", "author": "felixbarny", "createdAt": "2020-04-24T06:24:54Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzNTMwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414335309", "bodyText": "Mmmm, Ill have a look.\nDo you mean in the context of, someone creates a Promise outside of a transaction, without evaluating it. And then only start evaluating it later on, inside of a transaction?", "author": "milanvdm", "createdAt": "2020-04-24T06:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM0MzYxMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414343613", "bodyText": "Yes, exactly.\nThis would also allow us to do another nice thing. Currenly, all classes have to be evaluated whether they are a subclass of Promise (hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"))). This is a rather costly matcher as we can't exclude any class by name so all classes that are loaded have to be parsed.\nSee this example of the AsyncHttpClient instrumentation how we only instrument AsyncHandler classes that are passed to the org.asynchttpclient.DefaultAsyncHttpClient#executeRequest(org.asynchttpclient.Request, org.asynchttpclient.AsyncHandler<T>) method.\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n    \n    \n         Line 106\n      in\n      75160fe\n    \n    \n    \n    \n\n        \n          \n           ElasticApmAgent.ensureInstrumented(asyncHandler.getClass(), ASYNC_HANDLER_INSTRUMENTATIONS); \n        \n    \n  \n\n\nUsing this strategy, we wouldn't have to instrument any Promises to start with. Only those subclasses that pass the canonical place where they are scheduled would be instrumented at runtime.", "author": "felixbarny", "createdAt": "2020-04-24T07:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM0ODQ4Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414348486", "bodyText": "But how would you handle the case that there is a thread-switch between the creation of a Promise and the scheduling?\nIf the context is not propagated across that thread-switch, you would not know the transaction linked to this Promise and schedule it linked to no transaction.", "author": "milanvdm", "createdAt": "2020-04-24T07:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1NzU0OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414357549", "bodyText": "Usually, the thread on which the promise is scheduled is the thread we want to propagate the context.\nDo you know any counter-examples?", "author": "felixbarny", "createdAt": "2020-04-24T07:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2Mzg2Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414363866", "bodyText": "You start a transaction (thread 1)\nYou create a Promise (thread 1) - no context is saved on this Promise now\nSome thread switching - as I understand, the transaction of thread 1 will not be propagated\nPromise gets scheduled (thread 2) - it cannot find an active transaction", "author": "milanvdm", "createdAt": "2020-04-24T07:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4NDM5NA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414384394", "bodyText": "Some thread switching\n\nThis thread switching should also be covered by one of our instrumentation. For example, if the switch is done by another promise.", "author": "felixbarny", "createdAt": "2020-04-24T08:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4NzAyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414387021", "bodyText": "Oke, I'll dig a bit deeper into how Scala executes the Promises.", "author": "milanvdm", "createdAt": "2020-04-24T08:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNzE4Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414627187", "bodyText": "I've added some instrumentation on Scala's ExecutionContext instead of the Promise directly.\nIt seems to be working correctly since all spans are correctly reported in the APM UI.\nOne of the issues that I have is the logging though. With %X{transaction.id:-null} in my logback, I had all transaction ids of every operation when instrumenting the Promises directly.\nWith the instrumentation on the ExecutionContext, I see quite some nulls appearing:\nForkJoinPool-3-worker-5-id INFO  Main - Starting with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-7-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-25-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-21-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-7-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-9-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  Main - Halfway with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id null\nForkJoinPool-3-worker-23-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF2 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - keeping busy with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - runF1 with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-31-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-17-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-9-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-3-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-19-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id 56a80e276396e400\nForkJoinPool-3-worker-5-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-27-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  me.milan.concurrent.MultiThreadingF - sleeping with transaction-id null\nForkJoinPool-3-worker-13-id INFO  Main - Finished with transaction-id null", "author": "milanvdm", "createdAt": "2020-04-24T14:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MTY4Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414771687", "bodyText": "Not sure if relevant, but in DEBUG mode, I see the following:\n2020-04-24 20:14:59.428 [ForkJoinPool-1-worker-19] DEBUG co.elastic.apm.agent.mdc.MdcActivationListener - Class loader jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17 cannot load log4j API\njava.lang.ClassNotFoundException: org.apache.log4j.MDC\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener$2.get(MdcActivationListener.java:76)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener$2.get(MdcActivationListener.java:70)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache$CacheValue.<init>(WeakKeySoftValueLoadingCache.java:124)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache$CacheValue.<init>(WeakKeySoftValueLoadingCache.java:116)\n\tat co.elastic.apm.agent.cache.WeakKeySoftValueLoadingCache.get(WeakKeySoftValueLoadingCache.java:81)\n\tat co.elastic.apm.agent.mdc.MdcActivationListener.beforeActivate(MdcActivationListener.java:154)\n\tat co.elastic.apm.agent.impl.transaction.TraceContextHolder.activate(TraceContextHolder.java:101)\n\tat co.elastic.apm.agent.impl.transaction.AbstractSpan.activate(AbstractSpan.java:345)\n\tat co.elastic.apm.agent.impl.transaction.AbstractSpan.activate(AbstractSpan.java:42)\n\tat co.elastic.apm.api.AbstractSpanImpl.activate(AbstractSpanImpl.java:137)\n\tat me.milan.MainF$.$anonfun$program$3(MainF.scala:30)", "author": "milanvdm", "createdAt": "2020-04-24T18:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2MzI5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r416863298", "bodyText": "@felixbarny Should I create an issue about the mismatch between traces in the UI and the actual logging of the transaction-id?", "author": "milanvdm", "createdAt": "2020-04-28T19:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTYzNA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417139634", "bodyText": "One of the issues that I have is the logging though. With %X{transaction.id:-null} in my logback, I had all transaction ids of every operation when instrumenting the Promises directly.\n\nHm, that's strange.. Maybe there's another thread switch in-between? Could there be some work-stealing going on? Is it seemingly random when the MDC works and when it doesn't? In the cases where there's no MDC, does ElasticApm.currentSpan() (from the apm-agent-api module) return a noop span?\nThe debug message about ClassNotFoundException: org.apache.log4j.MDC can be ignored.", "author": "felixbarny", "createdAt": "2020-04-29T08:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MjU0NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417242545", "bodyText": "At the moment it looks quite random. I'll look into into it a bit more to see if I can reproduce it in a better way.\nBut as far as I understand it, the logging should be part of the submitted Runnable and therefore have exactly the same transaction as the action it is logging.", "author": "milanvdm", "createdAt": "2020-04-29T11:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NTM3Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417255377", "bodyText": "Yes, that's correct. Whenever a span is activated, it also sets the MDC.", "author": "felixbarny", "createdAt": "2020-04-29T11:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Njk5Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417256992", "bodyText": "In the cases where there's no MDC, does ElasticApm.currentSpan() (from the apm-agent-api module) return a noop span?\n\nWould you test this by adding doing something like:\nprintln(ElasticApm.currentSpan())\nlog.info(testing MDC)", "author": "milanvdm", "createdAt": "2020-04-29T11:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Nzk2OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417257968", "bodyText": "Yes, exactly", "author": "felixbarny", "createdAt": "2020-04-29T11:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU1NDYwNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417554607", "bodyText": "@felixbarny The println of ElasticApm.currentSpan().getId() returns an empty String so according to the docs it is indeed a noop.\nI'll need to check how the logging is executed in a different thread for whatever reason.", "author": "milanvdm", "createdAt": "2020-04-29T19:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5MDgwMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417890801", "bodyText": "It seems to be related to the usage of the Scala sttp library. It wraps the AsyncHttpClient from Java with https://github.com/reactive-streams/reactive-streams-jvm.\nAsyncHttpClient from Java uses https://github.com/reactive-streams/reactive-streams-jvm and it the way how the sttp library uses it, makes it lose the context.\nI'm checking out where it exactly loses the tracing context.", "author": "milanvdm", "createdAt": "2020-04-30T09:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1Mjg2OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417952868", "bodyText": "@felixbarny So basically what happens is that the Scala future will be completed (scheduled?) the moment override def onCompleted(): Unit is called on the org.asynchttpclient.handler.StreamedAsyncHandler.\nIf I add an ElasticAPM.currentSpan() in the onCompleted, it prints a Noop which shows that no trace-context is available at that moment. And therefore, also not on the Scala Future that gets completed by that method.\nI assume because the AsyncHttpClient is instrumented on the executeRequest, it causes the span of the http request to still be correctly closed.\nBut because I continue logging after the completion of the Scala future, the logging lost its context due to the org.asynchttpclient.handler.StreamedAsyncHandler.\nThis seems to boil down to a decision on instrumenting on a Promise directly or instrumenting the ExecutionContext. Unless you see it as a mistake that the trace-context is not passed into the org.asynchttpclient.handler.StreamedAsyncHandler#onCompleted?\nBut maybe there are other cases where thread-switches happen and that a Scala Future is completed on a different thread where there is no trace-context.", "author": "milanvdm", "createdAt": "2020-04-30T11:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MzY5Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419543692", "bodyText": "So basically what happens is that the Scala future will be completed (scheduled?) the moment override def onCompleted(): Unit is called on the org.asynchttpclient.handler.StreamedAsyncHandler\n\nThanks for the analysis!\n\nUnless you see it as a mistake that the trace-context is not passed into the org.asynchttpclient.handler.StreamedAsyncHandler#onCompleted?\n\nYes, that's a mistake.\nThis should be easy to fix in the AsyncHttpClient instrumentation:\n\n  \n    \n      apm-agent-java/apm-agent-plugins/apm-asynchttpclient-plugin/src/main/java/co/elastic/apm/agent/asynchttpclient/AbstractAsyncHttpClientInstrumentation.java\n    \n    \n        Lines 174 to 187\n      in\n      94c9215\n    \n    \n    \n    \n\n        \n          \n           public static class AsyncHandlerOnCompletedInstrumentation extends AbstractAsyncHandlerInstrumentation { \n        \n\n        \n          \n            \n        \n\n        \n          \n               public AsyncHandlerOnCompletedInstrumentation() { \n        \n\n        \n          \n                   super(named(\"onCompleted\").and(takesArguments(0))); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               @Advice.OnMethodEnter(suppress = Throwable.class) \n        \n\n        \n          \n               private static void onMethodEnter(@Advice.This AsyncHandler<?> asyncHandler) { \n        \n\n        \n          \n                   final Span span = handlerSpanMap.remove(asyncHandler); \n        \n\n        \n          \n                   if (span != null) { \n        \n\n        \n          \n                       span.end(); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nWe should activate the span in the @OnMethodEnter advice and deactivate it in the @OnMethodExit advice.", "author": "felixbarny", "createdAt": "2020-05-04T15:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NzkwOA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419557908", "bodyText": "@felixbarny Cool :) Can I try to create a PR to fix the AsyncHttpClient or do you prefer to do it from your side?\nOnce that is merged, Ill continue with testing this PR and start cleaning it up.", "author": "milanvdm", "createdAt": "2020-05-04T16:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDM5OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419570398", "bodyText": "Can I try to create a PR to fix the AsyncHttpClient or do you prefer to do it from your side?\n\nSure, go ahead! I think we should do the activation on all currently instrumented AsyncHandler callback methods. This way, users can add custom stuff in their own callbacks to the spans like ElasticApm.currentSpan().addCustom(\"foo\", responseStatus.getStatusText());", "author": "felixbarny", "createdAt": "2020-05-04T16:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyNzU3OA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r419627578", "bodyText": "@felixbarny First attempt: #1172\nWill need some help on how to add proper tests for this though.", "author": "milanvdm", "createdAt": "2020-05-04T18:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1ODMyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422058321", "bodyText": "@felixbarny I missed a method onStream on #1172 so will create a follow PR to add that one as well.\nLocally, it seems the span is now correctly passed along the AsyncHandler but there is still a place in my test setup where the span is not correctly passed on through all the Scala Futures.\nI will investigate further but I am maybe thinking there was a reason why other solutions instrument the Promise directly and not the ExecutionContext.", "author": "milanvdm", "createdAt": "2020-05-08T10:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NzMxMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422087310", "bodyText": "Both approaches seem to have their pros and cons. I currently don't have a clear opinion which is the best approach. I'm leaning towards instrument on ExecutionContext#execute as it's more efficient (no startup overhead) and supports propagating context for Promises that are created outside of a transaction. But I also see that it requires more work and is potentially more brittle.", "author": "felixbarny", "createdAt": "2020-05-08T11:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3NjQwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r422476406", "bodyText": "@felixbarny\nI went into the code again and found the behavior described in the accepted answer on https://stackoverflow.com/questions/59642314/scala-future-with-callback-and-context-switching.\nWhat seems to happen is that if a Future is already completed, it will be executed immediately. Meaning that final AbstractSpan<?> active = getActive(); in the OnExecute instrumentation, may return a null since the callback is executed on a thread that does not have an active span on it.\nSince the scala.concurrent.impl.Promise.DefaultPromise#dispatchOrAddCallback is the method that is executing the Future, this method somehow needs to be able to track which span is linked to that Future/Promise.\nI think this forces the choice to instrument on the Future/Promise directly instead of with the ExecutionContext.\nOne if the issues with instrumenting on the Promise directly, seems to be the extra dependency on Scala in the agent which cause some strange LinkageErrors sometimes. Is this related to the reason why the Elastic agent needs to shade libraries to avoid certain conflicts?", "author": "milanvdm", "createdAt": "2020-05-09T09:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMjkwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r424232905", "bodyText": "I added the instrumentation on the Promise back. It all works now for my test-setup.\nI sometimes get a warning though:\n09:35:28.230 [ForkJoinPool-5-worker-19] WARN co.elastic.apm.agent.impl.ElasticApmTracer - Tried to start a span with a non-zero reference count 1 'GET postman-echo.com' 00-00e98d3ae2d1d3665c8286557ca405f1-05f18334e53a3ee6-01 (3c295061)\nAs well as the LinkageError in some cases:\n[ERROR] Exception in thread \"main\" java.lang.LinkageError: loader constraint violation: loader 'bootstrap' wants to load class scala.collection.immutable.LazyList$State$Empty$. A different class with the same name was previously loaded by 'app'. (scala.collection.immutable.LazyList$State$Empty$ is in unnamed module of loader 'app')", "author": "milanvdm", "createdAt": "2020-05-13T07:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMTE2OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425731169", "bodyText": "@felixbarny As discussed, I make the Map use an Object instead of a Promise but it still get the Linkage issue. Here is the full trace:\nscala-elastic-apm[ERROR] Exception in thread \"main\" java.lang.LinkageError: loader constraint violation: loader 'bootstrap' wants to load class scala.collection.immutable.LazyList$State$Empty$. A different class with the same name was previously loaded by 'app'. (scala.collection.immutable.LazyList$State$Empty$ is in unnamed module of loader 'app')\nscala-elastic-apm[ERROR] \tat scala.collection.immutable.LazyList$.<clinit>(LazyList.scala:949)\nscala-elastic-apm[ERROR] \tat scala.package$.<clinit>(package.scala:89)\nscala-elastic-apm 2020-05-15 13:09:22.792 [elastic-apm-init-instrumentation-shutdown-hook] INFO co.elastic.apm.agent.impl.ElasticApmTracer - Tracer switched to STOPPED state\nscala-elastic-apm[ERROR] \tat scala.Predef$.<clinit>(Predef.scala:154)\nscala-elastic-apm 2020-05-15 13:09:22.792 [elastic-apm-init-instrumentation-shutdown-hook] INFO co.elastic.apm.agent.report.ApmServerReporter - dropped events because of full queue: 0\nscala-elastic-apm[ERROR] \tat scala.concurrent.Future$.<clinit>(Future.scala:520)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$.delayedEndpoint$me$milan$main$future$Main$1(Main.scala:32)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$delayedInit$body.apply(Main.scala:19)\nscala-elastic-apm[ERROR] \tat scala.Function0.apply$mcV$sp(Function0.scala:39)\nscala-elastic-apm[ERROR] \tat scala.Function0.apply$mcV$sp$(Function0.scala:39)\nscala-elastic-apm[ERROR] \tat scala.runtime.AbstractFunction0.apply$mcV$sp(AbstractFunction0.scala:17)\nscala-elastic-apm[ERROR] \tat scala.App.$anonfun$main$1(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.App.$anonfun$main$1$adapted(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.collection.IterableOnceOps.foreach(IterableOnce.scala:553)\nscala-elastic-apm[ERROR] \tat scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:551)\nscala-elastic-apm[ERROR] \tat scala.collection.AbstractIterable.foreach(Iterable.scala:920)\nscala-elastic-apm[ERROR] \tat scala.App.main(App.scala:73)\nscala-elastic-apm[ERROR] \tat scala.App.main$(App.scala:71)\nscala-elastic-apm[ERROR] \tat me.milan.main.future.Main$.main(Main.scala:19)", "author": "milanvdm", "createdAt": "2020-05-15T11:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNTMwMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425735303", "bodyText": "Actually, the usage of Promise as a type parameter of the map shouldn't be a problem because of type erasure.\nWhat you could try is to use Object instead of Promise<?> in the advice method signatures and cast within the method body. Maybe that avoids some eager linking. For example:\n        @Advice.OnMethodExit(suppress = Throwable.class)\n        public static void onExit(@Advice.This Object thiz) {\n            final AbstractSpan<?> context = getActive();\n            if (context != null) {\n                promisesToContext.put(thiz, context);\n            }\n        }", "author": "felixbarny", "createdAt": "2020-05-15T11:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc2MjIwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r425762206", "bodyText": "Some things:\n\nWhen I use Object in the Map and method so that I can remove the Scala dependency, there is no LinkageError.\nUsing Promise in the Map and in the method parameters Object does still have the LinkageError\nThe LinkageError does only happen when forking the JVM (in case of running Debug from IntelliJ or using something like https://github.com/spray/sbt-revolver to start your application)", "author": "milanvdm", "createdAt": "2020-05-15T12:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NDQ4OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426154489", "bodyText": "The LinkageError also happens when Cinnamon is enabled (and without running a forked JVM). So it seems specific to the Scala dependencies clashing somehow.\nOn the WARN that is happening:\nscala-elastic-apm 2020-05-15 14:08:53.201 [ForkJoinPool-1-worker-23] WARN co.elastic.apm.agent.impl.ElasticApmTracer - Tried to start a span with a non-zero reference count 1 'SELECT' 00-fbed3a699f6c244dffa8de3a3d95e48d-bd4655c8959cd4c8-01 (7b9e3d51)\nIm confused on how this warning can be generated. The method that logs this warning, first creates a new Span, and then counts the references. I don't see how the new Span can suddenly have any references right after being made and before the method actually returns the created Span.", "author": "milanvdm", "createdAt": "2020-05-16T13:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTk5NQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155995", "bodyText": "I've added suggestions that are likely to fix the cause of this.\n\nI don't see how the new Span can suddenly have any references right after being made and before the method actually returns the created Span.\n\nThat's because the span it gets out of the pool is still being referenced.", "author": "felixbarny", "createdAt": "2020-05-16T13:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1OTkzMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426159931", "bodyText": "The WARN is gone indeed :)\nSo ElasticAPM uses a pool of Spans that it cycles through? And since the Span is creating in the Promise but only activated later on, it may be that the Span gets recycled before it is actually used?\nIncrementing and decrementing makes sure the Span does not get recycled?", "author": "milanvdm", "createdAt": "2020-05-16T14:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MTYwNg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426161606", "bodyText": "Exactly. The pool is basically a queue that is initially empty. When trying to get a span from an empty pool, a new span is created. If the reference count if a span is 0, it gets recycled. Activating a span increments the reference count so under normal circumstances, you don\u2019t have to worry about the ref count. But in those async scenarios, it\u2019s important to keep the span alive if it can be used after it\u2019s ended.", "author": "felixbarny", "createdAt": "2020-05-16T15:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5NDU4MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r427094581", "bodyText": "And since the Span is creating in the Promise but only activated later on, it may be that the Span gets recycled before it is actually used?\n\nActually, it's not creating any span for the Promise. It just propagates the span that has been active when the promise was created to the thread that executes the promise. But the span might be already ended once the promise is executed.", "author": "felixbarny", "createdAt": "2020-05-19T07:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNjM0Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414326343", "bodyText": "Why is Java 9 required here? The agent must still support Java 7.  Loading the plugin (instantiating FutureInstrumentation) on an earlier JVM would result in an error.", "author": "felixbarny", "createdAt": "2020-04-24T06:27:02Z", "path": "apm-agent-core/pom.xml", "diffHunk": "@@ -165,6 +165,14 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>9</source>", "originalCommit": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMjI1OQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414332259", "bodyText": "I'll have to clean up the PR a bit later on, some parts were needed to get it running on my laptop. Otherwise, it was complaining about the java versions.", "author": "milanvdm", "createdAt": "2020-04-24T06:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNjM0Mw=="}], "type": "inlineReview"}, {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "url": "https://github.com/elastic/apm-agent-java/commit/9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "message": "Instrument ExecutionContext", "committedDate": "2020-04-24T18:06:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142417", "bodyText": "To properly deactivate on exit with considering wrapped promises, add @Advice.Local(\"context\") TraceContextHolder<?> context to the parameters.", "author": "felixbarny", "createdAt": "2020-04-29T08:16:55Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzkzMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143932", "bodyText": "Maybe the non-deactivated context has something to do with the MDC issue.", "author": "felixbarny", "createdAt": "2020-04-29T08:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTUwNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417241505", "bodyText": "Im not using the matchers on the Promise directly anymore. I'm only using matchers on the ExecutionContext directly using the wrapped Runnables:\nco.elastic.apm.agent.scala.concurrent.FutureInstrumentation$ExecutionContextInstrumentation\nco.elastic.apm.agent.scala.concurrent.FutureInstrumentation$BatchedExecutionContextInstrumentation\n#co.elastic.apm.agent.scala.concurrent.FutureInstrumentation$ConstructorInstrumentation\n#co.elastic.apm.agent.scala.concurrent.FutureInstrumentation$RunInstrumentation", "author": "milanvdm", "createdAt": "2020-04-29T11:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NTM1Ng==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417255356", "bodyText": "ah, got it", "author": "felixbarny", "createdAt": "2020-04-29T11:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjczMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz) {\n          \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") TraceContextHolder<?> context) {", "author": "felixbarny", "createdAt": "2020-04-29T08:17:34Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzMzNQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        promisesToContext.remove(thiz);\n          \n          \n            \n                        if (context != null) {\n          \n          \n            \n                            promisesToContext.remove(thiz);\n          \n          \n            \n                            tracer.deactivate(context);\n          \n          \n            \n                        }", "author": "felixbarny", "createdAt": "2020-04-29T08:18:41Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "originalCommit": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7ab2834402574dd4baa0c04cf76bf562e9448943", "url": "https://github.com/elastic/apm-agent-java/commit/7ab2834402574dd4baa0c04cf76bf562e9448943", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-05-08T07:39:26Z", "type": "commit"}, {"oid": "ee6da7dacbcded6509264890011e547cffdb3974", "url": "https://github.com/elastic/apm-agent-java/commit/ee6da7dacbcded6509264890011e547cffdb3974", "message": "Add onStream instrumentation on AsyncHandler", "committedDate": "2020-05-08T10:15:57Z", "type": "commit"}, {"oid": "ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "url": "https://github.com/elastic/apm-agent-java/commit/ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "message": "Add StreamHandler tests", "committedDate": "2020-05-08T11:02:49Z", "type": "commit"}, {"oid": "d9e0762aea300de8f45437353e384ec5739a7988", "url": "https://github.com/elastic/apm-agent-java/commit/d9e0762aea300de8f45437353e384ec5739a7988", "message": "Merge branch 'keep-spans-active-on-stream-async-http' into add-scala-executor-apm", "committedDate": "2020-05-08T11:12:00Z", "type": "commit"}, {"oid": "84417b0c209008813b79228a342f5b67c5884c8a", "url": "https://github.com/elastic/apm-agent-java/commit/84417b0c209008813b79228a342f5b67c5884c8a", "message": "Add Promise instrumentation", "committedDate": "2020-05-13T07:18:21Z", "type": "commit"}, {"oid": "199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "url": "https://github.com/elastic/apm-agent-java/commit/199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-13T07:18:30Z", "type": "commit"}, {"oid": "ad429931922d2f810fed7e4a323b922c89123e33", "url": "https://github.com/elastic/apm-agent-java/commit/ad429931922d2f810fed7e4a323b922c89123e33", "message": "Cleanup", "committedDate": "2020-05-15T09:56:23Z", "type": "commit"}, {"oid": "49bca5fe02443656ffbef02cfcc74f9ee685caf3", "url": "https://github.com/elastic/apm-agent-java/commit/49bca5fe02443656ffbef02cfcc74f9ee685caf3", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-15T10:22:08Z", "type": "commit"}, {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062", "url": "https://github.com/elastic/apm-agent-java/commit/e41f63c2d07732c4886892f22a1551dcebeb9062", "message": "Fix versions", "committedDate": "2020-05-15T11:10:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTQwMw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            // this span might be ended before the Promise$Transformation#run method starts\n          \n          \n            \n                            // we have to avoid that this span gets recycled, even in the above mentioned case\n          \n          \n            \n                            context.incrementReferences();", "author": "felixbarny", "createdAt": "2020-05-16T13:50:59Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);", "originalCommit": "e41f63c2d07732c4886892f22a1551dcebeb9062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTgyMg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155822", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            // decrements the reference we incremented to avoid that the parent context gets recycled before the promise is run\n          \n          \n            \n                            // because we have activated it, we can be sure it doesn't get recycled until we deactivate in the OnMethodExit advice\n          \n          \n            \n                            context.decrementReferences();", "author": "felixbarny", "createdAt": "2020-05-16T13:57:02Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") AbstractSpan<?> context) {\n+            context = promisesToContext.remove(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);", "originalCommit": "e41f63c2d07732c4886892f22a1551dcebeb9062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "url": "https://github.com/elastic/apm-agent-java/commit/a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "message": "Make sure spans are not recycled", "committedDate": "2020-05-16T14:44:58Z", "type": "commit"}, {"oid": "accd469299e47d98a9cd03f6597a25b7bac1b75d", "url": "https://github.com/elastic/apm-agent-java/commit/accd469299e47d98a9cd03f6597a25b7bac1b75d", "message": "Cleanup Java 9 compilers", "committedDate": "2020-05-19T08:38:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3NDcwOQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r427374709", "bodyText": "Marking as experimental disables this instrumentation by default.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Arrays.asList(\"concurrent\", \"future\");\n          \n          \n            \n                    return Arrays.asList(\"scala-future\", \"experimental\");", "author": "felixbarny", "createdAt": "2020-05-19T15:03:05Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");", "originalCommit": "accd469299e47d98a9cd03f6597a25b7bac1b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7843966cc39a26e402b10955c25ccab258e564d3", "url": "https://github.com/elastic/apm-agent-java/commit/7843966cc39a26e402b10955c25ccab258e564d3", "message": "Add docs", "committedDate": "2020-05-19T17:14:34Z", "type": "commit"}, {"oid": "0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "url": "https://github.com/elastic/apm-agent-java/commit/0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-19T17:15:10Z", "type": "commit"}, {"oid": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "url": "https://github.com/elastic/apm-agent-java/commit/f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "message": "Fix merge", "committedDate": "2020-05-19T17:15:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNTUwMA==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r431215500", "bodyText": "can this be removed?", "author": "felixbarny", "createdAt": "2020-05-27T15:08:28Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.16.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+        <maven.compiler.source>1.9</maven.compiler.source>", "originalCommit": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIzMjM2MQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r431232361", "bodyText": "Let me check since Scala does not support all Java version.\nIll also test Scala 2.12 in more detail.", "author": "milanvdm", "createdAt": "2020-05-27T15:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1ODQ1Mw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r431358453", "bodyText": "I tested Scala 2.12 and it doesn't work with that version. Not sure how to prevent a plugin to run with a specific version though.", "author": "milanvdm", "createdAt": "2020-05-27T18:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNTUwMA=="}], "type": "inlineReview"}, {"oid": "063ed391f99b95686f6b2aec0cabe5a99dcf364d", "url": "https://github.com/elastic/apm-agent-java/commit/063ed391f99b95686f6b2aec0cabe5a99dcf364d", "message": "Remove Java version", "committedDate": "2020-05-27T18:35:14Z", "type": "commit"}, {"oid": "6c638d9509fd5d44d1632d851f4d532089efb15c", "url": "https://github.com/elastic/apm-agent-java/commit/6c638d9509fd5d44d1632d851f4d532089efb15c", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-05-27T18:35:22Z", "type": "commit"}, {"oid": "40033fa77968c637587e912fe77d418c7eea1b47", "url": "https://github.com/elastic/apm-agent-java/commit/40033fa77968c637587e912fe77d418c7eea1b47", "message": "Improve testing for edge cases", "committedDate": "2020-05-29T18:47:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NDM0Nw==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r432674347", "bodyText": "@felixbarny I saw in your branch that you were using this approach.\nTechnically, this is not needed as the test framework will correctly await the Future for you.\nBut I can imagine that this makes it more explicit when you don't know the test-framework or Scala Futures.", "author": "milanvdm", "createdAt": "2020-05-29T18:51:30Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,224 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import munit.FunSuite\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future, Promise}\n+import scala.util.{Failure, Success}\n+\n+class FutureInstrumentationSpec extends FunSuite {\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach(context: BeforeEach): Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach(context: AfterEach): Unit = ElasticApmAgent.reset()\n+\n+  test(\"Scala Future should propagate the tracing-context correctly across different threads\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    val future =  Future(\"Test\")\n+      .map(_.length)\n+      .flatMap(l => Future(l * 2))\n+      .map(_.toString)\n+      .flatMap(s => Future(s\"$s-$s\"))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+\n+  }\n+\n+  test(\"Worker thread should correctly set context on the current transaction\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    new TestFutureTraceMethods().invokeAsync(tracer)\n+    transaction.deactivate().end()\n+    assertEquals(reporter.getTransactions.size(), 1)\n+    assertEquals(reporter.getSpans.size(), 0)\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+  }\n+\n+  test(\"Multiple async operations should be able to set context on the current transaction\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+            tracer.currentTransaction().addCustomContext(\"future1\", true)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+            tracer.currentTransaction().addCustomContext(\"future2\", true)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+            tracer.currentTransaction().addCustomContext(\"future3\", true)\n+          }\n+        ))\n+      }\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future1\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future2\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future3\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future {\n+      Thread.sleep(100)\n+      }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and complex Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+          }\n+        ))\n+      }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)", "originalCommit": "40033fa77968c637587e912fe77d418c7eea1b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "url": "https://github.com/elastic/apm-agent-java/commit/5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "message": "Simplify failing test", "committedDate": "2020-05-29T19:02:32Z", "type": "commit"}, {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb", "url": "https://github.com/elastic/apm-agent-java/commit/1721794b2f3a6c83c4d398fa3b87208dab54cceb", "message": "Add extra failing test on Future.sequence", "committedDate": "2020-05-29T19:36:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxNjI5Mg==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r432716292", "bodyText": "From what I tested with a Java Executor only:\n\nIf the Thread.sleep(x) with x = 1, the test does not always fail\nAdding a map with adding customContext on the Future inside of the Sequence, the context is correctly propagated\nSo only the map after the Sequence seems to lose context when only using the Java Executor\n\nSequence uses the parasitic Executor from Scala.", "author": "milanvdm", "createdAt": "2020-05-29T20:20:28Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,237 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import munit.FunSuite\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future, Promise}\n+import scala.util.{Failure, Success}\n+\n+class FutureInstrumentationSpec extends FunSuite {\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach(context: BeforeEach): Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach(context: AfterEach): Unit = ElasticApmAgent.reset()\n+\n+  test(\"Scala Future should propagate the tracing-context correctly across different threads\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    val future =  Future(\"Test\")\n+      .map(_.length)\n+      .flatMap(l => Future(l * 2))\n+      .map(_.toString)\n+      .flatMap(s => Future(s\"$s-$s\"))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+\n+  }\n+\n+  test(\"Worker thread should correctly set context on the current transaction\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    new TestFutureTraceMethods().invokeAsync(tracer)\n+    transaction.deactivate().end()\n+    assertEquals(reporter.getTransactions.size(), 1)\n+    assertEquals(reporter.getSpans.size(), 0)\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+  }\n+\n+  test(\"Multiple async operations should be able to set context on the current transaction\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+            tracer.currentTransaction().addCustomContext(\"future1\", true)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+            tracer.currentTransaction().addCustomContext(\"future2\", true)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+            tracer.currentTransaction().addCustomContext(\"future3\", true)\n+          }\n+        ))\n+      }\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future1\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future2\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future3\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future { Thread.sleep(100) }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a Future.sequence correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .sequence(List(\n+        Future(Thread.sleep(25))\n+      ))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))", "originalCommit": "1721794b2f3a6c83c4d398fa3b87208dab54cceb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "url": "https://github.com/elastic/apm-agent-java/commit/737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-06-15T15:01:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NjkyMQ==", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r440246921", "bodyText": "Maybe one thing to add is a test-dependency on the java-concurrent plugin to test the effects of having both means of context propagation on at the same time.", "author": "felixbarny", "createdAt": "2020-06-15T15:10:18Z", "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,50 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.16.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.scalameta</groupId>\n+            <artifactId>munit_2.13</artifactId>\n+            <version>0.7.2</version>\n+            <scope>test</scope>\n+        </dependency>", "originalCommit": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1885c8e64e22363b5ece20d07ddc24ce49496cb5", "url": "https://github.com/elastic/apm-agent-java/commit/1885c8e64e22363b5ece20d07ddc24ce49496cb5", "message": "Add java apm dependency to test", "committedDate": "2020-06-15T16:18:55Z", "type": "commit"}, {"oid": "c893ac024e0fdfa27a97c41708a64f8a72b78964", "url": "https://github.com/elastic/apm-agent-java/commit/c893ac024e0fdfa27a97c41708a64f8a72b78964", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-06-17T15:47:04Z", "type": "commit"}, {"oid": "f844049da47c548259973da58d5623fa1bca12b7", "url": "https://github.com/elastic/apm-agent-java/commit/f844049da47c548259973da58d5623fa1bca12b7", "message": "Bump to new snapshot version", "committedDate": "2020-06-17T15:48:28Z", "type": "commit"}, {"oid": "0f530a0684d941e3fd282157f0296ba4435409ac", "url": "https://github.com/elastic/apm-agent-java/commit/0f530a0684d941e3fd282157f0296ba4435409ac", "message": "Start tracer", "committedDate": "2020-06-23T18:24:06Z", "type": "commit"}, {"oid": "c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "url": "https://github.com/elastic/apm-agent-java/commit/c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm", "committedDate": "2020-06-23T18:24:52Z", "type": "commit"}, {"oid": "b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "url": "https://github.com/elastic/apm-agent-java/commit/b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "message": "Merge branch 'master' into add-scala-executor-apm", "committedDate": "2020-06-25T09:17:09Z", "type": "commit"}]}