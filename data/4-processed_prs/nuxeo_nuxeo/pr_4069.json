{"pr_number": 4069, "pr_title": "feature-NXP-26800-opencensus-stats-and-trace-reorg2", "pr_createdAt": "2020-05-25T12:23:43Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/4069", "timeline": [{"oid": "4062d06a31684efe610267a32446bad723f022d5", "url": "https://github.com/nuxeo/nuxeo/commit/4062d06a31684efe610267a32446bad723f022d5", "message": "NXP-27019: Deprecate and remove usage of SequenceTracer\n\nNow superseded by opencensus tracing", "committedDate": "2020-05-25T13:29:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MDA4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430160086", "bodyText": "Remove extra parentheses", "author": "efge", "createdAt": "2020-05-26T05:16:00Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/EventServiceImpl.java", "diffHunk": "@@ -299,53 +308,83 @@ public void fireEvent(Event event) {\n             if (event.isImmediate()) {\n                 EventBundleImpl b = new EventBundleImpl();\n                 b.push(shallowEvent);\n+                tracer.getCurrentSpan().addAnnotation(\"Event fire immediate bundle \" + event.getName());\n                 fireEventBundle(b);\n             } else {\n                 recordEvent(shallowEvent);\n             }\n         }\n     }\n \n+    protected void traceAddAnnotation(Event event, Tracer tracer, long elapsed, String listener) {\n+        Map<String, AttributeValue> attributes = new HashMap<>();\n+        attributes.put(\"event\", AttributeValue.stringAttributeValue(event.getName()));\n+        attributes.put(\"listener\", AttributeValue.stringAttributeValue(listener));\n+        attributes.put(\"duration_ms\", AttributeValue.longAttributeValue(elapsed));\n+        EventContext eventContext = event.getContext();\n+        if (eventContext instanceof DocumentEventContext) {\n+            DocumentEventContext docContext = ((DocumentEventContext) eventContext);", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MTU0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430161540", "bodyText": "I'd be more comfortable if the span.end() was alone in its own finally block to be independent of any tx failure.", "author": "efge", "createdAt": "2020-05-26T05:21:37Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/PostCommitEventExecutor.java", "diffHunk": "@@ -368,8 +424,31 @@ public Boolean call() {\n                 long elapsed = System.currentTimeMillis() - t0;\n                 SequenceTracer.stop(\"BulkPostcommit done \" + elapsed + \" ms\");\n                 log.debug(\"Events postcommit bulk execution finished in {}ms\", elapsed);\n+                span.end();", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MTY1NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430541654", "bodyText": "maybe but this is just tracing which is not critical and we are already inside an imbricated finally in legacy code that I don't want to rewrite.", "author": "bdelbosc", "createdAt": "2020-05-26T16:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MTc1OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430161759", "bodyText": "HashMap -> Map, or use var (several instances in the commit)", "author": "efge", "createdAt": "2020-05-26T05:22:29Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/PostCommitEventExecutor.java", "diffHunk": "@@ -368,8 +424,31 @@ public Boolean call() {\n                 long elapsed = System.currentTimeMillis() - t0;\n                 SequenceTracer.stop(\"BulkPostcommit done \" + elapsed + \" ms\");\n                 log.debug(\"Events postcommit bulk execution finished in {}ms\", elapsed);\n+                span.end();\n             }\n             return Boolean.TRUE; // no error to report\n         }\n+\n+        protected Span getTracingSpan(String spanName) {\n+            if (traceContext == null) {\n+                return BlankSpan.INSTANCE;\n+            }\n+            Tracer tracer = Tracing.getTracer();\n+            BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat();\n+            try {\n+                SpanContext spanContext = binaryFormat.fromByteArray(traceContext);\n+                Span span = tracer.spanBuilderWithRemoteParent(spanName, spanContext).startSpan();\n+                span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN));\n+                HashMap<String, AttributeValue> map = new HashMap<>();", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MjI3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430162272", "bodyText": "Add , e to chain the SpanContextParseException cause (several instances in this commit)", "author": "efge", "createdAt": "2020-05-26T05:24:36Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/PostCommitEventExecutor.java", "diffHunk": "@@ -226,60 +244,90 @@ public Boolean call() {\n             SequenceTracer.startFrom(callerThread, \"Postcommit\", \"#ff410f\");\n             long t0 = System.currentTimeMillis();\n             EventStats stats = Framework.getService(EventStats.class);\n+            Span span = getTracingSpan(\"postcommit.EventBundleBulkRunner\");\n+            try (Scope scope = Tracing.getTracer().withSpan(span)) {\n+                for (EventListenerDescriptor listener : listeners) {\n+                    EventBundle filtered = listener.filterBundle(bundle);\n+                    if (filtered.isEmpty()) {\n+                        continue;\n+                    }\n+                    log.debug(\"Events postcommit execution start for listener: {}\", listener::getName);\n+                    SequenceTracer.start(\"run listener \" + listener.getName());\n+                    long t1 = System.currentTimeMillis();\n \n-            for (EventListenerDescriptor listener : listeners) {\n-                EventBundle filtered = listener.filterBundle(bundle);\n-                if (filtered.isEmpty()) {\n-                    continue;\n-                }\n-                log.debug(\"Events postcommit execution start for listener: {}\", listener::getName);\n-                SequenceTracer.start(\"run listener \" + listener.getName());\n-                long t1 = System.currentTimeMillis();\n-\n-                boolean ok = false;\n-                ReconnectedEventBundle reconnected = null;\n-                // transaction timeout is managed by the FutureTask\n-                boolean tx = TransactionHelper.startTransaction();\n-                try {\n-                    reconnected = new ReconnectedEventBundleImpl(filtered, listeners.toString());\n+                    boolean ok = false;\n+                    ReconnectedEventBundle reconnected = null;\n+                    // transaction timeout is managed by the FutureTask\n+                    boolean tx = TransactionHelper.startTransaction();\n+                    try {\n+                        reconnected = new ReconnectedEventBundleImpl(filtered, listeners.toString());\n \n-                    listener.asPostCommitListener().handleEvent(reconnected);\n+                        listener.asPostCommitListener().handleEvent(reconnected);\n \n-                    ok = true;\n-                    // don't check for interrupted flag, the event completed normally, no reason to rollback\n-                } catch (RuntimeException e) {\n-                    log.error(\"Events postcommit execution encountered exception for listener: {}\", listener::getName,\n-                            () -> e);\n-                    // don't rethrow, but rollback (ok=false) and continue loop\n-                } finally {\n-                    try {\n-                        if (reconnected != null) {\n-                            reconnected.disconnect();\n-                        }\n+                        ok = true;\n+                        // don't check for interrupted flag, the event completed normally, no reason to rollback\n+                    } catch (RuntimeException e) {\n+                        log.error(\"Events postcommit execution encountered exception for listener: {}\",\n+                                listener::getName, () -> e);\n+                        // don't rethrow, but rollback (ok=false) and continue loop\n+                        span.setStatus(Status.UNKNOWN);\n                     } finally {\n-                        if (tx) {\n-                            if (!ok) {\n-                                TransactionHelper.setTransactionRollbackOnly();\n-                                log.error(\"Rolling back transaction\");\n+                        try {\n+                            if (reconnected != null) {\n+                                reconnected.disconnect();\n                             }\n-                            TransactionHelper.commitOrRollbackTransaction();\n-                        }\n-                        long elapsed = System.currentTimeMillis() - t1;\n-                        if (stats != null) {\n-                            stats.logAsyncExec(listener, elapsed);\n+                        } finally {\n+                            if (tx) {\n+                                if (!ok) {\n+                                    TransactionHelper.setTransactionRollbackOnly();\n+                                    log.error(\"Rolling back transaction\");\n+                                }\n+                                TransactionHelper.commitOrRollbackTransaction();\n+                            }\n+                            long elapsed = System.currentTimeMillis() - t1;\n+                            if (stats != null) {\n+                                stats.logAsyncExec(listener, elapsed);\n+                            }\n+                            log.debug(\"Events postcommit execution end for listener: {} in {}ms\", listener::getName,\n+                                    () -> elapsed);\n+                            SequenceTracer.stop(\"listener done \" + elapsed + \" ms\");\n+                            span.addAnnotation(\"Listener \" + listener.getName() + \" \" + elapsed + \" ms\");\n                         }\n-                        log.debug(\"Events postcommit execution end for listener: {} in {}ms\", listener::getName,\n-                                () -> elapsed);\n-                        SequenceTracer.stop(\"listener done \" + elapsed + \" ms\");\n                     }\n+                    // even if interrupted due to timeout, we continue the loop\n                 }\n-                // even if interrupted due to timeout, we continue the loop\n+                span.setStatus(Status.OK);\n+            } finally {\n+                span.end();\n             }\n+\n             long elapsed = System.currentTimeMillis() - t0;\n             log.debug(\"Events postcommit execution finished in {}ms\", elapsed);\n             SequenceTracer.stop(\"postcommit done\" + elapsed + \" ms\");\n             return Boolean.TRUE; // no error to report\n         }\n+\n+        protected Span getTracingSpan(String spanName) {\n+            if (traceContext == null) {\n+                return BlankSpan.INSTANCE;\n+            }\n+            Tracer tracer = Tracing.getTracer();\n+            BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat();\n+            try {\n+                SpanContext spanContext = binaryFormat.fromByteArray(traceContext);\n+                Span span = tracer.spanBuilderWithRemoteParent(spanName, spanContext).startSpan();\n+                span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN));\n+                HashMap<String, AttributeValue> map = new HashMap<>();\n+                map.put(\"tx.thread\", AttributeValue.stringAttributeValue(Thread.currentThread().getName()));\n+                map.put(\"bundle.event_count\", AttributeValue.longAttributeValue(bundle.size()));\n+                map.put(\"bundle.caller_thread\", AttributeValue.stringAttributeValue(callerThread));\n+                span.putAttributes(map);\n+                return span;\n+            } catch (SpanContextParseException e) {\n+                log.warn(\"Invalid trace context: \" + traceContext.length);", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MjU2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430162569", "bodyText": "indent", "author": "efge", "createdAt": "2020-05-26T05:25:42Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/work/AbstractWork.java", "diffHunk": "@@ -167,14 +182,16 @@ public AbstractWork() {\n         // - several calls in the time granularity of nanoTime()\n         // - several concurrent calls on different servers\n         this(System.nanoTime() + \".\" + (RANDOM.nextInt() & 0x7fffffff));\n-        callerThread = SequenceTracer.getThreadName();\n     }\n \n     public AbstractWork(String id) {\n         this.id = id;\n         progress = PROGRESS_INDETERMINATE;\n         schedulingTime = System.currentTimeMillis();\n         callerThread = SequenceTracer.getThreadName();\n+        traceContext = Tracing.getPropagationComponent()\n+                                .getBinaryFormat()\n+                                .toByteArray(Tracing.getTracer().getCurrentSpan().getContext());", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2Mjk5OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430162998", "bodyText": "Move the return BlankSpan.INSTANCE up in the catch block to be clear (several instances in this commit)", "author": "efge", "createdAt": "2020-05-26T05:27:23Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/PostCommitEventExecutor.java", "diffHunk": "@@ -226,60 +244,90 @@ public Boolean call() {\n             SequenceTracer.startFrom(callerThread, \"Postcommit\", \"#ff410f\");\n             long t0 = System.currentTimeMillis();\n             EventStats stats = Framework.getService(EventStats.class);\n+            Span span = getTracingSpan(\"postcommit.EventBundleBulkRunner\");\n+            try (Scope scope = Tracing.getTracer().withSpan(span)) {\n+                for (EventListenerDescriptor listener : listeners) {\n+                    EventBundle filtered = listener.filterBundle(bundle);\n+                    if (filtered.isEmpty()) {\n+                        continue;\n+                    }\n+                    log.debug(\"Events postcommit execution start for listener: {}\", listener::getName);\n+                    SequenceTracer.start(\"run listener \" + listener.getName());\n+                    long t1 = System.currentTimeMillis();\n \n-            for (EventListenerDescriptor listener : listeners) {\n-                EventBundle filtered = listener.filterBundle(bundle);\n-                if (filtered.isEmpty()) {\n-                    continue;\n-                }\n-                log.debug(\"Events postcommit execution start for listener: {}\", listener::getName);\n-                SequenceTracer.start(\"run listener \" + listener.getName());\n-                long t1 = System.currentTimeMillis();\n-\n-                boolean ok = false;\n-                ReconnectedEventBundle reconnected = null;\n-                // transaction timeout is managed by the FutureTask\n-                boolean tx = TransactionHelper.startTransaction();\n-                try {\n-                    reconnected = new ReconnectedEventBundleImpl(filtered, listeners.toString());\n+                    boolean ok = false;\n+                    ReconnectedEventBundle reconnected = null;\n+                    // transaction timeout is managed by the FutureTask\n+                    boolean tx = TransactionHelper.startTransaction();\n+                    try {\n+                        reconnected = new ReconnectedEventBundleImpl(filtered, listeners.toString());\n \n-                    listener.asPostCommitListener().handleEvent(reconnected);\n+                        listener.asPostCommitListener().handleEvent(reconnected);\n \n-                    ok = true;\n-                    // don't check for interrupted flag, the event completed normally, no reason to rollback\n-                } catch (RuntimeException e) {\n-                    log.error(\"Events postcommit execution encountered exception for listener: {}\", listener::getName,\n-                            () -> e);\n-                    // don't rethrow, but rollback (ok=false) and continue loop\n-                } finally {\n-                    try {\n-                        if (reconnected != null) {\n-                            reconnected.disconnect();\n-                        }\n+                        ok = true;\n+                        // don't check for interrupted flag, the event completed normally, no reason to rollback\n+                    } catch (RuntimeException e) {\n+                        log.error(\"Events postcommit execution encountered exception for listener: {}\",\n+                                listener::getName, () -> e);\n+                        // don't rethrow, but rollback (ok=false) and continue loop\n+                        span.setStatus(Status.UNKNOWN);\n                     } finally {\n-                        if (tx) {\n-                            if (!ok) {\n-                                TransactionHelper.setTransactionRollbackOnly();\n-                                log.error(\"Rolling back transaction\");\n+                        try {\n+                            if (reconnected != null) {\n+                                reconnected.disconnect();\n                             }\n-                            TransactionHelper.commitOrRollbackTransaction();\n-                        }\n-                        long elapsed = System.currentTimeMillis() - t1;\n-                        if (stats != null) {\n-                            stats.logAsyncExec(listener, elapsed);\n+                        } finally {\n+                            if (tx) {\n+                                if (!ok) {\n+                                    TransactionHelper.setTransactionRollbackOnly();\n+                                    log.error(\"Rolling back transaction\");\n+                                }\n+                                TransactionHelper.commitOrRollbackTransaction();\n+                            }\n+                            long elapsed = System.currentTimeMillis() - t1;\n+                            if (stats != null) {\n+                                stats.logAsyncExec(listener, elapsed);\n+                            }\n+                            log.debug(\"Events postcommit execution end for listener: {} in {}ms\", listener::getName,\n+                                    () -> elapsed);\n+                            SequenceTracer.stop(\"listener done \" + elapsed + \" ms\");\n+                            span.addAnnotation(\"Listener \" + listener.getName() + \" \" + elapsed + \" ms\");\n                         }\n-                        log.debug(\"Events postcommit execution end for listener: {} in {}ms\", listener::getName,\n-                                () -> elapsed);\n-                        SequenceTracer.stop(\"listener done \" + elapsed + \" ms\");\n                     }\n+                    // even if interrupted due to timeout, we continue the loop\n                 }\n-                // even if interrupted due to timeout, we continue the loop\n+                span.setStatus(Status.OK);\n+            } finally {\n+                span.end();\n             }\n+\n             long elapsed = System.currentTimeMillis() - t0;\n             log.debug(\"Events postcommit execution finished in {}ms\", elapsed);\n             SequenceTracer.stop(\"postcommit done\" + elapsed + \" ms\");\n             return Boolean.TRUE; // no error to report\n         }\n+\n+        protected Span getTracingSpan(String spanName) {\n+            if (traceContext == null) {\n+                return BlankSpan.INSTANCE;\n+            }\n+            Tracer tracer = Tracing.getTracer();\n+            BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat();\n+            try {\n+                SpanContext spanContext = binaryFormat.fromByteArray(traceContext);\n+                Span span = tracer.spanBuilderWithRemoteParent(spanName, spanContext).startSpan();\n+                span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN));\n+                HashMap<String, AttributeValue> map = new HashMap<>();\n+                map.put(\"tx.thread\", AttributeValue.stringAttributeValue(Thread.currentThread().getName()));\n+                map.put(\"bundle.event_count\", AttributeValue.longAttributeValue(bundle.size()));\n+                map.put(\"bundle.caller_thread\", AttributeValue.stringAttributeValue(callerThread));\n+                span.putAttributes(map);\n+                return span;\n+            } catch (SpanContextParseException e) {\n+                log.warn(\"Invalid trace context: \" + traceContext.length);\n+            }\n+            return BlankSpan.INSTANCE;", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2Mzc3NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430163774", "bodyText": "Not needed, there's an empty default method in the Filter interface.", "author": "efge", "createdAt": "2020-05-26T05:30:18Z", "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/internal/TracingWebFilter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.management.jtajca.internal;\n+\n+import java.io.IOException;\n+import java.security.Principal;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpSession;\n+\n+import io.opencensus.trace.AttributeValue;\n+import io.opencensus.trace.EndSpanOptions;\n+import io.opencensus.trace.Span;\n+import io.opencensus.trace.SpanContext;\n+import io.opencensus.trace.Tracing;\n+\n+/**\n+ * Add some tags to span created by OcHttpServletFilter\n+ */\n+public class TracingWebFilter implements Filter {\n+\n+    protected FilterConfig config;\n+\n+    protected static final String USER_KEY = \"http.user\";\n+\n+    protected static final String THREAD_KEY = \"http.thread\";\n+\n+    protected static final String SESSION_KEY = \"http.session\";\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) {\n+        config = filterConfig;\n+    }\n+\n+    @Override\n+    public void destroy() {\n+\n+    }", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NDY2OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430164668", "bodyText": "Please extend HttpFilter instead, which provides more boilerplate (config field, doFilter with a HttpServletRequest).", "author": "efge", "createdAt": "2020-05-26T05:33:36Z", "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/internal/TracingWebFilter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.ecm.core.management.jtajca.internal;\n+\n+import java.io.IOException;\n+import java.security.Principal;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpSession;\n+\n+import io.opencensus.trace.AttributeValue;\n+import io.opencensus.trace.EndSpanOptions;\n+import io.opencensus.trace.Span;\n+import io.opencensus.trace.SpanContext;\n+import io.opencensus.trace.Tracing;\n+\n+/**\n+ * Add some tags to span created by OcHttpServletFilter\n+ */\n+public class TracingWebFilter implements Filter {", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NTA3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430165071", "bodyText": "Unused imports.", "author": "efge", "createdAt": "2020-05-26T05:34:59Z", "path": "modules/core/nuxeo-core-storage-dbs/src/main/java/org/nuxeo/ecm/core/storage/dbs/DBSSession.java", "diffHunk": "@@ -163,6 +163,10 @@\n import io.dropwizard.metrics5.SharedMetricRegistries;\n import io.dropwizard.metrics5.Timer;\n \n+import io.opencensus.trace.AttributeValue;\n+import io.opencensus.trace.Span;\n+import io.opencensus.trace.Tracing;", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NTExNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430165115", "bodyText": "Unused code.", "author": "efge", "createdAt": "2020-05-26T05:35:11Z", "path": "modules/core/nuxeo-core-storage-dbs/src/main/java/org/nuxeo/ecm/core/storage/dbs/DBSSession.java", "diffHunk": "@@ -1633,6 +1637,7 @@ public void removeDocument(String id) {\n     @SuppressWarnings(\"resource\") // Time.Context closed by stop()\n     protected PartialList<String> doQuery(String query, String queryType, QueryFilter queryFilter, int countUpTo) {\n         final Timer.Context timerContext = queryTimer.time();\n+        int match = 0;", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NTE0Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430165147", "bodyText": "Unused", "author": "efge", "createdAt": "2020-05-26T05:35:17Z", "path": "modules/core/nuxeo-core-storage-dbs/src/main/java/org/nuxeo/ecm/core/storage/dbs/DBSSession.java", "diffHunk": "@@ -1643,6 +1648,7 @@ public void removeDocument(String id) {\n                 String id = (String) map.get(idKey);\n                 ids.add(id);\n             }\n+            match = ids.size();", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NTM2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430165366", "bodyText": "Remove extra empty line", "author": "efge", "createdAt": "2020-05-26T05:36:12Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/api/AbstractSession.java", "diffHunk": "@@ -65,6 +65,7 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NTczMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430165733", "bodyText": "Why not call it map like in other uses?", "author": "efge", "createdAt": "2020-05-26T05:37:39Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/api/AbstractSession.java", "diffHunk": "@@ -1188,6 +1193,27 @@ public DocumentModelList query(String query, Filter filter, long limit, long off\n     @Override\n     public DocumentModelList query(String query, String queryType, Filter filter, long limit, long offset,\n             long countUpTo) {\n+        Span span = Tracing.getTracer().getCurrentSpan();\n+        Map<String, AttributeValue> attributes = new HashMap<>();", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NjAwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430166000", "bodyText": "match seems strange. Why not count?", "author": "efge", "createdAt": "2020-05-26T05:38:38Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/api/AbstractSession.java", "diffHunk": "@@ -1188,6 +1193,27 @@ public DocumentModelList query(String query, Filter filter, long limit, long off\n     @Override\n     public DocumentModelList query(String query, String queryType, Filter filter, long limit, long offset,\n             long countUpTo) {\n+        Span span = Tracing.getTracer().getCurrentSpan();\n+        Map<String, AttributeValue> attributes = new HashMap<>();\n+        attributes.put(\"nxql\", AttributeValue.stringAttributeValue(query));\n+        if (filter != null) {\n+            attributes.put(\"filter\", AttributeValue.stringAttributeValue(filter.toString()));\n+        }\n+        attributes.put(\"limit\", AttributeValue.longAttributeValue(limit));\n+        attributes.put(\"offset\", AttributeValue.longAttributeValue(offset));\n+        attributes.put(\"countUpTo\", AttributeValue.longAttributeValue(countUpTo));\n+        span.addAnnotation(\"query\", attributes);\n+\n+        DocumentModelList ret = tracedQuery(query, queryType, filter, limit, offset, countUpTo);\n+\n+        attributes.clear();\n+        attributes.put(\"match\", AttributeValue.longAttributeValue(ret.totalSize()));", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1NjEwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430556109", "bodyText": "ok I prefer totalSize then", "author": "bdelbosc", "createdAt": "2020-05-26T16:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NjAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NjM0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430166345", "bodyText": "match -> count?", "author": "efge", "createdAt": "2020-05-26T05:40:00Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/api/AbstractSession.java", "diffHunk": "@@ -1275,7 +1305,13 @@ public IterableQueryResult queryAndFetch(String query, String queryType, boolean\n             Collection<Transformer> transformers = getPoliciesQueryTransformers(queryType);\n \n             QueryFilter queryFilter = new QueryFilter(principal, principals, permissions, null, transformers, 0, 0);\n-            return getSession().queryAndFetch(query, queryType, queryFilter, distinctDocuments, params);\n+            IterableQueryResult result = getSession().queryAndFetch(query, queryType, queryFilter, distinctDocuments,\n+                    params);\n+\n+            attributes.clear();\n+            attributes.put(\"match\", AttributeValue.longAttributeValue(result.size()));", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1NjQxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430556416", "bodyText": "totalSize", "author": "bdelbosc", "createdAt": "2020-05-26T16:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NjM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NjU4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430166580", "bodyText": "Should log distinctDocuments too (as distinct maybe)", "author": "efge", "createdAt": "2020-05-26T05:40:51Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/api/AbstractSession.java", "diffHunk": "@@ -1267,6 +1293,10 @@ public IterableQueryResult queryAndFetch(String query, String queryType, Object.\n     @Override\n     public IterableQueryResult queryAndFetch(String query, String queryType, boolean distinctDocuments,\n             Object... params) {\n+        Span span = Tracing.getTracer().getCurrentSpan();\n+        Map<String, AttributeValue> attributes = new HashMap<>();\n+        attributes.put(\"nxql\", AttributeValue.stringAttributeValue(query));", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NzAyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430167025", "bodyText": "space after try", "author": "efge", "createdAt": "2020-05-26T05:42:23Z", "path": "modules/platform/nuxeo-automation/nuxeo-automation-server/src/main/java/org/nuxeo/ecm/automation/server/jaxrs/adapters/AsyncOperationAdapter.java", "diffHunk": "@@ -175,19 +188,24 @@ public OperationException onError(OperationException error) {\n         NuxeoPrincipal principal = session.getPrincipal();\n \n         // TODO NXP-26303: use thread pool\n+        SpanContext traceContext = Tracing.getTracer().getCurrentSpan().getContext();\n         new Thread(() -> {\n-            TransactionHelper.runInTransaction(() -> {\n-                LoginComponent.pushPrincipal(principal);\n-                try {\n-                    CoreSession s = CoreInstance.getCoreSession(repoName, principal);\n-                    opCtx.setCoreSession(s);\n-                    service.run(opCtx, opId, xreq.getParams());\n-                } catch (OperationException e) {\n-                    setError(executionId, e);\n-                } finally {\n-                    LoginComponent.popPrincipal();\n-                }\n-            });\n+            Span span = Tracing.getTracer().spanBuilderWithRemoteParent(\"asyncOp.\" + opId, traceContext).startSpan();\n+            span.addLink(Link.fromSpanContext(traceContext, Link.Type.PARENT_LINKED_SPAN));\n+            try(Scope scope = Tracing.getTracer().withSpan(span)) {", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NzgyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430167820", "bodyText": "replaceAll is costly, it this needed or can it be done differently?", "author": "efge", "createdAt": "2020-05-26T05:45:27Z", "path": "modules/runtime/nuxeo-runtime-jtajca/src/main/java/org/nuxeo/runtime/jtajca/NuxeoContainer.java", "diffHunk": "@@ -518,17 +530,48 @@ public void setTransactionTimeout(int seconds) throws SystemException {\n         public void begin() throws NotSupportedException, SystemException {\n             SequenceTracer.start(\"tx begin\", \"#DarkSalmon\");\n             transactionManager.begin();\n+            Tracer tracer = Tracing.getTracer();\n+            Span span = tracer.getCurrentSpan();\n+            if (span instanceof BlankSpan) {\n+                // transaction without trace context\n+                span = tracer.spanBuilder(\"root.transaction\").startSpan();\n+                Scope scope = tracer.withSpan(span);\n+                scopes.put(transactionManager.getTransaction(), scope);\n+            }\n+            HashMap<String, AttributeValue> map = new HashMap<>();\n+            map.put(\"tx.thread\", AttributeValue.stringAttributeValue(Thread.currentThread().getName()));\n+            map.put(\"tx.id\", AttributeValue.stringAttributeValue(getTransactionId()));\n+            span.addAnnotation(\"tx.begin\", map);\n             timers.put(transactionManager.getTransaction(), transactionTimer.time());\n             concurrentCount.inc();\n             if (concurrentCount.getCount() > concurrentMaxCount.getCount()) {\n                 concurrentMaxCount.inc();\n             }\n         }\n \n+        protected String getTransactionId() {\n+            return transactionKeyAsString(((TransactionManagerImpl) transactionManager).getTransactionKey());\n+        }\n+\n+        protected static String transactionKeyAsString(Object key) {\n+            if (key instanceof XidImpl) {\n+                byte[] globalId = ((XidImpl) key).getGlobalTransactionId();\n+                StringBuilder buffer = new StringBuilder();\n+                for (byte aGlobalId : globalId) {\n+                    buffer.append(Integer.toHexString(aGlobalId));\n+                }\n+                return buffer.toString().replaceAll(\"0*$\", \"\");", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4MjkwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430882902", "bodyText": "replaced with substring", "author": "bdelbosc", "createdAt": "2020-05-27T06:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NzgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2OTQyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430169423", "bodyText": "Can we use our DurationUtils.parse here, a timeout attribute and have a default expressed in code as a Duration too like DEFAULT_TIMEOUT = Duration.ofSeconds(10)", "author": "efge", "createdAt": "2020-05-26T05:50:49Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/JaegerReporter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.trace.jaeger.JaegerExporterConfiguration;\n+import io.opencensus.exporter.trace.jaeger.JaegerTraceExporter;\n+import io.opencensus.trace.Tracing;\n+import io.opencensus.trace.config.TraceConfig;\n+import io.opencensus.trace.config.TraceParams;\n+import io.opencensus.trace.samplers.Samplers;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class JaegerReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(JaegerReporter.class);\n+\n+    public static final String URL = \"url\";\n+\n+    public static final String TIMEOUT_SECOND = \"timeoutSecond\";\n+\n+    public static final String DEFAULT_TIMEOUT_SECOND = \"10\";\n+\n+    public static final String MAX_ATTRIBUTES = \"maxAttributes\";\n+\n+    public static final String DEFAULT_MAX_ATTRIBUTES = \"128\";\n+\n+    public static final String MAX_ANNOTATIONS = \"maxAnnotations\";\n+\n+    public static final String DEFAULT_MAX_ANNOTATIONS = \"128\";\n+\n+    public static final String SAMPLER_PROB = \"samplerProbability\";\n+\n+    public static final String DEFAULT_SAMPLER_PROB = \"0.1\";\n+\n+    protected boolean activated;\n+\n+    @Override\n+    public void start(MetricRegistry registry, MetricFilter filter, Set<MetricAttribute> deniedExpansions) {\n+        log.warn(\"Creating Jaeger reporter\");\n+        String url = options.get(URL);\n+        Duration timeout = Duration.create(Long.valueOf(options.getOrDefault(TIMEOUT_SECOND, DEFAULT_TIMEOUT_SECOND)),", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2OTY3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430169678", "bodyText": "Blank line between constants.", "author": "efge", "createdAt": "2020-05-26T05:51:50Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/ZPageReporter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.contrib.zpages.ZPageHandler;\n+import io.opencensus.contrib.zpages.ZPageHandlers;\n+import io.opencensus.exporter.trace.zipkin.ZipkinExporterConfiguration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinTraceExporter;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ZPageReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(ZPageReporter.class);\n+\n+    public static final String PORT = \"port\";\n+    public static final String DEFAULT_PORT = \"8887\";", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2OTk3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430169972", "bodyText": "Same comment as in JaegerReporter", "author": "efge", "createdAt": "2020-05-26T05:52:50Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/ZipkinReporter.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinExporterConfiguration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinTraceExporter;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ZipkinReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(ZipkinReporter.class);\n+\n+    public static final String URL = \"url\";\n+\n+    public static final String TIMEOUT_SECOND = \"timeoutSecond\";\n+\n+    public static final String DEFAULT_TIMEOUT_SECOND = \"10\";\n+\n+    protected boolean activated;\n+\n+    @Override\n+    public void start(MetricRegistry registry, MetricFilter filter, Set<MetricAttribute> deniedExpansions) {\n+        log.warn(\"Creating Zipkin reporter\");\n+        String url = options.get(URL);\n+        Duration timeout = Duration.create(Long.valueOf(options.getOrDefault(TIMEOUT_SECOND, DEFAULT_TIMEOUT_SECOND)),", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDEyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430170122", "bodyText": "Isn't this a concern?", "author": "efge", "createdAt": "2020-05-26T05:53:16Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/ZPageReporter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.contrib.zpages.ZPageHandler;\n+import io.opencensus.contrib.zpages.ZPageHandlers;\n+import io.opencensus.exporter.trace.zipkin.ZipkinExporterConfiguration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinTraceExporter;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ZPageReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(ZPageReporter.class);\n+\n+    public static final String PORT = \"port\";\n+    public static final String DEFAULT_PORT = \"8887\";\n+\n+    protected boolean activated;\n+\n+    @Override\n+    public void start(MetricRegistry registry, MetricFilter filter, Set<MetricAttribute> deniedExpansions) {\n+        log.warn(\"Creating ZPage reporter\");\n+        int port = Integer.parseInt(options.getOrDefault(PORT, DEFAULT_PORT));\n+        try {\n+            ZPageHandlers.startHttpServerAndRegisterAll(port);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(\"Cannot start ZPage server on port: \" + port, e);\n+        }\n+        activated = true;\n+    }\n+\n+    @Override\n+    public void stop() {\n+        log.debug(\"Stop reporting\");\n+        if (activated) {\n+            // no way to stop the ZPage ...", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NzYxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430567619", "bodyText": "the method to unregister zpage is missing, I don't think this is a problem.", "author": "bdelbosc", "createdAt": "2020-05-26T16:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDUxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430170519", "bodyText": "Please check with @kevinleturc but I don't think we need an activated boolean, it's possible that the framework guarantees that stop is called only once and after a start.", "author": "efge", "createdAt": "2020-05-26T05:54:30Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/JaegerReporter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.trace.jaeger.JaegerExporterConfiguration;\n+import io.opencensus.exporter.trace.jaeger.JaegerTraceExporter;\n+import io.opencensus.trace.Tracing;\n+import io.opencensus.trace.config.TraceConfig;\n+import io.opencensus.trace.config.TraceParams;\n+import io.opencensus.trace.samplers.Samplers;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class JaegerReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(JaegerReporter.class);\n+\n+    public static final String URL = \"url\";\n+\n+    public static final String TIMEOUT_SECOND = \"timeoutSecond\";\n+\n+    public static final String DEFAULT_TIMEOUT_SECOND = \"10\";\n+\n+    public static final String MAX_ATTRIBUTES = \"maxAttributes\";\n+\n+    public static final String DEFAULT_MAX_ATTRIBUTES = \"128\";\n+\n+    public static final String MAX_ANNOTATIONS = \"maxAnnotations\";\n+\n+    public static final String DEFAULT_MAX_ANNOTATIONS = \"128\";\n+\n+    public static final String SAMPLER_PROB = \"samplerProbability\";\n+\n+    public static final String DEFAULT_SAMPLER_PROB = \"0.1\";\n+\n+    protected boolean activated;\n+\n+    @Override\n+    public void start(MetricRegistry registry, MetricFilter filter, Set<MetricAttribute> deniedExpansions) {\n+        log.warn(\"Creating Jaeger reporter\");\n+        String url = options.get(URL);\n+        Duration timeout = Duration.create(Long.valueOf(options.getOrDefault(TIMEOUT_SECOND, DEFAULT_TIMEOUT_SECOND)),\n+                0);\n+        JaegerExporterConfiguration configuration = JaegerExporterConfiguration.builder()\n+                                                                               .setServiceName(\"nuxeo\")\n+                                                                               .setThriftEndpoint(url)\n+                                                                               .setDeadline(timeout)\n+                                                                               .build();\n+        JaegerTraceExporter.createAndRegister(configuration);\n+        activated = true;\n+        enableTracing(options);\n+    }\n+\n+    public static void enableTracing(Map<String, String> options) {\n+        TraceConfig traceConfig = Tracing.getTraceConfig();\n+        TraceParams activeTraceParams = traceConfig.getActiveTraceParams();\n+        TraceParams.Builder builder = activeTraceParams.toBuilder();\n+        int maxAttributes = Integer.parseInt(options.getOrDefault(MAX_ATTRIBUTES, DEFAULT_MAX_ATTRIBUTES));\n+        int maxAnnotations = Integer.parseInt(options.getOrDefault(MAX_ANNOTATIONS, DEFAULT_MAX_ANNOTATIONS));\n+        builder.setMaxNumberOfAttributes(maxAttributes).setMaxNumberOfAnnotations(maxAnnotations);\n+        float samplerProbability = Float.valueOf(options.getOrDefault(SAMPLER_PROB, DEFAULT_SAMPLER_PROB));\n+        if (samplerProbability >= 0.999) {\n+            builder.setSampler(Samplers.alwaysSample());\n+        } else if (samplerProbability <= 0.001) {\n+            builder.setSampler(Samplers.neverSample());\n+        } else {\n+            builder.setSampler(Samplers.probabilitySampler(samplerProbability));\n+        }\n+        traceConfig.updateActiveTraceParams(builder.build());\n+    }\n+\n+    @Override\n+    public void stop() {\n+        log.debug(\"Stop reporting\");\n+        if (activated) {", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI0NzczMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430247730", "bodyText": "Agree, the runtime guarantees the activate/start/stop/deactivate lifecycle and each stage is called only once per component.\nHere, the only benefit I saw to have the activated boolean is to make these classes stateless regarding the error case. Indeed if start stage fails but don't crash the runtime, the stop stage will be called. We may want to have this try/catch mechanism on the component starting these reporters and not register them if so, as it during stop we will stop only the active ones?", "author": "kevinleturc", "createdAt": "2020-05-26T08:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5Mjk2MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430892961", "bodyText": "I have no way to check if the exporter is started so I use a boolean to make sure unregister is called only when exporter start succeed. In case of failure during start, it prevents to get also a failure during stop.", "author": "bdelbosc", "createdAt": "2020-05-27T06:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5OTIwNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430999204", "bodyText": "We have an operation to start/stop reporters, indeed we need this boolean \ud83d\udc4d.", "author": "kevinleturc", "createdAt": "2020-05-27T09:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MTc4NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430171785", "bodyText": "I think this can be just a Map", "author": "efge", "createdAt": "2020-05-26T05:58:29Z", "path": "modules/runtime/nuxeo-stream/src/main/java/org/nuxeo/lib/stream/computation/log/ComputationRunner.java", "diffHunk": "@@ -292,7 +307,6 @@ protected boolean processTimer() {\n             return false;\n         }\n         long now = System.currentTimeMillis();\n-        final boolean[] timerUpdate = { false };\n         // filter and order timers\n         LinkedHashMap<String, Long> sortedTimer = timers.entrySet()", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg3NzQ4MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430877481", "bodyText": "an ordered map is needed here but this is not part of the PR", "author": "bdelbosc", "createdAt": "2020-05-27T06:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MjMyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430172329", "bodyText": "No need for .toString() (also in next method)", "author": "efge", "createdAt": "2020-05-26T06:00:09Z", "path": "modules/runtime/nuxeo-stream/src/main/java/org/nuxeo/lib/stream/computation/log/ComputationRunner.java", "diffHunk": "@@ -478,16 +557,24 @@ protected void saveState() {\n     protected void saveOffsets() {\n         if (tailer != null) {\n             tailer.commit();\n+            Span span = Tracing.getTracer().getCurrentSpan();\n+            span.addAnnotation(\"Checkpoint positions\" + Instant.now().toString());", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MzI3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430173272", "bodyText": "No need for this extra empty line", "author": "efge", "createdAt": "2020-05-26T06:03:01Z", "path": "modules/core/nuxeo-core-management-jtajca/src/main/java/org/nuxeo/ecm/core/management/jtajca/internal/Log4jWebFilter.java", "diffHunk": "@@ -57,6 +57,7 @@ public void destroy() {\n     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n             ServletException {\n         try {\n+", "originalCommit": "df6b7c745cd2181c08203520d92566b40f87f9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE3MzYxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430173619", "bodyText": "Bad link", "author": "efge", "createdAt": "2020-05-26T06:04:12Z", "path": "modules/runtime/nuxeo-common/src/main/java/org/nuxeo/common/logging/SequenceTracer.java", "diffHunk": "@@ -25,7 +25,9 @@\n  * Helper to log information that can be displayed using plantuml to render sequence UML diagram.\n  *\n  * @since 8.1\n+ * @deprecated since 11.1 use {#io.opencensus.trace.Tracing} instead.", "originalCommit": "4062d06a31684efe610267a32446bad723f022d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MjIzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r430942232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        AttributeValue.stringAttributeValue(docContext.getSourceDocument().getId()));\n          \n          \n            \n                                        AttributeValue.stringAttributeValue(id));", "author": "kevinleturc", "createdAt": "2020-05-27T08:23:58Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/event/impl/EventServiceImpl.java", "diffHunk": "@@ -299,53 +304,83 @@ public void fireEvent(Event event) {\n             if (event.isImmediate()) {\n                 EventBundleImpl b = new EventBundleImpl();\n                 b.push(shallowEvent);\n+                tracer.getCurrentSpan().addAnnotation(\"Event fire immediate bundle \" + event.getName());\n                 fireEventBundle(b);\n             } else {\n                 recordEvent(shallowEvent);\n             }\n         }\n     }\n \n+    protected void traceAddAnnotation(Event event, Tracer tracer, long elapsed, String listener) {\n+        Map<String, AttributeValue> attributes = new HashMap<>();\n+        attributes.put(\"event\", AttributeValue.stringAttributeValue(event.getName()));\n+        attributes.put(\"listener\", AttributeValue.stringAttributeValue(listener));\n+        attributes.put(\"duration_ms\", AttributeValue.longAttributeValue(elapsed));\n+        EventContext eventContext = event.getContext();\n+        if (eventContext instanceof DocumentEventContext) {\n+            DocumentEventContext docContext = ((DocumentEventContext) eventContext);\n+            if (docContext.getSourceDocument() != null) {\n+                Path docPath = docContext.getSourceDocument().getPath();\n+                if (docPath != null) {\n+                    attributes.put(\"doc\", AttributeValue.stringAttributeValue(docPath.toString()));\n+                }\n+                String id = docContext.getSourceDocument().getId();\n+                if (id != null) {\n+                    attributes.put(\"doc_id\",\n+                            AttributeValue.stringAttributeValue(docContext.getSourceDocument().getId()));", "originalCommit": "4062d06a31684efe610267a32446bad723f022d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwMDU1Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r431000552", "bodyText": "Why moving the constant?", "author": "kevinleturc", "createdAt": "2020-05-27T09:59:07Z", "path": "modules/runtime/nuxeo-stream/src/main/java/org/nuxeo/lib/stream/computation/Record.java", "diffHunk": "@@ -41,32 +46,30 @@\n @SuppressWarnings(\"deprecation\")\n public class Record implements Externalizable {\n \n-    protected static final byte[] NO_DATA = new byte[0];\n-\n     // Externalizable do rely on serialVersionUID\n-    static final long serialVersionUID = 2017_05_29L;\n+    static final long serialVersionUID = 2020_05_23L;\n \n-    /** @deprecated 10.2 use {@link #getWatermark()} or {@link #setWatermark(long)} instead */\n-    @Deprecated\n-    public long watermark;\n+    protected long watermark;\n \n-    /** @deprecated 10.2 use {@link #getKey()} or {@link #setKey(String)} instead */\n-    @Deprecated\n-    public String key;\n+    protected String key;\n \n-    /** @deprecated 10.2 use {@link #getData()} or {@link #setData(byte[])} instead */\n-    @Deprecated\n-    // We can not use null because Nullable on byte[] requires avro 1.7.6 cf AVRO-1401\n-    public byte[] data = NO_DATA;\n+    @Nullable\n+    protected byte[] data;\n+\n+    protected static final byte[] NO_DATA = new byte[0];", "originalCommit": "4062d06a31684efe610267a32446bad723f022d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81e5fa9723e8ca675355d7ad1649bce4daab825a", "url": "https://github.com/nuxeo/nuxeo/commit/81e5fa9723e8ca675355d7ad1649bce4daab825a", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T13:47:43Z", "type": "forcePushed"}, {"oid": "3ac4d94c1207ea1224917feb1d889a273b70f656", "url": "https://github.com/nuxeo/nuxeo/commit/3ac4d94c1207ea1224917feb1d889a273b70f656", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T14:24:42Z", "type": "forcePushed"}, {"oid": "2ff858d289ff73a1fd4305b90c33f7f810229ebc", "url": "https://github.com/nuxeo/nuxeo/commit/2ff858d289ff73a1fd4305b90c33f7f810229ebc", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T14:26:22Z", "type": "forcePushed"}, {"oid": "d2742dc8352ee4bbd47ecb75ceca1e220bbb7eb6", "url": "https://github.com/nuxeo/nuxeo/commit/d2742dc8352ee4bbd47ecb75ceca1e220bbb7eb6", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T14:51:49Z", "type": "forcePushed"}, {"oid": "21a7ed78e77c75db9fc7245cb3ea7c45f145e451", "url": "https://github.com/nuxeo/nuxeo/commit/21a7ed78e77c75db9fc7245cb3ea7c45f145e451", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T16:03:56Z", "type": "forcePushed"}, {"oid": "82b8db59e175f1861ff3c630b4384b7f2199e412", "url": "https://github.com/nuxeo/nuxeo/commit/82b8db59e175f1861ff3c630b4384b7f2199e412", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-27T16:47:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQwMTk0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r431401941", "bodyText": "Clearer I think:\n    Duration timeout = Duration.fromMillis(DurationUtils.parsePositive(options.get(TIMEOUT), DEFAULT_TIMEOUT).toMillis());", "author": "efge", "createdAt": "2020-05-27T19:47:00Z", "path": "modules/runtime/nuxeo-runtime-metrics/src/main/java/org/nuxeo/runtime/metrics/reporter/ZipkinReporter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     bdelbosc\n+ */\n+package org.nuxeo.runtime.metrics.reporter;\n+\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.common.utils.DurationUtils;\n+import org.nuxeo.runtime.metrics.AbstractMetricsReporter;\n+\n+import io.dropwizard.metrics5.MetricAttribute;\n+import io.dropwizard.metrics5.MetricFilter;\n+import io.dropwizard.metrics5.MetricRegistry;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinExporterConfiguration;\n+import io.opencensus.exporter.trace.zipkin.ZipkinTraceExporter;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ZipkinReporter extends AbstractMetricsReporter {\n+\n+    private static final Logger log = LogManager.getLogger(ZipkinReporter.class);\n+\n+    public static final String URL = \"url\";\n+\n+    public static final String TIMEOUT = \"timeout\";\n+\n+    public static final java.time.Duration DEFAULT_TIMEOUT = java.time.Duration.ofSeconds(10);\n+\n+    protected boolean activated;\n+\n+    @Override\n+    public void start(MetricRegistry registry, MetricFilter filter, Set<MetricAttribute> deniedExpansions) {\n+        log.warn(\"Creating Zipkin reporter\");\n+        String url = options.get(URL);\n+        Duration timeout = Duration.create(\n+                DurationUtils.parsePositive(options.get(TIMEOUT), DEFAULT_TIMEOUT).getSeconds(), 0);", "originalCommit": "82b8db59e175f1861ff3c630b4384b7f2199e412", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MjU3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r431652576", "bodyText": "it is an opencensus Duration object not java.time.Duration", "author": "bdelbosc", "createdAt": "2020-05-28T08:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQwMTk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5MzY1OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r431693658", "bodyText": "Yes I know but it still has a fromMillis method", "author": "efge", "createdAt": "2020-05-28T09:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQwMTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQwMjkzMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4069#discussion_r431402931", "bodyText": "Could you move this one up in the catch too please?", "author": "efge", "createdAt": "2020-05-27T19:48:51Z", "path": "modules/core/nuxeo-core-event/src/main/java/org/nuxeo/ecm/core/work/AbstractWork.java", "diffHunk": "@@ -353,35 +367,72 @@ public void run() {\n             suspended();\n             return;\n         }\n-        if (SequenceTracer.isEnabled()) {\n-            SequenceTracer.startFrom(callerThread, \"Work \" + getTitleOr(\"unknown\"), \" #7acde9\");\n-        }\n-        RuntimeException suppressed = null;\n-        int retryCount = getRetryCount(); // may be 0\n-        for (int i = 0; i <= retryCount; i++) {\n-            if (i > 0) {\n-                log.debug(\"Retrying work due to concurrent update (\" + i + \"): \" + this);\n-                log.trace(\"Concurrent update\", suppressed);\n-            }\n-            if (ExceptionUtils.hasInterruptedCause(suppressed)) {\n-                // if we're here suppressed != null so we destroy SequenceTracer\n-                log.debug(\"No need to retry the work with id=\" + getId() + \", work manager is shutting down\");\n-                break;\n-            }\n-            try {\n-                runWorkWithTransaction();\n-                SequenceTracer.stop(\"Work done \" + (completionTime - startTime) + \" ms\");\n-                return;\n-            } catch (RuntimeException e) {\n-                if (suppressed == null) {\n-                    suppressed = e;\n-                } else {\n-                    suppressed.addSuppressed(e);\n+        Span span = getSpanFromContext(traceContext);\n+        try (Scope scope = Tracing.getTracer().withSpan(span)) {\n+            RuntimeException suppressed = null;\n+            int retryCount = getRetryCount(); // may be 0\n+            for (int i = 0; i <= retryCount; i++) {\n+                if (i > 0) {\n+                    span.addAnnotation(\"AbstractWork#run Retrying \" + i);\n+                    log.debug(\"Retrying work due to concurrent update (\" + i + \"): \" + this);\n+                    log.trace(\"Concurrent update\", suppressed);\n+                }\n+                if (ExceptionUtils.hasInterruptedCause(suppressed)) {\n+                    log.debug(\"No need to retry the work with id=\" + getId() + \", work manager is shutting down\");\n+                    break;\n+                }\n+                try {\n+                    runWorkWithTransaction();\n+                    span.setStatus(Status.OK);\n+                    return;\n+                } catch (RuntimeException e) {\n+                    span.addAnnotation(\"AbstractSession#run Failure: \" + e.getMessage());\n+                    span.setStatus(Status.UNKNOWN);\n+                    if (suppressed == null) {\n+                        suppressed = e;\n+                    } else {\n+                        suppressed.addSuppressed(e);\n+                    }\n                 }\n             }\n+            workFailed(suppressed);\n+        } finally {\n+            span.end();\n         }\n+    }\n \n-        workFailed(suppressed);\n+    protected Span getSpanFromContext(byte[] traceContext) {\n+        if (traceContext == null || traceContext.length == 0) {\n+            return BlankSpan.INSTANCE;\n+        }\n+        Tracer tracer = Tracing.getTracer();\n+        BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat();\n+        try {\n+            // followsFrom relationship\n+            SpanContext spanContext = binaryFormat.fromByteArray(traceContext);\n+            Span span = tracer.spanBuilderWithRemoteParent(\"work/\" + getClass().getSimpleName(), spanContext)\n+                              .startSpan();\n+            span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN));\n+            HashMap<String, AttributeValue> map = new HashMap<>();\n+            map.put(\"tx.thread\", AttributeValue.stringAttributeValue(Thread.currentThread().getName()));\n+            map.put(\"work.id\", AttributeValue.stringAttributeValue(getId()));\n+            map.put(\"work.category\", AttributeValue.stringAttributeValue(getCategory()));\n+            map.put(\"work.title\", AttributeValue.stringAttributeValue(getTitle()));\n+            map.put(\"work.parent_path\", AttributeValue.stringAttributeValue(getSchedulePath().getParentPath()));\n+            map.put(\"work.caller_thread\", AttributeValue.stringAttributeValue(callerThread));\n+            map.put(\"work.to_string\", AttributeValue.stringAttributeValue(toString()));\n+            if (docId != null) {\n+                map.put(\"work.doc_id\", AttributeValue.stringAttributeValue(docId));\n+            }\n+            if (docIds != null && !docIds.isEmpty()) {\n+                map.put(\"work.doc_count\", AttributeValue.longAttributeValue(docIds.size()));\n+            }\n+            span.putAttributes(map);\n+            return span;\n+        } catch (SpanContextParseException e) {\n+            log.warn(\"No span context \" + traceContext.length);\n+        }\n+        return BlankSpan.INSTANCE;", "originalCommit": "82b8db59e175f1861ff3c630b4384b7f2199e412", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "693d9965b859840f8ea8b47accc7d7848cb8ba90", "url": "https://github.com/nuxeo/nuxeo/commit/693d9965b859840f8ea8b47accc7d7848cb8ba90", "message": "NXP-27019: Add tracing capabilities using OpenCensus\n\nAdd tracing on asynchronous work and computation.\nAdd tracing annotation on session.\nAdd Zipkin and Jaeger reporter.\nUpgrade to Avro 1.9.2 to enable Nullable on byte[].", "committedDate": "2020-05-28T08:03:39Z", "type": "commit"}, {"oid": "424d2a69d3865d01b1123a39d787774297e68d05", "url": "https://github.com/nuxeo/nuxeo/commit/424d2a69d3865d01b1123a39d787774297e68d05", "message": "NXP-27019: Deprecate and remove usage of SequenceTracer\n\nNow superseded by opencensus tracing", "committedDate": "2020-05-28T08:03:39Z", "type": "commit"}, {"oid": "6f8c44ecf9abad1c187135cd30c94fcaae192320", "url": "https://github.com/nuxeo/nuxeo/commit/6f8c44ecf9abad1c187135cd30c94fcaae192320", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-28T08:03:39Z", "type": "commit"}, {"oid": "6f8c44ecf9abad1c187135cd30c94fcaae192320", "url": "https://github.com/nuxeo/nuxeo/commit/6f8c44ecf9abad1c187135cd30c94fcaae192320", "message": "NXP-27019: Trace Elasticsearch Rest client", "committedDate": "2020-05-28T08:03:39Z", "type": "forcePushed"}]}