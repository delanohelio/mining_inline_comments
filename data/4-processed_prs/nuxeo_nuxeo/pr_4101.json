{"pr_number": 4101, "pr_title": "NXP-28758 / NXP-28370: version security", "pr_createdAt": "2020-06-02T09:25:02Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/4101", "timeline": [{"oid": "25ee9c3526130e52d3eb2d873389a4d1dd6152fe", "url": "https://github.com/nuxeo/nuxeo/commit/25ee9c3526130e52d3eb2d873389a4d1dd6152fe", "message": "NXP-28758: allow version ACLs to be taken into account", "committedDate": "2020-06-02T11:36:54Z", "type": "forcePushed"}, {"oid": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a", "url": "https://github.com/nuxeo/nuxeo/commit/82f3d3a11bd4aeab9c37a639ff53aa78b75d968a", "message": "NXP-28758: allow version ACLs to be taken into account", "committedDate": "2020-06-05T11:24:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDY3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438760678", "bodyText": "missing new line", "author": "NourNuxeo", "createdAt": "2020-06-11T12:55:50Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.blob.DocumentBlobManager;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Common code for VCS and DBS {@link Session} implementations.\n+ *\n+ * @since 11.1\n+ */\n+public abstract class BaseSession implements Session<QueryFilter> {\n+\n+    protected final Repository repository;\n+\n+    protected BaseSession(Repository repository) {\n+        this.repository = repository;\n+    }\n+\n+    protected DocumentBlobManager getDocumentBlobManager() {\n+        return Framework.getService(DocumentBlobManager.class);\n+    }\n+\n+    protected void notifyAfterCopy(Document doc) {\n+        getDocumentBlobManager().notifyAfterCopy(doc);\n+    }\n+\n+    /*\n+     * ----- Common ACP code -----\n+     */\n+\n+    protected void checkNegativeAcl(ACP acp) {\n+        if (acp == null || isNegativeAclAllowed()) {\n+            return;\n+        }\n+        for (ACL acl : acp.getACLs()) {\n+            if (acl.getName().equals(ACL.INHERITED_ACL)) {\n+                continue;\n+            }\n+            for (ACE ace : acl.getACEs()) {\n+                if (ace.isGranted()) {\n+                    continue;\n+                }\n+                String permission = ace.getPermission();\n+                if (permission.equals(SecurityConstants.EVERYTHING)\n+                        && ace.getUsername().equals(SecurityConstants.EVERYONE)) {\n+                    continue;\n+                }\n+                // allow Write, as we're sure it doesn't include Read/Browse\n+                if (permission.equals(SecurityConstants.WRITE)) {\n+                    continue;\n+                }\n+                throw new IllegalArgumentException(\"Negative ACL not allowed: \" + ace);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the ACP for the document (without any inheritance).\n+     *\n+     * @param doc the document\n+     * @return the ACP\n+     */\n+    public abstract ACP getACP(Document doc);\n+\n+    @Override\n+    public ACP getMergedACP(Document doc) {\n+        Document base = doc.isVersion() ? doc.getSourceDocument() : doc;\n+        if (base == null) {\n+            return null;\n+        }\n+        ACP acp = getACP(base);\n+        if (doc.getParent() == null) {\n+            return acp;\n+        }\n+        // get inherited ACLs only if no blocking inheritance ACE exists in the top level ACP\n+        ACL acl = null;\n+        if (acp == null || acp.getAccess(SecurityConstants.EVERYONE, SecurityConstants.EVERYTHING) != Access.DENY) {\n+            acl = getInheritedACLs(doc);\n+        }\n+        if (acp == null) {\n+            if (acl == null) {\n+                return null;\n+            }\n+            acp = new ACPImpl();\n+        }\n+        if (acl != null) {\n+            acp.addACL(acl);\n+        }\n+        return acp;\n+    }\n+\n+    protected ACL getInheritedACLs(Document doc) {\n+        doc = doc.getParent();\n+        ACL merged = null;\n+        while (doc != null) {\n+            ACP acp = getACP(doc);\n+            if (acp != null) {\n+                ACL acl = acp.getMergedACLs(ACL.INHERITED_ACL);\n+                if (merged == null) {\n+                    merged = acl;\n+                } else {\n+                    merged.addAll(acl);\n+                }\n+                if (acp.getAccess(SecurityConstants.EVERYONE, SecurityConstants.EVERYTHING) == Access.DENY) {\n+                    break;\n+                }\n+            }\n+            doc = doc.getParent();\n+        }\n+        return merged;\n+    }\n+\n+    /**\n+     * Returns the merge of two ACPs.\n+     */\n+    protected ACP updateACP(ACP curAcp, ACP addAcp) {\n+        if (curAcp == null) {\n+            return addAcp;\n+        }\n+        ACP newAcp = curAcp.clone(); // clone as we may modify ACLs and ACPs\n+        Map<String, ACL> acls = new HashMap<>();\n+        for (ACL acl : newAcp.getACLs()) {\n+            String name = acl.getName();\n+            if (ACL.INHERITED_ACL.equals(name)) {\n+                throw new IllegalStateException(curAcp.toString());\n+            }\n+            acls.put(name, acl);\n+        }\n+        for (ACL acl : addAcp.getACLs()) {\n+            String name = acl.getName();\n+            if (ACL.INHERITED_ACL.equals(name)) {\n+                continue;\n+            }\n+            ACL curAcl = acls.get(name);\n+            if (curAcl != null) {\n+                // TODO avoid duplicates\n+                curAcl.addAll(acl);\n+            } else {\n+                newAcp.addACL(acl);\n+            }\n+        }\n+        return newAcp;\n+    }\n+\n+}", "originalCommit": "31a3986c22f18d45305312f14be68217611beef9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MDY5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438850695", "bodyText": "maybe make the members final as they are meant to be set once per instantiation ?", "author": "NourNuxeo", "createdAt": "2020-06-11T15:00:04Z", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;", "originalCommit": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTc2Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439431763", "bodyText": "That would mean writing a constructor, and not being able to update the fields independently which is how this is used today. So no, that would be much more verbosity.", "author": "efge", "createdAt": "2020-06-12T13:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NTk1Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438855957", "bodyText": "Less clarity but maybe this would avoid getting a boolean before knowing if it's aimed at the user regarding the permission ?\nI tried adding a comment not to lose too much readability:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            boolean grant = rs.getShort(1) != 0;\n          \n          \n            \n                            String permission = rs.getString(2);\n          \n          \n            \n                            String user = rs.getString(3);\n          \n          \n            \n                            if (principals.contains(user) && permissions.contains(permission)) {\n          \n          \n            \n                                return grant;\n          \n          \n            \n                            }\n          \n          \n            \n                            String permission = rs.getString(2);\n          \n          \n            \n                            String user = rs.getString(3);\n          \n          \n            \n                            if (principals.contains(user) && permissions.contains(permission)) {\n          \n          \n            \n                                return rs.getShort(1) != 0; // the access grant boolean value\n          \n          \n            \n                            }", "author": "NourNuxeo", "createdAt": "2020-06-11T15:07:45Z", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/EmbeddedFunctions.java", "diffHunk": "@@ -132,82 +143,93 @@ public static boolean isAccessAllowed(Serializable id, Set<String> principals, S\n      * @param id the id of the document\n      * @param principals the allowed identities\n      * @param permissions the allowed permissions\n+     * @param disableVersionACL whether ACLs on a version are disabled\n+     * @since 11.1\n      */\n     public static boolean isAccessAllowed(Connection conn, Serializable id, Set<String> principals,\n-            Set<String> permissions) throws SQLException {\n-        if (isLogEnabled()) {\n-            logDebug(\"isAccessAllowed \" + id + \" \" + principals + \" \" + permissions);\n-        }\n-        try (PreparedStatement ps1 = conn.prepareStatement(\n+            Set<String> permissions, boolean disableVersionACL) throws SQLException {\n+        try (PreparedStatement psAcl = conn.prepareStatement(\n                 \"SELECT \\\"GRANT\\\", \\\"PERMISSION\\\", \\\"USER\\\" FROM \\\"ACLS\\\" WHERE ID = ? AND (STATUS IS NULL OR STATUS = 1) ORDER BY POS\");\n-                PreparedStatement ps2 = conn.prepareStatement(\"SELECT PARENTID FROM HIERARCHY WHERE ID = ?\")) {\n-            boolean first = true;\n-            do {\n-                /*\n-                 * Check permissions at this level.\n-                 */\n-                ps1.setObject(1, id);\n-                try (ResultSet rs = ps1.executeQuery()) {\n-                    while (rs.next()) {\n-                        boolean grant = rs.getShort(1) != 0;\n-                        String permission = rs.getString(2);\n-                        String user = rs.getString(3);\n-                        if (isLogEnabled()) {\n-                            logDebug(\" -> \" + user + \" \" + permission + \" \" + grant);\n-                        }\n-                        if (principals.contains(user) && permissions.contains(permission)) {\n-                            if (isLogEnabled()) {\n-                                logDebug(\" => \" + grant);\n-                            }\n-                            return grant;\n-                        }\n+                PreparedStatement psHier = conn.prepareStatement(\n+                        \"SELECT PARENTID, ISVERSION FROM HIERARCHY WHERE ID = ?\");\n+                PreparedStatement psVer = conn.prepareStatement(\"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n+            RowInfo rowInfo = null; // info about the row for the current id\n+            if (disableVersionACL) {\n+                // if it's a version, ignore its ACL and find the live doc\n+                rowInfo = getRowInfo(psHier, psVer, id);\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                    if (id == null) {\n+                        return false;\n                     }\n+                    rowInfo = null;\n                 }\n-                /*\n-                 * Nothing conclusive found, repeat on the parent.\n-                 */\n-                ps2.setObject(1, id);\n-                Serializable newId;\n-                try (ResultSet rs = ps2.executeQuery()) {\n-                    if (rs.next()) {\n-                        newId = (Serializable) rs.getObject(1);\n-                        if (rs.wasNull()) {\n-                            newId = null;\n-                        }\n-                    } else {\n-                        // no such id\n-                        newId = null;\n-                    }\n+            }\n+            do {\n+                // check permissions at this level\n+                Boolean access = getAccess(psAcl, id, principals, permissions);\n+                if (access != null) {\n+                    return access;\n+                }\n+                // nothing conclusive found, repeat on the parent\n+                if (rowInfo == null) {\n+                    rowInfo = getRowInfo(psHier, psVer, id);\n+                }\n+                if (rowInfo.isVersion) {\n+                    id = rowInfo.versionableId;\n+                } else {\n+                    id = rowInfo.parentId;\n                 }\n-                if (first && newId == null) {\n-                    // there is no parent for the first level\n-                    // we may have a version on our hands, find the live doc\n-                    try (PreparedStatement ps3 = conn.prepareStatement(\n-                            \"SELECT VERSIONABLEID FROM VERSIONS WHERE ID = ?\")) {\n-                        ps3.setObject(1, id);\n-                        try (ResultSet rs = ps3.executeQuery()) {\n-                            if (rs.next()) {\n-                                newId = (Serializable) rs.getObject(1);\n-                                if (rs.wasNull()) {\n-                                    newId = null;\n-                                }\n-                            } else {\n-                                // no such id\n-                                newId = null;\n-                            }\n+                rowInfo = null;\n+            } while (id != null);\n+            // we've reached the root or a placeless document, deny access\n+            return false;\n+        }\n+    }\n+\n+    protected static class RowInfo {\n+\n+        public Serializable parentId;\n+\n+        public boolean isVersion;\n+\n+        public Serializable versionableId;\n+    }\n+\n+    protected static RowInfo getRowInfo(PreparedStatement psHier, PreparedStatement psVer, Serializable id)\n+            throws SQLException {\n+        psHier.setObject(1, id);\n+        try (ResultSet rs = psHier.executeQuery()) {\n+            RowInfo rowInfo = new RowInfo();\n+            if (rs.next()) {\n+                rowInfo.parentId = (Serializable) rs.getObject(1);\n+                rowInfo.isVersion = rs.getBoolean(2);\n+                if (rowInfo.isVersion) {\n+                    psVer.setObject(1, id);\n+                    try (ResultSet rs2 = psVer.executeQuery()) {\n+                        if (rs2.next()) {\n+                            rowInfo.versionableId = (Serializable) rs2.getObject(1);\n                         }\n                     }\n                 }\n-                first = false;\n-                id = newId;\n-            } while (id != null);\n-            /*\n-             * We reached the root, deny access.\n-             */\n-            if (isLogEnabled()) {\n-                logDebug(\" => false (root)\");\n             }\n-            return false;\n+            return rowInfo;\n+        }\n+    }\n+\n+    protected static Boolean getAccess(PreparedStatement psAcl, Serializable id, Set<String> principals,\n+            Set<String> permissions) throws SQLException {\n+        psAcl.setObject(1, id);\n+        try (ResultSet rs = psAcl.executeQuery()) {\n+            while (rs.next()) {\n+                boolean grant = rs.getShort(1) != 0;\n+                String permission = rs.getString(2);\n+                String user = rs.getString(3);\n+                if (principals.contains(user) && permissions.contains(permission)) {\n+                    return grant;\n+                }", "originalCommit": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMzE0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439433144", "bodyText": "I prefer the clarity of getting all the values first, then acting on them. Also, this is just code that was moved.", "author": "efge", "createdAt": "2020-06-12T13:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2ODcxNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r438868715", "bodyText": "Since the signature is not the same maybe it could get rid off the 2 suffix ?\nif the args are not splittable and end in single object collections the name would still be relevant.\nOr is it because of the alias creation you need a distinct name ?\nit seems you can define the arguments types as in java.lang.Integer.parseInt(java.lang.String, int): https://www.h2database.com/html/commands.html#create_alias\nNot sure the result would be pretty with a Connection, 3 String and 1 boolean though...", "author": "NourNuxeo", "createdAt": "2020-06-11T15:26:09Z", "path": "modules/core/nuxeo-core-storage-sql/nuxeo-core-storage-sql-extensions/src/main/java/org/nuxeo/ecm/core/storage/sql/db/H2Functions.java", "diffHunk": "@@ -55,15 +55,34 @@ public static boolean isInTreeString(Connection conn, String id, String baseId)\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * @deprecated since 11.1, unused\n+     */\n+    @Deprecated\n     public static boolean isInTreeLong(Connection conn, Long id, Long baseId) throws SQLException {\n         return isInTree(conn, id, baseId);\n     }\n \n+    /**\n+     * Compatibility signature without {@code disableVersionACL} parameter\n+     */\n     public static boolean isAccessAllowedString(Connection conn, String id, String principals, String permissions)\n             throws SQLException {\n         return isAccessAllowed(conn, id, split(principals), split(permissions));\n     }\n \n+    /**\n+     * @since 11.1\n+     */\n+    public static boolean isAccessAllowed2(Connection conn, String id, String principals, String permissions,", "originalCommit": "82f3d3a11bd4aeab9c37a639ff53aa78b75d968a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzNDM1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r439434351", "bodyText": "Given that this is purely internal I prefer having a short and obviously unambiguous alias definition, so I won't change it.", "author": "efge", "createdAt": "2020-06-12T13:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2ODcxNQ=="}], "type": "inlineReview"}, {"oid": "806a253f3ad909e1240cccfdadd57092718d9411", "url": "https://github.com/nuxeo/nuxeo/commit/806a253f3ad909e1240cccfdadd57092718d9411", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-06-29T23:13:39Z", "type": "forcePushed"}, {"oid": "4176cb3e8dec58b9aa4c2e2992e6ff3485261a64", "url": "https://github.com/nuxeo/nuxeo/commit/4176cb3e8dec58b9aa4c2e2992e6ff3485261a64", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-09-01T18:54:44Z", "type": "forcePushed"}, {"oid": "33e03b37b008f195239002435ba6a5787ad22e5f", "url": "https://github.com/nuxeo/nuxeo/commit/33e03b37b008f195239002435ba6a5787ad22e5f", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-09-01T20:34:11Z", "type": "forcePushed"}, {"oid": "ddbb694af7b66deed6184bfce0c2c52a35458099", "url": "https://github.com/nuxeo/nuxeo/commit/ddbb694af7b66deed6184bfce0c2c52a35458099", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-09-02T17:59:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MjAwNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482782004", "bodyText": "Shouldn't have the same expected for the two checks on user3?", "author": "kevinleturc", "createdAt": "2020-09-03T07:57:04Z", "path": "modules/core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestVersionACLAbstract.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.nuxeo.ecm.core.api.security.SecurityConstants.BROWSE;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.VersioningOption;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.model.BaseSession.VersionAclMode;\n+import org.nuxeo.ecm.core.security.SecurityService;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@RepositoryConfig(cleanup = Granularity.METHOD)\n+public abstract class TestVersionACLAbstract {\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected SecurityService securityService;\n+\n+    protected abstract VersionAclMode getVersionAclMode();\n+\n+    protected abstract boolean isReadVersionPermissionEnabled();\n+\n+    @Test\n+    public void testVersionACL() {\n+        VersionAclMode mode = getVersionAclMode();\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"folder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        ACP acp = new ACPImpl();\n+        acp.addACE(\"acl1\", ACE.BLOCK);\n+        acp.addACE(\"acl1\", new ACE(\"user1\", \"Read\"));\n+        session.setACP(folder.getRef(), acp, true);\n+\n+        DocumentModel file = session.createDocumentModel(\"/folder\", \"file\", \"File\");\n+        file = session.createDocument(file);\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl2\", new ACE(\"user2\", \"Read\"));\n+        session.setACP(file.getRef(), acp, true);\n+\n+        // create a version\n+        DocumentRef verRef = session.checkIn(file.getRef(), VersioningOption.MINOR, null);\n+        String verId = session.getDocument(verRef).getId();\n+        // add ACL on version itself\n+        acp = new ACPImpl();\n+        acp.addACE(\"acl3\", new ACE(\"user3\", \"Read\"));\n+        session.setACP(verRef, acp, true);\n+\n+        // create a proxy pointing to the version\n+        session.createProxy(verRef, folder.getRef());\n+        session.save();\n+        coreFeature.waitForAsyncCompletion(); // DBS read ACL computation is async\n+\n+        // check ACLs on the version\n+        acp = session.getACP(verRef);\n+        List<ACE> aces = acpToAces(acp);\n+        assertEquals(mode == VersionAclMode.ENABLED ? 4 : 3, aces.size());\n+        Iterator<ACE> aceit = aces.iterator();\n+        if (mode == VersionAclMode.ENABLED) {\n+            assertEquals(\"user3\", aceit.next().getUsername());\n+        }\n+        assertEquals(\"user2\", aceit.next().getUsername());\n+        assertEquals(\"user1\", aceit.next().getUsername());\n+        assertEquals(ACE.BLOCK, aceit.next());\n+\n+        // check Browse permission on the ACL\n+        assertCanBrowse(false, acp, \"nosuchuser\");\n+        assertCanBrowse(true, acp, \"user1\");\n+        assertCanBrowse(true, acp, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, acp, \"user3\");\n+\n+        // check Browse permission using CoreSession document API\n+        assertCanBrowse(false, verRef, \"nosuchuser\");\n+        assertCanBrowse(true, verRef, \"user1\");\n+        assertCanBrowse(true, verRef, \"user2\");\n+        assertCanBrowse(mode == VersionAclMode.ENABLED, verRef, \"user3\");\n+\n+        // check Browse permission using CoreSession query API\n+        assertCanQuery(false, verId, \"nosuchuser\");\n+        assertCanQuery(true, verId, \"user1\");\n+        assertCanQuery(true, verId, \"user2\");\n+        assertCanQuery(mode != VersionAclMode.DISABLED, verId, \"user3\");", "originalCommit": "ddbb694af7b66deed6184bfce0c2c52a35458099", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTA3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482949075", "bodyText": "Good question. No, the reason is that there's historically a difference in behavior here, which is captured by the VersionAclMode.LEGACY mode:\n/** Version ACL disabled for direct access but enabled for queries. */\nLEGACY", "author": "efge", "createdAt": "2020-09-03T12:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4ODIzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482788230", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Optional<String> val = configurationService.getString(VERSION_ACL_DISABLED_PROP);\n          \n          \n            \n                        if (!val.isPresent()) {\n          \n          \n            \n                            return ENABLED;\n          \n          \n            \n                        }\n          \n          \n            \n                        String val = configurationService.getString(VERSION_ACL_DISABLED_PROP).orElse(\"false\");\n          \n      \n    \n    \n  \n\n?", "author": "kevinleturc", "createdAt": "2020-09-03T08:06:59Z", "path": "modules/core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/model/BaseSession.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Florent Guillaume\n+ */\n+package org.nuxeo.ecm.core.model;\n+\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.Access;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.ecm.core.blob.DocumentBlobManager;\n+import org.nuxeo.ecm.core.query.QueryFilter;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.services.config.ConfigurationService;\n+\n+/**\n+ * Common code for VCS and DBS {@link Session} implementations.\n+ *\n+ * @since 11.3\n+ */\n+public abstract class BaseSession implements Session<QueryFilter> {\n+\n+    private static final Logger log = LogManager.getLogger(BaseSession.class);\n+\n+    /**\n+     * Configuration property controlling whether ACLs on versions are disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String VERSION_ACL_DISABLED_PROP = \"org.nuxeo.version.acl.disabled\";\n+\n+    /**\n+     * Configuration property controlling whether ReadVersion permission is disabled.\n+     *\n+     * @since 11.3\n+     */\n+    public static final String READ_VERSION_PERM_DISABLED_PROP = \"org.nuxeo.version.readversion.disabled\";\n+\n+    /** INTERNAL. How we deal with ACLs on versions. */\n+    public enum VersionAclMode {\n+        /** Version ACL enabled. */\n+        ENABLED,\n+        /** Version ACL disabled. */\n+        DISABLED,\n+        /** Version ACL disabled for direct access but enabled for queries. */\n+        LEGACY;\n+\n+        public static VersionAclMode getConfiguration() {\n+            if (!Framework.isInitialized()) {\n+                // unit tests\n+                return ENABLED;\n+            }\n+            ConfigurationService configurationService = Framework.getService(ConfigurationService.class);\n+            Optional<String> val = configurationService.getString(VERSION_ACL_DISABLED_PROP);\n+            if (!val.isPresent()) {\n+                return ENABLED;\n+            }", "originalCommit": "ddbb694af7b66deed6184bfce0c2c52a35458099", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MjQwOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4101#discussion_r482962408", "bodyText": "\ud83d\udc4d", "author": "efge", "createdAt": "2020-09-03T13:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4ODIzMA=="}], "type": "inlineReview"}, {"oid": "f69667345363ca5001c536cac543b4f97025c78b", "url": "https://github.com/nuxeo/nuxeo/commit/f69667345363ca5001c536cac543b4f97025c78b", "message": "NXP-28758: factor common Session code into BaseSession", "committedDate": "2020-09-03T13:05:49Z", "type": "commit"}, {"oid": "b746b1de21aa9b1e01a7303cc90257115cc8399c", "url": "https://github.com/nuxeo/nuxeo/commit/b746b1de21aa9b1e01a7303cc90257115cc8399c", "message": "NXP-28758: allow version ACLs to be taken into account", "committedDate": "2020-09-03T13:05:49Z", "type": "commit"}, {"oid": "f9bf4ee97efd4ef53939d14b621f06828a4dd7fd", "url": "https://github.com/nuxeo/nuxeo/commit/f9bf4ee97efd4ef53939d14b621f06828a4dd7fd", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-09-03T13:05:49Z", "type": "commit"}, {"oid": "f9bf4ee97efd4ef53939d14b621f06828a4dd7fd", "url": "https://github.com/nuxeo/nuxeo/commit/f9bf4ee97efd4ef53939d14b621f06828a4dd7fd", "message": "NXP-28370: make version Read permission depend on live doc ReadVersion", "committedDate": "2020-09-03T13:05:49Z", "type": "forcePushed"}]}