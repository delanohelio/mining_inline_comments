{"pr_number": 7887, "pr_title": "Add JwtIssuerReactiveAuthenticationManagerResolver", "pr_createdAt": "2020-02-01T03:24:24Z", "pr_url": "https://github.com/spring-projects/spring-security/pull/7887", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r374959378", "bodyText": "@jzheaux  it is normal that JwtIssuerReactiveAuthenticationManagerResolver implements ReactiveAuthenticationManagerResolver<ServerWebExchange> instead of ReactiveAuthenticationManagerResolver<ServerHttpRequest> ??\n/**\n\t\t * Configures the {@link ReactiveAuthenticationManagerResolver}\n\t\t *\n\t\t * @param authenticationManagerResolver the {@link ReactiveAuthenticationManagerResolver}\n\t\t * @return the {@link OAuth2ResourceServerSpec} for additional configuration\n\t\t * @since 5.2\n\t\t */\n\t\tpublic OAuth2ResourceServerSpec authenticationManagerResolver(\n\t\t\t\tReactiveAuthenticationManagerResolver<ServerHttpRequest> authenticationManagerResolver) {\n\t\t\tAssert.notNull(authenticationManagerResolver, \"authenticationManagerResolver cannot be null\");\n\t\t\tthis.authenticationManagerResolver = authenticationManagerResolver;\n\t\t\treturn this;\n\t\t}", "author": null, "createdAt": "2020-02-04T22:28:42Z", "path": "oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtIssuerReactiveAuthenticationManagerResolver.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.oauth2.server.resource.authentication;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+\n+import com.nimbusds.jwt.JWTParser;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import org.springframework.core.convert.converter.Converter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.lang.NonNull;\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.authentication.ReactiveAuthenticationManager;\n+import org.springframework.security.authentication.ReactiveAuthenticationManagerResolver;\n+import org.springframework.security.oauth2.core.OAuth2AuthenticationException;\n+import org.springframework.security.oauth2.core.OAuth2Error;\n+import org.springframework.security.oauth2.jwt.ReactiveJwtDecoders;\n+import org.springframework.security.oauth2.server.resource.BearerTokenAuthenticationToken;\n+import org.springframework.security.oauth2.server.resource.BearerTokenError;\n+import org.springframework.security.oauth2.server.resource.BearerTokenErrorCodes;\n+import org.springframework.security.oauth2.server.resource.web.server.ServerBearerTokenAuthenticationConverter;\n+import org.springframework.util.Assert;\n+import org.springframework.web.server.ServerWebExchange;\n+\n+/**\n+ * An implementation of {@link ReactiveAuthenticationManagerResolver} that resolves a JWT-based\n+ * {@link ReactiveAuthenticationManager} based on the\n+ * <a href=\"https://openid.net/specs/openid-connect-core-1_0.html#IssuerIdentifier\">Issuer</a> in a\n+ * signed JWT (JWS).\n+ *\n+ * To use, this class must be able to determine whether or not the `iss` claim is trusted. Recall that\n+ * anyone can stand up an authorization server and issue valid tokens to a resource server. The simplest way\n+ * to achieve this is to supply a whitelist of trusted issuers in the constructor.\n+ *\n+ * This class derives the Issuer from the `iss` claim found in the {@link ServerWebExchange}'s\n+ * <a href=\"https://tools.ietf.org/html/rfc6750#section-1.2\" target=\"_blank\">Bearer Token</a>.\n+ *\n+ * @author Josh Cummings\n+ * @since 5.3\n+ */\n+public final class JwtIssuerReactiveAuthenticationManagerResolver\n+\t\timplements ReactiveAuthenticationManagerResolver<ServerWebExchange> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA2MDM5Mg==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r375060392", "bodyText": "Yes, @rmakhlouf, that's correct, thanks for checking. Actually, it's the AuthenticationWebFilter that is mistaken, which you can see in #7872.", "author": "jzheaux", "createdAt": "2020-02-05T05:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY5NDg2OA==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r375694868", "bodyText": "@jzheaux thanks for this looks good.  I'm using spring boot 5.2 so I temporarily back-ported your class into my project (and created a temporary custom ServerBearerTokenAuthenticationConverter) and all is working great in our test environment where we can now support multi tenants :-)", "author": "davidmelia", "createdAt": "2020-02-06T08:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1MDI3NA==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r375750274", "bodyText": "@davidmelia It will be awesome if you can share you adaptation to spring boot 5.2  :)", "author": null, "createdAt": "2020-02-06T10:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5NzMwMw==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r375997303", "bodyText": "Awesome, @davidmelia! Glad to hear it is working for you.", "author": "jzheaux", "createdAt": "2020-02-06T18:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI2NzE5MQ==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r376267191", "bodyText": "@davidmelia It will be awesome if you can share you adaptation to spring boot 5.2 :)\n\nSimply copied and slightly amended ServerBearerTokenAuthenticationConverter and JwtIssuerReactiveAuthenticationManagerResolver\npackage .....;\n\nimport com.nimbusds.jwt.JWTParser;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Predicate;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.lang.NonNull;\nimport org.springframework.security.authentication.ReactiveAuthenticationManager;\nimport org.springframework.security.authentication.ReactiveAuthenticationManagerResolver;\nimport org.springframework.security.oauth2.core.OAuth2AuthenticationException;\nimport org.springframework.security.oauth2.core.OAuth2Error;\nimport org.springframework.security.oauth2.jwt.ReactiveJwtDecoders;\nimport org.springframework.security.oauth2.server.resource.BearerTokenAuthenticationToken;\nimport org.springframework.security.oauth2.server.resource.BearerTokenError;\nimport org.springframework.security.oauth2.server.resource.BearerTokenErrorCodes;\nimport org.springframework.security.oauth2.server.resource.authentication.JwtReactiveAuthenticationManager;\nimport org.springframework.util.Assert;\nimport reactor.core.publisher.Mono;\nimport reactor.core.scheduler.Schedulers;\n\n/**\n * Spring Security 5.3 will contain this resolver so please replace then. This class is to support\n * Auth0 multi tenants.\n */\npublic final class JwtIssuerReactiveAuthenticationManagerResolver implements ReactiveAuthenticationManagerResolver<ServerHttpRequest> {\n  private static final OAuth2Error DEFAULT_INVALID_TOKEN = invalidToken(\"Invalid token\");\n\n  private final ReactiveAuthenticationManagerResolver<String> issuerAuthenticationManagerResolver;\n  private final Converter<ServerHttpRequest, Mono<String>> issuerConverter = new JwtClaimIssuerConverter();\n\n\n  public JwtIssuerReactiveAuthenticationManagerResolver(String... trustedIssuers) {\n    this(Arrays.asList(trustedIssuers));\n  }\n\n  public JwtIssuerReactiveAuthenticationManagerResolver(Collection<String> trustedIssuers) {\n    Assert.notEmpty(trustedIssuers, \"trustedIssuers cannot be empty\");\n    this.issuerAuthenticationManagerResolver = new TrustedIssuerJwtAuthenticationManagerResolver(Collections.unmodifiableCollection(trustedIssuers)::contains);\n  }\n\n\n  public JwtIssuerReactiveAuthenticationManagerResolver(ReactiveAuthenticationManagerResolver<String> issuerAuthenticationManagerResolver) {\n\n    Assert.notNull(issuerAuthenticationManagerResolver, \"issuerAuthenticationManagerResolver cannot be null\");\n    this.issuerAuthenticationManagerResolver = issuerAuthenticationManagerResolver;\n  }\n\n\n  @Override\n  public Mono<ReactiveAuthenticationManager> resolve(ServerHttpRequest exchange) {\n    return this.issuerConverter.convert(exchange)\n        .flatMap(issuer -> this.issuerAuthenticationManagerResolver.resolve(issuer).switchIfEmpty(Mono.error(new OAuth2AuthenticationException(invalidToken(\"Invalid issuer \" + issuer)))));\n  }\n\n  private static class JwtClaimIssuerConverter implements Converter<ServerHttpRequest, Mono<String>> {\n\n    private final ServerBearerTokenAuthenticationConverter converter = new ServerBearerTokenAuthenticationConverter();\n\n    @Override\n    public Mono<String> convert(@NonNull ServerHttpRequest exchange) {\n      return this.converter.convert(exchange).cast(BearerTokenAuthenticationToken.class).flatMap(this::issuer);\n    }\n\n    private Mono<String> issuer(BearerTokenAuthenticationToken token) {\n      try {\n        String issuer = JWTParser.parse(token.getToken()).getJWTClaimsSet().getIssuer();\n        return Mono.justOrEmpty(issuer).switchIfEmpty(Mono.error(new OAuth2AuthenticationException(invalidToken(\"Missing issuer\"))));\n      } catch (Exception e) {\n        return Mono.error(new OAuth2AuthenticationException(invalidToken(e.getMessage())));\n      }\n    }\n  }\n\n  private static class TrustedIssuerJwtAuthenticationManagerResolver implements ReactiveAuthenticationManagerResolver<String> {\n\n    private final Map<String, Mono<? extends ReactiveAuthenticationManager>> authenticationManagers = new ConcurrentHashMap<>();\n    private final Predicate<String> trustedIssuer;\n\n    TrustedIssuerJwtAuthenticationManagerResolver(Predicate<String> trustedIssuer) {\n      this.trustedIssuer = trustedIssuer;\n    }\n\n    @Override\n    public Mono<ReactiveAuthenticationManager> resolve(String issuer) {\n      return Mono.just(issuer).filter(this.trustedIssuer).flatMap(iss -> this.authenticationManagers.computeIfAbsent(iss,\n          k -> Mono.fromCallable(() -> ReactiveJwtDecoders.fromIssuerLocation(iss)).subscribeOn(Schedulers.boundedElastic()).map(JwtReactiveAuthenticationManager::new).cache()));\n    }\n  }\n\n  private static OAuth2Error invalidToken(String message) {\n    try {\n      return new BearerTokenError(BearerTokenErrorCodes.INVALID_TOKEN, HttpStatus.UNAUTHORIZED, message, \"https://tools.ietf.org/html/rfc6750#section-3.1\");\n    } catch (IllegalArgumentException malformed) {\n      // some third-party library error messages are not suitable for RFC 6750's error message charset\n      return DEFAULT_INVALID_TOKEN;\n    }\n  }\n}\n\npackage ...;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.oauth2.core.OAuth2AuthenticationException;\nimport org.springframework.security.oauth2.server.resource.BearerTokenAuthenticationToken;\nimport org.springframework.security.oauth2.server.resource.BearerTokenError;\nimport org.springframework.security.oauth2.server.resource.BearerTokenErrorCodes;\nimport org.springframework.util.StringUtils;\nimport reactor.core.publisher.Mono;\n\n/**\n * Cut and paste of springs ServerBearerTokenAuthenticationConverter. Not needed when Spring 5.3\n * comes in.\n */\nclass ServerBearerTokenAuthenticationConverter {\n  private static final Pattern authorizationPattern = Pattern.compile(\"^Bearer (?<token>[a-zA-Z0-9-._~+/]+)=*$\", Pattern.CASE_INSENSITIVE);\n\n  private boolean allowUriQueryParameter = false;\n\n  public Mono<Authentication> convert(ServerHttpRequest exchange) {\n    return Mono.justOrEmpty(token(exchange)).map(token -> {\n      if (token.isEmpty()) {\n        BearerTokenError error = invalidTokenError();\n        throw new OAuth2AuthenticationException(error);\n      }\n      return new BearerTokenAuthenticationToken(token);\n    });\n  }\n\n  private String token(ServerHttpRequest request) {\n    String authorizationHeaderToken = resolveFromAuthorizationHeader(request.getHeaders());\n    String parameterToken = request.getQueryParams().getFirst(\"access_token\");\n    if (authorizationHeaderToken != null) {\n      if (parameterToken != null) {\n        BearerTokenError error =\n            new BearerTokenError(BearerTokenErrorCodes.INVALID_REQUEST, HttpStatus.BAD_REQUEST, \"Found multiple bearer tokens in the request\", \"https://tools.ietf.org/html/rfc6750#section-3.1\");\n        throw new OAuth2AuthenticationException(error);\n      }\n      return authorizationHeaderToken;\n    } else if (parameterToken != null && isParameterTokenSupportedForRequest(request)) {\n      return parameterToken;\n    }\n    return null;\n  }\n\n  public void setAllowUriQueryParameter(boolean allowUriQueryParameter) {\n    this.allowUriQueryParameter = allowUriQueryParameter;\n  }\n\n  private static String resolveFromAuthorizationHeader(HttpHeaders headers) {\n    String authorization = headers.getFirst(HttpHeaders.AUTHORIZATION);\n    if (StringUtils.startsWithIgnoreCase(authorization, \"bearer\")) {\n      Matcher matcher = authorizationPattern.matcher(authorization);\n\n      if (!matcher.matches()) {\n        BearerTokenError error = invalidTokenError();\n        throw new OAuth2AuthenticationException(error);\n      }\n\n      return matcher.group(\"token\");\n    }\n    return null;\n  }\n\n  private static BearerTokenError invalidTokenError() {\n    return new BearerTokenError(BearerTokenErrorCodes.INVALID_TOKEN, HttpStatus.UNAUTHORIZED, \"Bearer token is malformed\", \"https://tools.ietf.org/html/rfc6750#section-3.1\");\n  }\n\n  private boolean isParameterTokenSupportedForRequest(ServerHttpRequest request) {\n    return this.allowUriQueryParameter && HttpMethod.GET.equals(request.getMethod());\n  }\n}", "author": "davidmelia", "createdAt": "2020-02-07T08:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1OTM3OA=="}], "type": "inlineReview"}, {"oid": "13c6e07f1f3ae3a58849160203db869d1738f5e4", "url": "https://github.com/spring-projects/spring-security/commit/13c6e07f1f3ae3a58849160203db869d1738f5e4", "message": "Add JwtIssuerReactiveAuthenticationManagerResolver\n\nFixes gh-7857", "committedDate": "2020-02-06T18:36:35Z", "type": "commit"}, {"oid": "13c6e07f1f3ae3a58849160203db869d1738f5e4", "url": "https://github.com/spring-projects/spring-security/commit/13c6e07f1f3ae3a58849160203db869d1738f5e4", "message": "Add JwtIssuerReactiveAuthenticationManagerResolver\n\nFixes gh-7857", "committedDate": "2020-02-06T18:36:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5OTU4OQ==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r457199589", "bodyText": "Hello, would you mind update this document/example with a bit more details please?\nI followed the guide, but the method authenticationManagerResolver() in OAuth2ResourceServerConfigurer complained that it's expecting an AuthenticationManagerResolver, but was receiving JwtIssuerReactiveAuthenticationManagerResolver.\nI tried to have my resource server may accept bearer tokens from two different authorization servers, using Spring Boot 2.3.1.RELEASE and spring-security-oauth2-resource-server 5.3.3.RELEASE\nSorry if I have missed something from the guide. Thanks", "author": "cmhuynh", "createdAt": "2020-07-20T09:03:51Z", "path": "docs/manual/src/docs/asciidoc/_includes/reactive/oauth2/resource-server.adoc", "diffHunk": "@@ -1005,6 +1005,77 @@ ReactiveOpaqueTokenIntrospector introspector() {\n }\n ----\n \n+[[oauth2resourceserver-multitenancy]]\n+== Multi-tenancy\n+\n+A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.\n+\n+For example, your resource server may accept bearer tokens from two different authorization servers.\n+Or, your authorization server may represent a multiplicity of issuers.\n+\n+In each case, there are two things that need to be done and trade-offs associated with how you choose to do them:\n+\n+1. Resolve the tenant\n+2. Propagate the tenant\n+\n+=== Resolving the Tenant By Claim\n+\n+One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the `JwtIssuerReactiveAuthenticationManagerResolver`, like so:\n+\n+[source,java]\n+----\n+JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerReactiveAuthenticationManagerResolver\n+    (\"https://idp.example.org/issuerOne\", \"https://idp.example.org/issuerTwo\");\n+\n+http\n+    .authorizeRequests(authorize -> authorize\n+        .anyRequest().authenticated()\n+    )\n+    .oauth2ResourceServer(oauth2 -> oauth2\n+        .authenticationManagerResolver(authenticationManagerResolver)\n+    );", "originalCommit": "13c6e07f1f3ae3a58849160203db869d1738f5e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MzMyMg==", "url": "https://github.com/spring-projects/spring-security/pull/7887#discussion_r457563322", "bodyText": "Sorry to hear you are having trouble, @cmhuynh.\nI believe the issue you've described is because you are trying to use a WebFlux class with the Web DSL. AuthenticationManagerResolver matches with JwtIssuerAuthenticationManagerResolver while ReactiveAuthenticationManagerResolver matches with JwtIssuerReactiveAuthenticationManagerResolver.\nIf you've got a concrete suggestion for how the docs can be improved to help with this issue, please open a separate ticket.", "author": "jzheaux", "createdAt": "2020-07-20T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5OTU4OQ=="}], "type": "inlineReview"}]}