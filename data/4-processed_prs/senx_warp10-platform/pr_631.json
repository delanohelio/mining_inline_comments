{"pr_number": 631, "pr_title": "fix median and percentile aggregators bugs when used as reducer", "pr_createdAt": "2020-01-14T22:39:43Z", "pr_url": "https://github.com/senx/warp10-platform/pull/631", "timeline": [{"oid": "acc8c156408a4d3f0de738cc439ae7ef18f22c04", "url": "https://github.com/senx/warp10-platform/commit/acc8c156408a4d3f0de738cc439ae7ef18f22c04", "message": "recode median aggregator to fix reducer.median bugs", "committedDate": "2020-01-14T22:31:25Z", "type": "commit"}, {"oid": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "url": "https://github.com/senx/warp10-platform/commit/389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "message": "fix of median aggregator", "committedDate": "2020-01-20T14:46:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4NzE1NA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368587154", "bodyText": "Retrieve the name from outside the comparator.", "author": "hbs", "createdAt": "2020-01-20T14:51:32Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -26,147 +26,107 @@\n import io.warp10.script.WarpScriptReducerFunction;\n import io.warp10.script.binary.EQ;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n \n-  public Median(String name) {\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n \n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Remove NO_LOCATION, keep valid latitude and longitude\n-    // Compute median of latitude, median of longitude\n+    // count null value\n     //\n-    ArrayList<Double> validLat = new ArrayList<Double>(locations.length);\n-    ArrayList<Double> validLong = new ArrayList<Double>(locations.length);\n-\n-    for (int i = 0; i < locations.length; i++) {\n-      if (GeoTimeSerie.NO_LOCATION != locations[i]) {\n-        validLat.add(GeoXPLib.fromGeoXPPoint(locations[i])[0]);\n-        validLong.add(GeoXPLib.fromGeoXPPoint(locations[i])[1]);\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n     }\n \n-    long location;\n-\n-    if (0 == validLat.size()) {\n-      location = GeoTimeSerie.NO_LOCATION;\n-    } else if (1 == validLat.size()) {\n-      location = GeoXPLib.toGeoXPPoint(validLat.get(0), validLong.get(0));\n-    } else {\n-      Collections.sort(validLat);\n-      Collections.sort(validLong);\n-      Double medianLatitude;\n-      Double medianLongitude;\n-      int len = validLat.size();\n-      if (0 == len % 2) {\n-        medianLatitude = (validLat.get(len / 2) + validLat.get(len / 2 - 1)) / 2.0D;\n-        medianLongitude = (validLong.get(len / 2) + validLong.get(len / 2 - 1)) / 2.0D;\n-      } else {\n-        medianLatitude = validLat.get(len / 2);\n-        medianLongitude = validLong.get(len / 2);\n-      }\n-      location = GeoXPLib.toGeoXPPoint(medianLatitude, medianLongitude);\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n \n-    //\n-    // Sort elevations.\n-    // As NO_ELEVATION == Long.MIN_VALUE, sorting elevations is a way to exclude NO_ELEVATION efficiently.\n-    // Compute elevation median\n-    //\n-    long elevation;\n-    Arrays.sort(elevations);\n-\n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // set offset to the first valid elevation\n-      int offset = 0;\n-      while (offset < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[offset]) {\n-        offset++;\n-      }\n-      if (offset == elevations.length) {\n-        // there is no valid elevation\n-        elevation = GeoTimeSerie.NO_ELEVATION;\n-      } else if (offset == elevations.length - 1) {\n-        // there is only one valid elevation\n-        elevation = elevations[offset];\n-      } else {\n-        // compute elevation median in the end of the array\n-        int len = elevations.length - offset;\n-        if (0 == len % 2) {\n-          elevation = (elevations[offset + (len / 2)] + elevations[offset + ((len / 2) - 1)]) / 2L;\n-        } else {\n-          elevation = elevations[offset + (len / 2)];\n-        }\n-      }\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n     }\n-\n     //\n-    // Remove nulls, NaN\n-    // Fail on non numeric values.\n+    // sort indices from values, null at the end of the sorted array.\n     //\n-    ArrayList<Number> validValues = new ArrayList<Number>(values.length);\n-    for (int i = 0; i < values.length; i++) {\n-      if (null != values[i]) {\n-        if (values[i] instanceof Number) {\n-          if (!(values[i] instanceof Double && Double.isNaN((Double) values[i]))) {\n-            validValues.add((Number) values[i]);\n-          }\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override\n+      public int compare(Integer idx1, Integer idx2) {\n+        if (null == values[idx1] && null == values[idx2]) {\n+          return 0;\n+        } else if (null == values[idx1] || null == values[idx2]) {\n+          return null == values[idx1] ? 1 : -1;\n+        } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+          return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n         } else {\n-          throw new WarpScriptException(this.getName() + \" cannot compute median of non numeric values.\");\n+          throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");", "originalCommit": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4NzQwNQ==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368587405", "bodyText": "Explain strategy for sorting in the presence of nulls", "author": "hbs", "createdAt": "2020-01-20T14:52:02Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -26,147 +26,107 @@\n import io.warp10.script.WarpScriptReducerFunction;\n import io.warp10.script.binary.EQ;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n \n-  public Median(String name) {\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n \n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Remove NO_LOCATION, keep valid latitude and longitude\n-    // Compute median of latitude, median of longitude\n+    // count null value\n     //\n-    ArrayList<Double> validLat = new ArrayList<Double>(locations.length);\n-    ArrayList<Double> validLong = new ArrayList<Double>(locations.length);\n-\n-    for (int i = 0; i < locations.length; i++) {\n-      if (GeoTimeSerie.NO_LOCATION != locations[i]) {\n-        validLat.add(GeoXPLib.fromGeoXPPoint(locations[i])[0]);\n-        validLong.add(GeoXPLib.fromGeoXPPoint(locations[i])[1]);\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n     }\n \n-    long location;\n-\n-    if (0 == validLat.size()) {\n-      location = GeoTimeSerie.NO_LOCATION;\n-    } else if (1 == validLat.size()) {\n-      location = GeoXPLib.toGeoXPPoint(validLat.get(0), validLong.get(0));\n-    } else {\n-      Collections.sort(validLat);\n-      Collections.sort(validLong);\n-      Double medianLatitude;\n-      Double medianLongitude;\n-      int len = validLat.size();\n-      if (0 == len % 2) {\n-        medianLatitude = (validLat.get(len / 2) + validLat.get(len / 2 - 1)) / 2.0D;\n-        medianLongitude = (validLong.get(len / 2) + validLong.get(len / 2 - 1)) / 2.0D;\n-      } else {\n-        medianLatitude = validLat.get(len / 2);\n-        medianLongitude = validLong.get(len / 2);\n-      }\n-      location = GeoXPLib.toGeoXPPoint(medianLatitude, medianLongitude);\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n \n-    //\n-    // Sort elevations.\n-    // As NO_ELEVATION == Long.MIN_VALUE, sorting elevations is a way to exclude NO_ELEVATION efficiently.\n-    // Compute elevation median\n-    //\n-    long elevation;\n-    Arrays.sort(elevations);\n-\n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // set offset to the first valid elevation\n-      int offset = 0;\n-      while (offset < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[offset]) {\n-        offset++;\n-      }\n-      if (offset == elevations.length) {\n-        // there is no valid elevation\n-        elevation = GeoTimeSerie.NO_ELEVATION;\n-      } else if (offset == elevations.length - 1) {\n-        // there is only one valid elevation\n-        elevation = elevations[offset];\n-      } else {\n-        // compute elevation median in the end of the array\n-        int len = elevations.length - offset;\n-        if (0 == len % 2) {\n-          elevation = (elevations[offset + (len / 2)] + elevations[offset + ((len / 2) - 1)]) / 2L;\n-        } else {\n-          elevation = elevations[offset + (len / 2)];\n-        }\n-      }\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n     }\n-\n     //\n-    // Remove nulls, NaN\n-    // Fail on non numeric values.\n+    // sort indices from values, null at the end of the sorted array.\n     //\n-    ArrayList<Number> validValues = new ArrayList<Number>(values.length);\n-    for (int i = 0; i < values.length; i++) {\n-      if (null != values[i]) {\n-        if (values[i] instanceof Number) {\n-          if (!(values[i] instanceof Double && Double.isNaN((Double) values[i]))) {\n-            validValues.add((Number) values[i]);\n-          }\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override", "originalCommit": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4Nzg5OA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368587898", "bodyText": "If there is only one location (same goes for elevation), wouldn't it be better to return that location (resp. elevation)?", "author": "hbs", "createdAt": "2020-01-20T14:53:03Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -26,147 +26,107 @@\n import io.warp10.script.WarpScriptReducerFunction;\n import io.warp10.script.binary.EQ;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n \n-  public Median(String name) {\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n \n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Remove NO_LOCATION, keep valid latitude and longitude\n-    // Compute median of latitude, median of longitude\n+    // count null value\n     //\n-    ArrayList<Double> validLat = new ArrayList<Double>(locations.length);\n-    ArrayList<Double> validLong = new ArrayList<Double>(locations.length);\n-\n-    for (int i = 0; i < locations.length; i++) {\n-      if (GeoTimeSerie.NO_LOCATION != locations[i]) {\n-        validLat.add(GeoXPLib.fromGeoXPPoint(locations[i])[0]);\n-        validLong.add(GeoXPLib.fromGeoXPPoint(locations[i])[1]);\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n     }\n \n-    long location;\n-\n-    if (0 == validLat.size()) {\n-      location = GeoTimeSerie.NO_LOCATION;\n-    } else if (1 == validLat.size()) {\n-      location = GeoXPLib.toGeoXPPoint(validLat.get(0), validLong.get(0));\n-    } else {\n-      Collections.sort(validLat);\n-      Collections.sort(validLong);\n-      Double medianLatitude;\n-      Double medianLongitude;\n-      int len = validLat.size();\n-      if (0 == len % 2) {\n-        medianLatitude = (validLat.get(len / 2) + validLat.get(len / 2 - 1)) / 2.0D;\n-        medianLongitude = (validLong.get(len / 2) + validLong.get(len / 2 - 1)) / 2.0D;\n-      } else {\n-        medianLatitude = validLat.get(len / 2);\n-        medianLongitude = validLong.get(len / 2);\n-      }\n-      location = GeoXPLib.toGeoXPPoint(medianLatitude, medianLongitude);\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n \n-    //\n-    // Sort elevations.\n-    // As NO_ELEVATION == Long.MIN_VALUE, sorting elevations is a way to exclude NO_ELEVATION efficiently.\n-    // Compute elevation median\n-    //\n-    long elevation;\n-    Arrays.sort(elevations);\n-\n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // set offset to the first valid elevation\n-      int offset = 0;\n-      while (offset < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[offset]) {\n-        offset++;\n-      }\n-      if (offset == elevations.length) {\n-        // there is no valid elevation\n-        elevation = GeoTimeSerie.NO_ELEVATION;\n-      } else if (offset == elevations.length - 1) {\n-        // there is only one valid elevation\n-        elevation = elevations[offset];\n-      } else {\n-        // compute elevation median in the end of the array\n-        int len = elevations.length - offset;\n-        if (0 == len % 2) {\n-          elevation = (elevations[offset + (len / 2)] + elevations[offset + ((len / 2) - 1)]) / 2L;\n-        } else {\n-          elevation = elevations[offset + (len / 2)];\n-        }\n-      }\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n     }\n-\n     //\n-    // Remove nulls, NaN\n-    // Fail on non numeric values.\n+    // sort indices from values, null at the end of the sorted array.\n     //\n-    ArrayList<Number> validValues = new ArrayList<Number>(values.length);\n-    for (int i = 0; i < values.length; i++) {\n-      if (null != values[i]) {\n-        if (values[i] instanceof Number) {\n-          if (!(values[i] instanceof Double && Double.isNaN((Double) values[i]))) {\n-            validValues.add((Number) values[i]);\n-          }\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override\n+      public int compare(Integer idx1, Integer idx2) {\n+        if (null == values[idx1] && null == values[idx2]) {\n+          return 0;\n+        } else if (null == values[idx1] || null == values[idx2]) {\n+          return null == values[idx1] ? 1 : -1;\n+        } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+          return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n         } else {\n-          throw new WarpScriptException(this.getName() + \" cannot compute median of non numeric values.\");\n+          throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n         }\n       }\n-    }\n-\n-    //\n-    // Sort values\n-    // Could be Long or Double, or a mix, if used as a reducer.\n-    //\n-    Collections.sort(validValues, new Comparator<Number>() {\n-      @Override\n-      public int compare(Number o1, Number o2) {\n-        return EQ.compare(o1, o2);\n-      }\n     });\n \n+    long location = 0;\n+    long elevation = GeoTimeSerie.NO_ELEVATION;\n+    Object median;\n \n-    Object median = null;\n+    int nonNullLength = values.length - nullCounter;\n \n-    if (0 != validValues.size()) {\n-      if (validValues.get(0).equals(validValues.get(validValues.size() - 1))) {\n-        // If extrema are identical, use this as the median\n-        median = validValues.get(0);\n-      } else {\n-        int len = validValues.size();\n-        if (0 == len % 2) {\n-          Object low = validValues.get((len / 2) - 1);\n-          Object high = validValues.get(len / 2);\n-          if (low instanceof Long && high instanceof Long) {\n-            median = ((long) low + (long) high) / 2L;\n-          } else {\n-            median = ((double) low + (double) high) / 2.0D;\n-          }\n-        } else {\n-          median = validValues.get(len / 2);\n+    //\n+    // singleton case\n+    //\n+    if (1 == nonNullLength) {\n+      return new Object[]{\n+          tick, locations[indices[0]], elevations[indices[0]], values[indices[0]]\n+      };\n+    } else {\n+      if (0 == nonNullLength % 2) {\n+        //\n+        // even number of non null values, return mean of both values.\n+        // If there is a location for both points, return centroid of locations\n+        // If there is an elevation for both points, return mean of elevations\n+        //\n+        int low = indices[nonNullLength / 2 - 1];\n+        int high = indices[nonNullLength / 2];\n+        median = (((Number) values[low]).doubleValue() + ((Number) values[high]).doubleValue()) / 2.0D;\n+        if (GeoTimeSerie.NO_ELEVATION != elevations[low] && GeoTimeSerie.NO_ELEVATION != elevations[high]) {", "originalCommit": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyMzA2MA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368623060", "bodyText": "fixed.", "author": "pi-r-p", "createdAt": "2020-01-20T16:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4Nzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4ODQ4Mw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368588483", "bodyText": "Shouldn't that be GeoTimeSeries.NO_LOCATION?", "author": "hbs", "createdAt": "2020-01-20T14:54:19Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -26,147 +26,107 @@\n import io.warp10.script.WarpScriptReducerFunction;\n import io.warp10.script.binary.EQ;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n \n-  public Median(String name) {\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n \n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Remove NO_LOCATION, keep valid latitude and longitude\n-    // Compute median of latitude, median of longitude\n+    // count null value\n     //\n-    ArrayList<Double> validLat = new ArrayList<Double>(locations.length);\n-    ArrayList<Double> validLong = new ArrayList<Double>(locations.length);\n-\n-    for (int i = 0; i < locations.length; i++) {\n-      if (GeoTimeSerie.NO_LOCATION != locations[i]) {\n-        validLat.add(GeoXPLib.fromGeoXPPoint(locations[i])[0]);\n-        validLong.add(GeoXPLib.fromGeoXPPoint(locations[i])[1]);\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n     }\n \n-    long location;\n-\n-    if (0 == validLat.size()) {\n-      location = GeoTimeSerie.NO_LOCATION;\n-    } else if (1 == validLat.size()) {\n-      location = GeoXPLib.toGeoXPPoint(validLat.get(0), validLong.get(0));\n-    } else {\n-      Collections.sort(validLat);\n-      Collections.sort(validLong);\n-      Double medianLatitude;\n-      Double medianLongitude;\n-      int len = validLat.size();\n-      if (0 == len % 2) {\n-        medianLatitude = (validLat.get(len / 2) + validLat.get(len / 2 - 1)) / 2.0D;\n-        medianLongitude = (validLong.get(len / 2) + validLong.get(len / 2 - 1)) / 2.0D;\n-      } else {\n-        medianLatitude = validLat.get(len / 2);\n-        medianLongitude = validLong.get(len / 2);\n-      }\n-      location = GeoXPLib.toGeoXPPoint(medianLatitude, medianLongitude);\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n \n-    //\n-    // Sort elevations.\n-    // As NO_ELEVATION == Long.MIN_VALUE, sorting elevations is a way to exclude NO_ELEVATION efficiently.\n-    // Compute elevation median\n-    //\n-    long elevation;\n-    Arrays.sort(elevations);\n-\n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // set offset to the first valid elevation\n-      int offset = 0;\n-      while (offset < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[offset]) {\n-        offset++;\n-      }\n-      if (offset == elevations.length) {\n-        // there is no valid elevation\n-        elevation = GeoTimeSerie.NO_ELEVATION;\n-      } else if (offset == elevations.length - 1) {\n-        // there is only one valid elevation\n-        elevation = elevations[offset];\n-      } else {\n-        // compute elevation median in the end of the array\n-        int len = elevations.length - offset;\n-        if (0 == len % 2) {\n-          elevation = (elevations[offset + (len / 2)] + elevations[offset + ((len / 2) - 1)]) / 2L;\n-        } else {\n-          elevation = elevations[offset + (len / 2)];\n-        }\n-      }\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n     }\n-\n     //\n-    // Remove nulls, NaN\n-    // Fail on non numeric values.\n+    // sort indices from values, null at the end of the sorted array.\n     //\n-    ArrayList<Number> validValues = new ArrayList<Number>(values.length);\n-    for (int i = 0; i < values.length; i++) {\n-      if (null != values[i]) {\n-        if (values[i] instanceof Number) {\n-          if (!(values[i] instanceof Double && Double.isNaN((Double) values[i]))) {\n-            validValues.add((Number) values[i]);\n-          }\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override\n+      public int compare(Integer idx1, Integer idx2) {\n+        if (null == values[idx1] && null == values[idx2]) {\n+          return 0;\n+        } else if (null == values[idx1] || null == values[idx2]) {\n+          return null == values[idx1] ? 1 : -1;\n+        } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+          return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n         } else {\n-          throw new WarpScriptException(this.getName() + \" cannot compute median of non numeric values.\");\n+          throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n         }\n       }\n-    }\n-\n-    //\n-    // Sort values\n-    // Could be Long or Double, or a mix, if used as a reducer.\n-    //\n-    Collections.sort(validValues, new Comparator<Number>() {\n-      @Override\n-      public int compare(Number o1, Number o2) {\n-        return EQ.compare(o1, o2);\n-      }\n     });\n \n+    long location = 0;", "originalCommit": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxODQ2OQ==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368618469", "bodyText": "indeed !", "author": "pi-r-p", "createdAt": "2020-01-20T15:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4ODQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4ODkwNw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368588907", "bodyText": "0 != nullCounter", "author": "hbs", "createdAt": "2020-01-20T14:55:07Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -26,147 +26,107 @@\n import io.warp10.script.WarpScriptReducerFunction;\n import io.warp10.script.binary.EQ;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n \n-  public Median(String name) {\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n \n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Remove NO_LOCATION, keep valid latitude and longitude\n-    // Compute median of latitude, median of longitude\n+    // count null value\n     //\n-    ArrayList<Double> validLat = new ArrayList<Double>(locations.length);\n-    ArrayList<Double> validLong = new ArrayList<Double>(locations.length);\n-\n-    for (int i = 0; i < locations.length; i++) {\n-      if (GeoTimeSerie.NO_LOCATION != locations[i]) {\n-        validLat.add(GeoXPLib.fromGeoXPPoint(locations[i])[0]);\n-        validLong.add(GeoXPLib.fromGeoXPPoint(locations[i])[1]);\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n     }\n \n-    long location;\n-\n-    if (0 == validLat.size()) {\n-      location = GeoTimeSerie.NO_LOCATION;\n-    } else if (1 == validLat.size()) {\n-      location = GeoXPLib.toGeoXPPoint(validLat.get(0), validLong.get(0));\n-    } else {\n-      Collections.sort(validLat);\n-      Collections.sort(validLong);\n-      Double medianLatitude;\n-      Double medianLongitude;\n-      int len = validLat.size();\n-      if (0 == len % 2) {\n-        medianLatitude = (validLat.get(len / 2) + validLat.get(len / 2 - 1)) / 2.0D;\n-        medianLongitude = (validLong.get(len / 2) + validLong.get(len / 2 - 1)) / 2.0D;\n-      } else {\n-        medianLatitude = validLat.get(len / 2);\n-        medianLongitude = validLong.get(len / 2);\n-      }\n-      location = GeoXPLib.toGeoXPPoint(medianLatitude, medianLongitude);\n+    if (nullCounter != 0 && this.forbidNulls) {", "originalCommit": "389ef5d1b3fd93ea76044f5ec1b7eca16ff40e38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "426ef27ad481317675d211defe58e9f748a81663", "url": "https://github.com/senx/warp10-platform/commit/426ef27ad481317675d211defe58e9f748a81663", "message": "fix the percentile aggregator null pointer exception", "committedDate": "2020-01-20T15:37:41Z", "type": "commit"}, {"oid": "4e70be6a567bbad3e4d6afdf540e29f86719c93b", "url": "https://github.com/senx/warp10-platform/commit/4e70be6a567bbad3e4d6afdf540e29f86719c93b", "message": "returns long if inputs are long, for bucketizer retrocompatibility", "committedDate": "2020-01-20T15:44:06Z", "type": "commit"}, {"oid": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "url": "https://github.com/senx/warp10-platform/commit/c1b12779c52e1c7034fc5945a6e55bec271f2794", "message": "fix median: one location is better than nothing.", "committedDate": "2020-01-20T16:02:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODk3Ng==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368888976", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:25:35Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -1839,9 +1839,10 @@\n     addNamedWarpScriptFunction(new MapperKernelTricube(\"mapper.kernel.tricube\"));\n     addNamedWarpScriptFunction(new MapperKernelTriweight(\"mapper.kernel.triweight\"));\n     addNamedWarpScriptFunction(new MapperKernelUniform(\"mapper.kernel.uniform\"));\n-        \n-    addNamedWarpScriptFunction(new Percentile.Builder(\"mapper.percentile\"));\n-    \n+\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"mapper.percentile\",false));\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"mapper.percentile.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTAyMg==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368889022", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:25:41Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -2173,13 +2174,16 @@\n     addNamedWarpScriptFunction(new Min(\"bucketizer.min\", true));\n     addNamedWarpScriptFunction(new Max(\"bucketizer.max\", true));\n     addNamedWarpScriptFunction(new Mean(\"bucketizer.mean\", false));\n-    addNamedWarpScriptFunction(new Median(\"bucketizer.median\"));\n+    addNamedWarpScriptFunction(new Median(\"bucketizer.median\",false));\n+    addNamedWarpScriptFunction(new Median(\"bucketizer.median.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTA1Ng==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368889056", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:25:46Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -2173,13 +2174,16 @@\n     addNamedWarpScriptFunction(new Min(\"bucketizer.min\", true));\n     addNamedWarpScriptFunction(new Max(\"bucketizer.max\", true));\n     addNamedWarpScriptFunction(new Mean(\"bucketizer.mean\", false));\n-    addNamedWarpScriptFunction(new Median(\"bucketizer.median\"));\n+    addNamedWarpScriptFunction(new Median(\"bucketizer.median\",false));\n+    addNamedWarpScriptFunction(new Median(\"bucketizer.median.forbid-nulls\",true));\n     addNamedWarpScriptFunction(new MAD(\"bucketizer.mad\"));\n     addNamedWarpScriptFunction(new Or(\"bucketizer.or\", false));\n     addNamedWarpScriptFunction(new Sum(\"bucketizer.sum\", true));\n     addNamedWarpScriptFunction(new Join.Builder(\"bucketizer.join\", true, false, null));\n     addNamedWarpScriptFunction(new Count(\"bucketizer.count\", false));\n-    addNamedWarpScriptFunction(new Percentile.Builder(\"bucketizer.percentile\"));\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"bucketizer.percentile\",false));\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"bucketizer.percentile.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTExMw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368889113", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:25:53Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -2205,7 +2209,8 @@\n     addNamedWarpScriptFunction(new Min(MAPPER_MIN, true));\n     addNamedWarpScriptFunction(new Max(MAPPER_MAX, true));\n     addNamedWarpScriptFunction(new Mean(\"mapper.mean\", false));\n-    addNamedWarpScriptFunction(new Median(\"mapper.median\"));\n+    addNamedWarpScriptFunction(new Median(\"mapper.median\",false));\n+    addNamedWarpScriptFunction(new Median(\"mapper.median.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTE3Mw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368889173", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:26:00Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -2263,7 +2268,8 @@\n     addNamedWarpScriptFunction(new Max(\"reducer.max.nonnull\", false));\n     addNamedWarpScriptFunction(new Mean(\"reducer.mean\", false));\n     addNamedWarpScriptFunction(new Mean(\"reducer.mean.exclude-nulls\", true));\n-    addNamedWarpScriptFunction(new Median(\"reducer.median\"));\n+    addNamedWarpScriptFunction(new Median(\"reducer.median\",false));\n+    addNamedWarpScriptFunction(new Median(\"reducer.median.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4OTIzOQ==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368889239", "bodyText": "Missing space after ,.", "author": "ftence", "createdAt": "2020-01-21T09:26:07Z", "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -2287,7 +2293,8 @@\n     addNamedWarpScriptFunction(new Count(\"reducer.count.nonnull\", true));\n     addNamedWarpScriptFunction(new ShannonEntropy(\"reducer.shannonentropy.0\", false));\n     addNamedWarpScriptFunction(new ShannonEntropy(\"reducer.shannonentropy.1\", true));\n-    addNamedWarpScriptFunction(new Percentile.Builder(\"reducer.percentile\"));\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"reducer.percentile\",false));\n+    addNamedWarpScriptFunction(new Percentile.Builder(\"reducer.percentile.forbid-nulls\",true));", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5OTg0MQ==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368899841", "bodyText": "Missing space after [].", "author": "ftence", "createdAt": "2020-01-21T09:47:34Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -16,185 +16,136 @@\n \n package io.warp10.script.aggregator;\n \n+import com.geoxp.GeoXPLib;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n import io.warp10.script.WarpScriptAggregatorFunction;\n import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptMapperFunction;\n import io.warp10.script.WarpScriptReducerFunction;\n-import io.warp10.script.WarpScriptException;\n+import io.warp10.script.binary.EQ;\n \n import java.util.Arrays;\n-\n-import com.geoxp.GeoXPLib;\n+import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n-  public Median(String name) {\n+\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n-    long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Sort locations, elevations\n-    //\n-    \n-    Arrays.sort(locations);\n-    Arrays.sort(elevations);\n-    \n-    long location = GeoTimeSerie.NO_LOCATION;\n-    long elevation = GeoTimeSerie.NO_ELEVATION;\n-    \n+    // count null value. Also check if there is one double at least\n     //\n-    // If start and end locations are identical, set median to that value\n-    //\n-    \n-    if (locations[0] == locations[locations.length - 1]) {\n-      location = locations[0];\n-    } else {\n-      // Remove NO_LOCATION\n-      int idx = Arrays.binarySearch(locations, GeoTimeSerie.NO_LOCATION);\n-      int len = locations.length;\n-      \n-      if (idx >= 0) {\n-        int i = idx + 1;\n-        while (i < locations.length && GeoTimeSerie.NO_LOCATION == locations[i]) {\n-          i++;\n-        }\n-        // Remove the NO_LOCATION values from the array\n-        if (i < locations.length) {\n-          System.arraycopy(locations, i, locations, idx, locations.length - i);\n-          len -= (i - idx);\n-        }\n+    int nullCounter = 0;\n+    boolean inputHasDouble = false;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n-      \n-      // Compute median of location\n-      \n-      if (0 == len % 2) {\n-        double[] high = GeoXPLib.fromGeoXPPoint(locations[len / 2]);\n-        double[] low = GeoXPLib.fromGeoXPPoint(locations[(len / 2) - 1]);\n-        location = GeoXPLib.toGeoXPPoint((high[0] + low[0])/2.0D, (high[1] + low[1])/2.0D);\n-      } else {\n-        location = locations[len / 2];\n-      }      \n+      inputHasDouble |= (v instanceof Double);\n     }\n \n+    if (0 != nullCounter && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n+    }\n+\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n+    }\n     //\n-    // If start and end elevations are identical, set median to that value\n+    // sort indices from values, null at the end of the sorted array.\n+    // a null is considered bigger than any other value.\n     //\n-    \n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // Remove NO_elevation\n-      int idx = Arrays.binarySearch(elevations, GeoTimeSerie.NO_ELEVATION);\n-      int len = elevations.length;\n-      \n-      if (idx >= 0) {\n-        int i = idx + 1;\n-        while (i < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[i]) {\n-          i++;\n-        }\n-        // Remove the NO_elevation values from the array\n-        if (i < elevations.length) {\n-          System.arraycopy(elevations, i, elevations, idx, elevations.length - i);\n-          len -= (i - idx);\n+    final String functionName = this.getName();\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override\n+      public int compare(Integer idx1, Integer idx2) {\n+        if (null == values[idx1] && null == values[idx2]) {\n+          return 0;\n+        } else if (null == values[idx1] || null == values[idx2]) {\n+          return null == values[idx1] ? 1 : -1;\n+        } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+          return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n+        } else {\n+          throw new RuntimeException(functionName + \" can only operate on numeric Geo Time Series.\");\n         }\n       }\n-      \n-      // Compute median of elevation\n-      \n-      if (0 == len % 2) {\n-        elevation = (elevations[len / 2] + elevations[(len / 2) - 1]) / 2L;\n-      } else {\n-        elevation = elevations[len / 2];\n-      }      \n-    }\n+    });\n+\n+    long location = GeoTimeSerie.NO_LOCATION;\n+    long elevation = GeoTimeSerie.NO_ELEVATION;\n+    Object median;\n+\n+    int nonNullLength = values.length - nullCounter;\n \n-    \n     //\n-    // Remove nulls\n+    // singleton case\n     //\n-    \n-    int nonnulls = values.length;\n-    \n-    for (int i = 0; i < values.length; i++) {\n-      if (null == values[i]) {\n-        // If the null is the last value, decrement the number of\n-        // nonnulls and bail out\n-        if (i == values.length - 1) {\n-          nonnulls--;\n-          break;\n-        }\n-        // Find the first non null starting from the end of the array\n-        while(nonnulls > i + 1 && null == values[nonnulls - 1]) {\n-          nonnulls--;          \n+    if (1 == nonNullLength) {\n+      return new Object[]{\n+          tick, locations[indices[0]], elevations[indices[0]], values[indices[0]]\n+      };\n+    } else {\n+      if (0 == nonNullLength % 2) {\n+        //\n+        // even number of non null values, return mean of both values.\n+        // If there is a location for both points, return centroid of locations\n+        // If there is an elevation for both points, return mean of elevations\n+        // If there is location or elevation for just one point, return this point. Better than nothing.\n+        //\n+        int low = indices[nonNullLength / 2 - 1];\n+        int high = indices[nonNullLength / 2];\n+        median = (((Number) values[low]).doubleValue() + ((Number) values[high]).doubleValue()) / 2.0D;\n+        if (GeoTimeSerie.NO_ELEVATION != elevations[low] && GeoTimeSerie.NO_ELEVATION != elevations[high]) {\n+          elevation = (elevations[low] + elevations[high]) / 2;\n+        } else if (GeoTimeSerie.NO_ELEVATION != elevations[low]) {\n+          elevation = elevations[low];\n+        } else if (GeoTimeSerie.NO_ELEVATION != elevations[high]) {\n+          elevation = elevations[high];\n         }\n-        \n-        // Bail out if no non null value was found\n-        if (i == nonnulls) {\n-          break;\n+        if (GeoTimeSerie.NO_LOCATION != locations[low] && GeoTimeSerie.NO_LOCATION != locations[high]) {\n+          long[] xyLow = GeoXPLib.xyFromGeoXPPoint(locations[low]);\n+          long[] xyHigh = GeoXPLib.xyFromGeoXPPoint(locations[high]);\n+          location = GeoXPLib.toGeoXPPoint((xyLow[0] + xyHigh[0]) / 2, (xyLow[1] + xyHigh[1]) / 2);\n+        } else if (GeoTimeSerie.NO_LOCATION != locations[low]) {\n+          location = locations[low];\n+        } else if (GeoTimeSerie.NO_LOCATION != locations[high]) {\n+          location = locations[high];\n         }\n-        \n-        values[i] = values[nonnulls - 1];        \n-      }\n-    }\n \n-    //\n-    // Remove nulls\n-    //\n+      } else {\n+        //\n+        // odd number of non null values\n+        //\n+        location = locations[indices[nonNullLength / 2]];\n+        elevation = elevations[indices[nonNullLength / 2]];\n+        median = ((Number) values[indices[nonNullLength / 2]]).doubleValue();\n+      }\n \n-    if (nonnulls != values.length) {\n-      values = Arrays.copyOf(values, nonnulls);\n     }\n-    \n-    //\n-    // Sort values\n-    //\n-    Arrays.sort(values);\n \n-    //\n-    // If extrema are identical, use this as the median, otherwise remove nulls\n-    //\n-    \n-    Object median = null;\n-    \n-    if (0 != values.length) {\n-      if (values[0].equals(values[values.length - 1])) {\n-        median = values[0];\n-      } else {      \n-        int len = values.length;\n-        \n-        // Compute median\n-        if (0 == len % 2) {\n-          Object low = values[(len / 2) - 1];\n-          Object high = values[len / 2];\n-          \n-          if (low instanceof Long && high instanceof Long) {\n-            median = ((long) low + (long) high) / 2L;\n-          } else if (low instanceof Double && high instanceof Double) {\n-            median = ((double) low + (double) high) / 2.0D;\n-          } else {\n-            throw new WarpScriptException(\"Unable to compute median on an even number of non numeric values.\");\n-          }\n-        } else {\n-          median = values[len / 2];\n-        }\n-      }      \n+    // if the input has only long values, return a long.\n+    if (!inputHasDouble) {\n+      median = ((Double) median).longValue();\n     }\n-    \n-    return new Object[] { tick, location, elevation, median };\n+    return new Object[]{tick, location, elevation, median};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMDAxMw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368900013", "bodyText": "Missing space after [].", "author": "ftence", "createdAt": "2020-01-21T09:47:54Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -16,185 +16,136 @@\n \n package io.warp10.script.aggregator;\n \n+import com.geoxp.GeoXPLib;\n import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n import io.warp10.script.WarpScriptAggregatorFunction;\n import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptMapperFunction;\n import io.warp10.script.WarpScriptReducerFunction;\n-import io.warp10.script.WarpScriptException;\n+import io.warp10.script.binary.EQ;\n \n import java.util.Arrays;\n-\n-import com.geoxp.GeoXPLib;\n+import java.util.Comparator;\n \n /**\n  * Return the median of the values on the interval.\n- * The returned location will be the median of all locations.\n- * The returned elevation will be the median of all elevations.\n+ * If median data point has an associated location and elevation, return it\n+ * If forbidNulls and null among inputs, the function will raise an exception.\n  */\n public class Median extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n-  public Median(String name) {\n+\n+  private final boolean forbidNulls;\n+\n+  public Median(String name, boolean forbidNulls) {\n     super(name);\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long tick = (long) args[0];\n-    long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n-    Object[] values = (Object[]) args[6];\n+    final Object[] values = (Object[]) args[6];\n \n     //\n-    // Sort locations, elevations\n-    //\n-    \n-    Arrays.sort(locations);\n-    Arrays.sort(elevations);\n-    \n-    long location = GeoTimeSerie.NO_LOCATION;\n-    long elevation = GeoTimeSerie.NO_ELEVATION;\n-    \n+    // count null value. Also check if there is one double at least\n     //\n-    // If start and end locations are identical, set median to that value\n-    //\n-    \n-    if (locations[0] == locations[locations.length - 1]) {\n-      location = locations[0];\n-    } else {\n-      // Remove NO_LOCATION\n-      int idx = Arrays.binarySearch(locations, GeoTimeSerie.NO_LOCATION);\n-      int len = locations.length;\n-      \n-      if (idx >= 0) {\n-        int i = idx + 1;\n-        while (i < locations.length && GeoTimeSerie.NO_LOCATION == locations[i]) {\n-          i++;\n-        }\n-        // Remove the NO_LOCATION values from the array\n-        if (i < locations.length) {\n-          System.arraycopy(locations, i, locations, idx, locations.length - i);\n-          len -= (i - idx);\n-        }\n+    int nullCounter = 0;\n+    boolean inputHasDouble = false;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n       }\n-      \n-      // Compute median of location\n-      \n-      if (0 == len % 2) {\n-        double[] high = GeoXPLib.fromGeoXPPoint(locations[len / 2]);\n-        double[] low = GeoXPLib.fromGeoXPPoint(locations[(len / 2) - 1]);\n-        location = GeoXPLib.toGeoXPPoint((high[0] + low[0])/2.0D, (high[1] + low[1])/2.0D);\n-      } else {\n-        location = locations[len / 2];\n-      }      \n+      inputHasDouble |= (v instanceof Double);\n     }\n \n+    if (0 != nullCounter && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n+    }\n+\n+    Integer[] indices = new Integer[values.length];\n+    for (int i = 0; i < indices.length; i++) {\n+      indices[i] = i;\n+    }\n     //\n-    // If start and end elevations are identical, set median to that value\n+    // sort indices from values, null at the end of the sorted array.\n+    // a null is considered bigger than any other value.\n     //\n-    \n-    if (elevations[0] == elevations[elevations.length - 1]) {\n-      elevation = elevations[0];\n-    } else {\n-      // Remove NO_elevation\n-      int idx = Arrays.binarySearch(elevations, GeoTimeSerie.NO_ELEVATION);\n-      int len = elevations.length;\n-      \n-      if (idx >= 0) {\n-        int i = idx + 1;\n-        while (i < elevations.length && GeoTimeSerie.NO_ELEVATION == elevations[i]) {\n-          i++;\n-        }\n-        // Remove the NO_elevation values from the array\n-        if (i < elevations.length) {\n-          System.arraycopy(elevations, i, elevations, idx, elevations.length - i);\n-          len -= (i - idx);\n+    final String functionName = this.getName();\n+    Arrays.sort(indices, new Comparator<Integer>() {\n+      @Override\n+      public int compare(Integer idx1, Integer idx2) {\n+        if (null == values[idx1] && null == values[idx2]) {\n+          return 0;\n+        } else if (null == values[idx1] || null == values[idx2]) {\n+          return null == values[idx1] ? 1 : -1;\n+        } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+          return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n+        } else {\n+          throw new RuntimeException(functionName + \" can only operate on numeric Geo Time Series.\");\n         }\n       }\n-      \n-      // Compute median of elevation\n-      \n-      if (0 == len % 2) {\n-        elevation = (elevations[len / 2] + elevations[(len / 2) - 1]) / 2L;\n-      } else {\n-        elevation = elevations[len / 2];\n-      }      \n-    }\n+    });\n+\n+    long location = GeoTimeSerie.NO_LOCATION;\n+    long elevation = GeoTimeSerie.NO_ELEVATION;\n+    Object median;\n+\n+    int nonNullLength = values.length - nullCounter;\n \n-    \n     //\n-    // Remove nulls\n+    // singleton case\n     //\n-    \n-    int nonnulls = values.length;\n-    \n-    for (int i = 0; i < values.length; i++) {\n-      if (null == values[i]) {\n-        // If the null is the last value, decrement the number of\n-        // nonnulls and bail out\n-        if (i == values.length - 1) {\n-          nonnulls--;\n-          break;\n-        }\n-        // Find the first non null starting from the end of the array\n-        while(nonnulls > i + 1 && null == values[nonnulls - 1]) {\n-          nonnulls--;          \n+    if (1 == nonNullLength) {\n+      return new Object[]{", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjg1NA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368906854", "bodyText": "Missing space after [].", "author": "ftence", "createdAt": "2020-01-21T10:01:28Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNzQwMA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368907400", "bodyText": "Use function name.", "author": "ftence", "createdAt": "2020-01-21T10:02:29Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxNzIzNg==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368917236", "bodyText": "Missing space after Object[].", "author": "ftence", "createdAt": "2020-01-21T10:22:17Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n           }\n         }\n-      });      \n+      });\n     } catch (RuntimeException re) {\n       throw new WarpScriptException(re);\n     }\n-    \n+\n+    int nonNullLength = values.length - nullCounter;\n     //\n     // Compute rank\n     //\n-    \n-    int n = (int) Math.round(0.5 + this.percentile * indices.length / 100.0) - 1;\n+\n+    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n \n     if (!this.interpolate) {\n-      if (n >= indices.length) { n--; }\n-      return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+      if (n >= nonNullLength) {\n+        n--;\n+      }\n+      return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkxODQ4Mw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r368918483", "bodyText": "Missing space after [].", "author": "ftence", "createdAt": "2020-01-21T10:24:50Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n           }\n         }\n-      });      \n+      });\n     } catch (RuntimeException re) {\n       throw new WarpScriptException(re);\n     }\n-    \n+\n+    int nonNullLength = values.length - nullCounter;\n     //\n     // Compute rank\n     //\n-    \n-    int n = (int) Math.round(0.5 + this.percentile * indices.length / 100.0) - 1;\n+\n+    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n \n     if (!this.interpolate) {\n-      if (n >= indices.length) { n--; }\n-      return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+      if (n >= nonNullLength) {\n+        n--;\n+      }\n+      return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * indices.length / 100.0) - 1;\n-      \n-      double pn = (100.0 / indices.length) * (n + 1 - 0.5D);\n-      double pm = (100.0 / indices.length) * (m + 1 - 0.5D);\n+      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+\n+      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n+      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n \n       if (0 == n && this.percentile < pn) {\n-        return new Object[] { ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]] };\n-      } else if (m == indices.length - 1 && this.percentile > pm) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};\n+      } else if (m == nonNullLength - 1 && this.percentile > pm) {\n+        return new Object[]{ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n       } else if (pn == this.percentile) {\n-        return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+        return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n       } else if (pm == this.percentile) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n       } else if (pm < this.percentile && this.percentile < pn) {\n-        double factor = indices.length * (this.percentile - pm) / 100.0D;\n-        \n+        double factor = nonNullLength * (this.percentile - pm) / 100.0D;\n+\n         long tick = (long) (ticks[indices[m]] + factor * (ticks[indices[n]] - ticks[indices[m]]));\n         double v;\n-        \n+\n         if (values[indices[m]] instanceof Long) {\n           v = ((Number) values[indices[m]]).longValue() + factor * (((Number) values[indices[n]]).longValue() - ((Number) values[indices[m]]).longValue());\n         } else {\n-          v = ((Number) values[indices[m]]).doubleValue() + factor * (((Number) values[indices[n]]).doubleValue() - ((Number) values[indices[m]]).doubleValue());          \n+          v = ((Number) values[indices[m]]).doubleValue() + factor * (((Number) values[indices[n]]).doubleValue() - ((Number) values[indices[m]]).doubleValue());\n         }\n-        \n+\n         long location = GeoTimeSerie.NO_LOCATION;\n-        \n+\n         if (GeoTimeSerie.NO_LOCATION != locations[indices[m]] && GeoTimeSerie.NO_LOCATION != locations[indices[n]]) {\n           double[] latlonm = GeoXPLib.fromGeoXPPoint(locations[indices[m]]);\n           double[] latlonn = GeoXPLib.fromGeoXPPoint(locations[indices[n]]);\n-          \n+\n           double lat = latlonm[0] + factor * (latlonn[0] - latlonm[0]);\n           double lon = latlonm[1] + factor * (latlonn[1] - latlonm[1]);\n-          \n+\n           location = GeoXPLib.toGeoXPPoint(lat, lon);\n         }\n-        \n+\n         long elevation = GeoTimeSerie.NO_ELEVATION;\n-        \n+\n         if (GeoTimeSerie.NO_LOCATION != elevations[indices[m]] && GeoTimeSerie.NO_ELEVATION != elevations[indices[n]]) {\n           elevation = (long) (elevations[indices[m]] + factor * (elevations[indices[n]] - elevations[indices[m]]));\n         }\n-        \n-        return new Object[] { tick, location, elevation, v };\n+\n+        return new Object[]{tick, location, elevation, v};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQwNQ==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r369008405", "bodyText": "Missing space after Object[].", "author": "ftence", "createdAt": "2020-01-21T13:47:02Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n           }\n         }\n-      });      \n+      });\n     } catch (RuntimeException re) {\n       throw new WarpScriptException(re);\n     }\n-    \n+\n+    int nonNullLength = values.length - nullCounter;\n     //\n     // Compute rank\n     //\n-    \n-    int n = (int) Math.round(0.5 + this.percentile * indices.length / 100.0) - 1;\n+\n+    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n \n     if (!this.interpolate) {\n-      if (n >= indices.length) { n--; }\n-      return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+      if (n >= nonNullLength) {\n+        n--;\n+      }\n+      return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * indices.length / 100.0) - 1;\n-      \n-      double pn = (100.0 / indices.length) * (n + 1 - 0.5D);\n-      double pm = (100.0 / indices.length) * (m + 1 - 0.5D);\n+      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+\n+      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n+      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n \n       if (0 == n && this.percentile < pn) {\n-        return new Object[] { ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]] };\n-      } else if (m == indices.length - 1 && this.percentile > pm) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};\n+      } else if (m == nonNullLength - 1 && this.percentile > pm) {\n+        return new Object[]{ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n       } else if (pn == this.percentile) {\n-        return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+        return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQ0MA==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r369008440", "bodyText": "Missing space after Object[].", "author": "ftence", "createdAt": "2020-01-21T13:47:06Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n           }\n         }\n-      });      \n+      });\n     } catch (RuntimeException re) {\n       throw new WarpScriptException(re);\n     }\n-    \n+\n+    int nonNullLength = values.length - nullCounter;\n     //\n     // Compute rank\n     //\n-    \n-    int n = (int) Math.round(0.5 + this.percentile * indices.length / 100.0) - 1;\n+\n+    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n \n     if (!this.interpolate) {\n-      if (n >= indices.length) { n--; }\n-      return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+      if (n >= nonNullLength) {\n+        n--;\n+      }\n+      return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * indices.length / 100.0) - 1;\n-      \n-      double pn = (100.0 / indices.length) * (n + 1 - 0.5D);\n-      double pm = (100.0 / indices.length) * (m + 1 - 0.5D);\n+      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+\n+      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n+      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n \n       if (0 == n && this.percentile < pn) {\n-        return new Object[] { ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]] };\n-      } else if (m == indices.length - 1 && this.percentile > pm) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQ5Nw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r369008497", "bodyText": "Missing space after Object[].", "author": "ftence", "createdAt": "2020-01-21T13:47:13Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n       }\n-      \n-      stack.push(new Percentile(getName(), percentile, false));\n+\n+      stack.push(new Percentile(getName(), percentile, false, this.forbidNulls));\n       return stack;\n     }\n   }\n \n-  public Percentile(String name, double percentile, boolean interpolate) {\n+  public Percentile(String name, double percentile, boolean interpolate, boolean forbidNulls) {\n     super(name);\n     this.percentile = percentile < 0.0D ? 0.0D : (percentile > 100.0D ? 100.0D : percentile);\n     this.interpolate = interpolate;\n+    this.forbidNulls = forbidNulls;\n   }\n-  \n+\n   @Override\n   public Object apply(Object[] args) throws WarpScriptException {\n     long[] ticks = (long[]) args[3];\n     long[] locations = (long[]) args[4];\n     long[] elevations = (long[]) args[5];\n     final Object[] values = (Object[]) args[6];\n-    \n+\n     if (0 == ticks.length) {\n-      return new Object[] { Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null };\n+      return new Object[]{Long.MAX_VALUE, GeoTimeSerie.NO_LOCATION, GeoTimeSerie.NO_ELEVATION, null};\n+    }\n+\n+\n+    //\n+    // count null value\n+    //\n+    int nullCounter = 0;\n+    for (Object v: values) {\n+      if (null == v) {\n+        nullCounter++;\n+      }\n+    }\n+\n+    if (nullCounter != 0 && this.forbidNulls) {\n+      throw new WarpScriptException(this.getName() + \" cannot compute median of null values.\");\n     }\n-    \n+\n     //\n     // Sort the array indices by increasing value\n     // FIXME(hbs): find something less memory hungry...\n     //\n-    \n+\n     Integer[] indices = new Integer[values.length];\n     for (int i = 0; i < indices.length; i++) {\n       indices[i] = i;\n     }\n-    \n+\n     try {\n       Arrays.sort(indices, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer idx1, Integer idx2) {\n-          if (values[idx1] instanceof Double) {\n-            return Double.compare(((Number) values[idx1]).doubleValue(), ((Number) values[idx2]).doubleValue());\n-          } else if (values[idx1] instanceof Long) {\n-            return Long.compare(((Number) values[idx1]).longValue(), ((Number) values[idx2]).longValue());\n+          if (null == values[idx1] && null == values[idx2]) {\n+            return 0;\n+          } else if (null == values[idx1] || null == values[idx2]) {\n+            return null == values[idx1] ? 1 : -1;\n+          } else if (values[idx1] instanceof Number && values[idx2] instanceof Number) {\n+            return EQ.compare((Number) values[idx1], (Number) values[idx2]);\n           } else {\n-            throw new RuntimeException(\"PERCENTILE can only operate on numeric Geo Time Series.\");\n+            throw new RuntimeException(\"MEDIAN can only operate on numeric Geo Time Series.\");\n           }\n         }\n-      });      \n+      });\n     } catch (RuntimeException re) {\n       throw new WarpScriptException(re);\n     }\n-    \n+\n+    int nonNullLength = values.length - nullCounter;\n     //\n     // Compute rank\n     //\n-    \n-    int n = (int) Math.round(0.5 + this.percentile * indices.length / 100.0) - 1;\n+\n+    int n = (int) Math.round(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n \n     if (!this.interpolate) {\n-      if (n >= indices.length) { n--; }\n-      return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+      if (n >= nonNullLength) {\n+        n--;\n+      }\n+      return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n     } else {\n-      int m = (int) Math.floor(0.5 + this.percentile * indices.length / 100.0) - 1;\n-      \n-      double pn = (100.0 / indices.length) * (n + 1 - 0.5D);\n-      double pm = (100.0 / indices.length) * (m + 1 - 0.5D);\n+      int m = (int) Math.floor(0.5 + this.percentile * nonNullLength / 100.0) - 1;\n+\n+      double pn = (100.0 / nonNullLength) * (n + 1 - 0.5D);\n+      double pm = (100.0 / nonNullLength) * (m + 1 - 0.5D);\n \n       if (0 == n && this.percentile < pn) {\n-        return new Object[] { ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]] };\n-      } else if (m == indices.length - 1 && this.percentile > pm) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[0]], locations[indices[0]], elevations[indices[0]], values[indices[0]]};\n+      } else if (m == nonNullLength - 1 && this.percentile > pm) {\n+        return new Object[]{ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};\n       } else if (pn == this.percentile) {\n-        return new Object[] { ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]] };\n+        return new Object[]{ticks[indices[n]], locations[indices[n]], elevations[indices[n]], values[indices[n]]};\n       } else if (pm == this.percentile) {\n-        return new Object[] { ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]] };\n+        return new Object[]{ticks[indices[m]], locations[indices[m]], elevations[indices[m]], values[indices[m]]};", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwOTQ0Nw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r369009447", "bodyText": "Add function name.", "author": "ftence", "createdAt": "2020-01-21T13:49:06Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -31,150 +31,175 @@\n import java.util.Arrays;\n \n import com.geoxp.GeoXPLib;\n+import io.warp10.script.binary.EQ;\n \n /**\n  * Return the Nth percentile of the values on the interval.\n  * The returned location will be that of the chosen value\n  * The returned elevation will be that of the chosen value\n  */\n public class Percentile extends NamedWarpScriptFunction implements WarpScriptAggregatorFunction, WarpScriptMapperFunction, WarpScriptBucketizerFunction, WarpScriptReducerFunction {\n-  \n+\n   /**\n    * Should we use linear interpolation?\n    */\n-  final boolean interpolate;\n-  \n-  final double percentile;\n-  \n+  private final boolean interpolate;\n+\n+  private final double percentile;\n+  private final boolean forbidNulls;\n+\n   public static class Builder extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-    \n-    public Builder(String name) {\n+    private final boolean forbidNulls;\n+\n+    public Builder(String name, boolean forbidNulls) {\n       super(name);\n+      this.forbidNulls = forbidNulls;\n     }\n-    \n+\n     @Override\n     public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       Object value = stack.pop();\n-      \n+\n       if (!(value instanceof Number)) {\n         throw new WarpScriptException(\"Invalid parameter for \" + getName());\n       }\n-      \n+\n       double percentile = ((Number) value).doubleValue();\n-      \n+\n       if (percentile < 0.0D || percentile > 100.0D) {\n         throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");", "originalCommit": "c1b12779c52e1c7034fc5945a6e55bec271f2794", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d559ef59dfbe82ac3d1e7235246936a410c544b5", "url": "https://github.com/senx/warp10-platform/commit/d559ef59dfbe82ac3d1e7235246936a410c544b5", "message": "name function in percentile exception", "committedDate": "2020-01-23T15:31:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE5Mzg3Ng==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r370193876", "bodyText": "missing whitespace before call to getName", "author": "hbs", "createdAt": "2020-01-23T15:40:35Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Percentile.java", "diffHunk": "@@ -67,7 +67,7 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       double percentile = ((Number) value).doubleValue();\n \n       if (percentile < 0.0D || percentile > 100.0D) {\n-        throw new WarpScriptException(\"Invalid percentile, MUST be between 0 and 100.\");\n+        throw new WarpScriptException(\"Invalid percentile for\" + getName() + \", MUST be between 0 and 100.\");", "originalCommit": "d559ef59dfbe82ac3d1e7235246936a410c544b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE5NDk5Mw==", "url": "https://github.com/senx/warp10-platform/pull/631#discussion_r370194993", "bodyText": "Indentation should be 2 spaces, not 4.", "author": "hbs", "createdAt": "2020-01-23T15:42:22Z", "path": "warp10/src/main/java/io/warp10/script/aggregator/Median.java", "diffHunk": "@@ -100,7 +100,7 @@ public int compare(Integer idx1, Integer idx2) {\n     // singleton case\n     //\n     if (1 == nonNullLength) {\n-      return new Object[]{\n+      return new Object[] {\n           tick, locations[indices[0]], elevations[indices[0]], values[indices[0]]", "originalCommit": "d559ef59dfbe82ac3d1e7235246936a410c544b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4068d3989cd81beb376eaa020171f465439784f3", "url": "https://github.com/senx/warp10-platform/commit/4068d3989cd81beb376eaa020171f465439784f3", "message": "Syntax Samaritan compliance", "committedDate": "2020-01-23T15:51:47Z", "type": "commit"}]}