{"pr_number": 1036, "pr_title": "TSK-1207: finished implementation of JaasExtension and its tests", "pr_createdAt": "2020-04-29T01:26:28Z", "pr_url": "https://github.com/Taskana/taskana/pull/1036", "timeline": [{"oid": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "url": "https://github.com/Taskana/taskana/commit/ee226d755487bb134b6f40cc4c9b37f5393dead5", "message": "TSK-1207: finished implementation of JaasExtension and its tests", "committedDate": "2020-04-29T03:52:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyODg3MQ==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417128871", "bodyText": "The new Method is called getAccesIds but is returning groups?", "author": "sfrevel", "createdAt": "2020-04-29T07:51:13Z", "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/security/CurrentUserContext.java", "diffHunk": "@@ -48,34 +51,23 @@ public static String getUserid() {\n   public static List<String> getGroupIds() {\n     Subject subject = Subject.getSubject(AccessController.getContext());\n     LOGGER.trace(\"Subject of caller: {}\", subject);\n-    List<String> groupIds = new ArrayList<>();\n     if (subject != null) {\n       Set<Group> groups = subject.getPrincipals(Group.class);\n       LOGGER.trace(\"Public groups of caller: {}\", groups);\n-      for (Principal group : groups) {\n-        String groupNameFound = group.getName();\n-        String groupNameReturned = groupNameFound;\n-        if (shouldUseLowerCaseForAccessIds() && groupNameFound != null) {\n-          groupNameReturned = groupNameFound.toLowerCase();\n-        }\n-        LOGGER.trace(\n-            \"Found group id {}. Returning group Id: {}\", groupNameFound, groupNameReturned);\n-        groupIds.add(groupNameReturned);\n-      }\n-      return groupIds;\n+      return groups.stream()\n+          .map(Principal::getName)\n+          .filter(Objects::nonNull)\n+          .map(CurrentUserContext::convertAccessId)\n+          .collect(Collectors.toList());\n     }\n-    LOGGER.trace(\"No groupids found in subject!\");\n-    return groupIds;\n+    LOGGER.trace(\"No groupIds found in subject!\");\n+    return Collections.emptyList();\n   }\n \n   public static List<String> getAccessIds() {", "originalCommit": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyMzc3Nw==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417223777", "bodyText": "done", "author": "mustaphazorgati", "createdAt": "2020-04-29T10:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyODg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzg1OA==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417133858", "bodyText": "could we use childrenMap instead of map", "author": "sfrevel", "createdAt": "2020-04-29T08:00:28Z", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {", "originalCommit": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwOTQzNg==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417209436", "bodyText": "done", "author": "mustaphazorgati", "createdAt": "2020-04-29T10:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTE3NQ==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417135175", "bodyText": "could we use dynamicNodes or children instead of collect?", "author": "sfrevel", "createdAt": "2020-04-29T08:02:56Z", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtension.java", "diffHunk": "@@ -159,27 +184,57 @@ public void interceptAfterAllMethod(\n       ExtensionContext extensionContext) {\n     extractAccessIdAndPerformInvocation(invocation, invocationContext.getExecutable());\n   }\n+\n   // endregion\n \n   // region TestTemplateInvocationContextProvider\n+\n   @Override\n   public boolean supportsTestTemplate(ExtensionContext context) {\n-    return isAnnotated(context.getRequiredTestMethod(), WithAccessIds.class);\n+    return isAnnotated(context.getElement(), WithAccessIds.class)\n+        || isAnnotated(context.getElement(), WithAccessId.class);\n   }\n \n   @Override\n   public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(\n       ExtensionContext context) {\n-    WithAccessIds annotation = context.getRequiredTestMethod().getAnnotation(WithAccessIds.class);\n+    List<WithAccessId> accessIds =\n+        AnnotationSupport.findRepeatableAnnotations(context.getElement(), WithAccessId.class);\n     Store store = getStore(context);\n-    return Stream.of(annotation.value())\n+    return accessIds.stream()\n         .peek(a -> store.put(ACCESS_IDS_STORE_KEY, a))\n         .map(JaasExtensionInvocationContext::new);\n   }\n+\n   // endregion\n \n+  private static void persistDynamicContainerChildren(\n+      Iterable<DynamicNode> nodes, Map<String, List<DynamicNode>> map) {\n+    nodes.forEach(\n+        node -> {\n+          if (node instanceof DynamicContainer) {\n+            DynamicContainer container = (DynamicContainer) node;\n+            List<DynamicNode> collect = container.getChildren().collect(Collectors.toList());", "originalCommit": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwOTg1NA==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417209854", "bodyText": "done", "author": "mustaphazorgati", "createdAt": "2020-04-29T10:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDY5MQ==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417144691", "bodyText": "So this test has to be extracted from this class, because the target of TestExecutionListeners annotation is ElementType.Type?", "author": "sfrevel", "createdAt": "2020-04-29T08:21:11Z", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "diffHunk": "@@ -58,33 +80,649 @@ void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_BeforeEach() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n+  // endregion\n+\n+  // region JaasExtension#interceptAfterEachMethod\n+\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @AfterEach\n+  void should_SetJaasSubject_When_AnnotationExists_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"aftereach\");\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @WithAccessId(user = \"afterach2\")\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptAfterAllMethod\n+\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @AfterAll\n+  static void should_SetJaasSubject_When_AnnotationExists_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"afterall\");\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @WithAccessId(user = \"afterall2\")\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestMethod\n+\n+  @Test\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n   @WithAccessId(user = \"user\")\n   @Test\n   void should_SetJaasSubject_When_AnnotationExists_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).isEmpty();\n+  }\n+\n+  @WithAccessId(\n+      user = \"user\",\n+      groups = {\"hans\", \"peter\"})\n+  @Test\n+  void should_SetJaasSubjectWithGroups_When_AnnotationExistsWithGroups_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).containsOnly(\"hans\", \"peter\");\n+  }\n+\n+  @WithAccessId(user = \"user\")\n+  @Test\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotInjectParameter_When_ParameterIsPresent_On_Test(WithAccessId accessId) {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n   }\n \n   @WithAccessId(user = \"user\")\n   @WithAccessId(user = \"user2\")\n   @Test\n-  @Disabled(\"can we make this work somehow?\")\n-  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_Test() {\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_ThrowException_When_MultipleAnnotationsExist_On_Test() {", "originalCommit": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NTA4NQ==", "url": "https://github.com/Taskana/taskana/pull/1036#discussion_r417145085", "bodyText": "see comment on should_ThrowException_When_MultipleAnnotationsExist_On_Test", "author": "sfrevel", "createdAt": "2020-04-29T08:21:50Z", "path": "lib/taskana-core/src/test/java/pro/taskana/security/JaasExtensionTest.java", "diffHunk": "@@ -58,33 +80,649 @@ void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_BeforeEach() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n+  // endregion\n+\n+  // region JaasExtension#interceptAfterEachMethod\n+\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @AfterEach\n+  void should_SetJaasSubject_When_AnnotationExists_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"aftereach\");\n+  }\n+\n+  @WithAccessId(user = \"aftereach\")\n+  @WithAccessId(user = \"afterach2\")\n+  @AfterEach\n+  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterEach() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptAfterAllMethod\n+\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_AnnotationIsMissing_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @AfterAll\n+  static void should_SetJaasSubject_When_AnnotationExists_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"afterall\");\n+  }\n+\n+  @WithAccessId(user = \"afterall\")\n+  @WithAccessId(user = \"afterall2\")\n+  @AfterAll\n+  static void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_AfterAll() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestMethod\n+\n+  @Test\n+  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+  }\n+\n   @WithAccessId(user = \"user\")\n   @Test\n   void should_SetJaasSubject_When_AnnotationExists_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).isEmpty();\n+  }\n+\n+  @WithAccessId(\n+      user = \"user\",\n+      groups = {\"hans\", \"peter\"})\n+  @Test\n+  void should_SetJaasSubjectWithGroups_When_AnnotationExistsWithGroups_On_Test() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n+    assertThat(CurrentUserContext.getGroupIds()).containsOnly(\"hans\", \"peter\");\n+  }\n+\n+  @WithAccessId(user = \"user\")\n+  @Test\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotInjectParameter_When_ParameterIsPresent_On_Test(WithAccessId accessId) {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"user\");\n   }\n \n   @WithAccessId(user = \"user\")\n   @WithAccessId(user = \"user2\")\n   @Test\n-  @Disabled(\"can we make this work somehow?\")\n-  void should_NotSetJaasSubject_When_MultipleAnnotationsExist_On_Test() {\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_ThrowException_When_MultipleAnnotationsExist_On_Test() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n   }\n \n-  @Test\n-  void should_NotSetJaasSubject_When_AnnotationIsMissing_On_Test() {\n+  // endregion\n+\n+  // region JaasExtension#interceptTestFactory\n+\n+  @TestFactory\n+  List<DynamicTest> should_NotSetJaasSubject_When_AnnotationIsMissing_On_TestFactory() {\n     assertThat(CurrentUserContext.getUserid()).isEqualTo(null);\n+    return Collections.emptyList();\n+  }\n+\n+  @WithAccessId(user = \"testfactory\")\n+  @TestFactory\n+  List<DynamicTest> should_SetJaasSubject_When_AnnotationExists_On_TestFactory() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"testfactory\");\n+    return Collections.emptyList();\n+  }\n+\n+  @WithAccessId(user = \"testfactory1\")\n+  @WithAccessId(user = \"testfactory2\")\n+  @TestFactory\n+  List<DynamicTest>\n+      should_SetJaasSubjectFromFirstAnnotation_When_MultipleAnnotationsExists_On_TestFactory() {\n+    assertThat(CurrentUserContext.getUserid()).isEqualTo(\"testfactory1\");\n+    return Collections.emptyList();\n+  }\n+\n+  // endregion\n+\n+  // region JaasExtension#interceptTestTemplateMethod\n+\n+  @TestTemplate\n+  @Disabled(\"this can be tested with a org.junit.platform.launcher.TestExecutionListener\")\n+  void should_NotFindContextProvider_When_AnnotationIsMissing_On_TestTemplate() {", "originalCommit": "ee226d755487bb134b6f40cc4c9b37f5393dead5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "57c4cdc2a9e0bb86dbd67852ab30c85d3ea339a6", "url": "https://github.com/Taskana/taskana/commit/57c4cdc2a9e0bb86dbd67852ab30c85d3ea339a6", "message": "TSK-1207: renamed some variable names", "committedDate": "2020-04-29T10:47:06Z", "type": "commit"}]}