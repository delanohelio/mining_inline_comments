{"pr_number": 959, "pr_title": "TSK-1143 UpdateTask with Planned sometimes fails", "pr_createdAt": "2020-03-03T12:19:18Z", "pr_url": "https://github.com/Taskana/taskana/pull/959", "timeline": [{"oid": "210fe992514065931a6e222e8a00ee0e1ebeed09", "url": "https://github.com/Taskana/taskana/commit/210fe992514065931a6e222e8a00ee0e1ebeed09", "message": "TSK-1143 UpdateTask with Planned sometimes fails", "committedDate": "2020-03-03T12:23:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NTQ0Mw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387655443", "bodyText": "setting planned twice does not make sense, does it?", "author": "holgerhagen", "createdAt": "2020-03-04T13:10:45Z", "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +336,21 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()\n+      throws NotAuthorizedException, TaskNotFoundException, ClassificationNotFoundException,\n+          InvalidArgumentException, InvalidStateException, ConcurrencyException,\n+          AttachmentPersistenceException {\n+    TaskService taskService = taskanaEngine.getTaskService();\n+    Task task = taskService.getTask(\"TKI:000000000000000000000000000000000030\");\n+    task.setPlanned(Instant.now());\n+    task.setPlanned(getInstant(\"2020-04-21T07:00:00\"));", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUwMDk4Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389500987", "bodyText": "That's right. I removed the first update...", "author": "BerndBreier", "createdAt": "2020-03-09T07:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1NTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTM1OA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387659358", "bodyText": "Can we use a MessageFormatter here?", "author": "holgerhagen", "createdAt": "2020-03-04T13:17:46Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls,\n+      BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task, Instant now)\n+      throws InvalidArgumentException {\n+    List<Attachment> attachments = task.getAttachments();\n+    if (attachments != null) {\n+      for (Attachment attachment : attachments) {\n+        AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+        attachmentImpl.setId(IdGenerator.generateWithPrefix(ID_PREFIX_ATTACHMENT));\n+        attachmentImpl.setTaskId(task.getId());\n+        attachmentImpl.setCreated(now);\n+        attachmentImpl.setModified(now);\n+        ObjectReference objRef = attachmentImpl.getObjectReference();\n+        validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n+        attachmentMapper.insert(attachmentImpl);\n+      }\n+    }\n+  }\n+\n+  void deleteRemovedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to deleteRemovedAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+\n+    final List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<String> newAttachmentIds = new ArrayList<>();\n+    if (newAttachments != null && !newAttachments.isEmpty()) {\n+      newAttachmentIds =\n+          newAttachments.stream().map(Attachment::getId).collect(Collectors.toList());\n+    }\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (oldAttachments != null && !oldAttachments.isEmpty()) {\n+      final List<String> newAttIds = newAttachmentIds;\n+      oldAttachments.forEach(\n+          a -> {\n+            if (!newAttIds.contains(a.getId())) {\n+              attachmentMapper.deleteAttachment(a.getId());\n+              LOGGER.debug(\n+                  \"TaskService.updateTask() for TaskId={} DELETED an Attachment={}.\",\n+                  newTaskImpl.getId(),\n+                  a);\n+            }\n+          });\n+    }\n+    LOGGER.debug(\"exit from deleteRemovedAttachmentsOnTaskUpdate()\");\n+  }\n+\n+  void insertNewAttachmentOnTaskUpdate(TaskImpl newTaskImpl, Attachment attachment)\n+      throws AttachmentPersistenceException {\n+    LOGGER.debug(\"entry to insertNewAttachmentOnTaskUpdate()\");\n+    AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+    initAttachment(attachmentImpl, newTaskImpl);\n+\n+    try {\n+      attachmentMapper.insert(attachmentImpl);\n+      LOGGER.debug(\n+          \"TaskService.updateTask() for TaskId={} INSERTED an Attachment={}.\",\n+          newTaskImpl.getId(),\n+          attachmentImpl);\n+    } catch (PersistenceException e) {\n+      throw new AttachmentPersistenceException(\n+          \"Cannot insert the Attachement \"", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyMTM3Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389521377", "bodyText": "good point. Done", "author": "BerndBreier", "createdAt": "2020-03-09T08:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTUxMQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387659511", "bodyText": "Why don't we call initAttachment()?", "author": "holgerhagen", "createdAt": "2020-03-04T13:18:05Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls,\n+      BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task, Instant now)\n+      throws InvalidArgumentException {\n+    List<Attachment> attachments = task.getAttachments();\n+    if (attachments != null) {\n+      for (Attachment attachment : attachments) {\n+        AttachmentImpl attachmentImpl = (AttachmentImpl) attachment;\n+        attachmentImpl.setId(IdGenerator.generateWithPrefix(ID_PREFIX_ATTACHMENT));\n+        attachmentImpl.setTaskId(task.getId());", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyMjAwOQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389522009", "bodyText": "this code is inherited. I changed it. Now it calls initAttachment()", "author": "BerndBreier", "createdAt": "2020-03-09T08:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1OTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MTcxNQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387661715", "bodyText": "why is this one public while the other are not?", "author": "holgerhagen", "createdAt": "2020-03-04T13:22:12Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package pro.taskana.task.internal;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  public List<Attachment> augmentAttachmentsByClassification(", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyMzYwOA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389523608", "bodyText": "Good catch. I remove the public access modifier.", "author": "BerndBreier", "createdAt": "2020-03-09T08:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2MTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDkxMw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387664913", "bodyText": "This does not make sense. If we can generalize the validation, then it should be part of ObjectReference instead of AttachmentHandler. If it is specific to task or attachment, it has to be placed in the corresponding service.", "author": "holgerhagen", "createdAt": "2020-03-04T13:27:56Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1587,86 +1496,11 @@ private void validateCustomFields(Map<String, String> customFieldsToUpdate)\n         .list();\n   }\n \n-  private void validateObjectReference(ObjectReference objRef, String objRefType, String objName)\n-      throws InvalidArgumentException {\n-    LOGGER.debug(\"entry to validateObjectReference()\");\n-    // check that all values in the ObjectReference are set correctly\n-    if (objRef == null) {\n-      throw new InvalidArgumentException(objRefType + \" of \" + objName + \" must not be null\");\n-    } else if (objRef.getCompany() == null || objRef.getCompany().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Company of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystem() == null || objRef.getSystem().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"System of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystemInstance() == null || objRef.getSystemInstance().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"SystemInstance of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getType() == null || objRef.getType().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Type of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getValue() == null || objRef.getValue().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Value of\" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    }\n-    LOGGER.debug(\"exit from validateObjectReference()\");\n-  }\n-\n-  private PrioDurationHolder handleAttachments(TaskImpl task) throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"entry to handleAttachments(task = {})\", task);\n-    }\n-\n-    List<Attachment> attachments = task.getAttachments();\n-    if (attachments == null || attachments.isEmpty()) {\n-      return new PrioDurationHolder(null, Integer.MIN_VALUE);\n-    }\n-\n-    PrioDurationHolder actualPrioDuration = new PrioDurationHolder(MAX_DURATION, Integer.MIN_VALUE);\n-\n-    Iterator<Attachment> i = attachments.iterator();\n-    while (i.hasNext()) {\n-      Attachment attachment = i.next();\n-      if (attachment == null) {\n-        i.remove();\n-      } else {\n-        actualPrioDuration = handleNonNullAttachment(actualPrioDuration, attachment);\n-      }\n-    }\n-    if (MAX_DURATION.equals(actualPrioDuration.getLeft())) {\n-      actualPrioDuration = new PrioDurationHolder(null, actualPrioDuration.getRight());\n-    }\n-\n-    LOGGER.debug(\"exit from handleAttachments(), returning {}\", actualPrioDuration);\n-    return actualPrioDuration;\n-  }\n-\n-  private PrioDurationHolder handleNonNullAttachment(\n-      PrioDurationHolder actualPrioDuration, Attachment attachment)\n-      throws InvalidArgumentException {\n-    ObjectReference objRef = attachment.getObjectReference();\n-    validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n-    if (attachment.getClassificationSummary() == null) {\n-      throw new InvalidArgumentException(\n-          \"Classification of attachment \" + attachment + \" must not be null\");\n-    } else {\n-      ClassificationSummary classificationSummary = attachment.getClassificationSummary();\n-      if (classificationSummary != null) {\n-        actualPrioDuration =\n-            getNewPrioDuration(\n-                actualPrioDuration,\n-                classificationSummary.getPriority(),\n-                classificationSummary.getServiceLevel());\n-      }\n-    }\n-    return actualPrioDuration;\n-  }\n-\n-  private void standardUpdateActions(\n-      TaskImpl oldTaskImpl, TaskImpl newTaskImpl, PrioDurationHolder prioDurationFromAttachments)\n-      throws InvalidArgumentException, ConcurrencyException, ClassificationNotFoundException,\n-          InvalidStateException {\n-    validateObjectReference(newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n+  private void standardUpdateActions(TaskImpl oldTaskImpl, TaskImpl newTaskImpl)\n+      throws InvalidArgumentException, ConcurrencyException, InvalidStateException,\n+          AttachmentPersistenceException, ClassificationNotFoundException {\n+    attachmentHandler.validateObjectReference(\n+        newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NTc5Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389545797", "bodyText": "I moved the validate method into class ObjectReference. However, I had to make it static because it checks whether the objectReference is null.", "author": "BerndBreier", "createdAt": "2020-03-09T09:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NDkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTg3OA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387665878", "bodyText": "why don't just check modified? It doesn't make sense to me to check the rest as well...", "author": "holgerhagen", "createdAt": "2020-03-04T13:29:41Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1587,86 +1496,11 @@ private void validateCustomFields(Map<String, String> customFieldsToUpdate)\n         .list();\n   }\n \n-  private void validateObjectReference(ObjectReference objRef, String objRefType, String objName)\n-      throws InvalidArgumentException {\n-    LOGGER.debug(\"entry to validateObjectReference()\");\n-    // check that all values in the ObjectReference are set correctly\n-    if (objRef == null) {\n-      throw new InvalidArgumentException(objRefType + \" of \" + objName + \" must not be null\");\n-    } else if (objRef.getCompany() == null || objRef.getCompany().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Company of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystem() == null || objRef.getSystem().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"System of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getSystemInstance() == null || objRef.getSystemInstance().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"SystemInstance of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getType() == null || objRef.getType().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Type of \" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    } else if (objRef.getValue() == null || objRef.getValue().length() == 0) {\n-      throw new InvalidArgumentException(\n-          \"Value of\" + objRefType + \" of \" + objName + MUST_NOT_BE_EMPTY);\n-    }\n-    LOGGER.debug(\"exit from validateObjectReference()\");\n-  }\n-\n-  private PrioDurationHolder handleAttachments(TaskImpl task) throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"entry to handleAttachments(task = {})\", task);\n-    }\n-\n-    List<Attachment> attachments = task.getAttachments();\n-    if (attachments == null || attachments.isEmpty()) {\n-      return new PrioDurationHolder(null, Integer.MIN_VALUE);\n-    }\n-\n-    PrioDurationHolder actualPrioDuration = new PrioDurationHolder(MAX_DURATION, Integer.MIN_VALUE);\n-\n-    Iterator<Attachment> i = attachments.iterator();\n-    while (i.hasNext()) {\n-      Attachment attachment = i.next();\n-      if (attachment == null) {\n-        i.remove();\n-      } else {\n-        actualPrioDuration = handleNonNullAttachment(actualPrioDuration, attachment);\n-      }\n-    }\n-    if (MAX_DURATION.equals(actualPrioDuration.getLeft())) {\n-      actualPrioDuration = new PrioDurationHolder(null, actualPrioDuration.getRight());\n-    }\n-\n-    LOGGER.debug(\"exit from handleAttachments(), returning {}\", actualPrioDuration);\n-    return actualPrioDuration;\n-  }\n-\n-  private PrioDurationHolder handleNonNullAttachment(\n-      PrioDurationHolder actualPrioDuration, Attachment attachment)\n-      throws InvalidArgumentException {\n-    ObjectReference objRef = attachment.getObjectReference();\n-    validateObjectReference(objRef, \"ObjectReference\", \"Attachment\");\n-    if (attachment.getClassificationSummary() == null) {\n-      throw new InvalidArgumentException(\n-          \"Classification of attachment \" + attachment + \" must not be null\");\n-    } else {\n-      ClassificationSummary classificationSummary = attachment.getClassificationSummary();\n-      if (classificationSummary != null) {\n-        actualPrioDuration =\n-            getNewPrioDuration(\n-                actualPrioDuration,\n-                classificationSummary.getPriority(),\n-                classificationSummary.getServiceLevel());\n-      }\n-    }\n-    return actualPrioDuration;\n-  }\n-\n-  private void standardUpdateActions(\n-      TaskImpl oldTaskImpl, TaskImpl newTaskImpl, PrioDurationHolder prioDurationFromAttachments)\n-      throws InvalidArgumentException, ConcurrencyException, ClassificationNotFoundException,\n-          InvalidStateException {\n-    validateObjectReference(newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n+  private void standardUpdateActions(TaskImpl oldTaskImpl, TaskImpl newTaskImpl)\n+      throws InvalidArgumentException, ConcurrencyException, InvalidStateException,\n+          AttachmentPersistenceException, ClassificationNotFoundException {\n+    attachmentHandler.validateObjectReference(\n+        newTaskImpl.getPrimaryObjRef(), \"primary ObjectReference\", TASK);\n     // TODO: not safe to rely only on different timestamps.\n     // With fast execution below 1ms there will be no concurrencyException\n     if (oldTaskImpl.getModified() != null", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NzkyOQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389547929", "bodyText": "The problem is that the timestamps are not safe to detect concurrent updates. We have already some testcases that fail intermittently due to this problem. With the additional tests (on claimed / state) we simply narrow the failure window. A real solution would be to maintain a version counter on task objects that is updated each time a task is persisted.", "author": "BerndBreier", "createdAt": "2020-03-09T09:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY2NTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3ODg1Mw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387678853", "bodyText": "I don't like to have this hidden in \"standardUpdateActions\".", "author": "holgerhagen", "createdAt": "2020-03-04T13:52:47Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1694,6 +1528,16 @@ private void standardUpdateActions(\n       newTaskImpl.setPlanned(oldTaskImpl.getPlanned());\n     }\n \n+    if (newTaskImpl.getClassificationSummary() == null) {\n+      newTaskImpl.setClassificationSummary(oldTaskImpl.getClassificationSummary());\n+    }\n+\n+    attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwOTU0NQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393009545", "bodyText": "moved it to updateTask() method.", "author": "BerndBreier", "createdAt": "2020-03-16T13:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3ODg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3OTM1OQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387679359", "bodyText": "Does this handle setPlanned as well. If it does, we probably don't need to initialize it in line 1528.", "author": "holgerhagen", "createdAt": "2020-03-04T13:53:37Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1694,6 +1528,16 @@ private void standardUpdateActions(\n       newTaskImpl.setPlanned(oldTaskImpl.getPlanned());\n     }\n \n+    if (newTaskImpl.getClassificationSummary() == null) {\n+      newTaskImpl.setClassificationSummary(oldTaskImpl.getClassificationSummary());\n+    }\n+\n+    attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+\n+    updateClassificationSummary(newTaskImpl, oldTaskImpl);\n+\n+    newTaskImpl = serviceLevelHandler.updatePrioPlannedDueOfTask(newTaskImpl, oldTaskImpl, false);", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1MjA1NA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389552054", "bodyText": "I removed the initialization of planned from line 1528", "author": "BerndBreier", "createdAt": "2020-03-09T09:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY3OTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MDEyMw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r387680123", "bodyText": "by the way: should attachment and tasks have the same modification timestamp? It would probably nice, wouldn't it?", "author": "holgerhagen", "createdAt": "2020-03-04T13:54:58Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -1706,393 +1550,24 @@ private void standardUpdateActions(\n           String.format(TASK_WITH_ID_IS_NOT_READY, oldTaskImpl.getId(), oldTaskImpl.getState()));\n     }\n \n-    updateClassificationRelatedProperties(oldTaskImpl, newTaskImpl, prioDurationFromAttachments);\n-\n     newTaskImpl.setModified(Instant.now());", "originalCommit": "210fe992514065931a6e222e8a00ee0e1ebeed09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU3MjQ1MQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r389572451", "bodyText": "I restructured the code so that tasks and attachments that are updated with the task have the same modification timestamp...", "author": "BerndBreier", "createdAt": "2020-03-09T10:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4MDEyMw=="}], "type": "inlineReview"}, {"oid": "20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "url": "https://github.com/Taskana/taskana/commit/20c4ca0492f6cdd98f739cd4bf26c0c109e37673", "message": "TSK-1143 UpdateTask planned - comments from Holger", "committedDate": "2020-03-10T13:34:59Z", "type": "forcePushed"}, {"oid": "287226c31c38cb20e9aa488a82ff4cee23aab123", "url": "https://github.com/Taskana/taskana/commit/287226c31c38cb20e9aa488a82ff4cee23aab123", "message": "TSK-1143 UpdateTask planned - comments from Holger", "committedDate": "2020-03-11T07:21:24Z", "type": "forcePushed"}, {"oid": "24bdd185806073bf75631ac0fb11135fb7bc5640", "url": "https://github.com/Taskana/taskana/commit/24bdd185806073bf75631ac0fb11135fb7bc5640", "message": "TSK-1143 UpdateTask planned - comments from Holger", "committedDate": "2020-03-11T07:45:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzA0Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392863047", "bodyText": "Shouldn't we move this test to the service level tests to have them all together in one file?", "author": "holgerhagen", "createdAt": "2020-03-16T08:51:49Z", "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +342,20 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxMDIyMg==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393010222", "bodyText": "moved it to ServiceLevelPriorityAccTest", "author": "BerndBreier", "createdAt": "2020-03-16T13:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzM4Mw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392863383", "bodyText": "I think most of the Exceptions will no longer be thrown by this test. Please verify.", "author": "holgerhagen", "createdAt": "2020-03-16T08:52:30Z", "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -336,4 +342,20 @@ void testUpdateCallbackInfoOfSimpleTask()\n \n     assertThat(retrievedUpdatedTask.getCallbackInfo()).isEqualTo(callbackInfo);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdatePlannedAndDue()\n+      throws NotAuthorizedException, TaskNotFoundException, ClassificationNotFoundException,", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxMDcwNw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393010707", "bodyText": "Exceptions are now validated", "author": "BerndBreier", "createdAt": "2020-03-16T13:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NTM0MA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392865340", "bodyText": "Please validate the throws statement. It contains too many Exceptions, which will no longer be thrown by this test.", "author": "holgerhagen", "createdAt": "2020-03-16T08:56:19Z", "path": "lib/taskana-core/src/test/java/acceptance/task/UpdateTaskAccTest.java", "diffHunk": "@@ -83,26 +83,32 @@ void testThrowsExceptionIfMandatoryPrimaryObjectReferenceIsNotSetOrIncomplete()\n     assertThatThrownBy(() -> taskService.updateTask(task))", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5ODczNQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392998735", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-16T12:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzI5Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392867297", "bodyText": "Please validate the throws declarations in the entire file.", "author": "holgerhagen", "createdAt": "2020-03-16T09:00:08Z", "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNzg1MQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393007851", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-16T13:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzQxNA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392867414", "bodyText": "This is not used anywhere.", "author": "holgerhagen", "createdAt": "2020-03-16T09:00:22Z", "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NDQ0MQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392994441", "bodyText": "done", "author": "BerndBreier", "createdAt": "2020-03-16T12:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NzQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2ODAzNw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392868037", "bodyText": "Please correct the uppercase H.\nIs this not noticed by checkstyle?", "author": "holgerhagen", "createdAt": "2020-03-16T09:01:37Z", "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    // test bulk operation setPlanned...\n+    BulkOperationResults<String, TaskanaException> results =\n+        taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, Arrays.asList(taskId));\n+    Task task = taskService.getTask(taskId);\n+    assertThat(results.containsErrors()).isFalse();\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWitHTaskUpdate()", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NDc0MQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392994741", "bodyText": "Apparently, checkstyle doesn't notice it", "author": "BerndBreier", "createdAt": "2020-03-16T12:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2ODAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MDk1Mw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392870953", "bodyText": "I'm a bit surprised that this test has no side effect as it changes all test data. Are you sure that we do not have any dependencies to the other tests?", "author": "holgerhagen", "createdAt": "2020-03-16T09:07:39Z", "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -256,4 +260,163 @@ void testSetPlannedPropertyOnEmptyTasksList()\n         taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, new ArrayList<>());\n     assertThat(results.containsErrors()).isFalse();\n   }\n+\n+  // +-----------------------------------------+------------------------------------------+------+\n+  // |TKI:000000000000000000000000000000000002 | CLI:100000000000000000000000000000000016 | P1D  |\n+  // |TAI:000000000000000000000000000000000003 | CLI:000000000000000000000000000000000004 | P4D  |\n+  // |TAI:000000000000000000000000000000000004 | CLI:000000000000000000000000000000000005 | P5D  |\n+  // |TAI:000000000000000000000000000000000005 | CLI:000000000000000000000000000000000006 | P5D  |\n+  // |TAI:000000000000000000000000000000000006 | CLI:000000000000000000000000000000000007 | P6D  |\n+  // |TAI:000000000000000000000000000000000007 | CLI:100000000000000000000000000000000008 | P1D  |\n+  // +-----------------------------------------+------------------------------------------+------+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWithBulkUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    // test bulk operation setPlanned...\n+    BulkOperationResults<String, TaskanaException> results =\n+        taskanaEngine.getTaskService().setPlannedPropertyOfTasks(planned, Arrays.asList(taskId));\n+    Task task = taskService.getTask(taskId);\n+    assertThat(results.containsErrors()).isFalse();\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskWitHTaskUpdate()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    Task task = taskService.getTask(taskId);\n+    // test update of planned date via updateTask()\n+    task.setPlanned(task.getPlanned().plus(Duration.ofDays(3)));\n+    task = taskService.updateTask(task);\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetDuePropertyOnSingleTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    Task task = taskService.getTask(taskId);\n+\n+    // test update of due that fails\n+    task.setDue(planned.plus(Duration.ofDays(8)));\n+    Task finalTask = task;\n+    assertThatThrownBy(\n+        () -> {\n+            taskService.updateTask(finalTask);\n+        })\n+        .isInstanceOf(InvalidArgumentException.class);\n+\n+    // update due and planned as expected.\n+    task = taskService.getTask(taskId);\n+    task.setDue(planned.plus(Duration.ofDays(3)));\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    task.setPlanned(task.getDue().plus(Duration.ofDays(-1)));\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+\n+    // update due and planned as expected.\n+    task = taskService.getTask(taskId);\n+    task.setDue(planned.plus(Duration.ofDays(3)));\n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnSingleTaskUpdateWithNulls()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException,\n+          ConcurrencyException, InvalidStateException, ClassificationNotFoundException,\n+          AttachmentPersistenceException {\n+    String taskId = \"TKI:000000000000000000000000000000000002\";\n+    final Instant planned = getInstant(\"2020-05-03T07:00:00\");\n+    Task task = taskService.getTask(taskId);\n+    \n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    DaysToWorkingDaysConverter converter = DaysToWorkingDaysConverter.initialize();\n+    long days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setDue(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setPlanned(planned.plus(Duration.ofDays(13)));\n+    task.setDue(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getPlanned(), 1);\n+    assertThat(task.getDue()).isEqualTo(task.getPlanned().plus(Duration.ofDays(days)));\n+\n+    task.setDue(planned.plus(Duration.ofDays(13)));\n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    days = converter.convertWorkingDaysToDays(task.getDue(), -1);\n+    assertThat(task.getDue()).isEqualTo(planned.plus(Duration.ofDays(13)));\n+    assertThat(task.getPlanned()).isEqualTo(task.getDue().plus(Duration.ofDays(days)));\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_2\"})\n+  @Test\n+  void testSetPlannedPropertyOnAllTasks()", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg0Mzg1OQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393843859", "bodyText": "This test has no side effects because I added a @beforeeach method that resets the database before each testcase.\nHowever, this could have impact on performance of our build process. Therefore, I think I should remove the @beforeeach method and move this specific testcase into a class of its own.", "author": "BerndBreier", "createdAt": "2020-03-17T17:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxNDkxOQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392914919", "bodyText": "Do we need the distinction between creation and update? Or could we at least use the same insertion method?", "author": "holgerhagen", "createdAt": "2020-03-16T10:28:01Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentHandler.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package pro.taskana.task.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.ibatis.exceptions.PersistenceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.internal.util.IdGenerator;\n+import pro.taskana.task.api.exceptions.AttachmentPersistenceException;\n+import pro.taskana.task.api.models.Attachment;\n+import pro.taskana.task.api.models.AttachmentSummary;\n+import pro.taskana.task.api.models.ObjectReference;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.internal.models.AttachmentImpl;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+public class AttachmentHandler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentHandler.class);\n+  private static final String ID_PREFIX_ATTACHMENT = \"TAI\";\n+  private final AttachmentMapper attachmentMapper;\n+  private final ClassificationService classificationService;\n+\n+  AttachmentHandler(\n+      AttachmentMapper attachmentMapper, ClassificationService classificationService) {\n+    this.attachmentMapper = attachmentMapper;\n+    this.classificationService = classificationService;\n+  }\n+\n+  List<Attachment> augmentAttachmentsByClassification(\n+      List<AttachmentImpl> attachmentImpls, BulkOperationResults<String, Exception> bulkLog) {\n+    LOGGER.debug(\"entry to augmentAttachmentsByClassification()\");\n+    List<Attachment> result = new ArrayList<>();\n+    if (attachmentImpls == null || attachmentImpls.isEmpty()) {\n+      return result;\n+    }\n+    List<ClassificationSummary> classifications =\n+        classificationService\n+            .createClassificationQuery()\n+            .idIn(\n+                attachmentImpls.stream()\n+                    .map(t -> t.getClassificationSummary().getId())\n+                    .distinct()\n+                    .toArray(String[]::new))\n+            .list();\n+    for (AttachmentImpl att : attachmentImpls) {\n+      ClassificationSummary classificationSummary =\n+          classifications.stream()\n+              .filter(cl -> cl.getId().equals(att.getClassificationSummary().getId()))\n+              .findFirst()\n+              .orElse(null);\n+      if (classificationSummary == null) {\n+        String id = att.getClassificationSummary().getId();\n+        bulkLog.addError(\n+            att.getClassificationSummary().getId(),\n+            new ClassificationNotFoundException(\n+                id,\n+                String.format(\n+                    \"When processing task updates due to change \"\n+                        + \"of classification, the classification with id %s was not found\",\n+                    id)));\n+      } else {\n+        att.setClassificationSummary(classificationSummary);\n+        result.add(att);\n+      }\n+    }\n+\n+    LOGGER.debug(\"exit from augmentAttachmentsByClassification()\");\n+    return result;\n+  }\n+\n+  void insertAndDeleteAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"entry to insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+    List<Attachment> newAttachments =\n+        newTaskImpl.getAttachments().stream().filter(Objects::nonNull).collect(Collectors.toList());\n+    newTaskImpl.setAttachments(newAttachments);\n+\n+    deleteRemovedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    insertNewAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    updateModifiedAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"exit from insertAndDeleteAttachmentsOnTaskUpdate(oldTaskImpl = {}, newTaskImpl = {})\",\n+          oldTaskImpl,\n+          newTaskImpl);\n+    }\n+  }\n+\n+  void updateModifiedAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl) {\n+    List<Attachment> newAttachments = newTaskImpl.getAttachments();\n+    List<Attachment> oldAttachments = oldTaskImpl.getAttachments();\n+    if (newAttachments != null\n+        && !newAttachments.isEmpty()\n+        && oldAttachments != null\n+        && !oldAttachments.isEmpty()) {\n+      final Map<String, Attachment> oldAttachmentMap =\n+          oldAttachments.stream()\n+              .collect(Collectors.toMap(AttachmentSummary::getId, Function.identity()));\n+      newAttachments.forEach(\n+          a -> {\n+            if (oldAttachmentMap.containsKey(a.getId())\n+                && !a.equals(oldAttachmentMap.get(a.getId()))) {\n+              attachmentMapper.update((AttachmentImpl) a);\n+            }\n+          });\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskUpdate(TaskImpl newTaskImpl, TaskImpl oldTaskImpl)\n+      throws AttachmentPersistenceException {\n+    List<String> oldAttachmentIds =\n+        oldTaskImpl.getAttachments().stream()\n+            .map(AttachmentSummary::getId)\n+            .collect(Collectors.toList());\n+    List<AttachmentPersistenceException> exceptions = new ArrayList<>();\n+    newTaskImpl\n+        .getAttachments()\n+        .forEach(\n+            a -> {\n+              if (!oldAttachmentIds.contains(a.getId())) {\n+                try {\n+                  insertNewAttachmentOnTaskUpdate(newTaskImpl, a);\n+                } catch (AttachmentPersistenceException excpt) {\n+                  exceptions.add(excpt);\n+                  LOGGER.warn(\"attempted to insert attachment {} and caught exception\", a, excpt);\n+                }\n+              }\n+            });\n+    if (!exceptions.isEmpty()) {\n+      throw exceptions.get(0);\n+    }\n+  }\n+\n+  void insertNewAttachmentsOnTaskCreation(TaskImpl task)", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk1NjM3NQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392956375", "bodyText": "The difference is:\n\non task creation, all attachments are inserted. The insertNewAttachmentsOnTaskCreation method just iterates over all attachments and inserts each of them\non task update, only new attachments are inserted. Therefore, method insertNewAttachmentsOnTaskUpdate first detects which attachment is new and then inserts only these attachments.\nI think, I will extract the common parts of these two methods into a method insertAttachment. This method would have to initialize the attachment, validate its ObjectReference and then call the mapper to insert it...", "author": "BerndBreier", "createdAt": "2020-03-16T11:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxNDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392922763", "bodyText": "This is some kind of precondition checking, isn't it? So we could move it even before \"openConnection\"?", "author": "holgerhagen", "createdAt": "2020-03-16T10:37:18Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -399,18 +389,20 @@ public Attachment newAttachment() {\n   @Override\n   public Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n-          ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException {\n+          NotAuthorizedException, AttachmentPersistenceException, InvalidStateException,\n+          ClassificationNotFoundException {\n     String userId = CurrentUserContext.getUserid();\n     LOGGER.debug(\"entry to updateTask(task = {}, userId = {})\", task, userId);\n     TaskImpl newTaskImpl = (TaskImpl) task;\n     TaskImpl oldTaskImpl;\n     try {\n       taskanaEngine.openConnection();\n       oldTaskImpl = (TaskImpl) getTask(newTaskImpl.getId());\n-      PrioDurationHolder prioDurationFromAttachments =\n-          handleAttachmentsOnTaskUpdate(oldTaskImpl, newTaskImpl);\n-      standardUpdateActions(oldTaskImpl, newTaskImpl, prioDurationFromAttachments);\n+\n+      newTaskImpl = checkConcurrencyAndSetModified(newTaskImpl, oldTaskImpl);\n+\n+      attachmentHandler.insertAndDeleteAttachmentsOnTaskUpdate(newTaskImpl, oldTaskImpl);\n+      standardUpdateActions(oldTaskImpl, newTaskImpl);", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyNjUxNA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392926514", "bodyText": "Ok, just saw that we need the old task impl for some checks. But maybe we could still extract the preconditions (e.g. check that no information is changed that must not be changed)? From my point of view this would improve the maintainability.", "author": "holgerhagen", "createdAt": "2020-03-16T10:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk2OTE2Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392969167", "bodyText": "Don't understand completely. To check whether information was changed. I need the old task from the database ...\nThe only action I could remove from standardUpdateActions is objectReference.validate().\nShould I do this?", "author": "BerndBreier", "createdAt": "2020-03-16T12:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwNzY4Mg==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393007682", "bodyText": "Ok, I moved the validation of the object reference out of standardUpdateActions.", "author": "BerndBreier", "createdAt": "2020-03-16T13:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyMjc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTExOQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392935119", "bodyText": "This should rather be placed in TaskServiceImpl, shouldn't it. It has nothing to do with service levels.\nMaybe we should rename it to getTasks? It does the same as getTask but or multiple tasks.", "author": "holgerhagen", "createdAt": "2020-03-16T10:55:05Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -645,10 +637,14 @@ public void forceDeleteTask(String taskId)\n     try {\n       taskanaEngine.openConnection();\n       // use only elements we are authorized for\n-      Pair<List<String>, BulkOperationResults<String, TaskanaException>> resultsPair =\n-          filterForAuthorizedTasks(taskIds);\n+      Pair<List<MinimalTaskSummary>, BulkLog> resultsPair =\n+          serviceLevelHandler.filterTasksForExistenceAndAuthorization(taskIds);", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxMzMzNA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393013334", "bodyText": "Placing it into TaskServiceImpl creates dependency loops because then TaskServiceImpl depends on ServiceLevelHandler and ServiceLevelHandler depends on TaskServiceImpl.\nIf we want to move it out of ServiceLevelHandler, we should create a general TaskServiceHelper class that can be called from TaskServiceImpl, ServiceLevelHandler, etc.\nIn this way we would create a loop-free dependency graph...", "author": "BerndBreier", "createdAt": "2020-03-16T13:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjQxMA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392936410", "bodyText": "These should already be included in the first result, correct? So we should not query the database again.", "author": "holgerhagen", "createdAt": "2020-03-16T10:57:38Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -658,13 +654,7 @@ public void forceDeleteTask(String taskId)\n           return bulkLog;\n         } else {\n           // check the outcome\n-          List<MinimalTaskSummary> existingMinimalTaskSummaries =\n-              taskMapper.findExistingTasks(taskIds, null);\n-          // add exceptions for non existing tasks\n-          bulkLog.addAllErrors(\n-              serviceLevelHander.addExceptionsForNonExistingTasks(\n-                  taskIds, existingMinimalTaskSummaries));\n-          // add exceptions of all remaining tasks whose owners were not set\n+          existingMinimalTaskSummaries = taskMapper.findExistingTasks(taskIds, null);", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNTM2Nw==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393015367", "bodyText": "This second call retrieves the tasks >after< the update action. The purpose is to identify which tasks were not affected by the update action and to log an error for these tasks.\nThis cannot be accomplished with the result of the first database call (which happens before the update )", "author": "BerndBreier", "createdAt": "2020-03-16T13:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzOTk3MA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392939970", "bodyText": "This is only used from the refresh job, isn't it? Does it need to be public for this?\nWould it be possible to apply our bulk scheme here as well?", "author": "holgerhagen", "createdAt": "2020-03-16T11:04:01Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -736,7 +726,8 @@ public void forceDeleteTask(String taskId)\n     return affectedTaskIds;\n   }\n \n-  public void refreshPriorityAndDueDate(String taskId) throws ClassificationNotFoundException {\n+  public void refreshPriorityAndDueDateOnClassificationUpdate(String taskId)", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAxNjg5MQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393016891", "bodyText": "Needs to be public because the refresh job belongs to another package (pro.taskana.common.internal.jobs).\nWhat do you mean with the 'bulk scheme'?", "author": "BerndBreier", "createdAt": "2020-03-16T13:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzOTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NDUzOQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393864539", "bodyText": "Movement of classification update to bulk actions is subject to TSK-442, Pull request #973", "author": "BerndBreier", "createdAt": "2020-03-17T17:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzOTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MTk1NQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392941955", "bodyText": "Why is this one public while the other operations are not?", "author": "holgerhagen", "createdAt": "2020-03-16T11:07:56Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -66,13 +68,12 @@ public ServiceLevelHandler(\n   // - For each task iterate through all referenced classifications and find minimum ServiceLevel\n   // - collect the results into a map Duration -> List of tasks\n   // - for each duration in this map update due date of all associated tasks\n-  public BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasksImpl(\n-      Instant planned, List<String> argTaskIds) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+  public BulkLog setPlannedPropertyOfTasksImpl(Instant planned, List<String> argTaskIds) {", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyMDMwOA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393020308", "bodyText": "Good catch. I removed the 'public' modifier", "author": "BerndBreier", "createdAt": "2020-03-16T13:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NjY2OQ==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r392946669", "bodyText": "Wouldn't it be nicer to move this to the converter?\nLike:\nnewTaskImpl.setDue(converter.addWorkingDaysToTimestamp(newTaskImpl.getPlanned(), durationPrioHolder.getDuration());\nWhat do you think?", "author": "holgerhagen", "createdAt": "2020-03-16T11:20:17Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -82,69 +83,207 @@ public ServiceLevelHandler(\n         findAllInvolvedClassifications(existingTasksAuthorizedFor, attachments);\n     List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n         resolveDurationsInClassifications(allInvolvedClassifications);\n-    Map<Duration, List<TaskDuration>> tasksPerDuration =\n-        getTasksPerDuration(\n+    Map<Duration, List<String>> durationToTaskIdsMap =\n+        getDurationToTaskIdsMap(\n             existingTasksAuthorizedFor, attachments, allInvolvedClassificationsWithDuration);\n-    bulkLog.addAllErrors(updateAffectedTasks(planned, tasksPerDuration));\n+    BulkLog updateResult = updatePlannedPropertyOfAffectedTasks(planned, durationToTaskIdsMap);\n+    bulkLog.addAllErrors(updateResult);\n \n     return bulkLog;\n   }\n \n-  BulkOperationResults<String, TaskanaException> addExceptionsForNonExistingTasks(\n+  BulkLog addExceptionsForNonExistingTasksToBulkLog(\n       List<String> requestTaskIds, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    BulkLog bulkLog = new BulkLog();\n     List<String> nonExistingTaskIds = new ArrayList<>(requestTaskIds);\n     List<String> existingTaskIds =\n         existingMinimalTaskSummaries.stream()\n             .map(MinimalTaskSummary::getTaskId)\n             .collect(Collectors.toList());\n     nonExistingTaskIds.removeAll(existingTaskIds);\n-    for (String taskId : nonExistingTaskIds) {\n-      bulkLog.addError(taskId, new TaskNotFoundException(taskId, \"Task was not found\"));\n-    }\n+    nonExistingTaskIds.forEach(\n+        taskId ->\n+            bulkLog.addError(taskId, new TaskNotFoundException(taskId, \"Task was not found\")));\n     return bulkLog;\n   }\n \n-  private BulkOperationResults<String, TaskanaException> updateAffectedTasks(\n-      Instant planned, Map<Duration, List<TaskDuration>> tasksPerDuration) {\n-    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n-    TaskImpl referenceTask = new TaskImpl();\n-    referenceTask.setPlanned(planned);\n-    for (Map.Entry<Duration, List<TaskDuration>> entry : tasksPerDuration.entrySet()) {\n-      List<String> taskIdsToUpdate =\n-          entry.getValue().stream().map(TaskDuration::getTaskId).collect(Collectors.toList());\n-      long days = converter.convertWorkingDaysToDays(planned, entry.getKey().toDays());\n-      Instant due = planned.plus(Duration.ofDays(days));\n-      referenceTask.setDue(due);\n-      referenceTask.setModified(Instant.now());\n-      long numTasksUpdated = taskMapper.updateTaskDueDates(taskIdsToUpdate, referenceTask);\n-      if (numTasksUpdated != taskIdsToUpdate.size()) {\n-        bulkLog.addAllErrors(\n-            checkResultsOfTasksUpdateAndAddErrorsToBulkLog(\n-                taskIdsToUpdate, referenceTask, numTasksUpdated));\n+  TaskImpl updatePrioPlannedDueOfTask(\n+      TaskImpl newTaskImpl, TaskImpl oldTaskImpl, boolean forRefreshOnClassificationUpdate)\n+      throws InvalidArgumentException {\n+    boolean onlyPriority = false;\n+    if (newTaskImpl.getClassificationSummary() == null\n+        || newTaskImpl.getClassificationSummary().getServiceLevel() == null) {\n+      onlyPriority = true;\n+    }\n+\n+    if (isPriorityAndDurationAlreadyCorrect(newTaskImpl, oldTaskImpl)) {\n+      return newTaskImpl;\n+    }\n+\n+    if (newTaskImpl.getPlanned() == null && newTaskImpl.getDue() == null) {\n+      newTaskImpl.setPlanned(Instant.now());\n+    }\n+\n+    DurationPrioHolder durationPrioHolder = determineTaskPrioDuration(newTaskImpl, onlyPriority);\n+    newTaskImpl.setPriority(durationPrioHolder.getPriority());\n+    if (onlyPriority) {\n+      return newTaskImpl;\n+    }\n+    // classification update\n+    if (forRefreshOnClassificationUpdate) {\n+      newTaskImpl.setDue(newPlannedDueInstant(newTaskImpl, durationPrioHolder.getDuration(), true));", "originalCommit": "24bdd185806073bf75631ac0fb11135fb7bc5640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1NDk1MA==", "url": "https://github.com/Taskana/taskana/pull/959#discussion_r393054950", "bodyText": "Good Idea. Actuall, I need 2 methods: addWorkingDaysToInstant and subtractWorkingDaysFromInstant. The reason is, that in the second method I need a negative number of days, but a Duration cannot be negated ...", "author": "BerndBreier", "createdAt": "2020-03-16T14:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0NjY2OQ=="}], "type": "inlineReview"}, {"oid": "26aee8d1ae0d895d957a4979b3df2dfd9cb5cbf5", "url": "https://github.com/Taskana/taskana/commit/26aee8d1ae0d895d957a4979b3df2dfd9cb5cbf5", "message": "TSK-1143 UpdateTask with Planned sometimes fails", "committedDate": "2020-03-17T18:02:57Z", "type": "commit"}, {"oid": "d54a91fae547ba9c49b8496a60713da788e5f888", "url": "https://github.com/Taskana/taskana/commit/d54a91fae547ba9c49b8496a60713da788e5f888", "message": "TSK-1143 UpdateTask planned - comments from Holger", "committedDate": "2020-03-17T18:13:58Z", "type": "commit"}, {"oid": "bea58eddcd996d9196b443545aa2fd3cc634dc20", "url": "https://github.com/Taskana/taskana/commit/bea58eddcd996d9196b443545aa2fd3cc634dc20", "message": "TSK-1143 Update Task PLANNED - Holger's comments", "committedDate": "2020-03-17T18:13:59Z", "type": "commit"}, {"oid": "2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "url": "https://github.com/Taskana/taskana/commit/2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "message": "TSK-1143 even more comments from Holger", "committedDate": "2020-03-18T07:38:13Z", "type": "commit"}, {"oid": "2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "url": "https://github.com/Taskana/taskana/commit/2eb10e2e130ff9fa80af960b4da4783d60bbd7c0", "message": "TSK-1143 even more comments from Holger", "committedDate": "2020-03-18T07:38:13Z", "type": "forcePushed"}]}