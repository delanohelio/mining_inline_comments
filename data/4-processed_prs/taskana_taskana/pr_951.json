{"pr_number": 951, "pr_title": "TSK-1139 Bulk update of Planned timestamp", "pr_createdAt": "2020-02-27T08:03:18Z", "pr_url": "https://github.com/Taskana/taskana/pull/951", "timeline": [{"oid": "4cc3267324a19d55033f333453b57b2ad9482b87", "url": "https://github.com/Taskana/taskana/commit/4cc3267324a19d55033f333453b57b2ad9482b87", "message": "TSK-1139 Bulk update of Planned timestamp", "committedDate": "2020-02-27T08:58:34Z", "type": "commit"}, {"oid": "4cc3267324a19d55033f333453b57b2ad9482b87", "url": "https://github.com/Taskana/taskana/commit/4cc3267324a19d55033f333453b57b2ad9482b87", "message": "TSK-1139 Bulk update of Planned timestamp", "committedDate": "2020-02-27T08:58:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNDkxMg==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385234912", "bodyText": "rather service level than due date, right?", "author": "holgerhagen", "createdAt": "2020-02-27T16:48:32Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -381,8 +382,20 @@ void forceDeleteTask(String taskId)\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due", "originalCommit": "4cc3267324a19d55033f333453b57b2ad9482b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU3NDExMw==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r389574113", "bodyText": "Correct. I updated it", "author": "BerndBreier", "createdAt": "2020-03-09T10:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNDkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNTc4Mg==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385235782", "bodyText": "Why did you delete this method?", "author": "holgerhagen", "createdAt": "2020-02-27T16:49:50Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentMapper.java", "diffHunk": "@@ -54,40 +54,18 @@\n       })\n   List<AttachmentImpl> findAttachmentsByTaskId(@Param(\"taskId\") String taskId);\n \n-  @Select(\n-      \"<script> SELECT ID, TASK_ID, CREATED, MODIFIED, CLASSIFICATION_KEY, CLASSIFICATION_ID, REF_COMPANY, REF_SYSTEM, REF_INSTANCE, REF_TYPE, REF_VALUE, CHANNEL, RECEIVED, CUSTOM_ATTRIBUTES \"\n-          + \"FROM ATTACHMENT \"\n-          + \"WHERE ID = #{attachmentId} \"\n-          + \"<if test=\\\"_databaseId == 'db2'\\\">with UR </if> \"\n-          + \"</script>\")\n-  @Results(\n-      value = {\n-        @Result(property = \"id\", column = \"ID\"),\n-        @Result(property = \"taskId\", column = \"TASK_ID\"),\n-        @Result(property = \"created\", column = \"CREATED\"),\n-        @Result(property = \"modified\", column = \"MODIFIED\"),\n-        @Result(property = \"classificationSummaryImpl.key\", column = \"CLASSIFICATION_KEY\"),\n-        @Result(property = \"classificationSummaryImpl.id\", column = \"CLASSIFICATION_ID\"),\n-        @Result(property = \"objectReference.company\", column = \"REF_COMPANY\"),\n-        @Result(property = \"objectReference.system\", column = \"REF_SYSTEM\"),\n-        @Result(property = \"objectReference.systemInstance\", column = \"REF_INSTANCE\"),\n-        @Result(property = \"objectReference.type\", column = \"REF_TYPE\"),\n-        @Result(property = \"objectReference.value\", column = \"REF_VALUE\"),\n-        @Result(property = \"channel\", column = \"CHANNEL\"),\n-        @Result(property = \"received\", column = \"RECEIVED\"),\n-        @Result(\n-            property = \"customAttributes\",\n-            column = \"CUSTOM_ATTRIBUTES\",\n-            javaType = Map.class,\n-            typeHandler = MapTypeHandler.class)\n-      })\n-  AttachmentImpl getAttachment(@Param(\"attachmentId\") String attachmentId);", "originalCommit": "4cc3267324a19d55033f333453b57b2ad9482b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMTA0Ng==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385601046", "bodyText": "Is not used at all", "author": "BerndBreier", "createdAt": "2020-02-28T09:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU3NDI5Mw==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r389574293", "bodyText": "This was dead code", "author": "BerndBreier", "createdAt": "2020-03-09T10:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNzEyNg==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385237126", "bodyText": "What is the meaning of this? Get all existing attachments?", "author": "holgerhagen", "createdAt": "2020-02-27T16:51:44Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/AttachmentMapper.java", "diffHunk": "@@ -54,40 +54,18 @@\n       })\n   List<AttachmentImpl> findAttachmentsByTaskId(@Param(\"taskId\") String taskId);\n \n-  @Select(\n-      \"<script> SELECT ID, TASK_ID, CREATED, MODIFIED, CLASSIFICATION_KEY, CLASSIFICATION_ID, REF_COMPANY, REF_SYSTEM, REF_INSTANCE, REF_TYPE, REF_VALUE, CHANNEL, RECEIVED, CUSTOM_ATTRIBUTES \"\n-          + \"FROM ATTACHMENT \"\n-          + \"WHERE ID = #{attachmentId} \"\n-          + \"<if test=\\\"_databaseId == 'db2'\\\">with UR </if> \"\n-          + \"</script>\")\n-  @Results(\n-      value = {\n-        @Result(property = \"id\", column = \"ID\"),\n-        @Result(property = \"taskId\", column = \"TASK_ID\"),\n-        @Result(property = \"created\", column = \"CREATED\"),\n-        @Result(property = \"modified\", column = \"MODIFIED\"),\n-        @Result(property = \"classificationSummaryImpl.key\", column = \"CLASSIFICATION_KEY\"),\n-        @Result(property = \"classificationSummaryImpl.id\", column = \"CLASSIFICATION_ID\"),\n-        @Result(property = \"objectReference.company\", column = \"REF_COMPANY\"),\n-        @Result(property = \"objectReference.system\", column = \"REF_SYSTEM\"),\n-        @Result(property = \"objectReference.systemInstance\", column = \"REF_INSTANCE\"),\n-        @Result(property = \"objectReference.type\", column = \"REF_TYPE\"),\n-        @Result(property = \"objectReference.value\", column = \"REF_VALUE\"),\n-        @Result(property = \"channel\", column = \"CHANNEL\"),\n-        @Result(property = \"received\", column = \"RECEIVED\"),\n-        @Result(\n-            property = \"customAttributes\",\n-            column = \"CUSTOM_ATTRIBUTES\",\n-            javaType = Map.class,\n-            typeHandler = MapTypeHandler.class)\n-      })\n-  AttachmentImpl getAttachment(@Param(\"attachmentId\") String attachmentId);\n-\n   @Select(\n       \"<script>SELECT ID, TASK_ID, CREATED, MODIFIED, CLASSIFICATION_KEY, CLASSIFICATION_ID, REF_COMPANY, REF_SYSTEM, REF_INSTANCE, REF_TYPE, REF_VALUE, CHANNEL, RECEIVED \"\n           + \"FROM ATTACHMENT \"\n           + \"<where>\"\n+          + \"<choose>\"\n+          + \"<when  test='taskIds == null'>\"\n+          + \" 1 = 2 \"", "originalCommit": "4cc3267324a19d55033f333453b57b2ad9482b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMTcwMA==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385601700", "bodyText": "This method selects attachments based on a list of task ids. If this list is null, w/o the 1=2 condition, all attachments are returned, but this is not intended ....", "author": "BerndBreier", "createdAt": "2020-02-28T09:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0MDIwOQ==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385240209", "bodyText": "Personally I find this hard to read. updateAffectedTasks is where the magic happens, right? And this is rather hidden this way ...", "author": "holgerhagen", "createdAt": "2020-02-27T16:56:33Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package pro.taskana.task.internal;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.TaskanaRole;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.common.api.exceptions.SystemException;\n+import pro.taskana.common.api.exceptions.TaskanaException;\n+import pro.taskana.common.internal.InternalTaskanaEngine;\n+import pro.taskana.common.internal.security.CurrentUserContext;\n+import pro.taskana.common.internal.util.DaysToWorkingDaysConverter;\n+import pro.taskana.common.internal.util.Pair;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.exceptions.UpdateFailedException;\n+import pro.taskana.task.internal.models.AttachmentSummaryImpl;\n+import pro.taskana.task.internal.models.MinimalTaskSummary;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+/** This class handles service level manipulations. */\n+class ServiceLevelHandler {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n+  private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n+  private final InternalTaskanaEngine taskanaEngine;\n+  private final TaskMapper taskMapper;\n+  private final AttachmentMapper attachmentMapper;\n+  private DaysToWorkingDaysConverter converter;\n+\n+  public ServiceLevelHandler(\n+      InternalTaskanaEngine taskanaEngine,\n+      TaskMapper taskMapper,\n+      AttachmentMapper attachmentMapper) {\n+    super();\n+    this.taskanaEngine = taskanaEngine;\n+    this.taskMapper = taskMapper;\n+    this.attachmentMapper = attachmentMapper;\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n+    }\n+  }\n+\n+  // Algorithm:\n+  // - load all relevant tasks and their attachmentSummaries\n+  // - load all classifications referenced by these tasks / attachments\n+  // - calculate duration for ServiceLevel in each classification\n+  // - For each task iterate through all referenced classifications and find minimum ServiceLevel\n+  // - collect the results into a map Duration -> List of tasks\n+  // - for each duration in this map update due date of all associated tasks\n+  public BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasksImpl(\n+      Instant planned, List<String> argTaskIds) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    if (argTaskIds == null || argTaskIds.isEmpty()) {\n+      return bulkLog;\n+    }\n+    Pair<List<MinimalTaskSummary>, BulkOperationResults<String, TaskanaException>> resultsPair =\n+        filterTasksForExistenceAndAuthorization(argTaskIds);\n+    List<MinimalTaskSummary> existingTasksAuthorizedFor = resultsPair.getLeft();\n+    bulkLog.addAllErrors(resultsPair.getRight());\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(existingTasksAuthorizedFor);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllInvolvedClassifications(existingTasksAuthorizedFor, attachments);\n+    List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+        resolveDurationsInClassifications(allInvolvedClassifications);\n+    Map<Duration, List<TaskDuration>> tasksPerDuration =\n+        getTasksPerDuration(\n+            existingTasksAuthorizedFor, attachments, allInvolvedClassificationsWithDuration);\n+    bulkLog.addAllErrors(updateAffectedTasks(planned, tasksPerDuration));", "originalCommit": "4cc3267324a19d55033f333453b57b2ad9482b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0MDg3Mg==", "url": "https://github.com/Taskana/taskana/pull/951#discussion_r385240872", "bodyText": "Didn't we have this for the owner already?", "author": "holgerhagen", "createdAt": "2020-02-27T16:57:36Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package pro.taskana.task.internal;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.classification.api.models.ClassificationSummary;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.TaskanaRole;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.common.api.exceptions.SystemException;\n+import pro.taskana.common.api.exceptions.TaskanaException;\n+import pro.taskana.common.internal.InternalTaskanaEngine;\n+import pro.taskana.common.internal.security.CurrentUserContext;\n+import pro.taskana.common.internal.util.DaysToWorkingDaysConverter;\n+import pro.taskana.common.internal.util.Pair;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.exceptions.UpdateFailedException;\n+import pro.taskana.task.internal.models.AttachmentSummaryImpl;\n+import pro.taskana.task.internal.models.MinimalTaskSummary;\n+import pro.taskana.task.internal.models.TaskImpl;\n+\n+/** This class handles service level manipulations. */\n+class ServiceLevelHandler {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServiceLevelHandler.class);\n+  private static final String ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER =\n+      \"Internal error. Cannot initialize DaysToWorkingDaysConverter\";\n+  private static final Duration MAX_DURATION = Duration.ofSeconds(Long.MAX_VALUE, 999_999_999);\n+  private final InternalTaskanaEngine taskanaEngine;\n+  private final TaskMapper taskMapper;\n+  private final AttachmentMapper attachmentMapper;\n+  private DaysToWorkingDaysConverter converter;\n+\n+  public ServiceLevelHandler(\n+      InternalTaskanaEngine taskanaEngine,\n+      TaskMapper taskMapper,\n+      AttachmentMapper attachmentMapper) {\n+    super();\n+    this.taskanaEngine = taskanaEngine;\n+    this.taskMapper = taskMapper;\n+    this.attachmentMapper = attachmentMapper;\n+    try {\n+      this.converter = DaysToWorkingDaysConverter.initialize();\n+    } catch (InvalidArgumentException e) {\n+      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n+      throw new SystemException(\n+          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n+    }\n+  }\n+\n+  // Algorithm:\n+  // - load all relevant tasks and their attachmentSummaries\n+  // - load all classifications referenced by these tasks / attachments\n+  // - calculate duration for ServiceLevel in each classification\n+  // - For each task iterate through all referenced classifications and find minimum ServiceLevel\n+  // - collect the results into a map Duration -> List of tasks\n+  // - for each duration in this map update due date of all associated tasks\n+  public BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasksImpl(\n+      Instant planned, List<String> argTaskIds) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    if (argTaskIds == null || argTaskIds.isEmpty()) {\n+      return bulkLog;\n+    }\n+    Pair<List<MinimalTaskSummary>, BulkOperationResults<String, TaskanaException>> resultsPair =\n+        filterTasksForExistenceAndAuthorization(argTaskIds);\n+    List<MinimalTaskSummary> existingTasksAuthorizedFor = resultsPair.getLeft();\n+    bulkLog.addAllErrors(resultsPair.getRight());\n+\n+    List<AttachmentSummaryImpl> attachments = getAttachmentSummaries(existingTasksAuthorizedFor);\n+    List<ClassificationSummary> allInvolvedClassifications =\n+        findAllInvolvedClassifications(existingTasksAuthorizedFor, attachments);\n+    List<ClassificationWithServiceLevelResolved> allInvolvedClassificationsWithDuration =\n+        resolveDurationsInClassifications(allInvolvedClassifications);\n+    Map<Duration, List<TaskDuration>> tasksPerDuration =\n+        getTasksPerDuration(\n+            existingTasksAuthorizedFor, attachments, allInvolvedClassificationsWithDuration);\n+    bulkLog.addAllErrors(updateAffectedTasks(planned, tasksPerDuration));\n+\n+    return bulkLog;\n+  }\n+\n+  BulkOperationResults<String, TaskanaException> addExceptionsForNonExistingTasks(\n+      List<String> requestTaskIds, List<MinimalTaskSummary> existingMinimalTaskSummaries) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    List<String> nonExistingTaskIds = new ArrayList<>(requestTaskIds);\n+    List<String> existingTaskIds =\n+        existingMinimalTaskSummaries.stream()\n+            .map(MinimalTaskSummary::getTaskId)\n+            .collect(Collectors.toList());\n+    nonExistingTaskIds.removeAll(existingTaskIds);\n+    for (String taskId : nonExistingTaskIds) {\n+      bulkLog.addError(taskId, new TaskNotFoundException(taskId, \"Task was not found\"));\n+    }\n+    return bulkLog;\n+  }\n+\n+  private BulkOperationResults<String, TaskanaException> updateAffectedTasks(\n+      Instant planned, Map<Duration, List<TaskDuration>> tasksPerDuration) {\n+    BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>();\n+    TaskImpl referenceTask = new TaskImpl();\n+    referenceTask.setPlanned(planned);\n+    for (Map.Entry<Duration, List<TaskDuration>> entry : tasksPerDuration.entrySet()) {\n+      List<String> taskIdsToUpdate =\n+          entry.getValue().stream().map(TaskDuration::getTaskId).collect(Collectors.toList());\n+      long days = converter.convertWorkingDaysToDays(planned, entry.getKey().toDays());\n+      Instant due = planned.plus(Duration.ofDays(days));\n+      referenceTask.setDue(due);\n+      referenceTask.setModified(Instant.now());\n+      long numTasksUpdated = taskMapper.updateTaskDueDates(taskIdsToUpdate, referenceTask);\n+      if (numTasksUpdated != taskIdsToUpdate.size()) {\n+        bulkLog.addAllErrors(\n+            checkResultsOfTasksUpdateAndAddErrorsToBulkLog(\n+                taskIdsToUpdate, referenceTask, numTasksUpdated));\n+      }\n+    }\n+    return bulkLog;\n+  }\n+\n+  private Pair<List<MinimalTaskSummary>, BulkOperationResults<String, TaskanaException>>\n+      filterTasksForExistenceAndAuthorization(List<String> argTaskIds) {", "originalCommit": "4cc3267324a19d55033f333453b57b2ad9482b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}