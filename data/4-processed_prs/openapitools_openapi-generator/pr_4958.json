{"pr_number": 4958, "pr_title": "[Python] Support for HTTP signature", "pr_createdAt": "2020-01-10T06:14:28Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/4958", "timeline": [{"oid": "2137cc177df99fce756b365bbbbbd8a259c16f9a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2137cc177df99fce756b365bbbbbd8a259c16f9a", "message": "http signature unit tests", "committedDate": "2020-01-23T03:32:57Z", "type": "commit"}, {"oid": "e532a67039ef2946e1c7d30d348a5495cd472447", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e532a67039ef2946e1c7d30d348a5495cd472447", "message": "Fix PEP8 format issue", "committedDate": "2020-01-23T04:36:24Z", "type": "commit"}, {"oid": "7d89594ca9d258b0ee8521cd92326ec1df68bb45", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7d89594ca9d258b0ee8521cd92326ec1df68bb45", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-23T17:38:03Z", "type": "commit"}, {"oid": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "message": "Merge branch 'http-signature' into python-http-signature", "committedDate": "2020-01-23T17:38:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370263793", "bodyText": "Why should we remove this exception?", "author": "spacether", "createdAt": "2020-01-23T17:47:10Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -3646,8 +3646,6 @@ public boolean isDataTypeFile(String dataType) {\n                     // As of January 2020, the \"signature\" scheme has not been registered with IANA yet.\n                     // This scheme may have to be changed when it is officially registered with IANA.\n                     cs.isHttpSignature = true;\n-                } else {\n-                    throw new RuntimeException(\"Unsupported security scheme: \" + securityScheme.getScheme());", "originalCommit": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Njg0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370266840", "bodyText": "This is to address  @jimschubert comments:\n\nThis would be a breaking change, as we failed silently for any unsupported schemes previously.", "author": "sebastien-rosset", "createdAt": "2020-01-23T17:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2NzgwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370267809", "bodyText": "@jimschubert doesn't this clause mean that we failed loudly before, not silently?\nHow did we fail silently before?", "author": "spacether", "createdAt": "2020-01-23T17:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI3MDA0Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370270046", "bodyText": "I think @jimschubert  meant codegen ignores the scheme, rather that \"fail\".\nIdeally, developers would be able to add their own security scheme without having to fork OpenAPITools. There would be a way to register a new security scheme.", "author": "sebastien-rosset", "createdAt": "2020-01-23T18:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM2MTY3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370361670", "bodyText": "Ah, I see that from our master branch at https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L3641. I misunderstood and thought that master had throw new RuntimeException when it was that only the earlier commit in this branch had it.\nFeel free to mark this as resolved. Thank you for the explanation.", "author": "spacether", "createdAt": "2020-01-23T21:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Mzc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2NjE2NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370266165", "bodyText": "Optionally, why not spreading out each requirement to a separate line?\nThen we don't need to use append statement.\nREQUIRES = [\n    \"urllib3 >= 1.15\",\n    ...\n{{#asyncio}}\n    \"aiohttp >= 3.0.0\"\n{{/asyncio}}\n]", "author": "spacether", "createdAt": "2020-01-23T17:52:14Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/setup.mustache", "diffHunk": "@@ -23,6 +23,10 @@ REQUIRES.append(\"aiohttp >= 3.0.0\")\n {{#tornado}}\n REQUIRES.append(\"tornado>=4.2,<5\")\n {{/tornado}}\n+{{#hasHttpSignatureMethods}}", "originalCommit": "1bb0df5601625da1bc2d2373fe42df7d11eb3e58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODg4NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r370268885", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-23T17:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2NjE2NQ=="}], "type": "inlineReview"}, {"oid": "39a6d014972ecd6b5448ebf8cc8cc9cdaa027cbd", "url": "https://github.com/OpenAPITools/openapi-generator/commit/39a6d014972ecd6b5448ebf8cc8cc9cdaa027cbd", "message": "spread out each requirement to a separate line", "committedDate": "2020-01-23T17:57:54Z", "type": "commit"}, {"oid": "15a5c09d6eb6575b99542c96dd2809d21cfe2950", "url": "https://github.com/OpenAPITools/openapi-generator/commit/15a5c09d6eb6575b99542c96dd2809d21cfe2950", "message": "run samples scripts", "committedDate": "2020-01-23T20:43:29Z", "type": "commit"}, {"oid": "3bcb9581391df785a102315a8cbc71d48a89a0cf", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3bcb9581391df785a102315a8cbc71d48a89a0cf", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-24T02:54:52Z", "type": "commit"}, {"oid": "7184320d07c9cdb1d3810c1b284256f4ad7d66a6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7184320d07c9cdb1d3810c1b284256f4ad7d66a6", "message": "run sample scripts", "committedDate": "2020-01-24T05:15:36Z", "type": "commit"}, {"oid": "45f2cfdde52e336038ff24b24dfbeebaea0a0a09", "url": "https://github.com/OpenAPITools/openapi-generator/commit/45f2cfdde52e336038ff24b24dfbeebaea0a0a09", "message": "sync from master", "committedDate": "2020-01-26T18:21:44Z", "type": "commit"}, {"oid": "4db1b218edb5704d738ee3659ee63c1d439eb49e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/4db1b218edb5704d738ee3659ee63c1d439eb49e", "message": "remove encoding of '+' character", "committedDate": "2020-01-26T18:30:28Z", "type": "commit"}, {"oid": "7c1967eff0cfe4f2099120ae0f39ff77d04f2ec1", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7c1967eff0cfe4f2099120ae0f39ff77d04f2ec1", "message": "Code reformatting", "committedDate": "2020-01-16T01:00:30Z", "type": "commit"}, {"oid": "2db7093daa4b298eaafd57f6cc72d5d5dbcf8d99", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2db7093daa4b298eaafd57f6cc72d5d5dbcf8d99", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-16T03:44:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjI5NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367166294", "bodyText": "Can you update the samples?\nThis is outdated", "author": "spacether", "createdAt": "2020-01-15T23:47:47Z", "path": "samples/client/petstore/python-experimental/petstore_api/api_client.py", "diffHunk": "@@ -62,6 +62,10 @@ class ApiClient(object):\n     PRIMITIVE_TYPES = (\n         (float, bool, six.binary_type, six.text_type) + six.integer_types\n     )\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjY1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367166659", "bodyText": "Can you move this to processOpts? It looks like that is where we are conditionally adding supporting files.", "author": "spacether", "createdAt": "2020-01-15T23:49:16Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -82,6 +84,12 @@ public PythonClientExperimentalCodegen() {\n \n         apiTemplateFiles.remove(\"api.mustache\");\n         apiTemplateFiles.put(\"python-experimental/api.mustache\", \".py\");\n+        Map<String, SecurityScheme> securitySchemeMap = openAPI != null ?\n+           (openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null) : null;\n+        List<CodegenSecurity> authMethods = fromSecurity(securitySchemeMap);\n+        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {\n+            apiTemplateFiles.put(\"python-experimental/signing.mustache\", \".py\");\n+        }", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0MjYyNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367242625", "bodyText": "Sure. I'm also changing to:\nsupportingFiles.add(new SupportingFile(\"python-experimental/signing.mustache\", packagePath(), \"signing.py\"));\n\nThough I don't understand the different between supportingFiles and apiTemplateFiles", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDMwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367180307", "bodyText": "Can we use our constants here?", "author": "spacether", "createdAt": "2020-01-16T00:42:49Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0MDYwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367240607", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDQ3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367180473", "bodyText": "Can we use our constants here?", "author": "spacether", "createdAt": "2020-01-16T00:43:27Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0MDAyMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367240022", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4MDQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDIyNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367184225", "bodyText": "Can we delete this line?\nLine 211 sets headers_value for us.", "author": "spacether", "createdAt": "2020-01-16T00:58:52Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:\n+        digest = SHA256.new()\n+        prefix = \"SHA-256=\"\n+    else:\n+        raise Exception(\n+            \"Unsupported signing algorithm: {0}\".format(configuration.signing_scheme))\n+    digest.update(data)\n+    return digest, prefix\n+\n+def sign_digest(configuration, digest):\n+    \"\"\"\n+    Signs a message digest with a private key specified in the configuration.\n+\n+    :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+    :return: A base-64 string representing the cryptographic signature of the input digest.\n+    \"\"\"\n+    load_private_key(configuration)\n+    privkey = self.private_key\n+    if isinstance(privkey, RSA.RsaKey):\n+        if configuration.signing_algorithm == ALGORITHM_RSASSA_PSS:\n+            # RSASSA-PSS in Section 8.1 of RFC8017.\n+            signature = pss.new(privkey).sign(digest)\n+        elif configuration.signing_algorithm == ALGORITHM_RSASSA_PKCS1v15:\n+            # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+            signature = PKCS1_v1_5.new(privkey).sign(digest)\n+        else:\n+            raise Exception(\"Unsupported signature algorithm: {0}\".format(configuration.signing_algorithm))\n+    elif isinstance(privkey, ECC.EccKey):\n+        if configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+            signature = DSS.new(privkey, configuration.signing_algorithm).sign(digest)\n+        else:\n+            raise Exception(\"Unsupported signature algorithm: {0}\".format(configuration.signing_algorithm))\n+    else:\n+        raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+    return b64encode(signature)\n+\n+def get_authorization_header(configuration, signed_headers, signed_msg):\n+    \"\"\"\n+    Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+    \n+    :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+        must be included in the HTTP signature calculation.\n+    :param signed_msg: A base-64 encoded string representation of the signature.\n+    :return: The string value of the 'Authorization' header, representing the signature\n+        of the HTTP request.\n+    \"\"\"\n+\n+    headers_value = \"\"", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzOTk2NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367239964", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDcwMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367184702", "bodyText": "We have no self here. Should this be privkey = signing_info.private_key?", "author": "spacether", "createdAt": "2020-01-16T01:01:01Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,221 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+\n+SCHEME_HS2019 = 'hs2019'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Create a cryptographic message signature for the HTTP request and add the signed headers.\n+    \n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+    if method is None:\n+        raise Exception(\"HTTP method must be set\")\n+    if resource_path is None:\n+        raise Exception(\"Resource path must be set\")\n+\n+    signed_headers_dict, request_headers_dict = get_signed_header_info(configuration,\n+        resource_path, method, headers, body, query_params)\n+\n+    header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+    string_to_sign = \"\\n\".join(header_items)\n+\n+    digest, digest_prefix = get_message_digest(configuration, string_to_sign.encode())\n+    b64_signed_msg = sign_digest(configuration, digest)\n+\n+    request_headers_dict['Authorization'] = get_authorization_header(configuration,\n+        signed_headers_dict, b64_signed_msg)\n+\n+    return request_headers_dict\n+\n+def load_private_key(configuration):\n+    \"\"\"Load the private key used to sign HTTP requests.\n+        The private key is used to sign HTTP requests as defined in\n+        https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+    \"\"\"\n+    if configuration.private_key is not None:\n+        return\n+    with open(configuration.private_key_path, \"rb\") as f:\n+        # Decode PEM file and determine key type from PEM header.\n+        # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+        keys = pem.parse(f.read())\n+        if len(keys) != 1:\n+            raise Exception(\"File must contain exactly one private key\")\n+        key = keys[0].as_text()\n+        if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+            configuration.private_key = RSA.importKey(key)\n+        elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+            configuration.private_key = ECC.importKey(key)\n+        else:\n+            raise Exception(\"Unsupported key\")\n+\n+def get_signed_header_info(configuration, resource_path, method, headers, body, query_params):\n+    \"\"\"\n+    Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+    :param resource_path : A string representation of the HTTP request resource path.\n+    :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+    :param headers: A dict containing the HTTP request headers.\n+    :param body: The string representation of the HTTP request body.\n+    :param query_params: A string representing the HTTP request query parameters.\n+    :return: A tuple containing two dict objects:\n+        The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+        The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+    \"\"\"\n+\n+    if body is None:\n+        body = ''\n+    else:\n+        body = json.dumps(body)\n+\n+    # Build the '(request-target)' HTTP signature parameter.\n+    target_host = urlparse(configuration.host).netloc\n+    target_path = urlparse(configuration.host).path\n+    request_target = method.lower() + \" \" + target_path + resource_path\n+    if query_params:\n+        raw_query = urlencode(query_params).replace('+', '%20')\n+        request_target += \"?\" + raw_query\n+\n+    # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+    now = datetime.datetime.now()\n+    stamp = mktime(now.timetuple())\n+    cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+    created = now.strftime(\"%s\")\n+    if configuration.signature_max_validity is not None:\n+        expires = (now + configuration.signature_max_validity).strftime(\"%s\")\n+\n+    signed_headers_dict = {}\n+    request_headers_dict = {}\n+    for hdr_key in configuration.signed_headers_dict:\n+        hdr_key = hdr_key.lower()\n+        if hdr_key == HEADER_REQUEST_TARGET:\n+            value = request_target\n+        elif hdr_key == HEADER_CREATED:\n+            value = created\n+        elif hdr_key == HEADER_EXPIRES:\n+            value = expires\n+        elif hdr_key == HEADER_DATE:\n+            value = cdate\n+            request_headers_dict['Date'] = '{0}'.format(cdate)\n+        elif hdr_key == HEADER_DIGEST:\n+            request_body = body.encode()\n+            body_digest, digest_prefix = get_message_digest(configuration, request_body)\n+            b64_body_digest = b64encode(body_digest.digest())\n+            value = digest_prefix + b64_body_digest.decode('ascii')\n+            request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+        elif hdr_key == HEADER_HOST:\n+            value = target_host\n+            request_headers_dict['Host'] = '{0}'.format(target_host)\n+        else:\n+            value = headers[hdr_key]\n+        signed_headers_dict[hdr_key] = value\n+\n+    # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+    if len(configuration.signed_headers_dict) == 0:\n+        signed_headers_dict[HEADER_CREATED] = created\n+\n+    return signed_header_dict, request_headers_dict\n+\n+def get_message_digest(configuration, data):\n+    \"\"\"\n+    Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+    :param data: The string representation of the date to be hashed with a cryptographic hash.\n+    :return: A tuple of (digest, prefix).\n+        The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+        The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+        'Digest' header as specified in RFC 3230.\n+    \"\"\"\n+    if configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+        digest = SHA512.new()\n+        prefix = \"SHA-512=\"\n+    elif configuration.signing_scheme in [\"rsa-sha256\"]:\n+        digest = SHA256.new()\n+        prefix = \"SHA-256=\"\n+    else:\n+        raise Exception(\n+            \"Unsupported signing algorithm: {0}\".format(configuration.signing_scheme))\n+    digest.update(data)\n+    return digest, prefix\n+\n+def sign_digest(configuration, digest):\n+    \"\"\"\n+    Signs a message digest with a private key specified in the configuration.\n+\n+    :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+    :return: A base-64 string representing the cryptographic signature of the input digest.\n+    \"\"\"\n+    load_private_key(configuration)\n+    privkey = self.private_key", "originalCommit": "21c478fe7e19b6641b964b615ffb32cad66441c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzOTg3MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367239871", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4NDcwMg=="}], "type": "inlineReview"}, {"oid": "de9124c071ad7793d5eaeacd1df7224b408e2762", "url": "https://github.com/OpenAPITools/openapi-generator/commit/de9124c071ad7793d5eaeacd1df7224b408e2762", "message": "externalize http signature configuration", "committedDate": "2020-01-16T04:27:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjUwOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367226508", "bodyText": "Can you move this class to signing.py?", "author": "spacether", "createdAt": "2020-01-16T04:32:54Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -478,3 +426,75 @@ class Configuration(object):\n             url = url.replace(\"{\" + variable_name + \"}\", used_value)\n \n         return url\n+\n+class HttpSigningConfiguration(object):", "originalCommit": "de9124c071ad7793d5eaeacd1df7224b408e2762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzOTU1NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367239555", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjY2MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367226660", "bodyText": "Can you update this to {{{packageName}}}.signing.HttpSigningConfiguration?", "author": "spacether", "createdAt": "2020-01-16T04:33:36Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -65,22 +41,23 @@ class Configuration(object):\n     sign the HTTP requests with the RSA-SSA-PSS signature algorithm, and set the expiration time\n     of the signature to 5 minutes after the signature has been created.\n       conf = {{{packageName}}}.Configuration(\n-        key_id='my-key-id',\n-        private_key_path='rsa.pem',\n-        signing_scheme=signing.SCHEME_HS2019,\n-        signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n-        signed_headers=[signing.HEADER_REQUEST_TARGET, signing.HEADER_CREATED,\n-                        signing.HEADER_EXPIRES, signing.HEADER_HOST, signing.HEADER_DATE,\n-                        signing.HEADER_DIGEST, 'Content-Type']\n-        signature_max_validity=timedelta(minutes=5),\n+        signing_info = {{{packageName}}}.HttpSigningConfiguration(", "originalCommit": "de9124c071ad7793d5eaeacd1df7224b408e2762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzOTI1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367239257", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNjY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzE3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367227170", "bodyText": "Can you change get_http_signature_headers so you pass in signing_info rather than configuration?\nThe functions only use signing_info, not any other of the configuration properties.", "author": "spacether", "createdAt": "2020-01-16T04:35:58Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -10,21 +10,29 @@ from Crypto.Hash import SHA256, SHA512\n from base64 import b64encode\n from email.utils import formatdate\n \n+from {{packageName}}.configuration import Configuration\n+\n HEADER_REQUEST_TARGET = '(request-target)'\n HEADER_CREATED = '(created)'\n HEADER_EXPIRES = '(expires)'\n HEADER_HOST = 'host'\n HEADER_DATE = 'date'\n HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n \n SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n \n ALGORITHM_RSASSA_PSS = 'PSS'\n ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n \n ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n-ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n \n def get_http_signature_headers(configuration, resource_path, method, headers, body, query_params):", "originalCommit": "de9124c071ad7793d5eaeacd1df7224b408e2762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzOTA4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367239088", "bodyText": "done. It's also using 'host', but I've simplified a bit.", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzQ2Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367227462", "bodyText": "Can you update this to {{{packageName}}}.signing.HttpSigningConfiguration?", "author": "spacether", "createdAt": "2020-01-16T04:37:34Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,32 +26,8 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n-    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n-        An 'Authorization' header is calculated by creating a hash of select headers,\n-        and optionally the body of the HTTP request, then signing the hash value using\n-        a private key which is available to the client.\n-    :param private_key_path: The path of the file containing a private key,\n-        when signing HTTP requests.\n-    :param signing_scheme: The signature scheme, when signing HTTP requests.\n-        Supported value is hs2019.\n-    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n-        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n-    :param signature_max_validity: The signature max validity,\n-        expressed as a datetime.timedelta value.\n-    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n-        that must be included in the HTTP signature calculation.\n-        The two special signature headers '(request-target)' and '(created)' SHOULD be\n-        included in SignedHeaders.\n-        The '(created)' header expresses when the signature was created.\n-        The '(request-target)' header is a concatenation of the lowercased :method, an\n-        ASCII space, and the :path pseudo-headers.\n-        When signed_headers is not specified, the client defaults to a single value,\n-        '(created)', in the list of HTTP headers.\n-        When SignedHeaders contains the 'Digest' value, the client performs the\n-        following operations:\n-        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n-        2. Set the 'Digest' header in the request body.\n-        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_info: Configuration parameters for HTTP signature.\n+        Must be an instance of {{{packageName}}}.HttpSigningConfiguration", "originalCommit": "de9124c071ad7793d5eaeacd1df7224b408e2762", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzNzMyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367237329", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T05:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzQ2Mg=="}], "type": "inlineReview"}, {"oid": "00fd981031522973d6375e6f831c9cdc0262b305", "url": "https://github.com/OpenAPITools/openapi-generator/commit/00fd981031522973d6375e6f831c9cdc0262b305", "message": "address PR review comments", "committedDate": "2020-01-16T05:47:58Z", "type": "commit"}, {"oid": "09b9515f4d9654b10e3d767b5df53c2e8d3e4033", "url": "https://github.com/OpenAPITools/openapi-generator/commit/09b9515f4d9654b10e3d767b5df53c2e8d3e4033", "message": "address PR review comments", "committedDate": "2020-01-16T05:58:40Z", "type": "commit"}, {"oid": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "message": "run samples scripts", "committedDate": "2020-01-16T06:00:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDI5MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367244290", "bodyText": "Which of these params are required?\nIf they are required please set them as positional arguments with no None default value", "author": "spacether", "createdAt": "2020-01-16T06:04:26Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,307 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    \"\"\"\n+    def __init__(self, key_id=None, private_key_path=None, signing_scheme=None,", "originalCommit": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDYwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367244609", "bodyText": "good point.", "author": "sebastien-rosset", "createdAt": "2020-01-16T06:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDYxNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367244617", "bodyText": "If signed headers is optional/can be set to None then please move these checks behind the if statement:\nif signed_headers is not None:\nWe are getting a CI error from tying to run len(signed_headers) when signed_headers = None", "author": "spacether", "createdAt": "2020-01-16T06:06:02Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,307 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    \"\"\"\n+    def __init__(self, key_id=None, private_key_path=None, signing_scheme=None,\n+                 signing_algorithm=None, signature_max_validity=None, signed_headers=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if self.signature_max_validity is None and \\\n+                signed_headers is not None and '(expires)' in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):", "originalCommit": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1MDU3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367250575", "bodyText": "good point, in golang this is not needed and I keep thinking golang.", "author": "sebastien-rosset", "createdAt": "2020-01-16T06:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NTY3OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367245678", "bodyText": "Aren't resource_path and method required?\nIf so please make them positional arguments without setting them to None by default.", "author": "spacether", "createdAt": "2020-01-16T06:09:49Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +522,34 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path=None, method=None, body=None):", "originalCommit": "0e4f43c64c5fd0e2ac0280dd2e200c999199ed28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2da37a26e77cbbaa576d0794777db2e78ab6f1b", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c2da37a26e77cbbaa576d0794777db2e78ab6f1b", "message": "Address PR review comments", "committedDate": "2020-01-16T06:37:42Z", "type": "commit"}, {"oid": "581e4336132c90058fa77e2f7240109cd6527a47", "url": "https://github.com/OpenAPITools/openapi-generator/commit/581e4336132c90058fa77e2f7240109cd6527a47", "message": "Move 'private_key' field to signing module", "committedDate": "2020-01-16T06:40:33Z", "type": "commit"}, {"oid": "5f60e2e9dbf90f1e55242513b3d99bb2bd4f74f5", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f60e2e9dbf90f1e55242513b3d99bb2bd4f74f5", "message": "Move 'private_key' field to signing module", "committedDate": "2020-01-16T06:45:44Z", "type": "commit"}, {"oid": "69d394d9bdf7bd55fffe8b631ac6f6e0449f999c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/69d394d9bdf7bd55fffe8b631ac6f6e0449f999c", "message": "code cleanup", "committedDate": "2020-01-16T06:48:48Z", "type": "commit"}, {"oid": "3ee3c0e31a2b2bea40e8cae53dc8d774779d1a9f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3ee3c0e31a2b2bea40e8cae53dc8d774779d1a9f", "message": "remove use of strftime('%s'), which is non portable", "committedDate": "2020-01-16T07:01:51Z", "type": "commit"}, {"oid": "7787a7b5b0084b75be56ce1e84449b00b00c6002", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7787a7b5b0084b75be56ce1e84449b00b00c6002", "message": "code cleanup", "committedDate": "2020-01-16T07:12:50Z", "type": "commit"}, {"oid": "8b69dc7961692e5ec464607c3c8513a1513bec6a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8b69dc7961692e5ec464607c3c8513a1513bec6a", "message": "code cleanup", "committedDate": "2020-01-16T07:24:18Z", "type": "commit"}, {"oid": "f67523cb0c4e85d662caeac4ec0df2be1b4a642c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/f67523cb0c4e85d662caeac4ec0df2be1b4a642c", "message": "code cleanup", "committedDate": "2020-01-16T07:36:40Z", "type": "commit"}, {"oid": "d169c6ef853d9fe72bb24092a25ca26ab74a1582", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d169c6ef853d9fe72bb24092a25ca26ab74a1582", "message": "run sample scripts", "committedDate": "2020-01-16T07:37:51Z", "type": "commit"}, {"oid": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/4148453c1a72f4ee6da15f00c7f934469a69f5a3", "message": "sync from mater", "committedDate": "2020-01-16T14:28:36Z", "type": "commit"}, {"oid": "755335c2726d1e754e09e237b98c9e3082e969ed", "url": "https://github.com/OpenAPITools/openapi-generator/commit/755335c2726d1e754e09e237b98c9e3082e969ed", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-16T14:31:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwODYyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367508629", "bodyText": "This is not assigning a value.\nCan you change it to add the entry to the dict only if self.signing_info is not None?", "author": "spacether", "createdAt": "2020-01-16T16:10:20Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -318,6 +361,15 @@ class Configuration(object):\n                 'value': 'Bearer ' + self.access_token\n             }\n   {{/isBasicBearer}}\n+  {{#isHttpSignature}}\n+            '{{name}}':", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NzA4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367577081", "bodyText": "thanks. Side effect of sync from master.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NzYzMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367577630", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwODYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMjUxNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367512517", "bodyText": "How about removing this for loop and changing it to\nheaders.update(auth_headerd)?", "author": "spacether", "createdAt": "2020-01-16T16:16:55Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':\n+                    # The HTTP signature scheme requires multiple HTTP headers\n+                    # that are calculated dynamically.\n+                    signing_info = self.configuration.signing_info\n+                    if signing_info is None:\n+                        raise Exception(\"HTTP signature configuration is missing\")\n+                    auth_headers = signing_info.get_http_signature_headers(\n+                                        self.configuration.host, resource_path,\n+                                        method, headers, body, querys)\n+                    for key, value in auth_headers.items():", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxNDQ0Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367614443", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxMjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367519509", "bodyText": "If these are required, can you change them to positional arguments?\nCan we remove the signing_scheme default value? Why set it when three options are accepted for it? List default values are a dangerous practice in python because they are mutable so let's change signed_headers to be positional or use a tuple for its default value.\nWhich of these parameters are optional?", "author": "spacether", "createdAt": "2020-01-16T16:28:23Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MjM4Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367562383", "bodyText": "From your code below, it looks like we allow signing_algorithm==None so it is optional?", "author": "spacether", "createdAt": "2020-01-16T17:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxMzc2Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367613766", "bodyText": "No, I made signing_algorithm mandatory in my latest iteration.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyODg4Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367728886", "bodyText": "So any arguments that have =None set by default is conveying that those arguments are optional and that them having values of None is fine and something that our users will use.\nSo it looks like I can call it with:\nconf = HttpSigningConfiguration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=SCHEME_HS2019\n)\n\nIs that a valid invocation?\nIf not can we make the params have defaults which are valid or make them positional?\nCan you describe why you have None value defaults set for signed_headers, signing_algorithm, and signature_max_validity?", "author": "spacether", "createdAt": "2020-01-17T01:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMjM4NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367732384", "bodyText": "@sebastien-rosset when you have time can you answer the questions I asked in my last comment here? This is not resolved yet.", "author": "spacether", "createdAt": "2020-01-17T01:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNTA3MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367735071", "bodyText": "So any arguments that have =None set by default is conveying that those arguments are optional and that them having values of None is fine and something that our users will use.\nSo it looks like I can call it with:\nconf = HttpSigningConfiguration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=SCHEME_HS2019\n)\n\nIs that a valid invocation?\n\nYes, this is valid. The default list of signed headers would be ['(created)'], as specified in the spec. The signing algorithm would be set to RSASSA_PSS because the specified key is an RSA key. And by default there would be no expiration for the signature (though in practice servers often have their own restrictions).\n\nIf not can we make the params have defaults which are valid or make them positional?\nCan you describe why you have None value defaults set for signed_headers, signing_algorithm, and signature_max_validity?", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjY4Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367736686", "bodyText": "Thank you for explaining that. I am fine with this __init__ signature now that I understand that the above use case is valid. Feel free to mark this as resolved.", "author": "spacether", "createdAt": "2020-01-17T01:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNzIxOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367527219", "bodyText": "Would the private key change between api calls?\nHow about moving this in to the __init__ method.", "author": "spacether", "createdAt": "2020-01-16T16:41:10Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the signing_info.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.load_private_key()", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzMjI0Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367532246", "bodyText": "Yes, I can do that.", "author": "sebastien-rosset", "createdAt": "2020-01-16T16:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367541157", "bodyText": "Now changes depending upon what time zone the machine is in running this code.\nCan you add a constant time_zone which defaults to UTC in this class's __init__ method?\nThat way our user can specify what timezone now is calculated in.\nCan you update now an unix time zero to use that self.time_zone timezone?\nSee an example of timezone usage here: https://medium.com/@chaoren/datetime-to-unix-time-epoch-in-python-2-3-ecba6493e8b", "author": "spacether", "createdAt": "2020-01-16T17:05:52Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwNTU1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367605557", "bodyText": "The link you provided uses strftime('%s'), but it's a bad idea to use that. See\nhttps://stackoverflow.com/questions/11743019/convert-python-datetime-to-epoch-with-strftime", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwNjI4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367606288", "bodyText": "Good to know, thanks. Sorry for that.", "author": "spacether", "createdAt": "2020-01-16T19:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxMDk4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367610987", "bodyText": "The code is essentially calculating the deltatime (now - 01/01/1970), where both now and 01/01/1970 are datetime objects are in the same timezone. It may be UTC, PST or any time zone, but both arguments are in the same timezone, so shouldn't the outcome be exactly the same regardless of the time zone?", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxMzA0Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367613047", "bodyText": "Good to know, thanks. Sorry for that.\n\nI know. It's everywhere, initially I also used strftime('%s'). There is a better option but unfortunately it only works for Python 3.3 and above.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxMzI0OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367613249", "bodyText": "Marking resolved for now.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0MTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0Mzk4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367543988", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:11:11Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjM3Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576377", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0Mzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDA1OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544058", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:11:21Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MjA5Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367552096", "bodyText": "sure, I can do that for all other methods, then. There is really only one method which is used outside this module.", "author": "sebastien-rosset", "createdAt": "2020-01-16T17:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MTU4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367561588", "bodyText": "Sounds good. That's what I want to highlight with our underscore usage in method names.", "author": "spacether", "createdAt": "2020-01-16T17:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjMyMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576320", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDI4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544281", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:11:45Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjI2Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576262", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDM2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544361", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:11:54Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjAwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576007", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDc3OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367544778", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:12:46Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:\n+            digest = SHA256.new()\n+            prefix = 'SHA-256='\n+        else:\n+            raise Exception(\"Unsupported signing algorithm: {0}\".format(self.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the signing_info.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.load_private_key()\n+        sig_alg = self.signing_algorithm\n+        if isinstance(self.private_key, RSA.RsaKey):\n+            if sig_alg is None or sig_alg == ALGORITHM_RSASSA_PSS:\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(self.private_key).sign(digest)\n+            elif sig_alg == ALGORITHM_RSASSA_PKCS1v15:\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(self.private_key).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(sig_alg))\n+        elif isinstance(self.private_key, ECC.EccKey):\n+            if sig_alg is None:\n+                sig_alg = ALGORITHM_ECDSA_MODE_FIPS_186_3\n+            if sig_alg in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(self.private_key, sig_alg).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(sig_alg))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(self.private_key)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjA2Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576067", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NDc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NTU2OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367545569", "bodyText": "Can change this method's name to add a a _ or __ prefix so we can tell that it is not our publicly used method?\nSee\n\nhttp://python.robasworld.com/private-member-name-mangling/\nhttps://softwareengineering.stackexchange.com/questions/229804/usage-of-while-declaring-any-variables-or-class-member-in-python", "author": "spacether", "createdAt": "2020-01-16T17:14:20Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NjE1MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367576150", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0ODA4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367548087", "bodyText": "Is host unchanging?\nIf so, why not pass it in or pass in our configuration instance to this class's __init__ method?", "author": "spacether", "createdAt": "2020-01-16T17:19:24Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU5Njg4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367596882", "bodyText": "I don't think SDK developers should have to set the host in the HttpSigningConfiguration constructor, because they already do it in the Configuration constructor. But the Configuration class can set the host. This is what I have done locally, you can review when I commit. I will mark resolved for now.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0ODA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MzkwMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367553902", "bodyText": "If we only add the signing_info instance to the auth_setting dict if self.signing_info is not None in configuration.py, then how about we delete this if statement and exception raising?", "author": "spacether", "createdAt": "2020-01-16T17:31:42Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':\n+                    # The HTTP signature scheme requires multiple HTTP headers\n+                    # that are calculated dynamically.\n+                    signing_info = self.configuration.signing_info\n+                    if signing_info is None:\n+                        raise Exception(\"HTTP signature configuration is missing\")", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMTU3Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367601576", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367555779", "bodyText": "Is this a specific if statement that can be included in the below if/elif case handling?\nHow about\n\nchanging this if statement to if auth_setting['in'] == 'header' and auth_setting['type'] == 'http-signature':\ndeleting the continue line from the bottom of this if block\nchange if auth_setting['in'] == 'cookie': to elif auth_setting['in'] == 'cookie':", "author": "spacether", "createdAt": "2020-01-16T17:35:49Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -517,19 +521,37 @@ class ApiClient(object):\n         else:\n             return content_types[0]\n \n-    def update_params_for_auth(self, headers, querys, auth_settings):\n+    def update_params_for_auth(self, headers, querys, auth_settings,\n+                               resource_path, method, body):\n         \"\"\"Updates header and query params based on authentication setting.\n \n         :param headers: Header parameters dict to be updated.\n         :param querys: Query parameters tuple list to be updated.\n         :param auth_settings: Authentication setting identifiers list.\n+        :resource_path: A string representation of the HTTP request resource path.\n+        :method: A string representation of the HTTP request method.\n+        :body: A string representation of the body of the HTTP request.\n         \"\"\"\n         if not auth_settings:\n             return\n \n         for auth in auth_settings:\n             auth_setting = self.configuration.auth_settings().get(auth)\n             if auth_setting:\n+{{#hasHttpSignatureMethods}}\n+                if auth_setting['type'] == 'http-signature':", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU5ODA2MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367598060", "bodyText": "what you are proposing would not work exactly as is, because the block is generated conditionally, so you could end up with a statement starting with \"elif\". But I get the idea.", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMDU1NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367600555", "bodyText": "Hmm, it's a bit tricky to make it clean because of the indentation requirements. For example, we could have something like below but I feel it makes the logic harder to understand.\n            if auth_setting:\n                if auth_setting['in'] == 'cookie':\n                    headers['Cookie'] = auth_setting['value']\n                elif auth_setting['in'] == 'header':\n{{#hasHttpSignatureMethods}}\n                    if auth_setting['type'] == 'http-signature':\n                        # The HTTP signature scheme requires multiple HTTP headers\n                        # that are calculated dynamically.\n                        signing_info = self.configuration.signing_info\n                        if signing_info is None:\n                            raise Exception(\"HTTP signature configuration is missing\")\n                        auth_headers = signing_info.get_http_signature_headers(\n                                            resource_path, method, headers, body, querys)\n                        for key, value in auth_headers.items():\n                            headers[key] = value\n                    else:\n                        headers[auth_setting['key']] = auth_setting['value']\n{{/hasHttpSignatureMethods}}\n{{^hasHttpSignatureMethods}}\n                    headers[auth_setting['key']] = auth_setting['value']\n{{/hasHttpSignatureMethods}}\n                elif auth_setting['in'] == 'query':\n                    querys.append((auth_setting['key'], auth_setting['value']))\n                else:\n                    raise ApiValueError(\n                        'Authentication token must be in `query` or `header`'\n                    )", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMDg0OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367600848", "bodyText": "That's true. You could change this block to an elif then and move it to be conditionally included down below.", "author": "spacether", "createdAt": "2020-01-16T19:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMzkyNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367603924", "bodyText": "You don't need all that code, how about:\n            if auth_setting:\n                if auth_setting['in'] == 'cookie':\n                    headers['Cookie'] = auth_setting['value']\n                elif auth_setting['in'] == 'header':\n                    if auth_setting['type'] != 'http-signature':\n                        headers[auth_setting['key']] = auth_setting['value']\n{{#hasHttpSignatureMethods}}\n                    else:\n                        # The HTTP signature scheme requires multiple HTTP headers\n                        # that are calculated dynamically.\n                        signing_info = self.configuration.signing_info\n                        # NOTE: no need to raise an exception because this entry only exists if signng_info is not None\n                        auth_headers = signing_info.get_http_signature_headers(\n                                            resource_path, method, headers, body, querys)\n                        headers.update(auth_headers)\n{{/hasHttpSignatureMethods}}\n                elif auth_setting['in'] == 'query':\n                    querys.append((auth_setting['key'], auth_setting['value']))\n                else:\n                    raise ApiValueError(\n                        'Authentication token must be in `query`, `header`, or `cookie`'\n                    )", "author": "spacether", "createdAt": "2020-01-16T19:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYxMjQzMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367612430", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T19:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjE5Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367556196", "bodyText": "Can you add type here? It is string, right?", "author": "spacether", "createdAt": "2020-01-16T17:36:48Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NDEwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367574109", "bodyText": "added.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjUxNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367556515", "bodyText": "Can you add type here? The string path", "author": "spacether", "createdAt": "2020-01-16T17:37:27Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3NDAwMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367574002", "bodyText": "added.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzE4NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367557185", "bodyText": "Can you add type here?", "author": "spacether", "createdAt": "2020-01-16T17:38:58Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3Mzg5Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367573896", "bodyText": "added", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzYwNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367557605", "bodyText": "Can you update this to list the three accepted values here?", "author": "spacether", "createdAt": "2020-01-16T17:39:57Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3MTIzNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367571237", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODAyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367558023", "bodyText": "Optionally remove this. Our context is python and we know that this is a constructor.", "author": "spacether", "createdAt": "2020-01-16T17:40:52Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3MTE3MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367571171", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODQxNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367558414", "bodyText": "Can you include your clearer description here?\n           For RSA keys, supported values are PKCS1v15, PSS.\n           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.", "author": "spacether", "createdAt": "2020-01-16T17:41:48Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3MTA0Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367571047", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1ODQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MDMxNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367560317", "bodyText": "Can you have all the docstring info on these parameters in the top of the class or here in the __init__ dosctring but not both?\nPython std practice is to put it in one of those places but not both. So if you want to keep it in the class can you delete these comments describing these params?", "author": "spacether", "createdAt": "2020-01-16T17:46:01Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2OTA3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367569079", "bodyText": "doing. I was just copying whatever other people had done in this repo, but what you are saying makes sense.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU3MDUyMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367570521", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MDMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2Mjk4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367562981", "bodyText": "Optionally change this to elif self.signing_scheme == SCHEME_RSA_SHA256:", "author": "spacether", "createdAt": "2020-01-16T17:51:43Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:\n+            digest = SHA512.new()\n+            prefix = 'SHA-512='\n+        elif self.signing_scheme in [SCHEME_RSA_SHA256]:", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2ODc5MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367568790", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2Mjk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzQ1OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367563458", "bodyText": "Optionally change this to if self.signing_scheme in {SCHEME_RSA_SHA512, SCHEME_HS2019}:\nSet inclusion is quicker than list inclusion.", "author": "spacether", "createdAt": "2020-01-16T17:52:43Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,317 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration\n+\n+HEADER_REQUEST_TARGET = '(request-target)'\n+HEADER_CREATED = '(created)'\n+HEADER_EXPIRES = '(expires)'\n+HEADER_HOST = 'host'\n+HEADER_DATE = 'date'\n+HEADER_DIGEST = 'Digest'\n+HEADER_AUTHORIZATION = 'Authorization'\n+\n+SCHEME_HS2019 = 'hs2019'\n+SCHEME_RSA_SHA256 = 'rsa-sha256'\n+SCHEME_RSA_SHA512 = 'rsa-sha512'\n+\n+ALGORITHM_RSASSA_PSS = 'PSS'\n+ALGORITHM_RSASSA_PKCS1v15 = 'PKCS1v15'\n+\n+ALGORITHM_ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+ALGORITHM_ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+ALGORITHM_ECDSA_KEY_SIGNING_ALGORITHMS = {\n+    ECDSA_MODE_FIPS_186_3,\n+    ECDSA_MODE_DETERMINISTIC_RFC6979\n+}\n+\n+class HttpSigningConfiguration(object):\n+    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n+\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    \"\"\"\n+    def __init__(self, key_id, private_key_path,\n+                 signing_scheme=SCHEME_HS2019,\n+                 signed_headers=[HEADER_CREATED],\n+                 signing_algorithm=None,\n+                 signature_max_validity=None):\n+        \"\"\"Constructor\n+        \"\"\"\n+        self.key_id = key_id\n+        \"\"\"The identifier of the key used to sign HTTP requests.\n+        \"\"\"\n+        self.private_key_path = private_key_path\n+        \"\"\"The path of the file containing a private key, used to sign HTTP requests.\n+        \"\"\"\n+        self.signing_scheme = signing_scheme\n+        \"\"\"The signature scheme when signing HTTP requests.\n+           Supported values are hs2019, rsa-sha256, rsa-sha512.\n+        \"\"\"\n+        self.signing_algorithm = signing_algorithm\n+        \"\"\"The signature algorithm when signing HTTP requests.\n+           For RSA keys, supported values are PKCS1v15, PSS.\n+           For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n+        \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if signed_headers is None or len(signed_headers) == 0:\n+            signed_headers = [HEADER_CREATED]\n+        if self.signature_max_validity is None and HEADER_EXPIRES in signed_headers:\n+            raise Exception(\n+                \"Signature max validity must be set when \" \\\n+                \"'(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):\n+            raise Exception(\"Cannot have duplicates in the signed_headers parameter\")\n+        if HEADER_AUTHORIZATION in signed_headers:\n+            raise Exception(\"'Authorization' header cannot be included in signed headers\")\n+        self.signed_headers = signed_headers\n+        \"\"\"A list of strings. Each value is the name of HTTP header that must be included\n+           in the HTTP signature calculation.\n+        \"\"\"\n+        self.private_key = None\n+        \"\"\"The private key used to sign HTTP requests.\n+            Initialized when the PEM-encoded private key is loaded from a file.\n+        \"\"\"\n+\n+    def get_http_signature_headers(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(\n+            host, resource_path, method, headers, body, query_params)\n+\n+        header_items = [\n+            \"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict[HEADER_AUTHORIZATION] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+            The private key is used to sign HTTP requests as defined in\n+            https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, 'rb') as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith('-----BEGIN RSA PRIVATE KEY-----'):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith('-----BEGIN EC PRIVATE KEY-----'):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+\n+    def get_unix_time(self, ts):\n+        \"\"\"Converts and returns a datetime object to UNIX time, the number of seconds\n+           elapsed since January 1, 1970 UTC.\n+        \"\"\"\n+        return (ts - datetime.datetime(1970,1,1)).total_seconds())\n+\n+    def get_signed_header_info(self, host, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(host).netloc\n+        target_path = urlparse(host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        # The '(created)' value MUST be a Unix timestamp integer value.\n+        # Subsecond precision is not supported.\n+        created = self.get_unix_time(int(now))\n+        if self.signature_max_validity is not None:\n+            expires = self.get_unix_time(now + self.signature_max_validity)\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == HEADER_REQUEST_TARGET:\n+                value = request_target\n+            elif hdr_key == HEADER_CREATED:\n+                value = '{0}'.format(created)\n+            elif hdr_key == HEADER_EXPIRES:\n+                value = '{0}'.format(expires)\n+            elif hdr_key == HEADER_DATE:\n+                value = cdate\n+                request_headers_dict[HEADER_DATE] = '{0}'.format(cdate)\n+            elif hdr_key == HEADER_DIGEST:\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict[HEADER_DIGEST] = '{0}{1}'.format(\n+                    digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == HEADER_HOST:\n+                value = target_host\n+                request_headers_dict[HEADER_HOST] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+            The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+            The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+            'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.signing_scheme in [SCHEME_RSA_SHA512, SCHEME_HS2019]:", "originalCommit": "4148453c1a72f4ee6da15f00c7f934469a69f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2ODY0NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367568645", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-16T18:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU2MzQ1OA=="}], "type": "inlineReview"}, {"oid": "06d25b932f678576baee23807e0d469541a706fa", "url": "https://github.com/OpenAPITools/openapi-generator/commit/06d25b932f678576baee23807e0d469541a706fa", "message": "Address PR review comments.", "committedDate": "2020-01-16T20:28:48Z", "type": "commit"}, {"oid": "1bf286fb797700ab91735adae9c3989b16d819a7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1bf286fb797700ab91735adae9c3989b16d819a7", "message": "Add http-signature security scheme", "committedDate": "2020-01-17T00:17:31Z", "type": "commit"}, {"oid": "517019545f2258920644e558937b2ab8c28b0794", "url": "https://github.com/OpenAPITools/openapi-generator/commit/517019545f2258920644e558937b2ab8c28b0794", "message": "Run sample scripts for go", "committedDate": "2020-01-17T00:56:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ1MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367727450", "bodyText": "Can you remove this import?\nHttpSigningConfiguration now exists inside this module", "author": "spacether", "createdAt": "2020-01-17T01:10:45Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,315 @@\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from datetime import timedelta\n+from six.moves.urllib.parse import urlencode, urlparse\n+import pem\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+from {{packageName}}.configuration import HttpSigningConfiguration", "originalCommit": "06d25b932f678576baee23807e0d469541a706fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyODExMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367728110", "bodyText": "I just created an integration branch that takes 3 PRs together. I won't merge it, but at least it will allow me to build and run the unit tests. I will fix this issue and any other issue that comes up.", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMDM3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367730370", "bodyText": "That sounds good. Do you know that you can test locally by:\n\nrunning the server with docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\nrun make test or make test-all in the python or python-experimental directories", "author": "spacether", "createdAt": "2020-01-17T01:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzI4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367733282", "bodyText": "yes, thanks. That's what I do.", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ1MA=="}], "type": "inlineReview"}, {"oid": "de10ae09c4bd5751a125a6194f281511375df07f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/de10ae09c4bd5751a125a6194f281511375df07f", "message": "Fix issue uncovered in integration branch", "committedDate": "2020-01-17T01:16:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367729302", "bodyText": "Should this class be changed from Configuration to HttpSigningConfiguration?", "author": "spacether", "createdAt": "2020-01-17T01:19:02Z", "path": "samples/client/petstore/python-experimental/tests/test_pet_api.py", "diffHunk": "@@ -175,6 +175,36 @@ def test_separate_default_config_instances(self):\n         pet_api2.api_client.configuration.host = 'someotherhost'\n         self.assertNotEqual(pet_api.api_client.configuration.host, pet_api2.api_client.configuration.host)\n \n+    def test_http_signature(self):\n+        config = Configuration(", "originalCommit": "06d25b932f678576baee23807e0d469541a706fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367733056", "bodyText": "yes, though I need to do something because that class is generated conditionally.", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzQ4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367733488", "bodyText": "Our sample spec should trigger the generation of signing.py, so we should be okay using it.", "author": "spacether", "createdAt": "2020-01-17T01:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjEwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367736106", "bodyText": "Well except that I think this particular file is also used for the OpenAPI spec version 2, which is using a different YAML file without the security scheme. I am thinking about creating a specific file under samples/openapi3/client/petstore/python-experimental/tests", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNzI2Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367737266", "bodyText": "Ah, this is a v2 test only.\nYes please fee free to add the test in either of the below folders\n\nsamples/openapi3/client/petstore/python-experimental/tests (manual tests I think)\nsamples/openapi3/client/petstore/python-experimental/test (autogen tests I think)\nEither location should be fine because those files are not overwritten once they exist", "author": "spacether", "createdAt": "2020-01-17T01:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNzg3Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367737872", "bodyText": "One thing I just discovered is that the directories don't seem to be merged by default.\nI created a file samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py, and I thought by default it would be merged with the files under samples/client/petstore/python-experimental/tests.\nIt would be nice if the build could copy the files from samples/client/petstore/python-experimental/tests and add the files from samples/openapi3/client/petstore/python-experimental/tests/ in a single \"tests\" directory.", "author": "sebastien-rosset", "createdAt": "2020-01-17T01:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2Mzg2OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367763868", "bodyText": "So the specs could be different. Those directories are generated by separate bash files. For now I prefer to keep them separate. Also because one is for v2 spec testing and one is for v3 spec testing. So they have different features.", "author": "spacether", "createdAt": "2020-01-17T04:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxMDk0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367810940", "bodyText": "ok, sure. I have created a separate unit test file. The code is now compiling and generating HTTP signatures. I was able to test because I combined this PR with the PR that contains the openapi3 samples (in my local workspace).\nThis cannot be tested directly until the \"openapi3 samples\" PR is merged.", "author": "sebastien-rosset", "createdAt": "2020-01-17T08:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyOTMwMg=="}], "type": "inlineReview"}, {"oid": "01766941fe8033cfbcdefa1c434c0d4f456cedd7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/01766941fe8033cfbcdefa1c434c0d4f456cedd7", "message": "Fix issue uncovered in integration branch", "committedDate": "2020-01-17T01:20:55Z", "type": "commit"}, {"oid": "155f55497cf3a17b0838a2df85dc64d5011a3d77", "url": "https://github.com/OpenAPITools/openapi-generator/commit/155f55497cf3a17b0838a2df85dc64d5011a3d77", "message": "Fix issue uncovered in integration branch", "committedDate": "2020-01-17T01:23:20Z", "type": "commit"}, {"oid": "0426487ff224c8eabd2a94172bc980de462a3ff4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0426487ff224c8eabd2a94172bc980de462a3ff4", "message": "Fix issue uncovered in integration branch", "committedDate": "2020-01-17T01:26:51Z", "type": "commit"}, {"oid": "6cfefa0a8d8a5a6d8c68ea50bd435e326220b8e0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6cfefa0a8d8a5a6d8c68ea50bd435e326220b8e0", "message": "Run samples scripts", "committedDate": "2020-01-17T01:31:44Z", "type": "commit"}, {"oid": "c8866584ae40fe339427aa0cef514c66fdda8722", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c8866584ae40fe339427aa0cef514c66fdda8722", "message": "move http signature tests to separate file", "committedDate": "2020-01-17T01:55:43Z", "type": "commit"}, {"oid": "c7a01ec4c3771ea2642f1ee59b08aa499bf211f5", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c7a01ec4c3771ea2642f1ee59b08aa499bf211f5", "message": "move http signature tests to separate file", "committedDate": "2020-01-17T02:00:59Z", "type": "commit"}, {"oid": "3ceda7840f23075be72f351256fd7b84dc984728", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3ceda7840f23075be72f351256fd7b84dc984728", "message": "unit tests for HTTP signature", "committedDate": "2020-01-17T02:52:18Z", "type": "commit"}, {"oid": "707d40bfa7d6599b2a2f7a9abe38696e8182653a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/707d40bfa7d6599b2a2f7a9abe38696e8182653a", "message": "continue implementation of unit tests", "committedDate": "2020-01-17T04:48:21Z", "type": "commit"}, {"oid": "ef59c0ca45c721b5163126895a01032faa930bda", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ef59c0ca45c721b5163126895a01032faa930bda", "message": "add http_signature_test to security scheme", "committedDate": "2020-01-17T04:49:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4ODY4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367788688", "bodyText": "Can you delete this note line and the comment line below it?\nThey are not needed", "author": "spacether", "createdAt": "2020-01-17T06:41:47Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -533,7 +541,19 @@ class ApiClient(object):\n                 if auth_setting['in'] == 'cookie':\n                     headers['Cookie'] = auth_setting['value']\n                 elif auth_setting['in'] == 'header':\n-                    headers[auth_setting['key']] = auth_setting['value']\n+                    if auth_setting['type'] != 'http-signature':\n+                        headers[auth_setting['key']] = auth_setting['value']\n+{{#hasHttpSignatureMethods}}\n+                    else:\n+                        # The HTTP signature scheme requires multiple HTTP headers\n+                        # that are calculated dynamically.\n+                        signing_info = self.configuration.signing_info\n+                        # NOTE: no need to raise an exception because this entry only exists", "originalCommit": "707d40bfa7d6599b2a2f7a9abe38696e8182653a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MTQzNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367791436", "bodyText": "How does this check results from the mock _pool?\nCan we verify that the signed data is eqal to a specific value?", "author": "spacether", "createdAt": "2020-01-17T06:53:48Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,164 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+import json\n+import os\n+import unittest\n+import shutil\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        self._tc.assertEqual(r[0], args)\n+        self._tc.assertEqual(r[1], kwargs)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+    def tearDown(self):\n+        if os.path.exists(self.rsa_key_path):\n+            os.unlink(self.rsa_key_path)\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+\n+    def test_http_signature(self):\n+        with open(self.rsa_key_path, 'w') as f:\n+          f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://localhost/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Bearer ',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=TimeoutWithEqual(total=5))\n+        mock_pool.expect_request('POST', 'http://localhost/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Bearer ',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=TimeoutWithEqual(connect=1, read=2))\n+\n+        pet_api.add_pet(self.pet, _request_timeout=5)", "originalCommit": "707d40bfa7d6599b2a2f7a9abe38696e8182653a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxMTkzOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367811939", "bodyText": "This is outdated. I initially copy-pasted the code from another file, but I wasn't ready to actually test. See my other comment, now I have several working unit tests. I will probably add more tomorrow. I particular, I will add a unit test that validates that for a given deterministic signature algorithm (not RSASSA-PSS), Python and golang generate the same signature.", "author": "sebastien-rosset", "createdAt": "2020-01-17T08:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1OTYwMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368159601", "bodyText": "I have added a bunch of unit tests.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MTQzNg=="}], "type": "inlineReview"}, {"oid": "9dacccaa763a35c9c856e4173e952b6b654a915e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9dacccaa763a35c9c856e4173e952b6b654a915e", "message": "add unit tests for http signature", "committedDate": "2020-01-17T08:04:24Z", "type": "commit"}, {"oid": "5355566335a2c4afb6c2b9296026ec1a04a9db60", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5355566335a2c4afb6c2b9296026ec1a04a9db60", "message": "address review comments", "committedDate": "2020-01-17T08:15:33Z", "type": "commit"}, {"oid": "0f7cbb1ec75ddd1f18ca4b67ff8fa28678306679", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0f7cbb1ec75ddd1f18ca4b67ff8fa28678306679", "message": "Merge branch 'master' into http-signature", "committedDate": "2020-01-17T16:19:31Z", "type": "commit"}, {"oid": "f8dea28d02889b1648bfdc353244610e436dde6d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/f8dea28d02889b1648bfdc353244610e436dde6d", "message": "remove http signature from petapi", "committedDate": "2020-01-17T16:21:11Z", "type": "commit"}, {"oid": "d33f6b694b170cd4c8382d098702bdd09599ae0e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d33f6b694b170cd4c8382d098702bdd09599ae0e", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-17T16:21:35Z", "type": "commit"}, {"oid": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "url": "https://github.com/OpenAPITools/openapi-generator/commit/aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "message": "Merge branch 'http-signature' into python-http-signature", "committedDate": "2020-01-17T16:21:51Z", "type": "commit"}, {"oid": "21e35f0cfeabef0d5cf51043872ea96bd418406d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/21e35f0cfeabef0d5cf51043872ea96bd418406d", "message": "Add separate OAS file with support for HTTP signature", "committedDate": "2020-01-17T16:23:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTgxNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368029814", "bodyText": "Why is this file in this update?\nCan we switch go to use the new spec in the go-experimental PR?", "author": "spacether", "createdAt": "2020-01-17T16:40:16Z", "path": "samples/openapi3/client/petstore/go-experimental/go-petstore/api/openapi.yaml", "diffHunk": "@@ -54,7 +54,7 @@ paths:\n       requestBody:\n         $ref: '#/components/requestBodies/Pet'\n       responses:\n-        405:\n+        \"405\":", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1OTQ2Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368159466", "bodyText": "I think this is because of some unrelated problem. I see other PRs opened recently have the same changes..", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTY3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368331673", "bodyText": "I have opened a separate PR for this one: #5049. It looks like somebody forgot to execute a script under ./bin", "author": "sebastien-rosset", "createdAt": "2020-01-19T23:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzcyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368033723", "bodyText": "Silly question but:\nCan you verify that this key is was generated only for this testing?\nOptionally, how about:\n\ngenerate the rsa key on the fly with:\n\nfrom os import chmod\nfrom Crypto.PublicKey import RSA\n\nkey = RSA.generate(2048)\nwith open(\"/tmp/private.key\", 'wb') as content_file:\n    chmod(\"/tmp/private.key\", 0600)\n    content_file.write(key.exportKey('PEM'))\npubkey = key.publickey()\nwith open(\"/tmp/public.key\", 'wb') as content_file:\n    content_file.write(pubkey.exportKey('OpenSSH'))\n\nper https://stackoverflow.com/questions/2466401/how-to-generate-ssh-key-pairs-with-python\n\ngenerating the rsa key on the fly by invoking ssh-keygen\nor moving this data to a file in a testfiles folder like we do for other file assets https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/python-experimental/testfiles", "author": "spacether", "createdAt": "2020-01-17T16:48:08Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MDU1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368040559", "bodyText": "Silly question but:\nCan you verify that this key is was generated only for this testing?\n\nI have put a code comment that says it's the test key from the http signature specification. The spec has a section about \"test values\", with the input key and expected Authorization header. The idea was to make it possible to compare that the implementation matches exactly the spec. Though subsequently I realized it's currently not possible because there is a warning that the test values are going to be regenerated in the next draft, and the test values don't actually show the signature string.\n\nOptionally, how about:\n\ngenerate the rsa key on the fly with:\n\nfrom os import chmod\nfrom Crypto.PublicKey import RSA\n\nkey = RSA.generate(2048)\nwith open(\"/tmp/private.key\", 'wb') as content_file:\n    chmod(\"/tmp/private.key\", 0600)\n    content_file.write(key.exportKey('PEM'))\npubkey = key.publickey()\nwith open(\"/tmp/public.key\", 'wb') as content_file:\n    content_file.write(pubkey.exportKey('OpenSSH'))\n\n\nYes, I do something similar for the RSA 4096 key, not exactly as you mention, but similar.\n\nper https://stackoverflow.com/questions/2466401/how-to-generate-ssh-key-pairs-with-python\n\ngenerating the rsa key on the fly by invoking ssh-keygen\nor moving this data to a file in a testfiles folder like we do for other file assets https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/python-experimental/testfiles\n\n\nI thought about this, but I wondered if people would start complaining this might be a production key. At least in the source code you can put comments about the origin of the private key (in this case the private key is published on the internet).", "author": "sebastien-rosset", "createdAt": "2020-01-17T17:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1OTEyNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368159127", "bodyText": "I think I can mark this as resolved. Feel free to reopen.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNDk1Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368034953", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "author": "spacether", "createdAt": "2020-01-17T16:50:45Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODk0Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368158946", "bodyText": "I have added unit tests to verify the signature with the public key.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTE1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035157", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "author": "spacether", "createdAt": "2020-01-17T16:51:05Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODkwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368158906", "bodyText": "I have added unit tests to verify the signature with the public key.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTIzMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035231", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "author": "spacether", "createdAt": "2020-01-17T16:51:11Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pss(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODg2Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368158862", "bodyText": "I have added unit tests to verify the signature with the public key.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTMwMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368035303", "bodyText": "Can you decode the request using the key to show that you get back the unencrypted data to verify that this is working?", "author": "spacether", "createdAt": "2020-01-17T16:51:21Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,370 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.PublicKey import RSA\n+from Crypto.PublicKey import ECC\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# Test RSA private key as published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers\n+        for k, expected in r[1].items():\n+            self._tc.assertIn(k, kwargs)\n+            actual = kwargs[k]\n+            if k == 'body':\n+                self._tc.assertEqual(expected, actual)\n+            elif k == 'headers':\n+                for expected_header_name, expected_header_value in expected.items():\n+                    self._tc.assertIn(expected_header_name, actual)\n+                    actual_header_value = actual[expected_header_name]\n+                    pattern = re.compile(expected_header_value)\n+                    m = pattern.match(actual_header_value)\n+                    self._tc.assertTrue(m, msg=\"Expected:\\n{0}\\nActual:\\n{1}\".format(\n+                                        expected_header_value,actual_header_value))\n+            elif k == 'timeout':\n+                self._tc.assertEqual(expected, actual)\n+        return urllib3.HTTPResponse(status=200, body=b'test')\n+\n+\n+class PetApiTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        self.setUpModels()\n+        self.setUpFiles()\n+\n+\n+    def setUpModels(self):\n+        self.category = petstore_api.Category()\n+        self.category.id = id_gen()\n+        self.category.name = \"dog\"\n+        self.tag = petstore_api.Tag()\n+        self.tag.id = id_gen()\n+        self.tag.name = \"python-pet-tag\"\n+        self.pet = petstore_api.Pet(name=\"hello kity\", photo_urls=[\"http://foo.bar.com/1\", \"http://foo.bar.com/2\"])\n+        self.pet.id = id_gen()\n+        self.pet.status = \"sold\"\n+        self.pet.category = self.category\n+        self.pet.tags = [self.tag]\n+\n+    def setUpFiles(self):\n+        self.test_file_dir = os.path.join(os.path.dirname(__file__), \"..\", \"testfiles\")\n+        self.test_file_dir = os.path.realpath(self.test_file_dir)\n+        if not os.path.exists(self.test_file_dir):\n+            os.mkdir(self.test_file_dir)\n+\n+        self.rsa_key_path = os.path.join(self.test_file_dir, 'rsa.pem')\n+        self.rsa4096_key_path = os.path.join(self.test_file_dir, 'rsa4096.pem')\n+        self.ec_p521_key_path = os.path.join(self.test_file_dir, 'ecP521.pem')\n+\n+        if not os.path.exists(self.rsa_key_path):\n+            with open(self.rsa_key_path, 'w') as f:\n+                f.write(RSA_TEST_PRIVATE_KEY)\n+\n+        if not os.path.exists(self.rsa4096_key_path):\n+            key = RSA.generate(4096)\n+            private_key = key.export_key()\n+            with open(self.rsa4096_key_path, \"wb\") as f:\n+                f.write(private_key)\n+\n+        if not os.path.exists(self.ec_p521_key_path):\n+            key = ECC.generate(curve='P-521')\n+            private_key = key.export_key(format='PEM')\n+            with open(self.ec_p521_key_path, \"wt\") as f:\n+                f.write(private_key)\n+\n+    def test_valid_http_signature(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+                signing.HEADER_HOST,\n+                signing.HEADER_DATE,\n+                signing.HEADER_DIGEST,\n+                'Content-Type'\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\) host date digest content-type\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_with_defaults(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pkcs1v15(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PKCS1v15,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_rsassa_pss(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.rsa4096_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signing_algorithm=signing.ALGORITHM_RSASSA_PSS,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+=\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)\n+\n+    def test_valid_http_signature_ec_p521(self):\n+        signing_cfg = signing.HttpSigningConfiguration(\n+            key_id=\"my-key-id\",\n+            private_key_path=self.ec_p521_key_path,\n+            signing_scheme=signing.SCHEME_HS2019,\n+            signed_headers=[\n+                signing.HEADER_REQUEST_TARGET,\n+                signing.HEADER_CREATED,\n+            ]\n+        )\n+        config = Configuration(host=HOST, signing_info=signing_cfg)\n+        # Set the OAuth2 acces_token to None. Here we are interested in testing\n+        # the HTTP signature scheme.\n+        config.access_token = None\n+\n+        api_client = petstore_api.ApiClient(config)\n+        pet_api = petstore_api.PetApi(api_client)\n+\n+        mock_pool = MockPoolManager(self)\n+        api_client.rest_client.pool_manager = mock_pool\n+\n+        mock_pool.expect_request('POST', 'http://petstore.swagger.io/v2/pet',\n+                                 body=json.dumps(api_client.sanitize_for_serialization(self.pet)),\n+                                 headers={'Content-Type': 'application/json',\n+                                          'Authorization': 'Signature keyId=\"my-key-id\",algorithm=\"hs2019\",created=[0-9]+,'\n+                                                'headers=\"\\(request-target\\) \\(created\\)\",'\n+                                                'signature=\"[a-zA-Z0-9+/]+\"',\n+                                          'User-Agent': 'OpenAPI-Generator/1.0.0/python'},\n+                                 preload_content=True, timeout=None)\n+\n+        pet_api.add_pet(self.pet)", "originalCommit": "aafedc6cfde3ef998dc12ee5ff6055717aa1f4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1ODgyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368158829", "bodyText": "There is no process to \"get back the unencrypted data\", it's a signature, but I think I know what you meant. I have added unit tests to verify the signature with the public key.", "author": "sebastien-rosset", "createdAt": "2020-01-17T22:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNTMwMw=="}], "type": "inlineReview"}, {"oid": "6ab9cf91a9a51c3eb352c60bdfae58e588b057f9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6ab9cf91a9a51c3eb352c60bdfae58e588b057f9", "message": "Merge branch 'http-signature' into python-http-signature", "committedDate": "2020-01-17T17:08:23Z", "type": "commit"}, {"oid": "7fb5c6e014aed227288914aeae611532e96a0657", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7fb5c6e014aed227288914aeae611532e96a0657", "message": "Add support for private key passphrase. Add more unit tests", "committedDate": "2020-01-17T19:30:15Z", "type": "commit"}, {"oid": "5f4d6c679db62d5650f0c657cb2c93b839bbbd74", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f4d6c679db62d5650f0c657cb2c93b839bbbd74", "message": "Add unit test to validate the signature against the public key", "committedDate": "2020-01-17T22:14:17Z", "type": "commit"}, {"oid": "daf060e87fcd77bc819f5f8226b00b65e50cb48e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/daf060e87fcd77bc819f5f8226b00b65e50cb48e", "message": "remove http signature from petstore-with-fake-endpoints-models-for-testing.yaml", "committedDate": "2020-01-17T22:31:48Z", "type": "commit"}, {"oid": "790c093a3f092ba4a559d0a4ab526f76be51f55c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/790c093a3f092ba4a559d0a4ab526f76be51f55c", "message": "Merge branch 'http-signature' into python-http-signature", "committedDate": "2020-01-17T22:32:25Z", "type": "commit"}, {"oid": "9f9f6be473576d69427ad56b7eb75440ce5774a0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9f9f6be473576d69427ad56b7eb75440ce5774a0", "message": "fix unit test issues", "committedDate": "2020-01-17T23:21:00Z", "type": "commit"}, {"oid": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "message": "run scripts in bin directory", "committedDate": "2020-01-18T00:22:53Z", "type": "commit"}, {"oid": "57e43fd0e4ccc970cf9036a1b6bd875570de985e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/57e43fd0e4ccc970cf9036a1b6bd875570de985e", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-19T03:41:43Z", "type": "commit"}, {"oid": "1b1aef6b13b8a6f52ced21b610351bbd916d330a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1b1aef6b13b8a6f52ced21b610351bbd916d330a", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-19T03:43:46Z", "type": "commit"}, {"oid": "4f7e6eb7c49780c553bac29d55a8a7c6c0041a54", "url": "https://github.com/OpenAPITools/openapi-generator/commit/4f7e6eb7c49780c553bac29d55a8a7c6c0041a54", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-19T15:50:23Z", "type": "commit"}, {"oid": "b9f2bff355bc7dfb24229d193c84c984ef87fe14", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b9f2bff355bc7dfb24229d193c84c984ef87fe14", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-19T15:50:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzg5OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368203898", "bodyText": "How about using variable names that convey the info in your comments?\nhttp_method_url_expected = r[0]\nEtc", "author": "spacether", "createdAt": "2020-01-18T03:53:05Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,486 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import base64\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.Hash import SHA256, SHA512\n+from Crypto.PublicKey import ECC, RSA\n+from Crypto.Signature import pkcs1_15, pss, DSS\n+from six.moves.urllib.parse import urlencode, urlparse\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# This test RSA private key below is published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def set_signing_config(self, signing_cfg):\n+        self.signing_cfg = signing_cfg\n+        self._tc.assertIsNotNone(self.signing_cfg)\n+        self.pubkey = self.signing_cfg.get_public_key()\n+        self._tc.assertIsNotNone(self.pubkey)\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.", "originalCommit": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjY0OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368332649", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-19T23:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzkzOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368203938", "bodyText": "How about using variable names that convey the info in your comments?\nkwargs could be named body_headers_actual", "author": "spacether", "createdAt": "2020-01-18T03:53:50Z", "path": "samples/openapi3/client/petstore/python-experimental/tests/test_http_signature.py", "diffHunk": "@@ -0,0 +1,486 @@\n+# coding: utf-8\n+\n+# flake8: noqa\n+\n+\"\"\"\n+Run the tests.\n+$ docker pull swaggerapi/petstore\n+$ docker run -d -e SWAGGER_HOST=http://petstore.swagger.io -e SWAGGER_BASE_PATH=/v2 -p 80:8080 swaggerapi/petstore\n+$ pip install nose (optional)\n+$ cd petstore_api-python\n+$ nosetests -v\n+\"\"\"\n+\n+from collections import namedtuple\n+from datetime import datetime, timedelta\n+import base64\n+import json\n+import os\n+import re\n+import shutil\n+import unittest\n+from Crypto.Hash import SHA256, SHA512\n+from Crypto.PublicKey import ECC, RSA\n+from Crypto.Signature import pkcs1_15, pss, DSS\n+from six.moves.urllib.parse import urlencode, urlparse\n+\n+import petstore_api\n+from petstore_api import Configuration, signing\n+from petstore_api.rest import (\n+    RESTClientObject,\n+    RESTResponse\n+)\n+\n+import six\n+\n+from petstore_api.exceptions import (\n+    ApiException,\n+    ApiValueError,\n+    ApiTypeError,\n+)\n+\n+from .util import id_gen\n+\n+import urllib3\n+\n+if six.PY3:\n+    from unittest.mock import patch\n+else:\n+    from mock import patch\n+\n+HOST = 'http://localhost/v2'\n+\n+# This test RSA private key below is published in Appendix C 'Test Values' of\n+# https://www.ietf.org/id/draft-cavage-http-signatures-12.txt\n+RSA_TEST_PRIVATE_KEY = \"\"\"-----BEGIN RSA PRIVATE KEY-----\n+MIICXgIBAAKBgQDCFENGw33yGihy92pDjZQhl0C36rPJj+CvfSC8+q28hxA161QF\n+NUd13wuCTUcq0Qd2qsBe/2hFyc2DCJJg0h1L78+6Z4UMR7EOcpfdUE9Hf3m/hs+F\n+UR45uBJeDK1HSFHD8bHKD6kv8FPGfJTotc+2xjJwoYi+1hqp1fIekaxsyQIDAQAB\n+AoGBAJR8ZkCUvx5kzv+utdl7T5MnordT1TvoXXJGXK7ZZ+UuvMNUCdN2QPc4sBiA\n+QWvLw1cSKt5DsKZ8UETpYPy8pPYnnDEz2dDYiaew9+xEpubyeW2oH4Zx71wqBtOK\n+kqwrXa/pzdpiucRRjk6vE6YY7EBBs/g7uanVpGibOVAEsqH1AkEA7DkjVH28WDUg\n+f1nqvfn2Kj6CT7nIcE3jGJsZZ7zlZmBmHFDONMLUrXR/Zm3pR5m0tCmBqa5RK95u\n+412jt1dPIwJBANJT3v8pnkth48bQo/fKel6uEYyboRtA5/uHuHkZ6FQF7OUkGogc\n+mSJluOdc5t6hI1VsLn0QZEjQZMEOWr+wKSMCQQCC4kXJEsHAve77oP6HtG/IiEn7\n+kpyUXRNvFsDE0czpJJBvL/aRFUJxuRK91jhjC68sA7NsKMGg5OXb5I5Jj36xAkEA\n+gIT7aFOYBFwGgQAQkWNKLvySgKbAZRTeLBacpHMuQdl1DfdntvAyqpAZ0lY0RKmW\n+G6aFKaqQfOXKCyWoUiVknQJAXrlgySFci/2ueKlIE1QqIiLSZ8V8OlpFLRnb1pzI\n+7U1yQXnTAEFYM560yJlzUpOb1V4cScGd365tiSMvxLOvTA==\n+-----END RSA PRIVATE KEY-----\"\"\"\n+\n+\n+class TimeoutWithEqual(urllib3.Timeout):\n+    def __init__(self, *arg, **kwargs):\n+        super(TimeoutWithEqual, self).__init__(*arg, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self._read == other._read and self._connect == other._connect and self.total == other.total\n+\n+class MockPoolManager(object):\n+    def __init__(self, tc):\n+        self._tc = tc\n+        self._reqs = []\n+\n+    def expect_request(self, *args, **kwargs):\n+        self._reqs.append((args, kwargs))\n+\n+    def set_signing_config(self, signing_cfg):\n+        self.signing_cfg = signing_cfg\n+        self._tc.assertIsNotNone(self.signing_cfg)\n+        self.pubkey = self.signing_cfg.get_public_key()\n+        self._tc.assertIsNotNone(self.pubkey)\n+\n+    def request(self, *args, **kwargs):\n+        self._tc.assertTrue(len(self._reqs) > 0)\n+        r = self._reqs.pop(0)\n+        self._tc.maxDiff = None\n+        # r[0] is the expected HTTP method, URL.\n+        # args is the actual HTTP method, URL.\n+        self._tc.assertEqual(r[0], args)\n+        # r[1] is a dict that contains the expected body, headers\n+        # kwargs is a dict that contains the actual body, headers", "originalCommit": "c4651cf51247ae9e3ac163c49f6a15f6eb0d7de5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjY0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r368332640", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-19T23:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzkzOA=="}], "type": "inlineReview"}, {"oid": "7b93f5477a717786d51bcecb96e19ea2a2c5b51d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b93f5477a717786d51bcecb96e19ea2a2c5b51d", "message": "Refact unit test with better variable names", "committedDate": "2020-01-19T23:31:32Z", "type": "commit"}, {"oid": "066237f18938f8e797a57fd30c189e02e5c99146", "url": "https://github.com/OpenAPITools/openapi-generator/commit/066237f18938f8e797a57fd30c189e02e5c99146", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-20T05:00:59Z", "type": "commit"}, {"oid": "34f126fb65077ecf2d23d12907158471c37fc93c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/34f126fb65077ecf2d23d12907158471c37fc93c", "message": "do not throw exception if security scheme is unrecognized", "committedDate": "2020-01-20T05:13:01Z", "type": "commit"}, {"oid": "7b3a54b277601c0c43474b99449ec8046704b800", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b3a54b277601c0c43474b99449ec8046704b800", "message": "change URL of apache license to use https", "committedDate": "2020-01-21T22:53:39Z", "type": "commit"}, {"oid": "85d13235beabd8401146259692da782a27189e81", "url": "https://github.com/OpenAPITools/openapi-generator/commit/85d13235beabd8401146259692da782a27189e81", "message": "sync from master", "committedDate": "2020-01-22T01:05:15Z", "type": "commit"}, {"oid": "6abf380a8a22badc4dae54c2ea7a07dc4b7ebe3d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6abf380a8a22badc4dae54c2ea7a07dc4b7ebe3d", "message": "sync from master", "committedDate": "2020-01-22T01:06:03Z", "type": "commit"}, {"oid": "d8b0dc65e1be4d84b628891988a4096a7e4d469a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d8b0dc65e1be4d84b628891988a4096a7e4d469a", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-22T01:06:16Z", "type": "commit"}, {"oid": "2d6516ee92457b26162778a23030f7d5c22aa6ac", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d6516ee92457b26162778a23030f7d5c22aa6ac", "message": "fix usage of escape character in python regex. Fix generated python documentation", "committedDate": "2020-01-22T18:14:01Z", "type": "commit"}, {"oid": "a14c50611555a8fc3903bd742e8197dfc5b927d9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a14c50611555a8fc3903bd742e8197dfc5b927d9", "message": "write HTTP signed headers in user-specified order. Fix PEP8 formatting issues", "committedDate": "2020-01-22T23:28:58Z", "type": "commit"}, {"oid": "a2b0c8420cfe0748ba6ad6469f590454ecf441e7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a2b0c8420cfe0748ba6ad6469f590454ecf441e7", "message": "write HTTP signed headers in user-specified order. Fix PEP8 formatting issues", "committedDate": "2020-01-22T23:36:56Z", "type": "commit"}, {"oid": "846b9ba82e7ef1672d07c11424be833244af6903", "url": "https://github.com/OpenAPITools/openapi-generator/commit/846b9ba82e7ef1672d07c11424be833244af6903", "message": "start implementation of HTTP signature", "committedDate": "2019-12-29T16:05:14Z", "type": "commit"}, {"oid": "64733bd797fd627c39fb28df9db4e54418e31833", "url": "https://github.com/OpenAPITools/openapi-generator/commit/64733bd797fd627c39fb28df9db4e54418e31833", "message": "add api key parameters for http message signature", "committedDate": "2020-01-02T19:28:50Z", "type": "commit"}, {"oid": "b151f2006ecbe621697596afba486238f3e81188", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b151f2006ecbe621697596afba486238f3e81188", "message": "HTTP signature authentication", "committedDate": "2020-01-06T04:16:40Z", "type": "commit"}, {"oid": "1cdc6ab20459e153a55874e4a83f2041799b5a18", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1cdc6ab20459e153a55874e4a83f2041799b5a18", "message": "start implementation of HTTP signature", "committedDate": "2020-01-06T17:18:46Z", "type": "commit"}, {"oid": "c2fdefa28a8f5268848e2396530730b2d8f29283", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c2fdefa28a8f5268848e2396530730b2d8f29283", "message": "add api key parameters for http message signature", "committedDate": "2020-01-06T17:18:47Z", "type": "commit"}, {"oid": "32a364767e08ab4683fba5290878fcd1143aec5f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/32a364767e08ab4683fba5290878fcd1143aec5f", "message": "HTTP signature authentication", "committedDate": "2020-01-06T17:21:16Z", "type": "commit"}, {"oid": "2d000e438a7551f85cbbee0fe0ce48ea152127ec", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d000e438a7551f85cbbee0fe0ce48ea152127ec", "message": "sync from master", "committedDate": "2020-01-06T17:22:31Z", "type": "commit"}, {"oid": "1ef838b6d77eb820d1102acd66d564674a58c610", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1ef838b6d77eb820d1102acd66d564674a58c610", "message": "HTTP signature authentication", "committedDate": "2020-01-06T17:31:23Z", "type": "commit"}, {"oid": "3246c1d705475613a5650f5b5ae2ab71dfc13a4c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3246c1d705475613a5650f5b5ae2ab71dfc13a4c", "message": "start implementation of HTTP signature", "committedDate": "2020-01-06T17:31:24Z", "type": "commit"}, {"oid": "4b33ef8a7f0b245301aa417772d3b85d65fa73cb", "url": "https://github.com/OpenAPITools/openapi-generator/commit/4b33ef8a7f0b245301aa417772d3b85d65fa73cb", "message": "fix merge issues", "committedDate": "2020-01-06T17:38:17Z", "type": "commit"}, {"oid": "52aecf8a53e27f89778f2b2690fe5f415760d87f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/52aecf8a53e27f89778f2b2690fe5f415760d87f", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-13T20:10:41Z", "type": "commit"}, {"oid": "2d63a3acc498f486259c387582a57ae3e90b812e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2d63a3acc498f486259c387582a57ae3e90b812e", "message": "Address formatting issues", "committedDate": "2020-01-13T21:13:39Z", "type": "commit"}, {"oid": "409ac382294bb62f9318cfb9044eb47c162889ca", "url": "https://github.com/OpenAPITools/openapi-generator/commit/409ac382294bb62f9318cfb9044eb47c162889ca", "message": "Address formatting issues", "committedDate": "2020-01-13T21:14:25Z", "type": "commit"}, {"oid": "2bf6f1a5a8fa121d1ec65121860f29f26bd59cee", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2bf6f1a5a8fa121d1ec65121860f29f26bd59cee", "message": "move python-experimental-openapiv3-sample to a separate PR", "committedDate": "2020-01-13T21:36:02Z", "type": "commit"}, {"oid": "d626293577ccd08a5b10b617498e30c8602f6eee", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d626293577ccd08a5b10b617498e30c8602f6eee", "message": "Add support for HTTP signature", "committedDate": "2020-01-13T21:56:13Z", "type": "commit"}, {"oid": "9eca52c65f9ba6c2c7ab0a96aa0e3c64c4600874", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9eca52c65f9ba6c2c7ab0a96aa0e3c64c4600874", "message": "Add code comments", "committedDate": "2020-01-13T22:02:50Z", "type": "commit"}, {"oid": "a59f75979a851cbbdd1a8c818bf70adb28c691d3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a59f75979a851cbbdd1a8c818bf70adb28c691d3", "message": "Add code comments", "committedDate": "2020-01-13T22:08:20Z", "type": "commit"}, {"oid": "b6e3b0cc37871ba9ffd4ae705fc09c590f84a10d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b6e3b0cc37871ba9ffd4ae705fc09c590f84a10d", "message": "merge from http-signature branch", "committedDate": "2020-01-13T22:13:16Z", "type": "commit"}, {"oid": "16c1891061fbe31be743de8688400e3dd5f67d19", "url": "https://github.com/OpenAPITools/openapi-generator/commit/16c1891061fbe31be743de8688400e3dd5f67d19", "message": "Fix formatting issues", "committedDate": "2020-01-13T22:13:24Z", "type": "commit"}, {"oid": "a1a181c177f2986d9528324527edef6a0b6f26cd", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a1a181c177f2986d9528324527edef6a0b6f26cd", "message": "Fix formatting issues", "committedDate": "2020-01-13T22:22:04Z", "type": "commit"}, {"oid": "7f1c4cfe031e5686858d30a19481949836df330a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7f1c4cfe031e5686858d30a19481949836df330a", "message": "Fix formatting issues", "committedDate": "2020-01-13T22:29:07Z", "type": "commit"}, {"oid": "9e6395fa4ec299a16e18ff895763177a21e3eb1b", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9e6395fa4ec299a16e18ff895763177a21e3eb1b", "message": "add code comments", "committedDate": "2020-01-14T00:24:03Z", "type": "commit"}, {"oid": "e5616dd246173a3acb6f55a4660f8f8c1d033224", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5616dd246173a3acb6f55a4660f8f8c1d033224", "message": "add code comments", "committedDate": "2020-01-14T00:31:51Z", "type": "commit"}, {"oid": "d8175a07b8a1cf25a365f094ed09c24cca844fdc", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d8175a07b8a1cf25a365f094ed09c24cca844fdc", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-14T16:25:31Z", "type": "commit"}, {"oid": "1b86216b8088c6fad1263a28356091a78f1c5056", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1b86216b8088c6fad1263a28356091a78f1c5056", "message": "Merge remote-tracking branch 'origin' into python-http-signature", "committedDate": "2020-01-14T16:27:52Z", "type": "commit"}, {"oid": "9fdb7ef5a7803225b17d0289600d277a2272c67e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9fdb7ef5a7803225b17d0289600d277a2272c67e", "message": "fix python formatting issues", "committedDate": "2020-01-14T17:36:23Z", "type": "commit"}, {"oid": "ae56f20eb8da4ea79206c9cd59f1c230179af5c4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ae56f20eb8da4ea79206c9cd59f1c230179af5c4", "message": "Make PKCS1v15 string constant consistent between Python and Golang", "committedDate": "2020-01-14T17:39:29Z", "type": "commit"}, {"oid": "c4c23b82cf8736781e31b7c90c395e54459e5331", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4c23b82cf8736781e31b7c90c395e54459e5331", "message": "fix python formatting issues", "committedDate": "2020-01-14T18:27:25Z", "type": "commit"}, {"oid": "8948135e982e8dfb5d0acaaf770502452b7f0300", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8948135e982e8dfb5d0acaaf770502452b7f0300", "message": "Add code comments in generated Python. Start adding unit tests for HTTP signature", "committedDate": "2020-01-14T18:54:26Z", "type": "commit"}, {"oid": "176f1305cc6d368fbfe610e857aa4c92ed76068e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/176f1305cc6d368fbfe610e857aa4c92ed76068e", "message": "compliance with HTTP signature draft 12", "committedDate": "2020-01-14T19:46:24Z", "type": "commit"}, {"oid": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "message": "compliance with HTTP signature draft 12", "committedDate": "2020-01-14T20:00:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDI3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554275", "bodyText": "Can you include the types of the list? Should it be list of str?", "author": "spacether", "createdAt": "2020-01-14T20:23:27Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NTU3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366565570", "bodyText": "Changing to:\nA list of strings. Each value is the name of a HTTP header that must be included in the HTTP signature calculation", "author": "sebastien-rosset", "createdAt": "2020-01-14T20:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDY2Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554666", "bodyText": "Should this be type bytes or string? (In Python2.7 byes creates strings)", "author": "spacether", "createdAt": "2020-01-14T20:24:19Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NjIxNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366566215", "bodyText": "Changing to:\nEach value is the name of a HTTP header that must be included in the HTTP signature calculation", "author": "sebastien-rosset", "createdAt": "2020-01-14T20:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4NzA4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366587081", "bodyText": "It is a base-64 encoded representation of the signature. I have updated code comments.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDk4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366554987", "bodyText": "What type is this? Int? Can you add the type here", "author": "spacether", "createdAt": "2020-01-14T20:25:07Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4MDkyNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366580924", "bodyText": "updated documentation", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NDk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NTQ3MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366555471", "bodyText": "How about for i, k in enumerate(signed_headers):?\nThen you don't need to create i, and we never use _ (value so no need to include it in iteration)", "author": "spacether", "createdAt": "2020-01-14T20:26:24Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzY0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366567644", "bodyText": "good suggestion.", "author": "sebastien-rosset", "createdAt": "2020-01-14T20:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NjU1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366556552", "bodyText": "Can you describe the return type?", "author": "spacether", "createdAt": "2020-01-14T20:29:01Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODgxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366568813", "bodyText": "yes, doing", "author": "sebastien-rosset", "createdAt": "2020-01-14T20:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1NjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1ODMxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366558313", "bodyText": "Why do we have 3 lines defining auth_str?\nWhy not just use this?\nauth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\"\".format(self.configuration.key_id, self.configuration.signing_scheme)", "author": "spacether", "createdAt": "2020-01-14T20:33:29Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key\n+            if key == '(created)':\n+                is_created_set = True\n+            i += 1\n+\n         auth_str = \"\"\n         auth_str = auth_str + \"Signature\"\n \n         auth_str = auth_str + \" \" + \"keyId=\\\"\" + self.configuration.key_id + \"\\\",\" + \"algorithm=\\\"\" +\n-            self.configuration.signing_scheme + \"\\\",\" + \"headers=\\\"(request-target)\"\n+            self.configuration.signing_scheme + \"\\\",\"", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTA1OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366571058", "bodyText": "simplifying, thanks.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU1ODMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDA4Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366560083", "bodyText": "Can you move this line higher than the if i > 0?\nIt is confusing because this lower line is run in the i==0 use case.\nWhat about using this?\n            headers_value += key\n            if i > 0:\n                headers_value += \" \"", "author": "spacether", "createdAt": "2020-01-14T20:37:47Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTY4NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366571684", "bodyText": "good suggestion", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDYzMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366560633", "bodyText": "Why not combine the next 3 lines and use \"blah..\".format(args) ?", "author": "spacether", "createdAt": "2020-01-14T20:39:06Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -699,23 +699,38 @@ class ApiClient(object):\n \n         return ss\n \n-    def get_authorization_header(self, hdrs, signed_msg):\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n         \"\"\"\n         Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n         \n-        :param hdrs : The list of signed HTTP Headers\n-        :param signed_msg: Signed Digest\n+        :param signed_headers : The list of signed HTTP Headers.\n+        :param signed_msg: Signed Digest.\n+        :param created_ts: The time when the signature was created, as a UNIX timestamp.\n         :return: instance of digest object \n         \"\"\"\n \n+        i = 0\n+        headers_value = \"\"\n+        is_created_set = False\n+        for key, _ in signed_headers.items():\n+            key = key.lower()\n+            if i > 0:\n+                headers_value = headers_value + \" \"\n+            headers_value = headers_value + key\n+            if key == '(created)':\n+                is_created_set = True\n+            i += 1\n+\n         auth_str = \"\"\n         auth_str = auth_str + \"Signature\"\n \n         auth_str = auth_str + \" \" + \"keyId=\\\"\" + self.configuration.key_id + \"\\\",\" + \"algorithm=\\\"\" +\n-            self.configuration.signing_scheme + \"\\\",\" + \"headers=\\\"(request-target)\"\n+            self.configuration.signing_scheme + \"\\\",\"\n+        if is_created_set:\n+            auth_str = auth_str + \"created={0},\".format(created_ts)\n+        auth_str = auth_str + \"headers=\\\"\"", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTc0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366571744", "bodyText": "yes", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MjMxNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366562317", "bodyText": "Can you move tis import to the top?\nPer pep8 imports should be at the top of the file https://www.python.org/dev/peps/pep-0008/#imports", "author": "spacether", "createdAt": "2020-01-14T20:42:49Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MjAwMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366572003", "bodyText": "yes", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MzE0Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366563142", "bodyText": "Can you add spaces around the equal sign on this line and the next line after the variable assignment?\ncdate = blah\ncreated = blah", "author": "spacether", "createdAt": "2020-01-14T20:44:45Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MjE1MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366572151", "bodyText": "yes", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MzE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2Mzg0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366563844", "bodyText": "Can you add type descriptions to these params?", "author": "spacether", "createdAt": "2020-01-14T20:46:29Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object ", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MzAzMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366573032", "bodyText": "yes, doing.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2Mzg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NTAxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366565016", "bodyText": "Can you add type descriptions to these params?\nb64encode(signature) does not return type bytes in python2.7, it returns type string", "author": "spacether", "createdAt": "2020-01-14T20:49:15Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NDM0MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366574341", "bodyText": "doing.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU5MTM0Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366591347", "bodyText": "updated description. It is actually a hashing object.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODQzNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366568434", "bodyText": "Can you turn these into a constant at the top of this module?\nSomething like:\nECDSA_KEY_SIGNING_ALGORITHMS =  {'fips-186-3', 'deterministic-rfc6979'}\nSet inclusion should be quicker than list inclusion and these values are unchanging across multiple function calls", "author": "spacether", "createdAt": "2020-01-14T20:57:29Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NTA5MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366575090", "bodyText": "doing.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODc4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366568782", "bodyText": "Can you add types to these parameter descriptions?", "author": "spacether", "createdAt": "2020-01-14T20:58:22Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object ", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3ODU5Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366578597", "bodyText": "completely removed function. It can be simplified and inline.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2ODc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTA1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366569056", "bodyText": "How about for i, (key, value) in enumerate(signed_headers.items()):?\nThen you don't need to create i and increment it", "author": "spacether", "createdAt": "2020-01-14T20:59:04Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object \n+        \"\"\"\n+        ss = \"\"\n+        i = 0\n+        for key, value in signed_headers.items():", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3ODg1OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366578858", "bodyText": "doing", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk0Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366569947", "bodyText": "Similar comment to what I say below:\nCan you move this line higher than the if i > 0?\nIt is confusing because this lower line is run in the i==0 use case.\nWhat about using this?\n            ss += \"{0}: {1}\".format(key.lower(), value)\n            if i > 0:\n                ss += \"\\n\"", "author": "spacether", "createdAt": "2020-01-14T21:00:57Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +561,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : resource path which is the api being called upon.\n+        :param method: the HTTP request method.\n+        :param headers: the request headers.\n+        :param body: body passed in the http request.\n+        :param query_params: query parameters used by the API.\n+        :return: instance of digest object \n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        from email.utils import formatdate\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate=formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created=now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = self.get_str_to_sign(signed_headers)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The message to be hashed with a cryptographic hash.\n+        :return: The message digest encoded as a byte string. \n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: digest of the HTTP message.\n+        :return: the HTTP message signature encoded as a byte string.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ['fips-186-3', 'deterministic-rfc6979']:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_str_to_sign(self, signed_headers):\n+        \"\"\"\n+        Generate and return a string value representing the HTTP request to be signed.\n+\n+        :param signed_headers: The HTTP Headers to be signed.\n+        :return: instance of digest object \n+        \"\"\"\n+        ss = \"\"\n+        i = 0\n+        for key, value in signed_headers.items():\n+            if i > 0:\n+                ss = ss + \"\\n\"\n+            ss = ss + key.lower() + \": \" + value", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3ODkyNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366578924", "bodyText": "doing.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MDg5MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366570890", "bodyText": "Do these values already exist as constants in your imported crypto libraries?\nWhy not use those constants rather than strings?", "author": "spacether", "createdAt": "2020-01-14T21:03:24Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,54 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3OTA3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366579079", "bodyText": "I am checking if they exist.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU5MzM1MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366593351", "bodyText": "I searched in the source code, it appears these strings are hard-coded. There is no constant. Marking as resolved for now.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MDg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTE3Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366571177", "bodyText": "Does this value already exist as a constant in your imported crypto libraries?\nWhy not use that constant rather than a string here?", "author": "spacether", "createdAt": "2020-01-14T21:04:07Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,54 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.", "originalCommit": "e4c0e1ae56d9a5d1fd6e9f55a467e5556b47f5fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU5MzU1NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366593554", "bodyText": "I searched in the source code, it appears these strings are hard-coded. There is no constant. Marking as resolved for now.", "author": "sebastien-rosset", "createdAt": "2020-01-14T21:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjQxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366602413", "bodyText": "Good plan", "author": "spacether", "createdAt": "2020-01-14T22:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MTE3Nw=="}], "type": "inlineReview"}, {"oid": "e4cc4df417e09266a11b2e69f570b3ffad57fe77", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e4cc4df417e09266a11b2e69f570b3ffad57fe77", "message": "working on review comments", "committedDate": "2020-01-14T21:24:55Z", "type": "commit"}, {"oid": "e5811b0d370a8fe0eb58593c00b2ed792fe2f2c8", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5811b0d370a8fe0eb58593c00b2ed792fe2f2c8", "message": "working on review comments", "committedDate": "2020-01-14T21:29:08Z", "type": "commit"}, {"oid": "916416d441d910c80fbfb570a966fa5cdf536a28", "url": "https://github.com/OpenAPITools/openapi-generator/commit/916416d441d910c80fbfb570a966fa5cdf536a28", "message": "working on review comments", "committedDate": "2020-01-14T21:36:57Z", "type": "commit"}, {"oid": "7db2a6222fbc0b0eba586fda470f6ab337b461b1", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7db2a6222fbc0b0eba586fda470f6ab337b461b1", "message": "working on review comments", "committedDate": "2020-01-14T21:51:00Z", "type": "commit"}, {"oid": "fac1af1347e914bd8ffe84317cdf177176142475", "url": "https://github.com/OpenAPITools/openapi-generator/commit/fac1af1347e914bd8ffe84317cdf177176142475", "message": "working on review comments", "committedDate": "2020-01-14T22:04:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNzcyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366607723", "bodyText": "How about refactoring lines 586 to 631 into a function called get_signed_header_info?\nAll of that code is only focused on generating those two dictionaries\nLike so:\nsigned_headers, signed_headers_dict = get_signed_header_info(body, self.configuration, method)\nThat would shorten our get_http_signature_headers and help make it more understandable.", "author": "spacether", "createdAt": "2020-01-14T22:31:42Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:", "originalCommit": "fac1af1347e914bd8ffe84317cdf177176142475", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3MTczNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366671735", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T02:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNzcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwODc2OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366608768", "bodyText": "How about we change to this?\nsigned_header_dict['Authorization'] = self.get_authorization_header(\n   signed_headers, b64_signed_msg, created)\n\nThat was we can delete the line above this too\nIt looks like we don't need the string interpolation here because our assigned value is already a string.", "author": "spacether", "createdAt": "2020-01-14T22:34:32Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)", "originalCommit": "fac1af1347e914bd8ffe84317cdf177176142475", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY2MTUyNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366661527", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T01:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwODc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMDUzNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366610537", "bodyText": "This returns a tuple of (digest, prefix) can you describe both returned params and types in this docstring?", "author": "spacether", "createdAt": "2020-01-14T22:39:14Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +566,159 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+\n+{{#hasHttpSignatureMethods}}\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers = {}\n+        signed_header_dict = {}\n+        for hdr_key in self.configuration.signed_headers:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                signed_header_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                signed_header_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                signed_header_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers[hdr_key] = value\n+\n+        if len(self.configuration.signed_headers) == 0:\n+            signed_headers['(created)'] = created\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        auth_header = self.get_authorization_header(signed_headers, b64_signed_msg, created)\n+        signed_header_dict['Authorization'] = '{0}'.format(auth_header)\n+\n+        return signed_header_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: The hashing object that contains the cryptographic digest of the HTTP request. ", "originalCommit": "fac1af1347e914bd8ffe84317cdf177176142475", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxODk2Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366618962", "bodyText": "updated documentation.", "author": "sebastien-rosset", "createdAt": "2020-01-14T23:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366615113", "bodyText": "Just a general question, not necessary to do:\nWhat do you think about moving these constants and\n\nget_http_signature_headers\nget_message_digest\nsign_digest\nget_authorization_header\nload_private_key\n\ninto a package called signing.py?\nThat way our users could use something like:\nfrom petstore_api import signing\n\n# Configure API client with HTTP signature authentication:\nconf = petstore_api.Configuration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=signing.scheme_hs2019,\n  signing_algorithm=signing.algorithm_PSS,\n  signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n)\n\nThese constants and functions seem much more related to signing than the api_client\nWhat do you think?", "author": "spacether", "createdAt": "2020-01-14T22:51:56Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -57,6 +64,10 @@ class ApiClient(object):\n     PRIMITIVE_TYPES = (\n         (float, bool, six.binary_type, six.text_type) + six.integer_types\n     )\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+", "originalCommit": "fac1af1347e914bd8ffe84317cdf177176142475", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNzI4Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366617283", "bodyText": "Sure, I can do that. Where would you commit the signing.py file in GIT? Do you mean to create a signing.mustache template that generates signing.py?", "author": "sebastien-rosset", "createdAt": "2020-01-14T22:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxOTI0OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366619249", "bodyText": "Yup it would be a signing.mustache file that we would add in the templates folder and the .java code generator", "author": "spacether", "createdAt": "2020-01-14T23:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDE4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r366620182", "bodyText": "It may make sense to only conditionally use the template if we are using hasHttpSignatureMethods", "author": "spacether", "createdAt": "2020-01-14T23:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE3MzIzNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367173234", "bodyText": "Great job creating that module! Can you mark this as resolved?", "author": "spacether", "createdAt": "2020-01-16T00:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTExMw=="}], "type": "inlineReview"}, {"oid": "e053076ac2902b65b7ccd2a5b639f9aee1138d10", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e053076ac2902b65b7ccd2a5b639f9aee1138d10", "message": "working on review comments", "committedDate": "2020-01-14T23:02:53Z", "type": "commit"}, {"oid": "2ef4815e9ebd978993822739da31a783cae19f19", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2ef4815e9ebd978993822739da31a783cae19f19", "message": "working on review comments", "committedDate": "2020-01-15T01:44:05Z", "type": "commit"}, {"oid": "a3e3c7206593da1c1747c31e0b1a25e6e7fbcce2", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a3e3c7206593da1c1747c31e0b1a25e6e7fbcce2", "message": "working on review comments", "committedDate": "2020-01-15T01:46:48Z", "type": "commit"}, {"oid": "b56e38f0c4f82d5c28b358786747bf3a9e11b12e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b56e38f0c4f82d5c28b358786747bf3a9e11b12e", "message": "working on review comments", "committedDate": "2020-01-15T02:36:23Z", "type": "commit"}, {"oid": "acfb44dadb6f50989d1c7175faf7014152609ecc", "url": "https://github.com/OpenAPITools/openapi-generator/commit/acfb44dadb6f50989d1c7175faf7014152609ecc", "message": "Merge remote-tracking branch 'origin' into http-signature", "committedDate": "2020-01-15T06:55:13Z", "type": "commit"}, {"oid": "9d81bb715f34f082ceca0f623eddf9844f2e0b7b", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9d81bb715f34f082ceca0f623eddf9844f2e0b7b", "message": "fix python formatting issues", "committedDate": "2020-01-15T14:18:05Z", "type": "commit"}, {"oid": "c4c153085d122ab88923457911c8d9411573c317", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c4c153085d122ab88923457911c8d9411573c317", "message": "fix trailing white space", "committedDate": "2020-01-15T17:30:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNjI2Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367016266", "bodyText": "Could we move lines 647 to 650 (body value checking and assignment) into get_signed_header_info?\nbody is only used in that function so handling the values and mutating it is more associated with that code.", "author": "spacether", "createdAt": "2020-01-15T17:45:35Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:", "originalCommit": "c4c153085d122ab88923457911c8d9411573c317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODQwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367018406", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T17:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNjI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODAzOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367018039", "bodyText": "Can we remove the created input argument from get_authorization_headers?\nIt is already accessible with created = signed_headers_dict['(created)'] which we can use inside get_authorization_headers.", "author": "spacether", "createdAt": "2020-01-15T17:49:08Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)", "originalCommit": "c4c153085d122ab88923457911c8d9411573c317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMTUyNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367021526", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-15T17:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODAzOQ=="}], "type": "inlineReview"}, {"oid": "c7a654e46b3750b57ad195ee0dc3033293720f06", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c7a654e46b3750b57ad195ee0dc3033293720f06", "message": "address PR comments", "committedDate": "2020-01-15T17:49:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxOTYwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367019606", "bodyText": "how about rather than using a boolean here we just use a variable which stores the created_ts?\nWe don't need to pass in created_ts because it already exists in our signed_headers dict.\nHere, we could do:\ncreated_ts = signed_headers.get('(created)')", "author": "spacether", "createdAt": "2020-01-15T17:52:28Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False", "originalCommit": "c4c153085d122ab88923457911c8d9411573c317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMjc0Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367022743", "bodyText": "done, thanks for the comments.", "author": "sebastien-rosset", "createdAt": "2020-01-15T17:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxOTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDE5Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367020196", "bodyText": "how about changing this to if created_ts is not None:?", "author": "spacether", "createdAt": "2020-01-15T17:53:41Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)\n+            key = key.lower()\n+            headers_value += key\n+            if i > 0:\n+                headers_value += \" \"\n+            if key == '(created)':\n+                is_created_set = True\n+\n+        auth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\",\"\n+            .format(self.configuration.key_id, self.configuration.signing_scheme)\n+        if is_created_set:", "originalCommit": "c4c153085d122ab88923457911c8d9411573c317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMzQwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367023407", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDE5Ng=="}], "type": "inlineReview"}, {"oid": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "message": "address PR comments", "committedDate": "2020-01-15T17:56:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMTU1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367021559", "bodyText": "How about we delete this if statement?\nIf we use the above  created_ts = signed_headers.get('(created)') then we don't need this if statement.", "author": "spacether", "createdAt": "2020-01-15T17:56:30Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,180 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg, created)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg, created_ts):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :param created_ts: The string representation of the time when the signature was created,\n+           as a UNIX timestamp value.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)\n+            key = key.lower()\n+            headers_value += key\n+            if i > 0:\n+                headers_value += \" \"\n+            if key == '(created)':", "originalCommit": "c4c153085d122ab88923457911c8d9411573c317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMzc0Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367023742", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMTU1OQ=="}], "type": "inlineReview"}, {"oid": "9c4c2fa6675e4fc397c92369ec47098d096ef5a1", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9c4c2fa6675e4fc397c92369ec47098d096ef5a1", "message": "address PR comments", "committedDate": "2020-01-15T17:58:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMzgwMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367023800", "bodyText": "Optionally how about changing this for loop into:\nlower_keys = [k.lower() for k in signed_headers]\nheaders_value = \" \".join(lower_keys)\n\nThat will save us two lines", "author": "spacether", "createdAt": "2020-01-15T18:01:22Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,179 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        is_created_set = False\n+        for i, key in enumerate(signed_headers)", "originalCommit": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjEyNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367036124", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNTM2Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367025367", "bodyText": "How about changing this to something like?\nheader_items = [\"{0}: {1}\".format(k.lower(), v) for k, v in signed_headers_dict.items()]\nstring_to_sign = \"\\n\".join(header_items)\n\nThat saves us 3 lines", "author": "spacether", "createdAt": "2020-01-15T18:04:55Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -542,3 +569,179 @@ class ApiClient(object):\n                     raise ApiValueError(\n                         'Authentication token must be in `query` or `header`'\n                     )\n+{{#hasHttpSignatureMethods}}\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        string_to_sign = \"\"\n+        for i, (key, value) in enumerate(signed_headers_dict.items()):\n+            string_to_sign += \"{0}: {1}\".format(key.lower(), value)\n+            if i > 0:\n+                string_to_sign += \"\\n\"", "originalCommit": "9b9d272ec7cff74b1fcb3c4d52e02a2e0d562cca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjAxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367036013", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNTM2Nw=="}], "type": "inlineReview"}, {"oid": "08557f48118f9972e4493dc73437cae66ac37dc8", "url": "https://github.com/OpenAPITools/openapi-generator/commit/08557f48118f9972e4493dc73437cae66ac37dc8", "message": "Add suppport for '(expires)' signature parameter", "committedDate": "2020-01-15T18:24:42Z", "type": "commit"}, {"oid": "2eb626406ec9c8e539807b089987099f985a0269", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2eb626406ec9c8e539807b089987099f985a0269", "message": "address PR comments", "committedDate": "2020-01-15T18:28:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNzEwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367037107", "bodyText": "Can you also add the condition self.signature_max_validity is None into this if statement?\nThen you can delete the inner if statement and just raise the exception.", "author": "spacether", "createdAt": "2020-01-15T18:30:04Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -121,6 +126,17 @@ class Configuration(object):\n            For RSA keys, supported values are PKCS1v15, PSS.\n            For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n         \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if signed_headers is not None and '(expires)' in signed_headers:", "originalCommit": "08557f48118f9972e4493dc73437cae66ac37dc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzI0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367047244", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNzEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367038113", "bodyText": "Would it be simpler to require that a set is passed in for signed_headers?\nThen we can remove this if statement.\nDo the signed_headers need to be in a specific order?", "author": "spacether", "createdAt": "2020-01-15T18:32:13Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -121,6 +126,17 @@ class Configuration(object):\n            For RSA keys, supported values are PKCS1v15, PSS.\n            For ECDSA keys, supported values are fips-186-3, deterministic-rfc6979.\n         \"\"\"\n+        if signature_max_validity is not None and signature_max_validity.total_seconds() < 0:\n+            raise Exception(\"The signature max validity must be a positive value\")\n+        self.signature_max_validity = signature_max_validity\n+        \"\"\"The signature max validity, expressed as a datetime.timedelta value.\n+        It must be a positive value.\n+        \"\"\"\n+        if signed_headers is not None and '(expires)' in signed_headers:\n+            if self.signature_max_validity is None:\n+                raise Exception(\"Signature max validity must be set when '(expires)' signature parameter is specified\")\n+        if len(signed_headers) != len(set(signed_headers)):", "originalCommit": "08557f48118f9972e4493dc73437cae66ac37dc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ4Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367042483", "bodyText": "Here is what the spec states:\nThe list order is important, and MUST be specified in the order\nthe HTTP header field-value pairs are concatenated together\nduring Signature String Construction (Section 2.3) used during\nsigning and verifying.\n\nIt is crucial to have an ordered list on the wire. This is required to properly generate the signature. That being said, in principle, the Python client could provide an unordered list (as well as any other programming language - I am also working on golang), as long as the implementation ensures the signature is properly generated. But I don't like this very much because on the wire, the list of signed headers will not be deterministic.\nNot having a deterministic list of signed headers can be frustrating when you are trying to troubleshoot the protocol.", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NTU1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367045559", "bodyText": "That's good to know. Thank you for including that spec information.\nCan you add code to enforce that with either of the below options?\n\nrequire that that a list with the correct order is passed in\npass in a set and select items in the correct order by iterating over an ordered list of keys when doing fancy signing things (this seems like an easier use case for our users)", "author": "spacether", "createdAt": "2020-01-15T18:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Nzk5Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367047992", "bodyText": "Sorry, I'm not sure I understand what you are asking.", "author": "sebastien-rosset", "createdAt": "2020-01-15T18:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTM4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367051381", "bodyText": "Right now a user could pass in a signed_headers list with items in the wrong order and our code would generate our signed string in the wrong order.\nIs that true?\nIf so then I would like to add code which ensures that we generate the signed string using the correct order. We could do that with either of these two solutions:\n\nrequire that that the items in the input signed_headers list are in the correct order\nhave our users pass in a set of signed_headers and convert it into a list which is ordered correctly inside our function", "author": "spacether", "createdAt": "2020-01-15T19:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1NTAyNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367055024", "bodyText": "Right now a user could pass in a signed_headers list with items in the wrong order and our code would generate our signed string in the wrong order.\nIs that true?\n\nNo. The order is important because basically the algorithm works as follows (simplified):\n\nConcatenate headers: (H1 + H2 + ... + Hn)\nCalculate cryptographic digest of above string\nSign digest with private key.\n\nThe digest would be totally different if the order was different, and the client and server would not be able to agree on the signature validation.\nThe user may have a reason to put the list signed headers in a specific order. It's a weak argument, but certainly it helps when you are troubleshooting a problem between a client and a server. On the server side, you may not have control over the client implementation, but it helps to have easily reproducible conditions.\n\nIf so then I would like to add code which ensures that we generate the signed string using the correct order. We could do that with either of these two solutions:\n\nrequire that that the items in the input signed_headers list are in the correct order\nhave our users pass in a set of signed_headers and convert it into a list which is ordered correctly inside our function\n\n\nThere isn't a \"correct\" order of the headers. It's up to the client to decide what is the order of the headers, send the ordered list to the server, and also generate a signature based on that specific order. Everything needs to match.\nFor example, you can generate a valid signature with the following headers:\n[(created), Content-Type, Content-Length, Host, From]\nYou can reorder the list and still create a valid signature, e.g.:\n[Content-Type, Content-Length, (created), Host, From]\nBut from a troubleshooting perspective, it could be really annoying if the order of headers keep changing.", "author": "sebastien-rosset", "createdAt": "2020-01-15T19:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTgxOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367059819", "bodyText": "Ah, I understand now. Thank you for explaining that. So the client needs to be able to set the order and there is no correct order to use. We are all set here then. Feel free to mark this conversation as resolved.", "author": "spacether", "createdAt": "2020-01-15T19:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzODExMw=="}], "type": "inlineReview"}, {"oid": "976b55b93009c6cdcdd71b8aa28597ff3cbe98a4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/976b55b93009c6cdcdd71b8aa28597ff3cbe98a4", "message": "address PR comments", "committedDate": "2020-01-15T18:52:19Z", "type": "commit"}, {"oid": "05e60696f69f17e354062d7d1ab6534ce076d357", "url": "https://github.com/OpenAPITools/openapi-generator/commit/05e60696f69f17e354062d7d1ab6534ce076d357", "message": "Fix python formatting issues", "committedDate": "2020-01-15T19:20:48Z", "type": "commit"}, {"oid": "dc5539122eb8aee30cc376119e2de463baf5b81e", "url": "https://github.com/OpenAPITools/openapi-generator/commit/dc5539122eb8aee30cc376119e2de463baf5b81e", "message": "Fix python formatting issues", "committedDate": "2020-01-15T19:23:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MjE5Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367062197", "bodyText": "If we create the signing.py module, it would also be helpful if we could move this function (load_private_key) into it\nThat way all of our signing code would be in one place\nAgain we would need to conditionally include the from petstore_api import signing import up top", "author": "spacether", "createdAt": "2020-01-15T19:24:55Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -301,6 +400,29 @@ class Configuration(object):\n {{/isOAuth}}\n {{/authMethods}}\n         }\n+{{#hasHttpSignatureMethods}}\n+\n+    def load_private_key(self):\n+        \"\"\"Load the private key used to sign HTTP requests.\n+           The private key is used to sign HTTP requests as defined in\n+           https://datatracker.ietf.org/doc/draft-cavage-http-signatures/.\n+        \"\"\"\n+        if self.private_key is not None:\n+            return\n+        with open(self.private_key_path, \"rb\") as f:\n+            # Decode PEM file and determine key type from PEM header.\n+            # Supported values are \"RSA PRIVATE KEY\" and \"ECDSA PRIVATE KEY\".\n+            keys = pem.parse(f.read())\n+            if len(keys) != 1:\n+                raise Exception(\"File must contain exactly one private key\")\n+            key = keys[0].as_text()\n+            if key.startswith(\"-----BEGIN RSA PRIVATE KEY-----\"):\n+                self.private_key = RSA.importKey(key)\n+            elif key.startswith(\"-----BEGIN EC PRIVATE KEY-----\"):\n+                self.private_key = ECC.importKey(key)\n+            else:\n+                raise Exception(\"Unsupported key\")\n+{{/hasHttpSignatureMethods}}", "originalCommit": "05e60696f69f17e354062d7d1ab6534ce076d357", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2ODQ5Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367068492", "bodyText": "sure. I'm starting to move the code to a signing.mustache file.", "author": "sebastien-rosset", "createdAt": "2020-01-15T19:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MjE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEwMTE0Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367101142", "bodyText": "What is the right way to determine if hasHttpSignatureMethods is set in the Java code?\n\nSee https://github.com/OpenAPITools/openapi-generator/pull/4958/files#diff-bd1652e990ffe227072a5c8908fd3054R854\nI'm not sure what's the right way to conditionally generate a template.", "author": "sebastien-rosset", "createdAt": "2020-01-15T20:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MjE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEwNDgwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367104809", "bodyText": "I added a comment in PythonClientExperimental.java on how we can do this", "author": "spacether", "createdAt": "2020-01-15T21:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MjE5Nw=="}], "type": "inlineReview"}, {"oid": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/959178a63fbe713196a6703e2774c6a8d5cfd2c4", "message": "Starting to move code to dedicated file for HTTP signatures", "committedDate": "2020-01-15T19:37:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3Mzc1Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367073753", "bodyText": "Why not pass in configuration here?\nThen you can delete the parent class and make these all functions.\nThe other functions would also need to accept a configuration input argument", "author": "spacether", "createdAt": "2020-01-15T19:49:52Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):\n+        if configuration is None:\n+            raise Exception(\"Configuration must be specified\")\n+        self.configuration = configuration\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+        if self.configuration.signature_max_validity is not None:\n+            expires = (now + self.configuration.signature_max_validity).strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == '(expires)':\n+                value = expires\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):", "originalCommit": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMjI2OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367112268", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3Mzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NDIxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367074213", "bodyText": "How about deleting this class?\nWe only use it to store the configuration object which could be passed in to get_http_signature_headers.", "author": "spacether", "createdAt": "2020-01-15T19:50:51Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):", "originalCommit": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMjEyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367112123", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NDIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NTc1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367075757", "bodyText": "How about setting these parameters as module constants?\nhow about naming them with prefixes like SCHEME_ and ALGORITHM_\nThat way our users could use magic string constants like so, and not have to worry about typing quotes:\nfrom petstore_api import signing\n\n# Configure API client with HTTP signature authentication:\nconf = petstore_api.Configuration(\n  key_id='my-key-id',\n  private_key_path='rsa.pem',\n  signing_scheme=signing.SCHEME_HS2019,\n  signing_algorithm=signing.ALGORITHM_PSS,\n  signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n)", "author": "spacether", "createdAt": "2020-01-15T19:54:09Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}", "originalCommit": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NzMwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367077309", "bodyText": "How do you feel about making constants for the headers too, like:\nHEADER_REQUEST_TARGET = '(request-target)'\nHEADER_CREATED = '(created)'\nHEADER_HOST = 'host'\nHEADER_DATE = 'date'\nHEADER_CONTENT_TYPE = 'Content-Type'\nHEADER_DIGEST = 'Digest'\n\nThat way we could use them in this module, and our users could use them when passing in signed headers with:\nsigned_headers = [\n  signing.HEADER_REQUEST_TARGET,\n  signing.HEADER_CREATED,\n  signing.HEADER_HOST,\n  signing.HEADER_DATE,\n  signing.HEADER_CONTENT_TYPE,\n  signing.HEADER_DIGEST]", "author": "spacether", "createdAt": "2020-01-15T19:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMTk5NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367111994", "bodyText": "done.", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MDEzNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367080136", "bodyText": "This module should only be included if this signature method is used.\nSo we can enable/disable the inclusion of this module in the Java code.\nBecause the Java will handle it, can you delete this hasHttpSignatureMethods mustache tag?", "author": "spacether", "createdAt": "2020-01-15T20:03:50Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/signing.mustache", "diffHunk": "@@ -0,0 +1,204 @@\n+{{#hasHttpSignatureMethods}}\n+# coding: utf-8\n+{{>partial_header}}\n+from __future__ import absolute_import\n+\n+from six.moves.urllib.parse import urlencode, urlparse\n+from Crypto.PublicKey import RSA, ECC\n+from Crypto.Signature import PKCS1_v1_5, pss, DSS\n+from Crypto.Hash import SHA256, SHA512\n+from base64 import b64encode\n+from email.utils import formatdate\n+\n+class HttpSignatureHandler(object):\n+    \"\"\"OpenAPI HTTP signature handler to generate and verify HTTP signatures.\n+\n+    NOTE: This class is auto generated by OpenAPI Generator.\n+    Ref: https://openapi-generator.tech\n+    Do not edit the class manually.\n+\n+    :param configuration: .Configuration object for this client\n+    \"\"\"\n+\n+    ECDSA_MODE_FIPS_186_3 = 'fips-186-3'\n+    ECDSA_MODE_DETERMINISTIC_RFC6979 = 'deterministic-rfc6979'\n+    ECDSA_KEY_SIGNING_ALGORITHMS = {ECDSA_MODE_FIPS_186_3, ECDSA_MODE_DETERMINISTIC_RFC6979}\n+\n+    def __init__(self, configuration=None):\n+        if configuration is None:\n+            raise Exception(\"Configuration must be specified\")\n+        self.configuration = configuration\n+\n+    def get_signed_header_info(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Build the HTTP headers (name, value) that need to be included in the HTTP signature scheme.\n+\n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A tuple containing two dict objects:\n+            The first dict contains the HTTP headers that are used to calculate the HTTP signature.\n+            The second dict contains the HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+\n+        if body is None:\n+            body = ''\n+        else:\n+            body = json.dumps(body)\n+\n+        # Build the '(request-target)' HTTP signature parameter.\n+        target_host = urlparse(self.configuration.host).netloc\n+        target_path = urlparse(self.configuration.host).path\n+        request_target = method.lower() + \" \" + target_path + resource_path\n+        if query_params:\n+            raw_query = urlencode(query_params).replace('+', '%20')\n+            request_target += \"?\" + raw_query\n+\n+        # Get current time and generate RFC 1123 (HTTP/1.1) date/time string.\n+        now = datetime.datetime.now()\n+        stamp = mktime(now.timetuple())\n+        cdate = formatdate(timeval=stamp, localtime=False, usegmt=True)\n+        created = now.strftime(\"%s\")\n+        if self.configuration.signature_max_validity is not None:\n+            expires = (now + self.configuration.signature_max_validity).strftime(\"%s\")\n+\n+        signed_headers_dict = {}\n+        request_headers_dict = {}\n+        for hdr_key in self.configuration.signed_headers_dict:\n+            hdr_key = hdr_key.lower()\n+            if hdr_key == '(request-target)':\n+                value = request_target\n+            elif hdr_key == '(created)':\n+                value = created\n+            elif hdr_key == '(expires)':\n+                value = expires\n+            elif hdr_key == 'date':\n+                value = cdate\n+                request_headers_dict['Date'] = '{0}'.format(cdate)\n+            elif hdr_key == 'digest':\n+                request_body = body.encode()\n+                body_digest, digest_prefix = self.get_message_digest(request_body)\n+                b64_body_digest = b64encode(body_digest.digest())\n+                value = digest_prefix + b64_body_digest.decode('ascii')\n+                request_headers_dict['Digest'] = '{0}{1}'.format(digest_prefix, b64_body_digest.decode('ascii'))\n+            elif hdr_key == 'host':\n+                value = target_host\n+                request_headers_dict['Host'] = '{0}'.format(target_host)\n+            else:\n+                value = headers[hdr_key]\n+            signed_headers_dict[hdr_key] = value\n+\n+        # If the user has not provided any signed_headers, the default must be set to '(created)'.\n+        if len(self.configuration.signed_headers_dict) == 0:\n+            signed_headers_dict['(created)'] = created\n+\n+        return signed_header_dict, request_headers_dict\n+\n+    def get_http_signature_headers(self, resource_path, method, headers, body, query_params):\n+        \"\"\"\n+        Create a cryptographic message signature for the HTTP request and add the signed headers.\n+        \n+        :param resource_path : A string representation of the HTTP request resource path.\n+        :param method: A string representation of the HTTP request method, e.g. GET, POST.\n+        :param headers: A dict containing the HTTP request headers.\n+        :param body: The string representation of the HTTP request body.\n+        :param query_params: A string representing the HTTP request query parameters.\n+        :return: A dict of HTTP headers that must be added to the outbound HTTP request.\n+        \"\"\"\n+        if method is None:\n+            raise Exception(\"HTTP method must be set\")\n+        if resource_path is None:\n+            raise Exception(\"Resource path must be set\")\n+\n+        signed_headers_dict, request_headers_dict = self.get_signed_header_info(self,\n+            resource_path, method, headers, body, query_params)\n+\n+        header_items = [\"{0}: {1}\".format(key.lower(), value) for key, value in signed_headers_dict.items()]\n+        string_to_sign = \"\\n\".join(header_items)\n+\n+        digest, digest_prefix = self.get_message_digest(string_to_sign.encode())\n+        b64_signed_msg = self.sign_digest(digest)\n+\n+        request_headers_dict['Authorization'] = self.get_authorization_header(\n+            signed_headers_dict, b64_signed_msg)\n+\n+        return request_headers_dict\n+\n+    def get_message_digest(self, data):\n+        \"\"\"\n+        Calculates and returns a cryptographic digest of a specified HTTP request.\n+\n+        :param data: The string representation of the date to be hashed with a cryptographic hash.\n+        :return: A tuple of (digest, prefix).\n+          The digest is a hashing object that contains the cryptographic digest of the HTTP request.\n+          The prefix is a string that identifies the cryptographc hash. It is used to generate the\n+          'Digest' header as specified in RFC 3230.\n+        \"\"\"\n+        if self.configuration.signing_scheme in [\"rsa-sha512\", \"hs2019\"]:\n+            digest = SHA512.new()\n+            prefix = \"SHA-512=\"\n+        elif self.configuration.signing_scheme in [\"rsa-sha256\"]:\n+            digest = SHA256.new()\n+            prefix = \"SHA-256=\"\n+        else:\n+            raise Exception(\n+                \"Unsupported signing algorithm: {0}\".format(self.configuration.signing_scheme))\n+        digest.update(data)\n+        return digest, prefix\n+\n+    def sign_digest(self, digest):\n+        \"\"\"\n+        Signs a message digest with a private key specified in the configuration.\n+\n+        :param digest: A hashing object that contains the cryptographic digest of the HTTP request.\n+        :return: A base-64 string representing the cryptographic signature of the input digest.\n+        \"\"\"\n+        self.configuration.load_private_key()\n+        privkey = self.configuration.private_key\n+        if isinstance(privkey, RSA.RsaKey):\n+            if self.configuration.signing_algorithm == 'PSS':\n+                # RSASSA-PSS in Section 8.1 of RFC8017.\n+                signature = pss.new(privkey).sign(digest)\n+            elif self.configuration.signing_algorithm == 'PKCS1v15':\n+                # RSASSA-PKCS1-v1_5 in Section 8.2 of RFC8017.\n+                signature = PKCS1_v1_5.new(privkey).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        elif isinstance(privkey, ECC.EccKey):\n+            if self.configuration.signing_algorithm in ECDSA_KEY_SIGNING_ALGORITHMS:\n+                signature = DSS.new(privkey, self.configuration.signing_algorithm).sign(digest)\n+            else:\n+                raise Exception(\"Unsupported signature algorithm: {0}\".format(self.configuration.signing_algorithm))\n+        else:\n+            raise Exception(\"Unsupported private key: {0}\".format(type(privkey)))\n+        return b64encode(signature)\n+\n+    def get_authorization_header(self, signed_headers, signed_msg):\n+        \"\"\"\n+        Calculates and returns the value of the 'Authorization' header when signing HTTP requests.\n+        \n+        :param signed_headers : A list of strings. Each value is the name of a HTTP header that\n+           must be included in the HTTP signature calculation.\n+        :param signed_msg: A base-64 encoded string representation of the signature.\n+        :return: The string value of the 'Authorization' header, representing the signature\n+           of the HTTP request.\n+        \"\"\"\n+\n+        headers_value = \"\"\n+        created_ts = signed_headers.get('(created)')\n+        expires_ts = signed_headers.get('(expires)')\n+        lower_keys = [k.lower() for k in signed_headers]\n+        headers_value = \" \".join(lower_keys)\n+\n+        auth_str = \"Signature keyId=\\\"{0}\\\",algorithm=\\\"{1}\\\",\"\n+            .format(self.configuration.key_id, self.configuration.signing_scheme)\n+        if created_ts is not None:\n+            auth_str = auth_str + \"created={0},\".format(created_ts)\n+        if expires_ts is not None:\n+            auth_str = auth_str + \"expires={0},\".format(expires_ts)\n+        auth_str = auth_str + \"headers=\\\"{0}\\\",signature=\\\"{1}\\\"\"\n+            .format(headers_value, signed_msg.decode('ascii'))\n+        return auth_str\n+{{/hasHttpSignatureMethods}}", "originalCommit": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMTc0NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367111745", "bodyText": "done", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367092362", "bodyText": "It may be time to separate these into separate dict inputs with None defaults.\nWe are up to 11 non-self arguments.\n@sebastien-rosset what do you think?\nHow about something like:\n__init__(self, host=\"{{{basePath}}}\", api_key_info=None, basic_auth_info=None, signing_info=None)\n\napi_key_info:\n\nkey\nprefix\n\n\nbasic_auth_info\n\nusername\npassword\n\n\nsigning_info\n\nkey_id\nprivate_key_path\nscheme\nalgorithm\nmax_validity\nheaders", "author": "spacether", "createdAt": "2020-01-15T20:32:10Z", "path": "modules/openapi-generator/src/main/resources/python/configuration.mustache", "diffHunk": "@@ -26,11 +30,59 @@ class Configuration(object):\n     :param api_key_prefix: Dict to store API prefix (e.g. Bearer)\n     :param username: Username for HTTP basic authentication\n     :param password: Password for HTTP basic authentication\n+    :param key_id: The identifier of the cryptographic key, when signing HTTP requests.\n+        An 'Authorization' header is calculated by creating a hash of select headers,\n+        and optionally the body of the HTTP request, then signing the hash value using\n+        a private key which is available to the client.\n+    :param private_key_path: The path of the file containing a private key,\n+        when signing HTTP requests.\n+    :param signing_scheme: The signature scheme, when signing HTTP requests.\n+        Supported value is hs2019.\n+    :param signing_algorithm: The signature algorithm, when signing HTTP requests.\n+        Supported values are PKCS1v15, PSS; fips-186-3, deterministic-rfc6979.\n+    :param signature_max_validity: The signature max validity,\n+        expressed as a datetime.timedelta value.\n+    :param signed_headers: A list of strings. Each value is the name of a HTTP header\n+        that must be included in the HTTP signature calculation.\n+        The two special signature headers '(request-target)' and '(created)' SHOULD be\n+        included in SignedHeaders.\n+        The '(created)' header expresses when the signature was created.\n+        The '(request-target)' header is a concatenation of the lowercased :method, an\n+        ASCII space, and the :path pseudo-headers.\n+        When signed_headers is not specified, the client defaults to a single value,\n+        '(created)', in the list of HTTP headers.\n+        When SignedHeaders contains the 'Digest' value, the client performs the\n+        following operations:\n+        1. Calculate a digest of request body, as specified in RFC3230, section 4.3.2.\n+        2. Set the 'Digest' header in the request body.\n+        3. Include the 'Digest' header and value in the HTTP signature.\n+\n+    :Example:\n+\n+    Configure API client with HTTP basic authentication:\n+      conf = {{{packageName}}}.Configuration(\n+          username='the-user',\n+          password='the-password',\n+      )\n+\n+    Configure API client with HTTP signature authentication. Use the 'hs2019' signature scheme,\n+    sign the HTTP requests with the RSA-SSA-PSS signature algorithm, and set the expiration time\n+    of the signature to 5 minutes after the signature has been created.\n+      conf = {{{packageName}}}.Configuration(\n+        key_id='my-key-id',\n+        private_key_path='rsa.pem',\n+        signing_scheme='hs2019',\n+        signing_algorithm='PSS',\n+        signed_headers=['(request-target)', '(created)', 'host', 'date', 'Content-Type', 'Digest']\n+        signature_max_validity=timedelta(minutes=5),\n+      )\n     \"\"\"\n \n     def __init__(self, host=\"{{{basePath}}}\",\n                  api_key=None, api_key_prefix=None,\n-                 username=\"\", password=\"\"):\n+                 username=\"\", password=\"\",\n+                 key_id=None, private_key_path=None, signing_scheme=None,\n+                 signing_algorithm=None, signature_max_validity=None, signed_headers=None):", "originalCommit": "959178a63fbe713196a6703e2774c6a8d5cfd2c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxODIyMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367218222", "bodyText": "I think I'll do that for signing info, but I'd rather keep the others as is, I'm concerned the breaking change will cause acceptance issues.", "author": "sebastien-rosset", "createdAt": "2020-01-16T03:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNDU1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367224552", "bodyText": "Good catch, thanks. I keep thinking that these changes are for python-experimental, but this one is for python + python-experimental. Splitting out signing_info will help us here.\nIf we want to be aggressive we could make a separate template for python-experimental and switch to using the above 3 dicts. But that's probably best kept as work for another day in a future PR. What do you think?", "author": "spacether", "createdAt": "2020-01-16T04:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0Mzc3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367243770", "bodyText": "Yes, I was thinking this could be done as a separate PR. It's already big enough, and I am worried it's going to stay in limbo state for a while.", "author": "sebastien-rosset", "createdAt": "2020-01-16T06:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2Mg=="}], "type": "inlineReview"}, {"oid": "277e48978c58712538cec73939bae8efc9fca4f1", "url": "https://github.com/OpenAPITools/openapi-generator/commit/277e48978c58712538cec73939bae8efc9fca4f1", "message": "Continue to refactor code to dedicated file for HTTP signatures", "committedDate": "2020-01-15T20:44:44Z", "type": "commit"}, {"oid": "7fb18e2e0c33a60fc6b760f2e202d0bce1a50dd3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7fb18e2e0c33a60fc6b760f2e202d0bce1a50dd3", "message": "Continue to refactor code to dedicated file for HTTP signatures", "committedDate": "2020-01-15T20:57:00Z", "type": "commit"}, {"oid": "071316439675ee55efb3682ecd2e7d666a52cd94", "url": "https://github.com/OpenAPITools/openapi-generator/commit/071316439675ee55efb3682ecd2e7d666a52cd94", "message": "Continue to refactor code to dedicated file for HTTP signatures", "committedDate": "2020-01-15T21:17:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367118141", "bodyText": "Per my debugging in InteliJ fullAuthmethods doesn't exist yet.\nthis.OpenAPI (the spec does)\nHow about using this?\n        Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;\n        List<CodegenSecurity> authMethods = fromSecurity(securitySchemeMap);\n        if (hasHttpSignatureMethods(authMethods)) {\n            supportingFiles.add(new SupportingFile(\"python-experimental/signing.mustache\", packagePath(), \"signing.py\"));\n        }", "author": "spacether", "createdAt": "2020-01-15T21:32:35Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -82,6 +82,9 @@ public PythonClientExperimentalCodegen() {\n \n         apiTemplateFiles.remove(\"api.mustache\");\n         apiTemplateFiles.put(\"python-experimental/api.mustache\", \".py\");\n+        if (hasHttpSignatureMethods(this.fullAuthMethods)) {", "originalCommit": "071316439675ee55efb3682ecd2e7d666a52cd94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMzU5MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367123591", "bodyText": "For the record I don't know when we should use supportingFiles.add vs apiTemplateFiles.put\nIt looks like supportingFiles.add is used more for conditional file additions, so maybe we should\n\nuse supportingFiles.add(..\nmove the above if statement into which uses supportingFiles.add(.. into the processOpts method\nWhat do you think?", "author": "spacether", "createdAt": "2020-01-15T21:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNTE2OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367125168", "bodyText": "yes, that's what I'm trying to do. For some reason the compiler cannot find the config symbol. I'll keep looking.", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNTY1NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367125654", "bodyText": "Ah config is where you are. Just delete it. It should be fromSecurity(securitySchemeMap)\nI just updated my suggested code sample", "author": "spacether", "createdAt": "2020-01-15T21:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNzkxMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367127911", "bodyText": "oh I just realized there are two distinct classes, DefaultGenerator and DefaultCodeGen...\nPythonClientExperimentalCodegen extends from DefaultCodeGen, not DefaultGenerator, and config is defined in DefaultGenerator.\nNow I can make it work, though hasHttpSignatureMethods() is not accessible from PythonClientExperimentalCodegen, but there is an easy workaround.", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyOTk4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367129982", "bodyText": "Sounds good", "author": "spacether", "createdAt": "2020-01-15T22:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNzA4NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367137085", "bodyText": "It looks like putting\nhasHttpSignatureMethods\nin modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ProcessUtils.java\nwould work because both classes can use it.", "author": "spacether", "createdAt": "2020-01-15T22:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MDU3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367140579", "bodyText": "I have a basic question. When the constructor is invoked, has the OAS spec been parsed? Isn't it done later? Because I'm seeing a NPE and wonder if this is because the OAS spec hasn't been parsed yet, hence codegen wouldn't know what the security schemes are in the constructor.", "author": "sebastien-rosset", "createdAt": "2020-01-15T22:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NDY1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367144652", "bodyText": "The spec is parsed, I am seeing the above code successfully generate authMethods:\nauthMethods = {ArrayList@2705}  size = 5\n 0 = {CodegenSecurity@2714} \"CodegenSecurity{name='api_key', type='apiKey', scheme='null', hasMore=true, isBasic=false, isOAuth=false, isApiKey=true, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='api_key', isKeyInQuery=false, isKeyInHeader=true, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 1 = {CodegenSecurity@2715} \"CodegenSecurity{name='api_key_query', type='apiKey', scheme='null', hasMore=true, isBasic=false, isOAuth=false, isApiKey=true, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='api_key_query', isKeyInQuery=true, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 2 = {CodegenSecurity@2716} \"CodegenSecurity{name='bearer_test', type='http', scheme='bearer', hasMore=true, isBasic=true, isOAuth=false, isApiKey=false, isBasicBasic=false, isBasicBearer=true, bearerFormat='JWT', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 3 = {CodegenSecurity@2717} \"CodegenSecurity{name='http_basic_test', type='http', scheme='basic', hasMore=true, isBasic=true, isOAuth=false, isApiKey=false, isBasicBasic=true, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 4 = {CodegenSecurity@2718} \"CodegenSecurity{name='petstore_auth', type='oauth2', scheme='null', hasMore=false, isBasic=false, isOAuth=true, isApiKey=false, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='implicit', authorizationUrl='http://petstore.swagger.io/api/oauth/dialog', tokenUrl='null', scopes=[{scope=write:pets, hasMore=true, description=modify pets in your account}, {scope=read:pets, hasMore=null, description=read your pets}], isCode=false, isPassword=false, isApplication=false, isImplicit=true}\"\n\nAre you invoking it inside processOpts?", "author": "spacether", "createdAt": "2020-01-15T22:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NjEzOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367156139", "bodyText": "The spec is parsed, I am seeing the above code successfully generate authMethods:\nauthMethods = {ArrayList@2705}  size = 5\n 0 = {CodegenSecurity@2714} \"CodegenSecurity{name='api_key', type='apiKey', scheme='null', hasMore=true, isBasic=false, isOAuth=false, isApiKey=true, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='api_key', isKeyInQuery=false, isKeyInHeader=true, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 1 = {CodegenSecurity@2715} \"CodegenSecurity{name='api_key_query', type='apiKey', scheme='null', hasMore=true, isBasic=false, isOAuth=false, isApiKey=true, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='api_key_query', isKeyInQuery=true, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 2 = {CodegenSecurity@2716} \"CodegenSecurity{name='bearer_test', type='http', scheme='bearer', hasMore=true, isBasic=true, isOAuth=false, isApiKey=false, isBasicBasic=false, isBasicBearer=true, bearerFormat='JWT', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 3 = {CodegenSecurity@2717} \"CodegenSecurity{name='http_basic_test', type='http', scheme='basic', hasMore=true, isBasic=true, isOAuth=false, isApiKey=false, isBasicBasic=true, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='null', authorizationUrl='null', tokenUrl='null', scopes=null, isCode=false, isPassword=false, isApplication=false, isImplicit=false}\"\n 4 = {CodegenSecurity@2718} \"CodegenSecurity{name='petstore_auth', type='oauth2', scheme='null', hasMore=false, isBasic=false, isOAuth=true, isApiKey=false, isBasicBasic=false, isBasicBearer=false, bearerFormat='null', vendorExtensions={}, keyParamName='null', isKeyInQuery=false, isKeyInHeader=false, isKeyInCookie=false, flow='implicit', authorizationUrl='http://petstore.swagger.io/api/oauth/dialog', tokenUrl='null', scopes=[{scope=write:pets, hasMore=true, description=modify pets in your account}, {scope=read:pets, hasMore=null, description=read your pets}], isCode=false, isPassword=false, isApplication=false, isImplicit=true}\"\n\nAre you invoking it inside processOpts?\n\nno, from the constructor. There are a few test cases when the \"openAPI\" field is null, so I have to test for that too.", "author": "sebastien-rosset", "createdAt": "2020-01-15T23:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNDY4MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367224680", "bodyText": "Can you mark this as resolved?", "author": "spacether", "createdAt": "2020-01-16T04:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExODE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDEyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367120129", "bodyText": "Can you change this to:\nfrom {{packageName}} import signing \nand move it down in between the rest and Configuration imports?", "author": "spacether", "createdAt": "2020-01-15T21:37:23Z", "path": "modules/openapi-generator/src/main/resources/python/python-experimental/api_client.mustache", "diffHunk": "@@ -13,6 +13,9 @@ from six.moves.urllib.parse import quote\n {{#tornado}}\n import tornado.gen\n {{/tornado}}\n+{{#hasHttpSignatureMethods}}\n+import signing", "originalCommit": "277e48978c58712538cec73939bae8efc9fca4f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNDcyNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367124727", "bodyText": "sure. With the {{#hasHttpSignatureMethods}}, right?", "author": "sebastien-rosset", "createdAt": "2020-01-15T21:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNjcwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367126706", "bodyText": "Yup, we need to keep the tag with it", "author": "spacether", "createdAt": "2020-01-15T21:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDEyOQ=="}], "type": "inlineReview"}, {"oid": "719146d165cb10b8ad9b32a82c34e929c41ed6d3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/719146d165cb10b8ad9b32a82c34e929c41ed6d3", "message": "Continue to refactor code to dedicated file for HTTP signatures", "committedDate": "2020-01-15T22:03:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMjAwNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367132004", "bodyText": "How about making this public boolean and move this into DefaultCodegen?\nThen you can invoke it with config.hasHttpSignatureMethods(blah..)", "author": "spacether", "createdAt": "2020-01-15T22:05:45Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -1332,6 +1335,19 @@ private boolean hasBearerMethods(List<CodegenSecurity> authMethods) {\n         return false;\n     }\n \n+    // hasHttpSignatureMethods returns true if the specified OAS model has\n+    // HTTP signature methods.\n+    // The HTTP signature scheme is defined in https://datatracker.ietf.org/doc/draft-cavage-http-signatures/\n+    private boolean hasHttpSignatureMethods(List<CodegenSecurity> authMethods) {", "originalCommit": "719146d165cb10b8ad9b32a82c34e929c41ed6d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjY2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367136661", "bodyText": "Or how about putting it here?\nmodules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ProcessUtils.java\nThat way both classes can use it.", "author": "spacether", "createdAt": "2020-01-15T22:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMjAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODMxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4958#discussion_r367158316", "bodyText": "I moved it to ProcessUtils.java", "author": "sebastien-rosset", "createdAt": "2020-01-15T23:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMjAwNA=="}], "type": "inlineReview"}, {"oid": "31519820f6e0a8a06805d6a84a9dfaa17eb122eb", "url": "https://github.com/OpenAPITools/openapi-generator/commit/31519820f6e0a8a06805d6a84a9dfaa17eb122eb", "message": "move method to ProcessUtils", "committedDate": "2020-01-15T23:13:21Z", "type": "commit"}, {"oid": "6fd84329220997e6a77c82d5bc56c3036fa5f1c8", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6fd84329220997e6a77c82d5bc56c3036fa5f1c8", "message": "conditionally build signing.py", "committedDate": "2020-01-15T23:13:46Z", "type": "commit"}, {"oid": "bb124210a23ff595c191e0230c6b35ab86476aa5", "url": "https://github.com/OpenAPITools/openapi-generator/commit/bb124210a23ff595c191e0230c6b35ab86476aa5", "message": "move method to ProcessUtils", "committedDate": "2020-01-15T23:16:12Z", "type": "commit"}, {"oid": "21c478fe7e19b6641b964b615ffb32cad66441c1", "url": "https://github.com/OpenAPITools/openapi-generator/commit/21c478fe7e19b6641b964b615ffb32cad66441c1", "message": "Merge branch 'http-signature' of github.com:CiscoM31/openapi-generator into python-http-signature", "committedDate": "2020-01-15T23:17:35Z", "type": "commit"}]}