{"pr_number": 7585, "pr_title": "Upgrade Dart2 template to advertised best-practices, plenty of additions too.", "pr_createdAt": "2020-10-03T14:41:10Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/7585", "timeline": [{"oid": "3af4527e1655e3bc3e36a4bcbfef6b8cd075e200", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3af4527e1655e3bc3e36a4bcbfef6b8cd075e200", "message": "Updated Dart2 template.", "committedDate": "2020-10-03T14:37:11Z", "type": "commit"}, {"oid": "4270565502636f89c97ee5581cd59534ff095fee", "url": "https://github.com/OpenAPITools/openapi-generator/commit/4270565502636f89c97ee5581cd59534ff095fee", "message": "Generated Petstore client code for Dart2.", "committedDate": "2020-10-03T14:40:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTMzOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159338", "bodyText": "this yoda syntax is super strange to read", "author": "agilob", "createdAt": "2020-10-03T15:56:33Z", "path": "samples/client/petstore/dart2/petstore_client_lib/lib/model/pet.dart", "diffHunk": "@@ -1,142 +1,201 @@\n+//\n+// AUTO-GENERATED FILE, DO NOT MODIFY!\n+//\n+// @dart=2.0\n+\n+// ignore_for_file: unused_element, unused_import\n+// ignore_for_file: always_put_required_named_parameters_first\n+// ignore_for_file: avoid_init_to_null, lines_longer_than_80_chars\n+// ignore_for_file: prefer_single_quotes\n+\n part of openapi.api;\n \n class Pet {\n+  Pet({\n+    this.id,\n+    this.category,\n+    @required this.name,\n+    this.photoUrls = const const [],\n+    this.tags = const const [],\n+    this.status,\n+  });\n+\n   \n   int id;\n+\n   \n   Category category;\n+\n   \n   String name;\n+\n   \n-  List<String> photoUrls = const [];\n+  List<String> photoUrls;\n+\n   \n-  List<Tag> tags = const [];\n+  List<Tag> tags;\n+\n   /// pet status in the store\n   PetStatusEnum status;\n \n-  Pet({\n-    this.id,\n-    this.category,\n-    @required this.name,\n-    @required this.photoUrls,\n-    this.tags = const [],\n-    this.status,\n-  });\n+  @override\n+  bool operator ==(Object other) => identical(this, other) || other is Pet &&\n+     other.id == id &&\n+     other.category == category &&\n+     other.name == name &&\n+     other.photoUrls == photoUrls &&\n+     other.tags == tags &&\n+     other.status == status;\n \n   @override\n-  String toString() {\n-    return 'Pet[id=$id, category=$category, name=$name, photoUrls=$photoUrls, tags=$tags, status=$status, ]';\n-  }\n+  int get hashCode =>\n+    id.hashCode +\n+    category.hashCode +\n+    name.hashCode +\n+    photoUrls.hashCode +\n+    tags.hashCode +\n+    status.hashCode;\n+\n+  @override\n+  String toString() => 'Pet[id=$id, category=$category, name=$name, photoUrls=$photoUrls, tags=$tags, status=$status]';\n \n   Pet.fromJson(Map<String, dynamic> json) {\n-    if (json == null) return;\n-    id = json['id'];\n-    category = (json['category'] == null) ?\n-      null :\n-      Category.fromJson(json['category']);\n-    name = json['name'];\n-    photoUrls = (json['photoUrls'] == null) ?\n-      null :\n-      (json['photoUrls'] as List).cast<String>();\n-    tags = (json['tags'] == null) ?\n-      null :\n-      Tag.listFromJson(json['tags']);\n-    status = PetStatusEnum.fromJson(json['status']);\n+    if (json == null) {\n+      return;\n+    }\n+    id = json[\"id\"];\n+    category = Category.fromJson(json[\"category\"]);\n+    name = json[\"name\"];\n+    photoUrls = json[\"photoUrls\"] == null\n+      ? null\n+      : (json[\"photoUrls\"] as List).cast<String>();\n+    tags = Tag.listFromJson(json[\"tags\"]);\n+    status = PetStatusEnum.fromJson(json[\"status\"]);\n   }\n \n   Map<String, dynamic> toJson() {\n-    Map<String, dynamic> json = {};\n-    if (id != null)\n-      json['id'] = id;\n-    if (category != null)\n-      json['category'] = category;\n-    if (name != null)\n-      json['name'] = name;\n-    if (photoUrls != null)\n-      json['photoUrls'] = photoUrls;\n-    if (tags != null)\n-      json['tags'] = tags;\n-    if (status != null)\n-      json['status'] = status.value;\n+    final json = <String, dynamic>{};\n+    if (id != null) {\n+      json[\"id\"] = id;\n+    }\n+    if (category != null) {\n+      json[\"category\"] = category;\n+    }\n+    if (name != null) {\n+      json[\"name\"] = name;\n+    }\n+    if (photoUrls != null) {\n+      json[\"photoUrls\"] = photoUrls;\n+    }\n+    if (tags != null) {\n+      json[\"tags\"] = tags;\n+    }\n+    if (status != null) {\n+      json[\"status\"] = status;\n+    }\n     return json;\n   }\n \n-  static List<Pet> listFromJson(List<dynamic> json) {\n-    return json == null ? List<Pet>() : json.map((value) => Pet.fromJson(value)).toList();\n-  }\n+  static List<Pet> listFromJson(List<dynamic> json, {bool emptyIsNull, bool growable,}) =>\n+    json == null || json.isEmpty\n+      ? true == emptyIsNull ? null : <Pet>[]\n+      : json.map((v) => Pet.fromJson(v)).toList(growable: true == growable);\n \n   static Map<String, Pet> mapFromJson(Map<String, dynamic> json) {\n-    final map = Map<String, Pet>();\n+    final map = <String, Pet>{};\n     if (json != null && json.isNotEmpty) {\n-      json.forEach((String key, dynamic value) => map[key] = Pet.fromJson(value));\n+      json.forEach((String key, dynamic v) => map[key] = Pet.fromJson(v));\n     }\n     return map;\n   }\n \n   // maps a json object with a list of Pet-objects as value to a dart map\n-  static Map<String, List<Pet>> mapListFromJson(Map<String, dynamic> json) {\n-    final map = Map<String, List<Pet>>();\n+  static Map<String, List<Pet>> mapListFromJson(Map<String, dynamic> json, {bool emptyIsNull, bool growable,}) {\n+    final map = <String, List<Pet>>{};\n     if (json != null && json.isNotEmpty) {\n-      json.forEach((String key, dynamic value) {\n-        map[key] = Pet.listFromJson(value);\n+      json.forEach((String key, dynamic v) {\n+        map[key] = Pet.listFromJson(v, emptyIsNull: emptyIsNull, growable: growable);\n       });\n     }\n     return map;\n   }\n }\n+\n+/// pet status in the store\n class PetStatusEnum {\n+  /// Instantiate a new enum with the provided [value].\n+  const PetStatusEnum._(this.value);\n+\n   /// The underlying value of this enum member.\n   final String value;\n \n-  const PetStatusEnum._internal(this.value);\n-\n-  /// pet status in the store\n-  static const PetStatusEnum available_ = PetStatusEnum._internal(\"available\");\n-  /// pet status in the store\n-  static const PetStatusEnum pending_ = PetStatusEnum._internal(\"pending\");\n-  /// pet status in the store\n-  static const PetStatusEnum sold_ = PetStatusEnum._internal(\"sold\");\n-\n-  static List<PetStatusEnum> get values => const [\n-        available_,\n-        pending_,\n-        sold_,\n-      ];\n-\n-  String toJson () {\n-    return value;\n-  }\n-\n   @override\n-  String toString () {\n-    return value;\n-  }\n+  bool operator ==(Object other) =>\n+      identical(this, other) ||\n+      other is PetStatusEnum && other.value == value ||\n+      other is String && other == value;\n \n-  static PetStatusEnum fromJson(String value) {\n-    return PetStatusEnumTypeTransformer().decode(value);\n-  }\n+  @override\n+  int get hashCode => toString().hashCode;\n \n-  static List<PetStatusEnum> listFromJson(List<dynamic> json) {\n-    return json == null\n-      ? List<PetStatusEnum>()\n-      : json.map((value) => PetStatusEnum.fromJson(value)).toList();\n-  }\n+  @override\n+  String toString() => value;\n+\n+  String toJson() => value;\n+\n+  static const available_ = PetStatusEnum._(\"available\");\n+  static const pending_ = PetStatusEnum._(\"pending\");\n+  static const sold_ = PetStatusEnum._(\"sold\");\n+\n+  /// List of all possible values in this [enum][PetStatusEnum].\n+  static const values = <PetStatusEnum>[\n+    available_,\n+    pending_,\n+    sold_,\n+  ];\n+\n+  static PetStatusEnum fromJson(String value) =>\n+    PetStatusEnumTypeTransformer().decode(value);\n+\n+  static List<PetStatusEnum> listFromJson(List<dynamic> json, {bool emptyIsNull, bool growable,}) =>\n+    json == null || json.isEmpty\n+      ? true == emptyIsNull ? null : <PetStatusEnum>[]\n+      : json\n+          .map((value) => PetStatusEnum.fromJson(value))\n+          .toList(growable: true == growable);\n }\n \n+/// Transformation class that can [encode] an instance of [PetStatusEnum] to String,\n+/// and [decode] dynamic data back to [PetStatusEnum].\n class PetStatusEnumTypeTransformer {\n+  const PetStatusEnumTypeTransformer._();\n \n-  dynamic encode(PetStatusEnum data) {\n-    return data.value;\n-  }\n+  factory PetStatusEnumTypeTransformer() => _instance ??= PetStatusEnumTypeTransformer._();\n \n-  PetStatusEnum decode(dynamic data) {\n+  String encode(PetStatusEnum data) => data.value;\n+\n+  /// Decodes a [dynamic value][data] to a PetStatusEnum.\n+  ///\n+  /// If [allowNull] is true and the [dynamic value][data] cannot be decoded successfully,\n+  /// then null is returned. However, if [allowNull] is false and the [dynamic value][data]\n+  /// cannot be decoded successfully, then an [UnimplementedError] is thrown.\n+  ///\n+  /// The [allowNull] is very handy when an API changes and a new enum value is added or removed,\n+  /// and users are still using an old app with the old code.\n+  PetStatusEnum decode(dynamic data, {bool allowNull}) {\n     switch (data) {\n       case \"available\": return PetStatusEnum.available_;\n       case \"pending\": return PetStatusEnum.pending_;\n       case \"sold\": return PetStatusEnum.sold_;\n-      default: return null;\n+      default:\n+        if (false == allowNull) {", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTQyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159429", "bodyText": "Where did you get the best practice to use \" instead '?", "author": "agilob", "createdAt": "2020-10-03T15:57:41Z", "path": "modules/openapi-generator/src/main/resources/dart2/api.mustache", "diffHunk": "@@ -1,129 +1,131 @@\n-part of {{pubName}}.api;\n-\n+{{>header}}\n+{{>part_of}}\n {{#operations}}\n \n+class {{{classname}}} {\n+  {{{classname}}}([ApiClient apiClient]) : apiClient = apiClient ?? defaultApiClient;\n \n-class {{classname}} {\n   final ApiClient apiClient;\n-\n-  {{classname}}([ApiClient apiClient]) : apiClient = apiClient ?? defaultApiClient;\n-\n   {{#operation}}\n-  /// {{summary}} with HTTP info returned\n+\n+  /// {{{summary}}} with HTTP info returned\n   ///\n-  /// {{notes}}\n-  {{#returnType}}Future<Response> {{/returnType}}{{^returnType}}Future {{/returnType}}{{nickname}}WithHttpInfo({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{ {{#allParams}}{{^required}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}) async {\n-    Object postBody{{#bodyParam}} = {{paramName}}{{/bodyParam}};\n+  /// {{{notes}}}\n+  {{#returnType}}Future<Response> {{/returnType}}{{^returnType}}Future {{/returnType}}{{{nickname}}}WithHttpInfo({{#allParams}}{{#required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{ {{#allParams}}{{^required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}) async {\n+    Object postBody{{#bodyParam}} = {{{paramName}}}{{/bodyParam}};\n \n     // verify required params are set\n     {{#allParams}}\n       {{#required}}\n-    if({{paramName}} == null) {\n-     throw ApiException(400, \"Missing required param: {{paramName}}\");\n+    if ({{{paramName}}} == null) {\n+     throw ApiException(400, \"Missing required param: {{{paramName}}}\");\n     }\n       {{/required}}\n     {{/allParams}}\n \n     // create path and map variables\n-    String path = \"{{{path}}}\".replaceAll(\"{format}\",\"json\"){{#pathParams}}.replaceAll(\"{\" + \"{{baseName}}\" + \"}\", {{{paramName}}}.toString()){{/pathParams}};\n+    String path = \"{{{path}}}\".replaceAll(\"{format}\",\"json\"){{#pathParams}}.replaceAll(\"{\" + \"{{{baseName}}}\" + \"}\", {{{paramName}}}.toString()){{/pathParams}};\n \n     // query params\n     List<QueryParam> queryParams = [];\n     Map<String, String> headerParams = {};\n     Map<String, String> formParams = {};\n     {{#queryParams}}\n     {{^required}}\n-    if({{paramName}} != null) {\n+    if ({{{paramName}}} != null) {\n     {{/required}}\n-      queryParams.addAll(_convertParametersForCollectionFormat(\"{{collectionFormat}}\", \"{{baseName}}\", {{paramName}}));\n+      queryParams.addAll(_convertParametersForCollectionFormat(\"{{{collectionFormat}}}\", \"{{{baseName}}}\", {{{paramName}}}));\n     {{^required}}\n     }\n     {{/required}}\n     {{/queryParams}}\n     {{#headerParams}}\n-    headerParams[\"{{baseName}}\"] = {{paramName}};\n+    headerParams[\"{{{baseName}}}\"] = {{{paramName}}};\n     {{/headerParams}}\n \n     List<String> contentTypes = [{{#consumes}}\"{{{mediaType}}}\"{{#hasMore}},{{/hasMore}}{{/consumes}}];\n \n     String nullableContentType = contentTypes.isNotEmpty ? contentTypes[0] : null;\n-    List<String> authNames = [{{#authMethods}}\"{{name}}\"{{#hasMore}}, {{/hasMore}}{{/authMethods}}];\n+    List<String> authNames = [{{#authMethods}}\"{{{name}}}\"{{#hasMore}}, {{/hasMore}}{{/authMethods}}];\n \n-    if(nullableContentType != null && nullableContentType.startsWith(\"multipart/form-data\")) {\n+    if (nullableContentType != null && nullableContentType.startsWith(\"multipart/form-data\")) {\n       bool hasFields = false;\n       MultipartRequest mp = MultipartRequest(null, null);\n       {{#formParams}}\n       {{^isFile}}\n-      if ({{paramName}} != null) {\n+      if ({{{paramName}}} != null) {\n         hasFields = true;\n-        mp.fields['{{baseName}}'] = parameterToString({{paramName}});\n+        mp.fields[\"{{{baseName}}}\"] = parameterToString({{{paramName}}});\n       }\n       {{/isFile}}\n       {{#isFile}}\n-      if ({{paramName}} != null) {\n+      if ({{{paramName}}} != null) {\n         hasFields = true;\n-        mp.fields['{{baseName}}'] = {{paramName}}.field;\n-        mp.files.add({{paramName}});\n+        mp.fields[\"{{{baseName}}}\"] = {{{paramName}}}.field;", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4Nzk5NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499187995", "bodyText": "That's actually not a best-practice :) However, if given a choice either to have consistency or to conform, then I choose consistency. So the reasoning behind using double-quotes over single-quotes is because the Dart generator wraps string values with double-quotes.\nSo I would rather see double-quotes in the generated code all over the place, instead of having inconsistency.\nMakes sense?", "author": "noordawod", "createdAt": "2020-10-03T22:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMzQ1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499223452", "bodyText": "@agilob\nI have looked into DartClientCodegen.java and I can see where \" is used. I would rather have single quotes to be honest, so I think I will go ahead and roll back the changes for double-quotes.\nI also saw that the same Java code injects const [] and const {} (in toDefaultValue(Schema)), which is not backward compatible with previous versions of the same file. What do you reckon, should we keep the const in the Java file or put it in the Mustache template?", "author": "noordawod", "createdAt": "2020-10-04T09:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTU2NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159564", "bodyText": "Same here why \" not '? All dart src examples use ' https://dart.dev/guides/language/effective-dart/style", "author": "agilob", "createdAt": "2020-10-03T15:59:42Z", "path": "modules/openapi-generator/src/main/resources/dart2/api_client.mustache", "diffHunk": "@@ -1,182 +1,187 @@\n-part of {{pubName}}.api;\n-\n+{{>header}}\n+{{>part_of}}\n class QueryParam {\n+  QueryParam(this.name, this.value);\n+\n   String name;\n   String value;\n-\n-  QueryParam(this.name, this.value);\n }\n \n class ApiClient {\n-\n-  String basePath;\n-  var client = Client();\n-\n-  Map<String, String> _defaultHeaderMap = {};\n-  Map<String, Authentication> _authentications = {};\n-\n-  final _regList = RegExp(r'^List<(.*)>$');\n-  final _regMap = RegExp(r'^Map<String,(.*)>$');\n-\n   ApiClient({this.basePath = \"{{{basePath}}}\"}) {\n   {{#hasAuthMethods}}\n     // Setup authentications (key: authentication name, value: authentication).\n   {{#authMethods}}\n   {{#isBasic}}\n   {{#isBasicBasic}}\n-    _authentications['{{name}}'] = HttpBasicAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBasicAuth();\n   {{/isBasicBasic}}\n   {{#isBasicBearer}}\n-    _authentications['{{name}}'] = HttpBearerAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBearerAuth();\n   {{/isBasicBearer}}\n   {{/isBasic}}\n   {{#isApiKey}}\n-    _authentications['{{name}}'] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{keyParamName}}\");\n+    _authentications[\"{{{name}}}\"] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{{keyParamName}}}\");\n   {{/isApiKey}}\n   {{#isOAuth}}\n-    _authentications['{{name}}'] = OAuth();\n+    _authentications[\"{{{name}}}\"] = OAuth();\n   {{/isOAuth}}\n   {{/authMethods}}\n   {{/hasAuthMethods}}\n   }\n \n+  String basePath;\n+  var client = Client();\n+\n+  final _defaultHeaderMap = <String, String>{};\n+  final _authentications = <String, Authentication>{};\n+\n   void addDefaultHeader(String key, String value) {\n      _defaultHeaderMap[key] = value;\n   }\n \n-  dynamic _deserialize(dynamic value, String targetType) {\n-    try {\n-      switch (targetType) {\n-        case 'String':\n-          return '$value';\n-        case 'int':\n-          return value is int ? value : int.parse('$value');\n-        case 'bool':\n-          return value is bool ? value : '$value'.toLowerCase() == 'true';\n-        case 'double':\n-          return value is double ? value : double.parse('$value');\n-        {{#models}}\n-          {{#model}}\n-        case '{{classname}}':\n-            {{#isEnum}}\n-          return new {{classname}}TypeTransformer().decode(value);\n-            {{/isEnum}}\n-            {{^isEnum}}\n-          return {{classname}}.fromJson(value);\n-            {{/isEnum}}\n-          {{/model}}\n-        {{/models}}\n-        default:\n-          {\n-            Match match;\n-            if (value is List &&\n-                (match = _regList.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return value.map((v) => _deserialize(v, newTargetType)).toList();\n-            } else if (value is Map &&\n-                (match = _regMap.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return Map.fromIterables(value.keys,\n-                  value.values.map((v) => _deserialize(v, newTargetType)));\n-            }\n-          }\n-      }\n-    } on Exception catch (e, stack) {\n-      throw ApiException.withInner(500, 'Exception during deserialization.', e, stack);\n-    }\n-    throw ApiException(500, 'Could not find a suitable class for deserialization');\n-  }\n-\n-  dynamic deserialize(String json, String targetType) {\n+  dynamic deserialize(String json, String targetType, {bool growable}) {\n     // Remove all spaces.  Necessary for reg expressions as well.\n-    targetType = targetType.replaceAll(' ', '');\n-\n-    if (targetType == 'String') return json;\n+    targetType = targetType.replaceAll(\" \", \"\");\n \n-    var decodedJson = jsonDecode(json);\n-    return _deserialize(decodedJson, targetType);\n+    return targetType == \"String\"\n+      ? json\n+      : _deserialize(jsonDecode(json), targetType, growable: true == growable);\n   }\n \n-  String serialize(Object obj) {\n-    String serialized = '';\n-    if (obj == null) {\n-      serialized = '';\n-    } else {\n-      serialized = json.encode(obj);\n-    }\n-    return serialized;\n-  }\n+  String serialize(Object obj) => obj == null ? \"\" : json.encode(obj);\n \n-  // We don't use a Map<String, String> for queryParams.\n-  // If collectionFormat is 'multi' a key might appear multiple times.\n-  Future<Response> invokeAPI(String path,\n-                             String method,\n-                             Iterable<QueryParam> queryParams,\n-                             Object body,\n-                             Map<String, String> headerParams,\n-                             Map<String, String> formParams,\n-                             String nullableContentType,\n-                             List<String> authNames) async {\n+  T getAuthentication<T extends Authentication>(String name) {\n+    final authentication = _authentications[name];\n+    return authentication is T ? authentication : null;\n+  }\n \n+  // We don\u2019t use a Map<String, String> for queryParams.\n+  // If collectionFormat is \"multi\" a key might appear multiple times.\n+  Future<Response> invokeAPI(\n+    String path,\n+    String method,\n+    Iterable<QueryParam> queryParams,\n+    Object body,\n+    Map<String, String> headerParams,\n+    Map<String, String> formParams,\n+    String nullableContentType,\n+    List<String> authNames,\n+  ) async {\n     _updateParamsForAuth(authNames, queryParams, headerParams);\n \n-    var ps = queryParams\n+    headerParams.addAll(_defaultHeaderMap);\n+\n+    final ps = queryParams\n       .where((p) => p.value != null)\n-      .map((p) => '${p.name}=${Uri.encodeQueryComponent(p.value)}');\n+      .map((p) => \"${p.name}=${Uri.encodeQueryComponent(p.value)}\");", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTY4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159687", "bodyText": "You are mixing styles here as well, one liner trinary operator vs. multiline. Personally I prefer multiline as it's easier to quickly scan code while scrolling.", "author": "agilob", "createdAt": "2020-10-03T16:01:23Z", "path": "modules/openapi-generator/src/main/resources/dart2/api_client.mustache", "diffHunk": "@@ -1,182 +1,187 @@\n-part of {{pubName}}.api;\n-\n+{{>header}}\n+{{>part_of}}\n class QueryParam {\n+  QueryParam(this.name, this.value);\n+\n   String name;\n   String value;\n-\n-  QueryParam(this.name, this.value);\n }\n \n class ApiClient {\n-\n-  String basePath;\n-  var client = Client();\n-\n-  Map<String, String> _defaultHeaderMap = {};\n-  Map<String, Authentication> _authentications = {};\n-\n-  final _regList = RegExp(r'^List<(.*)>$');\n-  final _regMap = RegExp(r'^Map<String,(.*)>$');\n-\n   ApiClient({this.basePath = \"{{{basePath}}}\"}) {\n   {{#hasAuthMethods}}\n     // Setup authentications (key: authentication name, value: authentication).\n   {{#authMethods}}\n   {{#isBasic}}\n   {{#isBasicBasic}}\n-    _authentications['{{name}}'] = HttpBasicAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBasicAuth();\n   {{/isBasicBasic}}\n   {{#isBasicBearer}}\n-    _authentications['{{name}}'] = HttpBearerAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBearerAuth();\n   {{/isBasicBearer}}\n   {{/isBasic}}\n   {{#isApiKey}}\n-    _authentications['{{name}}'] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{keyParamName}}\");\n+    _authentications[\"{{{name}}}\"] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{{keyParamName}}}\");\n   {{/isApiKey}}\n   {{#isOAuth}}\n-    _authentications['{{name}}'] = OAuth();\n+    _authentications[\"{{{name}}}\"] = OAuth();\n   {{/isOAuth}}\n   {{/authMethods}}\n   {{/hasAuthMethods}}\n   }\n \n+  String basePath;\n+  var client = Client();\n+\n+  final _defaultHeaderMap = <String, String>{};\n+  final _authentications = <String, Authentication>{};\n+\n   void addDefaultHeader(String key, String value) {\n      _defaultHeaderMap[key] = value;\n   }\n \n-  dynamic _deserialize(dynamic value, String targetType) {\n-    try {\n-      switch (targetType) {\n-        case 'String':\n-          return '$value';\n-        case 'int':\n-          return value is int ? value : int.parse('$value');\n-        case 'bool':\n-          return value is bool ? value : '$value'.toLowerCase() == 'true';\n-        case 'double':\n-          return value is double ? value : double.parse('$value');\n-        {{#models}}\n-          {{#model}}\n-        case '{{classname}}':\n-            {{#isEnum}}\n-          return new {{classname}}TypeTransformer().decode(value);\n-            {{/isEnum}}\n-            {{^isEnum}}\n-          return {{classname}}.fromJson(value);\n-            {{/isEnum}}\n-          {{/model}}\n-        {{/models}}\n-        default:\n-          {\n-            Match match;\n-            if (value is List &&\n-                (match = _regList.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return value.map((v) => _deserialize(v, newTargetType)).toList();\n-            } else if (value is Map &&\n-                (match = _regMap.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return Map.fromIterables(value.keys,\n-                  value.values.map((v) => _deserialize(v, newTargetType)));\n-            }\n-          }\n-      }\n-    } on Exception catch (e, stack) {\n-      throw ApiException.withInner(500, 'Exception during deserialization.', e, stack);\n-    }\n-    throw ApiException(500, 'Could not find a suitable class for deserialization');\n-  }\n-\n-  dynamic deserialize(String json, String targetType) {\n+  dynamic deserialize(String json, String targetType, {bool growable}) {\n     // Remove all spaces.  Necessary for reg expressions as well.\n-    targetType = targetType.replaceAll(' ', '');\n-\n-    if (targetType == 'String') return json;\n+    targetType = targetType.replaceAll(\" \", \"\");\n \n-    var decodedJson = jsonDecode(json);\n-    return _deserialize(decodedJson, targetType);\n+    return targetType == \"String\"\n+      ? json\n+      : _deserialize(jsonDecode(json), targetType, growable: true == growable);\n   }\n \n-  String serialize(Object obj) {\n-    String serialized = '';\n-    if (obj == null) {\n-      serialized = '';\n-    } else {\n-      serialized = json.encode(obj);\n-    }\n-    return serialized;\n-  }\n+  String serialize(Object obj) => obj == null ? \"\" : json.encode(obj);\n \n-  // We don't use a Map<String, String> for queryParams.\n-  // If collectionFormat is 'multi' a key might appear multiple times.\n-  Future<Response> invokeAPI(String path,\n-                             String method,\n-                             Iterable<QueryParam> queryParams,\n-                             Object body,\n-                             Map<String, String> headerParams,\n-                             Map<String, String> formParams,\n-                             String nullableContentType,\n-                             List<String> authNames) async {\n+  T getAuthentication<T extends Authentication>(String name) {\n+    final authentication = _authentications[name];\n+    return authentication is T ? authentication : null;\n+  }\n \n+  // We don\u2019t use a Map<String, String> for queryParams.\n+  // If collectionFormat is \"multi\" a key might appear multiple times.\n+  Future<Response> invokeAPI(\n+    String path,\n+    String method,\n+    Iterable<QueryParam> queryParams,\n+    Object body,\n+    Map<String, String> headerParams,\n+    Map<String, String> formParams,\n+    String nullableContentType,\n+    List<String> authNames,\n+  ) async {\n     _updateParamsForAuth(authNames, queryParams, headerParams);\n \n-    var ps = queryParams\n+    headerParams.addAll(_defaultHeaderMap);\n+\n+    final ps = queryParams\n       .where((p) => p.value != null)\n-      .map((p) => '${p.name}=${Uri.encodeQueryComponent(p.value)}');\n+      .map((p) => \"${p.name}=${Uri.encodeQueryComponent(p.value)}\");\n \n-    String queryString = ps.isNotEmpty ?\n-                         '?' + ps.join('&') :\n-                         '';\n+    final queryString = ps.isNotEmpty ? \"?\" + ps.join(\"&\") : \"\";\n \n-    String url = basePath + path + queryString;\n+    final url = \"$basePath$path$queryString\";\n \n-    headerParams.addAll(_defaultHeaderMap);\n     if (nullableContentType != null) {\n-      final contentType = nullableContentType;\n-      headerParams['Content-Type'] = contentType;\n+      headerParams[\"Content-Type\"] = nullableContentType;\n     }\n \n-    if(body is MultipartRequest) {\n+    if (body is MultipartRequest) {\n       var request = MultipartRequest(method, Uri.parse(url));\n       request.fields.addAll(body.fields);\n       request.files.addAll(body.files);\n       request.headers.addAll(body.headers);\n       request.headers.addAll(headerParams);\n       var response = await client.send(request);\n       return Response.fromStream(response);\n-    } else {\n-      var msgBody = nullableContentType == \"application/x-www-form-urlencoded\" ? formParams : serialize(body);\n-      final nullableHeaderParams = (headerParams.isEmpty)? null: headerParams;\n-      switch(method) {\n-        case \"POST\":\n-          return client.post(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"PUT\":\n-          return client.put(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"DELETE\":\n-          return client.delete(url, headers: nullableHeaderParams);\n-        case \"PATCH\":\n-          return client.patch(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"HEAD\":\n-          return client.head(url, headers: nullableHeaderParams);\n+    }\n+\n+    final msgBody = nullableContentType == \"application/x-www-form-urlencoded\"\n+      ? formParams\n+      : serialize(body);", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODExMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499188110", "bodyText": "Ask dartfmt; it'll opt to either have the trinary operator on one line, or as I wrote it above.\nI almost never see the previous style in the wild, namely:\n  ps.isNotEmpty ? '?' + ps.join('&')\n    : '';", "author": "noordawod", "createdAt": "2020-10-03T22:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTc3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159779", "bodyText": "I'm not convinced we should be correcting method type. Most languages do not do it, found it in only 2 other templates.", "author": "agilob", "createdAt": "2020-10-03T16:02:32Z", "path": "modules/openapi-generator/src/main/resources/dart2/api_client.mustache", "diffHunk": "@@ -1,182 +1,187 @@\n-part of {{pubName}}.api;\n-\n+{{>header}}\n+{{>part_of}}\n class QueryParam {\n+  QueryParam(this.name, this.value);\n+\n   String name;\n   String value;\n-\n-  QueryParam(this.name, this.value);\n }\n \n class ApiClient {\n-\n-  String basePath;\n-  var client = Client();\n-\n-  Map<String, String> _defaultHeaderMap = {};\n-  Map<String, Authentication> _authentications = {};\n-\n-  final _regList = RegExp(r'^List<(.*)>$');\n-  final _regMap = RegExp(r'^Map<String,(.*)>$');\n-\n   ApiClient({this.basePath = \"{{{basePath}}}\"}) {\n   {{#hasAuthMethods}}\n     // Setup authentications (key: authentication name, value: authentication).\n   {{#authMethods}}\n   {{#isBasic}}\n   {{#isBasicBasic}}\n-    _authentications['{{name}}'] = HttpBasicAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBasicAuth();\n   {{/isBasicBasic}}\n   {{#isBasicBearer}}\n-    _authentications['{{name}}'] = HttpBearerAuth();\n+    _authentications[\"{{{name}}}\"] = HttpBearerAuth();\n   {{/isBasicBearer}}\n   {{/isBasic}}\n   {{#isApiKey}}\n-    _authentications['{{name}}'] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{keyParamName}}\");\n+    _authentications[\"{{{name}}}\"] = ApiKeyAuth({{#isKeyInCookie}}\"cookie\"{{/isKeyInCookie}}{{^isKeyInCookie}}{{#isKeyInHeader}}\"header\"{{/isKeyInHeader}}{{^isKeyInHeader}}\"query\"{{/isKeyInHeader}}{{/isKeyInCookie}}, \"{{{keyParamName}}}\");\n   {{/isApiKey}}\n   {{#isOAuth}}\n-    _authentications['{{name}}'] = OAuth();\n+    _authentications[\"{{{name}}}\"] = OAuth();\n   {{/isOAuth}}\n   {{/authMethods}}\n   {{/hasAuthMethods}}\n   }\n \n+  String basePath;\n+  var client = Client();\n+\n+  final _defaultHeaderMap = <String, String>{};\n+  final _authentications = <String, Authentication>{};\n+\n   void addDefaultHeader(String key, String value) {\n      _defaultHeaderMap[key] = value;\n   }\n \n-  dynamic _deserialize(dynamic value, String targetType) {\n-    try {\n-      switch (targetType) {\n-        case 'String':\n-          return '$value';\n-        case 'int':\n-          return value is int ? value : int.parse('$value');\n-        case 'bool':\n-          return value is bool ? value : '$value'.toLowerCase() == 'true';\n-        case 'double':\n-          return value is double ? value : double.parse('$value');\n-        {{#models}}\n-          {{#model}}\n-        case '{{classname}}':\n-            {{#isEnum}}\n-          return new {{classname}}TypeTransformer().decode(value);\n-            {{/isEnum}}\n-            {{^isEnum}}\n-          return {{classname}}.fromJson(value);\n-            {{/isEnum}}\n-          {{/model}}\n-        {{/models}}\n-        default:\n-          {\n-            Match match;\n-            if (value is List &&\n-                (match = _regList.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return value.map((v) => _deserialize(v, newTargetType)).toList();\n-            } else if (value is Map &&\n-                (match = _regMap.firstMatch(targetType)) != null) {\n-              var newTargetType = match[1];\n-              return Map.fromIterables(value.keys,\n-                  value.values.map((v) => _deserialize(v, newTargetType)));\n-            }\n-          }\n-      }\n-    } on Exception catch (e, stack) {\n-      throw ApiException.withInner(500, 'Exception during deserialization.', e, stack);\n-    }\n-    throw ApiException(500, 'Could not find a suitable class for deserialization');\n-  }\n-\n-  dynamic deserialize(String json, String targetType) {\n+  dynamic deserialize(String json, String targetType, {bool growable}) {\n     // Remove all spaces.  Necessary for reg expressions as well.\n-    targetType = targetType.replaceAll(' ', '');\n-\n-    if (targetType == 'String') return json;\n+    targetType = targetType.replaceAll(\" \", \"\");\n \n-    var decodedJson = jsonDecode(json);\n-    return _deserialize(decodedJson, targetType);\n+    return targetType == \"String\"\n+      ? json\n+      : _deserialize(jsonDecode(json), targetType, growable: true == growable);\n   }\n \n-  String serialize(Object obj) {\n-    String serialized = '';\n-    if (obj == null) {\n-      serialized = '';\n-    } else {\n-      serialized = json.encode(obj);\n-    }\n-    return serialized;\n-  }\n+  String serialize(Object obj) => obj == null ? \"\" : json.encode(obj);\n \n-  // We don't use a Map<String, String> for queryParams.\n-  // If collectionFormat is 'multi' a key might appear multiple times.\n-  Future<Response> invokeAPI(String path,\n-                             String method,\n-                             Iterable<QueryParam> queryParams,\n-                             Object body,\n-                             Map<String, String> headerParams,\n-                             Map<String, String> formParams,\n-                             String nullableContentType,\n-                             List<String> authNames) async {\n+  T getAuthentication<T extends Authentication>(String name) {\n+    final authentication = _authentications[name];\n+    return authentication is T ? authentication : null;\n+  }\n \n+  // We don\u2019t use a Map<String, String> for queryParams.\n+  // If collectionFormat is \"multi\" a key might appear multiple times.\n+  Future<Response> invokeAPI(\n+    String path,\n+    String method,\n+    Iterable<QueryParam> queryParams,\n+    Object body,\n+    Map<String, String> headerParams,\n+    Map<String, String> formParams,\n+    String nullableContentType,\n+    List<String> authNames,\n+  ) async {\n     _updateParamsForAuth(authNames, queryParams, headerParams);\n \n-    var ps = queryParams\n+    headerParams.addAll(_defaultHeaderMap);\n+\n+    final ps = queryParams\n       .where((p) => p.value != null)\n-      .map((p) => '${p.name}=${Uri.encodeQueryComponent(p.value)}');\n+      .map((p) => \"${p.name}=${Uri.encodeQueryComponent(p.value)}\");\n \n-    String queryString = ps.isNotEmpty ?\n-                         '?' + ps.join('&') :\n-                         '';\n+    final queryString = ps.isNotEmpty ? \"?\" + ps.join(\"&\") : \"\";\n \n-    String url = basePath + path + queryString;\n+    final url = \"$basePath$path$queryString\";\n \n-    headerParams.addAll(_defaultHeaderMap);\n     if (nullableContentType != null) {\n-      final contentType = nullableContentType;\n-      headerParams['Content-Type'] = contentType;\n+      headerParams[\"Content-Type\"] = nullableContentType;\n     }\n \n-    if(body is MultipartRequest) {\n+    if (body is MultipartRequest) {\n       var request = MultipartRequest(method, Uri.parse(url));\n       request.fields.addAll(body.fields);\n       request.files.addAll(body.files);\n       request.headers.addAll(body.headers);\n       request.headers.addAll(headerParams);\n       var response = await client.send(request);\n       return Response.fromStream(response);\n-    } else {\n-      var msgBody = nullableContentType == \"application/x-www-form-urlencoded\" ? formParams : serialize(body);\n-      final nullableHeaderParams = (headerParams.isEmpty)? null: headerParams;\n-      switch(method) {\n-        case \"POST\":\n-          return client.post(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"PUT\":\n-          return client.put(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"DELETE\":\n-          return client.delete(url, headers: nullableHeaderParams);\n-        case \"PATCH\":\n-          return client.patch(url, headers: nullableHeaderParams, body: msgBody);\n-        case \"HEAD\":\n-          return client.head(url, headers: nullableHeaderParams);\n+    }\n+\n+    final msgBody = nullableContentType == \"application/x-www-form-urlencoded\"\n+      ? formParams\n+      : serialize(body);\n+    final nullableHeaderParams = headerParams.isEmpty ? null : headerParams;\n+\n+    try {\n+      switch(method.toUpperCase()) {", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODEyNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499188127", "bodyText": "Agreed. Removing it.", "author": "noordawod", "createdAt": "2020-10-03T22:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTg3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159873", "bodyText": "Here again, I've seen import ' (single quote), but this line has \" - inconsistent style.", "author": "agilob", "createdAt": "2020-10-03T16:04:02Z", "path": "modules/openapi-generator/src/main/resources/dart2/api_test.mustache", "diffHunk": "@@ -1,13 +1,14 @@\n-import 'package:{{pubName}}/api.dart';\n-import 'package:test/test.dart';\n+{{>header}}\n+import \"package:{{{pubName}}}/api.dart\";\n+import \"package:test/test.dart\";", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1OTk0Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499159943", "bodyText": "This import using ' again - which I think is correct, but pointing out lack of consistency.", "author": "agilob", "createdAt": "2020-10-03T16:05:04Z", "path": "modules/openapi-generator/src/main/resources/dart2/object_doc.mustache", "diffHunk": "@@ -1,14 +1,14 @@\n-{{#models}}{{#model}}# {{pubName}}.model.{{classname}}\n+{{#models}}{{#model}}# {{{pubName}}}.model.{{classname}}\n \n ## Load the model package\n ```dart\n-import 'package:{{pubName}}/api.dart';\n+import 'package:{{{pubName}}}/api.dart';", "originalCommit": "4270565502636f89c97ee5581cd59534ff095fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "23491508584b376ea8881490a23e2710dce11af0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/23491508584b376ea8881490a23e2710dce11af0", "message": "Use double-quotes instead of single-quotes, to be consistent with output of Dart generator.", "committedDate": "2020-10-03T22:54:14Z", "type": "commit"}, {"oid": "c28af2199bcad1b9c998f711800df8a04f08835d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c28af2199bcad1b9c998f711800df8a04f08835d", "message": "Updated Petstore samples.", "committedDate": "2020-10-03T22:56:30Z", "type": "commit"}, {"oid": "7161f31ff42cd7ca5181543050eb3b8271c3c9b2", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7161f31ff42cd7ca5181543050eb3b8271c3c9b2", "message": "Wrap few more places with triple curly parentheses.", "committedDate": "2020-10-03T23:14:50Z", "type": "commit"}, {"oid": "c8c2b62a279a7fca24c0295524cac780e27c7bb9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c8c2b62a279a7fca24c0295524cac780e27c7bb9", "message": "Generated Petstore files.", "committedDate": "2020-10-03T23:16:04Z", "type": "commit"}, {"oid": "8d62cac60247b2bf9fa083518f4e2548e3dc4cae", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8d62cac60247b2bf9fa083518f4e2548e3dc4cae", "message": "Merge branch 'master' into refactor/dart2-template", "committedDate": "2020-10-04T09:05:09Z", "type": "commit"}, {"oid": "1cde1a8a296275d7f71da3120bfefc01927c0330", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1cde1a8a296275d7f71da3120bfefc01927c0330", "message": "Revert to using single quotes, fix Java generator too.", "committedDate": "2020-10-04T09:35:30Z", "type": "commit"}, {"oid": "8019aab87ab350820a0d74df331da26232f2a68a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8019aab87ab350820a0d74df331da26232f2a68a", "message": "Generated Petstore files.", "committedDate": "2020-10-04T09:39:12Z", "type": "commit"}, {"oid": "96ba839eea20c7cbf5a0f7eefd744c65ec47aff9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/96ba839eea20c7cbf5a0f7eefd744c65ec47aff9", "message": "Lower case the content type value.", "committedDate": "2020-10-04T09:43:27Z", "type": "commit"}, {"oid": "e761b0b09a6011d564cfb41803553bccd313f4c7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e761b0b09a6011d564cfb41803553bccd313f4c7", "message": "Only lower-case content type when checking its value.", "committedDate": "2020-10-04T09:44:38Z", "type": "commit"}, {"oid": "44e929dcf1da8f8dca91d0a87a32b30aa61ead28", "url": "https://github.com/OpenAPITools/openapi-generator/commit/44e929dcf1da8f8dca91d0a87a32b30aa61ead28", "message": "Generated files from running \"./bin/utils/ensure-up-to-date\".", "committedDate": "2020-10-04T10:28:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMDUxNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499230514", "bodyText": "dart1 has been removed now. looks like your branch isn't up to date with upstream master", "author": "agilob", "createdAt": "2020-10-04T10:30:22Z", "path": "docs/generators/dart-dio.md", "diffHunk": "@@ -3,11 +3,10 @@ title: Config Options for dart-dio\n sidebar_label: dart-dio\n ---\n \n-These options may be applied as additional-properties (cli) or configOptions (plugins). Refer to [configuration docs](https://openapi-generator.tech/docs/configuration) for more details.\n-\n | Option | Description | Values | Default |\n | ------ | ----------- | ------ | ------- |\n |allowUnicodeIdentifiers|boolean, toggles whether unicode identifiers are allowed in names or not, default is false| |false|\n+|browserClient|Is the client browser based (for Dart 1.x only)| |null|", "originalCommit": "44e929dcf1da8f8dca91d0a87a32b30aa61ead28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMDk1MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499230950", "bodyText": "$ git status \nOn branch master\nYour branch is up to date with 'origin/master'.\n\nnothing to commit, working tree clean\n$ git fetch upstream master\nFrom https://github.com/OpenAPITools/openapi-generator\n * branch                  master     -> FETCH_HEAD\n$ git merge upstream/master\nAlready up to date.\n$ git checkout refactor/dart2-template \nSwitched to branch 'refactor/dart2-template'\nYour branch is up to date with 'origin/refactor/dart2-template'.\n$ git merge master\nAlready up to date.", "author": "noordawod", "createdAt": "2020-10-04T10:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMDg2Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r499230867", "bodyText": "this flag has been removed too", "author": "agilob", "createdAt": "2020-10-04T10:31:57Z", "path": "docs/generators/dart-dio.md", "diffHunk": "@@ -23,6 +22,7 @@ These options may be applied as additional-properties (cli) or configOptions (pl\n |sortModelPropertiesByRequiredFlag|Sort model properties to place required parameters before optional parameters.| |true|\n |sortParamsByRequiredFlag|Sort method arguments to place required parameters before optional parameters.| |true|\n |sourceFolder|Source folder for generated code| |null|\n+|supportDart2|Support Dart 2.x (Dart 1.x support has been deprecated)| |true|", "originalCommit": "44e929dcf1da8f8dca91d0a87a32b30aa61ead28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a5e77b370101aa6b85c0b05ca83aa5af3378b0c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6a5e77b370101aa6b85c0b05ca83aa5af3378b0c", "message": "Remove outdated comments for Dart1.", "committedDate": "2020-10-04T10:35:55Z", "type": "commit"}, {"oid": "8578a2aebc05e0265f8f3eac33aeb113e904b3cd", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8578a2aebc05e0265f8f3eac33aeb113e904b3cd", "message": "Regenerate Petstore samples for Dart.", "committedDate": "2020-10-04T10:38:39Z", "type": "commit"}, {"oid": "a7bab6a7b17dd6715f8a24e64e0a39099f8137f6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a7bab6a7b17dd6715f8a24e64e0a39099f8137f6", "message": "Added a new option \"pubLibrary\".", "committedDate": "2020-10-04T11:00:41Z", "type": "commit"}, {"oid": "03c1de7298bf72dfe2ff7efddc1a07a71d7619ce", "url": "https://github.com/OpenAPITools/openapi-generator/commit/03c1de7298bf72dfe2ff7efddc1a07a71d7619ce", "message": "Merge branch 'master' into refactor/dart2-template", "committedDate": "2020-10-05T11:24:02Z", "type": "commit"}, {"oid": "7eaaf6dbd97b21cd7b2669520e445bb3c07b0c34", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7eaaf6dbd97b21cd7b2669520e445bb3c07b0c34", "message": "Merge branch 'master' into refactor/dart2-template", "committedDate": "2020-10-05T18:22:23Z", "type": "commit"}, {"oid": "89816202eb821f1ff5d584c7ea4aed01cb5cab6d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/89816202eb821f1ff5d584c7ea4aed01cb5cab6d", "message": "Added support for (de)serializing a DateTime into an epoch value.", "committedDate": "2020-10-06T11:03:12Z", "type": "commit"}, {"oid": "89816202eb821f1ff5d584c7ea4aed01cb5cab6d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/89816202eb821f1ff5d584c7ea4aed01cb5cab6d", "message": "Added support for (de)serializing a DateTime into an epoch value.", "committedDate": "2020-10-06T11:03:12Z", "type": "forcePushed"}, {"oid": "a28ccd3fd11973c008af4121147688cafa01cffe", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a28ccd3fd11973c008af4121147688cafa01cffe", "message": "Merge branch 'master' into refactor/dart2-template", "committedDate": "2020-10-06T12:36:58Z", "type": "commit"}, {"oid": "bcec0baded8f9b9e8f1d3c0bb99baa7ed7478b8a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/bcec0baded8f9b9e8f1d3c0bb99baa7ed7478b8a", "message": "Make client variable a getter/setter, adjust docs.", "committedDate": "2020-10-06T14:08:40Z", "type": "commit"}, {"oid": "991fcf6c7a7b99b81ef99b8826c5495789a78470", "url": "https://github.com/OpenAPITools/openapi-generator/commit/991fcf6c7a7b99b81ef99b8826c5495789a78470", "message": "Fixed a small error in class template.", "committedDate": "2020-10-06T14:26:02Z", "type": "commit"}, {"oid": "412df35d2b880cb5ef885860b629c0f595a21686", "url": "https://github.com/OpenAPITools/openapi-generator/commit/412df35d2b880cb5ef885860b629c0f595a21686", "message": "Fix Dart documentation in API classes.", "committedDate": "2020-10-06T16:03:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTY5Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r500429696", "bodyText": "I think this line can get more optimized to this:\nfinal str = (username ??  '') + ':' + (password ?? '');", "author": "sbu-WBT", "createdAt": "2020-10-06T16:20:16Z", "path": "modules/openapi-generator/src/main/resources/dart2/auth/http_basic_auth.mustache", "diffHunk": "@@ -1,16 +1,12 @@\n-part of {{pubName}}.api;\n-\n+{{>header}}\n+{{>part_of}}\n class HttpBasicAuth implements Authentication {\n-\n-  String _username;\n-  String _password;\n+  String username;\n+  String password;\n \n   @override\n   void applyToParams(List<QueryParam> queryParams, Map<String, String> headerParams) {\n-    String str = (_username == null ? \"\" : _username) + \":\" + (_password == null ? \"\" : _password);\n-    headerParams[\"Authorization\"] = \"Basic \" + base64.encode(utf8.encode(str));\n+    final str = (username == null ? '' : username) + ':' + (password == null ? '' : password);", "originalCommit": "412df35d2b880cb5ef885860b629c0f595a21686", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2MjM3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/7585#discussion_r500462373", "bodyText": "Patched, awaiting CI.", "author": "noordawod", "createdAt": "2020-10-06T17:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTY5Ng=="}], "type": "inlineReview"}, {"oid": "c1878668cc17ee65249a94759eeb76882b3c575a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c1878668cc17ee65249a94759eeb76882b3c575a", "message": "Simplify test in HTTP Basic auth, remove unused lint rule.", "committedDate": "2020-10-06T17:11:00Z", "type": "commit"}]}