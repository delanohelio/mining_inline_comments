{"pr_number": 6176, "pr_title": "[powershell-experimental] : http signature authentication implementation", "pr_createdAt": "2020-05-05T11:18:23Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/6176", "timeline": [{"oid": "49f2b4bb8064d385f08b8a5cc04da176b0d557aa", "url": "https://github.com/OpenAPITools/openapi-generator/commit/49f2b4bb8064d385f08b8a5cc04da176b0d557aa", "message": "Merge pull request #1 from OpenAPITools/master\n\ntest", "committedDate": "2020-04-16T11:43:24Z", "type": "commit"}, {"oid": "ad24d348d28835edfc90385a33357d6d51eef02d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ad24d348d28835edfc90385a33357d6d51eef02d", "message": "ValidatePattern having double quote(\") throws exception on running Build.ps1", "committedDate": "2020-04-16T11:59:58Z", "type": "commit"}, {"oid": "8bcd51d6a5cdaf81f1b274f293132bb012cf69a9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8bcd51d6a5cdaf81f1b274f293132bb012cf69a9", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-04-17T04:42:18Z", "type": "commit"}, {"oid": "ff0094804ab7c885251b31ad3a60a058c24006c0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ff0094804ab7c885251b31ad3a60a058c24006c0", "message": "fix tab with space", "committedDate": "2020-04-17T07:50:52Z", "type": "commit"}, {"oid": "f865bd8eb8410394d938a502902231fc6331b444", "url": "https://github.com/OpenAPITools/openapi-generator/commit/f865bd8eb8410394d938a502902231fc6331b444", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-05T10:09:49Z", "type": "commit"}, {"oid": "1d0d4e14ecb102e453559d04b65c9dc4377bb0d7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1d0d4e14ecb102e453559d04b65c9dc4377bb0d7", "message": "[powershell-experimental] : http signature auth", "committedDate": "2020-05-05T10:47:45Z", "type": "commit"}, {"oid": "5372b5ae8adb29e532afb3d45f51571b6a171127", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5372b5ae8adb29e532afb3d45f51571b6a171127", "message": "fix the tab issue", "committedDate": "2020-05-05T11:25:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2MjU4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421562581", "bodyText": "I'll remove these empty spaces in my next PR to the PowerShell generator", "author": "wing328", "createdAt": "2020-05-07T14:45:24Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PowerShellExperimentalClientCodegen.java", "diffHunk": "@@ -626,7 +629,7 @@ public void processOpts() {\n     @SuppressWarnings(\"static-method\")\n     @Override\n     public String escapeText(String input) {\n-    \n+        ", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MTg2OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421771869", "bodyText": "@Ghufz, these comments should be removed", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:24:39Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MjQ3MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421772470", "bodyText": "Need better error handling", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:25:51Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3Mjc4Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421772786", "bodyText": "Remove code comments.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:26:27Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3Mjg3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421772875", "bodyText": "Remove this line", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:26:36Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MzA4NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421773085", "bodyText": "remove these two lines", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:26:59Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MzIxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421773213", "bodyText": "Remove these two lines", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:27:15Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();\n+            //byte[] psbytes = utf8.GetBytes(pswd);\n+\n+            // --- contatenate salt and pswd bytes into fixed data array ---\n+            byte[] data00 = new byte[psbytes.Length + salt.Length];\n+            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+            MD5 md5 = new MD5CryptoServiceProvider();\n+            byte[] result = null;\n+            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+            for (int j = 0; j < miter; j++)\n+            {\n+                // ----  Now hash consecutively for count times ------\n+                if (j == 0)\n+                    result = data00;    //initialize \n+                else\n+                {\n+                    Array.Copy(result, hashtarget, result.Length);\n+                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+                    result = hashtarget;\n+                    //Console.WriteLine(\"Updated new initial hash target:\") ;", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NDQ1NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421774454", "bodyText": "TODO: document the meaning of api key prefix. Is this really needed?\nIt looks like this is used to control the prefix of the \"Authorization\" HTTP header, but I don't see in the \"HTTP signature\" spec any option to control the name of the attribute. This is supposed to be exactly \"Signature\". On the other hand, other parameters are currently hard-coded and should be exposed as configuration parameters.\nExample:\nAuthorization: Signature keyId=\"rsa-key-1\",algorithm=\"rsa-sha256\",\n   headers=\"(request-target) host date digest content-length\",\n   signature=\"Base64(RSA-SHA256(signing string))\"", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:29:38Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NDYxMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421774611", "bodyText": "Typo: reterieve.\nAdd space after \"details,\"", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:30:00Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NTYyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421775629", "bodyText": "I suggest using \"keyId\", not \"key Id\" to use the HTTP signature terminology.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:31:52Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NTkzMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421775933", "bodyText": "Add some overview description explaining this code is for HTTP signature. See python example\nI just realized in Python we should give a better name instead of \"private key\" because in the HTTP signature spec, both asymmetric and symmetric keys are supported.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:32:30Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwOTI3NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r422109274", "bodyText": "What about HttpSignatureKey?", "author": "wing328", "createdAt": "2020-05-08T12:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3NzM3OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421777378", "bodyText": "Let's use the same terminology as the HTTP signature spec:\n\nThe \"signature\" authentication scheme is based on the model that the client must authenticate itself with a digital signature produced by either a private asymmetric key (e.g., RSA) or a shared symmetric key (e.g., HMAC). The scheme is parameterized enough such that it is not bound to any particular key type or signing algorithm. However, it does explicitly assume that clients can send an HTTP Date header.\n\nThe spec does not talk about \"API keys\".", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:35:10Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3ODY0OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421778648", "bodyText": "Grammar: \"it use\"", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:37:41Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3OTE2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421779161", "bodyText": "The HTTP signature spec does not mandate this specific sequence of HTTP headers. The headers are supposed to be provided by the caller.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:38:34Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3OTI4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421779288", "bodyText": "Please use case consistently (HTTP).", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:38:49Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3OTU0OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421779548", "bodyText": "typo: reterieve", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:39:20Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3OTczMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421779732", "bodyText": "Remove space before double quote", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:39:41Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3OTk2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421779961", "bodyText": "The HASH algorithm should be provided as an input parameter.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:40:06Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4MDc3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421780775", "bodyText": "The signature algorithm should not be hard-coded to \"rsa-sha256\" because 1) this algorithm has been deprecated in the HTTP signature spec and 2) the client should be able to decide which signature algorithm to use.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:41:30Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", ", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Mjk2OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421782968", "bodyText": "The URL must not be lowercase, per spec.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:45:40Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Mzc0NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421783745", "bodyText": "The content-type header should not be hard-coded to application/json", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:47:10Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n+        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    \n+    $HttpSignedHeader[\"Date\"] = $currentDate\n+    $HttpSignedHeader[\"Host\"] = $TargetHost\n+    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Mzk2NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421783965", "bodyText": "The list of signed HTTP headers should be configurable by the client.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:47:36Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n+        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    \n+    $HttpSignedHeader[\"Date\"] = $currentDate", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NDEwMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421784100", "bodyText": "Grammar: \"it use\"", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:47:52Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n+        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    \n+    $HttpSignedHeader[\"Date\"] = $currentDate\n+    $HttpSignedHeader[\"Host\"] = $TargetHost\n+    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n+    $HttpSignedHeader[\"Digest\"] = $Digest\n+    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n+    return $HttpSignedHeader\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NDMxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421784313", "bodyText": "We should support ECDSA keys.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:48:14Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n+        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    \n+    $HttpSignedHeader[\"Date\"] = $currentDate\n+    $HttpSignedHeader[\"Host\"] = $TargetHost\n+    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n+    $HttpSignedHeader[\"Digest\"] = $Digest\n+    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n+    return $HttpSignedHeader\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER APIKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.OUTPUTS\n+    String\n+#>\n+function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+    Param(\n+        [string]$APIKeyFilePath,\n+        [byte[]]$DataToSign\n+    )\n+    try {\n+        \n+        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NDQ5Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421784497", "bodyText": "This should not be hard-coded to SHA256", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:48:37Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n+    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n+        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    \n+    $HttpSignedHeader[\"Date\"] = $currentDate\n+    $HttpSignedHeader[\"Host\"] = $TargetHost\n+    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n+    $HttpSignedHeader[\"Digest\"] = $Digest\n+    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n+    return $HttpSignedHeader\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER APIKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.OUTPUTS\n+    String\n+#>\n+function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+    Param(\n+        [string]$APIKeyFilePath,\n+        [byte[]]$DataToSign\n+    )\n+    try {\n+        \n+        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n+        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+        Add-Type -TypeDefinition $rsa_provider_sourceCode\n+        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n+        if ($null -eq $signed_string) {\n+            throw \"Unable to sign the header using the API key\"\n+        }\n+        return $signed_string\n+    }\n+    catch {\n+        throw $_\n+    }\n+}\n+<#\n+.Synopsis\n+    Gets the hash of string.\n+.Description\n+    Gets the hash of string\n+.Outputs\n+String \n+#>\n+Function Get-{{{apiNamePrefix}}}StringHash([String] $String, $HashName = \"SHA256\") { ", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NTg4OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421785888", "bodyText": "The generated code should not force the client to use interactive input through the console. All input must be provided as configuration parameters, and it's up to the client to decide how to get these parameters (e.g. from console, from a secret store, etc).\nYou can provide a helper function as an example, but it should not be required to use it.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:51:14Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();\n+            //byte[] psbytes = utf8.GetBytes(pswd);\n+\n+            // --- contatenate salt and pswd bytes into fixed data array ---\n+            byte[] data00 = new byte[psbytes.Length + salt.Length];\n+            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+            MD5 md5 = new MD5CryptoServiceProvider();\n+            byte[] result = null;\n+            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+            for (int j = 0; j < miter; j++)\n+            {\n+                // ----  Now hash consecutively for count times ------\n+                if (j == 0)\n+                    result = data00;    //initialize \n+                else\n+                {\n+                    Array.Copy(result, hashtarget, result.Length);\n+                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+                    result = hashtarget;\n+                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n+                    //showBytes(result) ;\n+                }\n+\n+                for (int i = 0; i < count; i++)\n+                    result = md5.ComputeHash(result);\n+                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n+            }\n+            //showBytes(\"Final key material\", keymaterial);\n+            byte[] deskey = new byte[24];\n+            Array.Copy(keymaterial, deskey, deskey.Length);\n+\n+            Array.Clear(psbytes, 0, psbytes.Length);\n+            Array.Clear(data00, 0, data00.Length);\n+            Array.Clear(result, 0, result.Length);\n+            Array.Clear(hashtarget, 0, hashtarget.Length);\n+            Array.Clear(keymaterial, 0, keymaterial.Length);\n+\n+            return deskey;\n+        }\n+\n+        public static string GetRSASignb64encode(string private_key_path, byte[] digest)\n+        {\n+            RSACryptoServiceProvider cipher = new RSACryptoServiceProvider();\n+            cipher = GetRSAProviderFromPemFile(private_key_path);\n+            RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(cipher);\n+            RSAFormatter.SetHashAlgorithm(\"SHA256\");\n+            byte[] signedHash = RSAFormatter.CreateSignature(digest);\n+            return Convert.ToBase64String(signedHash);\n+        }\n+\n+        public static RSACryptoServiceProvider GetRSAProviderFromPemFile(String pemfile)\n+        {\n+            bool isPrivateKeyFile = true;\n+            if (!File.Exists(pemfile))\n+            {\n+                throw new Exception(\"pemfile does not exist.\");\n+            }\n+            string pemstr = File.ReadAllText(pemfile).Trim();\n+            if (pemstr.StartsWith(pempubheader) && pemstr.EndsWith(pempubfooter))\n+                isPrivateKeyFile = false;\n+\n+            byte[] pemkey = null;\n+            if (isPrivateKeyFile)\n+                pemkey = DecodeOpenSSLPrivateKey(pemstr);\n+\n+\n+            if (pemkey == null)\n+                return null;\n+\n+            if (isPrivateKeyFile)\n+            {\n+                return DecodeRSAPrivateKey(pemkey);\n+            }\n+            return null;\n+        }\n+\n+        static byte[] DecryptKey(byte[] cipherData, byte[] desKey, byte[] IV)\n+        {\n+            MemoryStream memst = new MemoryStream();\n+            TripleDES alg = TripleDES.Create();\n+            alg.Key = desKey;\n+            alg.IV = IV;\n+            try\n+            {\n+                CryptoStream cs = new CryptoStream(memst, alg.CreateDecryptor(), CryptoStreamMode.Write);\n+                cs.Write(cipherData, 0, cipherData.Length);\n+                cs.Close();\n+            }\n+            catch (Exception exc)\n+            {\n+                Console.WriteLine(exc.Message);\n+                return null;\n+            }\n+            byte[] decryptedData = memst.ToArray();\n+            return decryptedData;\n+        }\n+\n+        static SecureString GetSecPswd(String prompt)\n+        {\n+            SecureString password = new SecureString();\n+\n+            Console.ForegroundColor = ConsoleColor.Gray;\n+            Console.ForegroundColor = ConsoleColor.Magenta;\n+\n+            while (true)\n+            {\n+                ConsoleKeyInfo cki = Console.ReadKey(true);", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NTI1Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r422045257", "bodyText": "removed the console for password input, value can be provided using method argument", "author": "Ghufz", "createdAt": "2020-05-08T09:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Njg4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421786881", "bodyText": "This is an unusual word contraction. Is there any reason you can't use \"Password\"?", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:53:05Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();\n+            //byte[] psbytes = utf8.GetBytes(pswd);\n+\n+            // --- contatenate salt and pswd bytes into fixed data array ---\n+            byte[] data00 = new byte[psbytes.Length + salt.Length];\n+            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+            MD5 md5 = new MD5CryptoServiceProvider();\n+            byte[] result = null;\n+            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+            for (int j = 0; j < miter; j++)\n+            {\n+                // ----  Now hash consecutively for count times ------\n+                if (j == 0)\n+                    result = data00;    //initialize \n+                else\n+                {\n+                    Array.Copy(result, hashtarget, result.Length);\n+                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+                    result = hashtarget;\n+                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n+                    //showBytes(result) ;\n+                }\n+\n+                for (int i = 0; i < count; i++)\n+                    result = md5.ComputeHash(result);\n+                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n+            }\n+            //showBytes(\"Final key material\", keymaterial);\n+            byte[] deskey = new byte[24];\n+            Array.Copy(keymaterial, deskey, deskey.Length);\n+\n+            Array.Clear(psbytes, 0, psbytes.Length);\n+            Array.Clear(data00, 0, data00.Length);\n+            Array.Clear(result, 0, result.Length);\n+            Array.Clear(hashtarget, 0, hashtarget.Length);\n+            Array.Clear(keymaterial, 0, keymaterial.Length);\n+\n+            return deskey;\n+        }\n+\n+        public static string GetRSASignb64encode(string private_key_path, byte[] digest)\n+        {\n+            RSACryptoServiceProvider cipher = new RSACryptoServiceProvider();\n+            cipher = GetRSAProviderFromPemFile(private_key_path);\n+            RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(cipher);\n+            RSAFormatter.SetHashAlgorithm(\"SHA256\");\n+            byte[] signedHash = RSAFormatter.CreateSignature(digest);\n+            return Convert.ToBase64String(signedHash);\n+        }\n+\n+        public static RSACryptoServiceProvider GetRSAProviderFromPemFile(String pemfile)\n+        {\n+            bool isPrivateKeyFile = true;\n+            if (!File.Exists(pemfile))\n+            {\n+                throw new Exception(\"pemfile does not exist.\");\n+            }\n+            string pemstr = File.ReadAllText(pemfile).Trim();\n+            if (pemstr.StartsWith(pempubheader) && pemstr.EndsWith(pempubfooter))\n+                isPrivateKeyFile = false;\n+\n+            byte[] pemkey = null;\n+            if (isPrivateKeyFile)\n+                pemkey = DecodeOpenSSLPrivateKey(pemstr);\n+\n+\n+            if (pemkey == null)\n+                return null;\n+\n+            if (isPrivateKeyFile)\n+            {\n+                return DecodeRSAPrivateKey(pemkey);\n+            }\n+            return null;\n+        }\n+\n+        static byte[] DecryptKey(byte[] cipherData, byte[] desKey, byte[] IV)\n+        {\n+            MemoryStream memst = new MemoryStream();\n+            TripleDES alg = TripleDES.Create();\n+            alg.Key = desKey;\n+            alg.IV = IV;\n+            try\n+            {\n+                CryptoStream cs = new CryptoStream(memst, alg.CreateDecryptor(), CryptoStreamMode.Write);\n+                cs.Write(cipherData, 0, cipherData.Length);\n+                cs.Close();\n+            }\n+            catch (Exception exc)\n+            {\n+                Console.WriteLine(exc.Message);\n+                return null;\n+            }\n+            byte[] decryptedData = memst.ToArray();\n+            return decryptedData;\n+        }\n+\n+        static SecureString GetSecPswd(String prompt)", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA0NDE5MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r422044191", "bodyText": "done", "author": "Ghufz", "createdAt": "2020-05-08T09:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Njg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4ODcwNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421788706", "bodyText": "typo: reterieve", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:56:19Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5MDU1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421790556", "bodyText": "You should make it clear which specific RSA signing algorithm is used. Is it RSASSA-PSS or RSA PKCS v1.5? Ideally this would be configurable by the client.", "author": "sebastien-rosset", "createdAt": "2020-05-07T20:59:39Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n+.OUTPUTS\n+PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n+#>\n+function Get-{{{apiNamePrefix}}}APIKeyInfo {\n+    $ApiKeysList = $Script:Configuration['ApiKey']\n+    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n+    $apiPrefix = \"Signature\"\n+\n+    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n+        throw \"Unable to reterieve the api key details\"\n+    }\n+\n+    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n+        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n+    }\n+\n+    foreach ($item in $ApiKeysList.GetEnumerator()) {\n+        if (![string]::IsNullOrEmpty($item.Name)) {\n+            if (Test-Path -Path $item.Value) {\n+                $apiKey = $item.Value\n+                $apikeyId = $item.Name\n+                break;\n+            }\n+            else {\n+                throw \"API key file path does not exist.\"\n+            }\n+        }\n+    }\n+\n+    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n+        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n+    }\n+\n+    if ($apikeyId -and $apiKey -and $apiPrefix) {\n+        $result = New-Object -Type PSCustomObject -Property @{ \n+            ApiKeyId       = $apikeyId;\n+            ApiKeyFilePath = $apiKey\n+            ApiKeyPrefix   = $apiPrefix\n+        }\n+    }\n+    else {\n+        return $null\n+    }\n+    return $result\n+}\n+\n+<#\n+.SYNOPSIS\n+    Gets the headers for http signed auth.\n+\n+.DESCRIPTION\n+    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+.PARAMETER Method\n+    Http method\n+.PARAMETER UriBuilder\n+    UriBuilder for url and query parameter\n+.PARAMETER Body\n+    Request body\n+.OUTPUTS\n+    Hashtable\n+#>\n+function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+    param(\n+        [string]$Method,\n+        [System.UriBuilder]$UriBuilder,\n+        [string]$Body\n+    )\n+\n+    #Hash table to store singed headers\n+    $HttpSignedHeader = @{}\n+    $TargetHost = $UriBuilder.Host\n+\n+    #Check for Authentication type\n+    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n+    if ($null -eq $apiKeyInfo) {\n+        throw \"Unable to reterieve the api key info \"\n+    }\n+\n+    #get the body digest\n+    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n+    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+\n+    #get the date in UTC\n+    $dateTime = Get-Date\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n+    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n+    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n+    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n+    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+\n+    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n+                                    $h_requestTarget,$h_cdate,\n+                                    $h_targetHost,$h_digest)\n+    \n+    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n+    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5MTM4MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421791380", "bodyText": "It's not an \"OpenSSL\" private key, it's a private key encoded in PEM format.", "author": "sebastien-rosset", "createdAt": "2020-05-07T21:01:07Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyMjc2Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421822767", "bodyText": "It would be good to document which of the methods are public versus which one are for internal use.", "author": "sebastien-rosset", "createdAt": "2020-05-07T22:07:28Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/http_signature_auth.mustache", "diffHunk": "@@ -0,0 +1,162 @@\n+{{>partial_header}}\n+<#\n+.SYNOPSIS\n+Get the API key Id and API key file path.\n+\n+.DESCRIPTION\n+Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNjg5Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421826893", "bodyText": "Remove this line", "author": "sebastien-rosset", "createdAt": "2020-05-07T22:18:06Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();\n+            //byte[] psbytes = utf8.GetBytes(pswd);\n+\n+            // --- contatenate salt and pswd bytes into fixed data array ---\n+            byte[] data00 = new byte[psbytes.Length + salt.Length];\n+            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+            MD5 md5 = new MD5CryptoServiceProvider();\n+            byte[] result = null;\n+            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+            for (int j = 0; j < miter; j++)\n+            {\n+                // ----  Now hash consecutively for count times ------\n+                if (j == 0)\n+                    result = data00;    //initialize \n+                else\n+                {\n+                    Array.Copy(result, hashtarget, result.Length);\n+                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+                    result = hashtarget;\n+                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n+                    //showBytes(result) ;\n+                }\n+\n+                for (int i = 0; i < count; i++)\n+                    result = md5.ComputeHash(result);\n+                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n+            }\n+            //showBytes(\"Final key material\", keymaterial);", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgyNzc2Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6176#discussion_r421827767", "bodyText": "Ah ok, finally I found the code location that configures the specific signature algorithm. This needs to be parameterized, with support for RSA PKCS v1.5 and RSA SSA. Also, this needs to be documentation in the user documentation.", "author": "sebastien-rosset", "createdAt": "2020-05-07T22:20:21Z", "path": "modules/openapi-generator/src/main/resources/powershell-experimental/rsa_provider.mustache", "diffHunk": "@@ -0,0 +1,377 @@\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Security;\n+using System.Security.Cryptography;\n+using System.Text;\n+\n+namespace RSAEncryption\n+{\n+    public class RSAEncryptionProvider\n+    {\n+\n+        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n+        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n+        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n+        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n+        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n+        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+        {\n+            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+            MemoryStream mem = new MemoryStream(privkey);\n+            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+            byte bt = 0;\n+            ushort twobytes = 0;\n+            int elems = 0;\n+            try\n+            {\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+                    binr.ReadByte();    //advance 1 byte\n+                else if (twobytes == 0x8230)\n+                    binr.ReadInt16();   //advance 2 bytes\n+                else\n+                    return null;\n+\n+                twobytes = binr.ReadUInt16();\n+                if (twobytes != 0x0102) //version number\n+                    return null;\n+                bt = binr.ReadByte();\n+                if (bt != 0x00)\n+                    return null;\n+\n+\n+                //------  all private key components are Integer sequences ----\n+                elems = GetIntegerSize(binr);\n+                MODULUS = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                E = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                D = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                P = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                Q = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DP = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                DQ = binr.ReadBytes(elems);\n+\n+                elems = GetIntegerSize(binr);\n+                IQ = binr.ReadBytes(elems);\n+\n+                /*Console.WriteLine(\"showing components ..\");\n+                if (true)\n+                {\n+                    showBytes(\"\\nModulus\", MODULUS);\n+                    showBytes(\"\\nExponent\", E);\n+                    showBytes(\"\\nD\", D);\n+                    showBytes(\"\\nP\", P);\n+                    showBytes(\"\\nQ\", Q);\n+                    showBytes(\"\\nDP\", DP);\n+                    showBytes(\"\\nDQ\", DQ);\n+                    showBytes(\"\\nIQ\", IQ);\n+                }*/\n+\n+                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+                RSAParameters RSAparams = new RSAParameters();\n+                RSAparams.Modulus = MODULUS;\n+                RSAparams.Exponent = E;\n+                RSAparams.D = D;\n+                RSAparams.P = P;\n+                RSAparams.Q = Q;\n+                RSAparams.DP = DP;\n+                RSAparams.DQ = DQ;\n+                RSAparams.InverseQ = IQ;\n+                RSA.ImportParameters(RSAparams);\n+                return RSA;\n+            }\n+            catch (Exception)\n+            {\n+                return null;\n+            }\n+            finally { binr.Close(); }\n+        }\n+\n+        private static int GetIntegerSize(BinaryReader binr)\n+        {\n+            byte bt = 0;\n+            byte lowbyte = 0x00;\n+            byte highbyte = 0x00;\n+            int count = 0;\n+            bt = binr.ReadByte();\n+            if (bt != 0x02)     //expect integer\n+                return 0;\n+            bt = binr.ReadByte();\n+\n+            if (bt == 0x81)\n+                count = binr.ReadByte();    // data size in next byte\n+            else\n+                if (bt == 0x82)\n+            {\n+                highbyte = binr.ReadByte(); // data size in next 2 bytes\n+                lowbyte = binr.ReadByte();\n+                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+                count = BitConverter.ToInt32(modint, 0);\n+            }\n+            else\n+            {\n+                count = bt;     // we already have the data size\n+            }\n+            while (binr.ReadByte() == 0x00)\n+            {   //remove high order zeros in data\n+                count -= 1;\n+            }\n+            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n+            //last ReadByte wasn't a removed zero, so back up a byte\n+            return count;\n+        }\n+\n+        static byte[] DecodeOpenSSLPrivateKey(String instr)\n+        {\n+            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+            String pemstr = instr.Trim();\n+            byte[] binkey;\n+            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+                return null;\n+\n+            StringBuilder sb = new StringBuilder(pemstr);\n+            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n+            sb.Replace(pemprivfooter, \"\");\n+\n+            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n+\n+            try\n+            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+                binkey = Convert.FromBase64String(pvkstr);\n+                return binkey;\n+            }\n+            catch (System.FormatException)\n+            {       //if can't b64 decode, it must be an encrypted private key\n+                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n+            }\n+\n+            StringReader str = new StringReader(pvkstr);\n+\n+            //-------- read PEM encryption info. lines and extract salt -----\n+            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+                return null;\n+            String saltline = str.ReadLine();\n+            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+                return null;\n+            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+            byte[] salt = new byte[saltstr.Length / 2];\n+            for (int i = 0; i < salt.Length; i++)\n+                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+            if (!(str.ReadLine() == \"\"))\n+                return null;\n+\n+            //------ remaining b64 data is encrypted RSA key ----\n+            String encryptedstr = str.ReadToEnd();\n+\n+            try\n+            {   //should have b64 encrypted RSA key now\n+                binkey = Convert.FromBase64String(encryptedstr);\n+            }\n+            catch (System.FormatException)\n+            {  // bad b64 data.\n+                return null;\n+            }\n+\n+            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n+\n+            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n+            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n+            //String pswd = Console.ReadLine();\n+            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+            if (deskey == null)\n+                return null;\n+            //showBytes(\"3DES key\", deskey) ;\n+\n+            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+            if (rsakey != null)\n+                return rsakey;  //we have a decrypted RSA private key\n+            else\n+            {\n+                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n+                return null;\n+            }\n+        }\n+\n+        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n+        {\n+            IntPtr unmanagedPswd = IntPtr.Zero;\n+            int HASHLENGTH = 16;    //MD5 bytes\n+            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\n+            byte[] psbytes = new byte[secpswd.Length];\n+            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+            //UTF8Encoding utf8 = new UTF8Encoding();\n+            //byte[] psbytes = utf8.GetBytes(pswd);\n+\n+            // --- contatenate salt and pswd bytes into fixed data array ---\n+            byte[] data00 = new byte[psbytes.Length + salt.Length];\n+            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+            MD5 md5 = new MD5CryptoServiceProvider();\n+            byte[] result = null;\n+            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+            for (int j = 0; j < miter; j++)\n+            {\n+                // ----  Now hash consecutively for count times ------\n+                if (j == 0)\n+                    result = data00;    //initialize \n+                else\n+                {\n+                    Array.Copy(result, hashtarget, result.Length);\n+                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+                    result = hashtarget;\n+                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n+                    //showBytes(result) ;\n+                }\n+\n+                for (int i = 0; i < count; i++)\n+                    result = md5.ComputeHash(result);\n+                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n+            }\n+            //showBytes(\"Final key material\", keymaterial);\n+            byte[] deskey = new byte[24];\n+            Array.Copy(keymaterial, deskey, deskey.Length);\n+\n+            Array.Clear(psbytes, 0, psbytes.Length);\n+            Array.Clear(data00, 0, data00.Length);\n+            Array.Clear(result, 0, result.Length);\n+            Array.Clear(hashtarget, 0, hashtarget.Length);\n+            Array.Clear(keymaterial, 0, keymaterial.Length);\n+\n+            return deskey;\n+        }\n+\n+        public static string GetRSASignb64encode(string private_key_path, byte[] digest)\n+        {\n+            RSACryptoServiceProvider cipher = new RSACryptoServiceProvider();\n+            cipher = GetRSAProviderFromPemFile(private_key_path);\n+            RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(cipher);", "originalCommit": "5372b5ae8adb29e532afb3d45f51571b6a171127", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}