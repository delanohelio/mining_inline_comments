{"pr_number": 6397, "pr_title": "[PS] Refactor the http signing auth with ecdsa support", "pr_createdAt": "2020-05-22T08:52:14Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/6397", "timeline": [{"oid": "49f2b4bb8064d385f08b8a5cc04da176b0d557aa", "url": "https://github.com/OpenAPITools/openapi-generator/commit/49f2b4bb8064d385f08b8a5cc04da176b0d557aa", "message": "Merge pull request #1 from OpenAPITools/master\n\ntest", "committedDate": "2020-04-16T11:43:24Z", "type": "commit"}, {"oid": "ad24d348d28835edfc90385a33357d6d51eef02d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ad24d348d28835edfc90385a33357d6d51eef02d", "message": "ValidatePattern having double quote(\") throws exception on running Build.ps1", "committedDate": "2020-04-16T11:59:58Z", "type": "commit"}, {"oid": "8bcd51d6a5cdaf81f1b274f293132bb012cf69a9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8bcd51d6a5cdaf81f1b274f293132bb012cf69a9", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-04-17T04:42:18Z", "type": "commit"}, {"oid": "ff0094804ab7c885251b31ad3a60a058c24006c0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ff0094804ab7c885251b31ad3a60a058c24006c0", "message": "fix tab with space", "committedDate": "2020-04-17T07:50:52Z", "type": "commit"}, {"oid": "f865bd8eb8410394d938a502902231fc6331b444", "url": "https://github.com/OpenAPITools/openapi-generator/commit/f865bd8eb8410394d938a502902231fc6331b444", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-05T10:09:49Z", "type": "commit"}, {"oid": "1d0d4e14ecb102e453559d04b65c9dc4377bb0d7", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1d0d4e14ecb102e453559d04b65c9dc4377bb0d7", "message": "[powershell-experimental] : http signature auth", "committedDate": "2020-05-05T10:47:45Z", "type": "commit"}, {"oid": "5372b5ae8adb29e532afb3d45f51571b6a171127", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5372b5ae8adb29e532afb3d45f51571b6a171127", "message": "fix the tab issue", "committedDate": "2020-05-05T11:25:19Z", "type": "commit"}, {"oid": "e6a43442a809d3bdb602828c47ffe7f977f0a508", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e6a43442a809d3bdb602828c47ffe7f977f0a508", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-22T07:26:26Z", "type": "commit"}, {"oid": "c6a6a82a76a2326799093b6ffe219a174dd62620", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c6a6a82a76a2326799093b6ffe219a174dd62620", "message": "merge cnflict fix for powershell experimental", "committedDate": "2020-05-22T07:30:16Z", "type": "commit"}, {"oid": "0d66824619223487bd519b0bceb243621a0df8ce", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0d66824619223487bd519b0bceb243621a0df8ce", "message": "Htpp signing : added support for ecdsa", "committedDate": "2020-05-22T08:44:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMjM0NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429302345", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw \"SignatureValidityPeriod must be greater that 0 seconds.\"\n          \n          \n            \n                    throw \"SignatureValidityPeriod must be greater than 0 seconds.\"", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:06:25Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the http signing key is protected\n+\n+.PARAMETER HttpSigningHeader\n+HttpSigningHeader list of http headers used to calculate the signature, Accepted values are \n+\"(request-target), (created), (expires), Host, Date, Digest\". If no headers are specified then '(created)' sets as default.\n+\n+.PARAMETER HashAlgorithm\n+HashAlgrithm to calculate the hash, Supported values are \"sha256\" and \"sha512\"\n+\n+.PARAMETER SigningAlgorithm\n+SigningAlgorithm specifies the signature algorithm, supported values are \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\" \n+RSA key : Supported values \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\", for ECDSA key this parameter is not applicable\n+\n+.PARAMETER SignatureValidityPeriod\n+SignatureValidityPeriod specifies the signature maximum validity time in seconds. It accepts interger value \n+\n+.OUTPUTS\n+\n+System.Collections.Hashtable\n+#>\n+function Set-{{apiNamePrefix}}ConfigurationHttpSigning{\n+    [CmdletBinding()]\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [ValidateNotNullOrEmpty()]\n+        [string]$KeyId,\n+        [Parameter(Mandatory = $true)]\n+        [string]$KeyFilePath,\n+        [Parameter(Mandatory = $false)]\n+        [securestring]$KeyPassPhrase,\n+        [Parameter(Mandatory = $false)]\n+        [ValidateNotNullOrEmpty()]\n+        [ValidateSet(\"(request-target)\",\"(created)\",\"(expires)\",\"Host\",\"Date\",\"Digest\")]\n+        [string[]] $HttpSigningHeader = @(\"(created)\"),\n+        [Parameter(Mandatory = $false)]\n+        [ValidateSet(\"sha256\",\"sha512\")]\n+        [string] $HashAlgorithm = \"sha256\",\n+        [Parameter(Mandatory = $false)]\n+        [ValidateSet(\"RSASSA-PKCS1-v1_5\",\"RSASSA-PSS\")]\n+        [string]$SigningAlgorithm ,\n+        [Parameter(Mandatory = $false)]\n+        [int]$SignatureValidityPeriod\n+    )\n+\n+    Process{\n+    $httpSignatureConfiguration = @{}\n+\n+    if(Test-Path -Path $KeyFilePath){\n+        $httpSignatureConfiguration[\"KeyId\"] = $KeyId\n+        $httpSignatureConfiguration[\"KeyFilePath\"] = $KeyFilePath\n+    }else{\n+        throw \"Private key file path does not exist\"\n+    }\n+\n+    $keyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $KeyFilePath\n+    if([String]::IsNullOrEmpty($SigningAlgorithm)){\n+        if($keyType -eq \"RSA\"){\n+            $SigningAlgorithm = \"RSASSA-PKCS1-v1_5\"\n+        }\n+    }\n+\n+    if($keyType -eq \"RSA\" -and \n+        ($SigningAlgorithm -ne \"RSASSA-PKCS1-v1_5\" -and $SigningAlgorithm -ne \"RSASSA-PSS\" ))\n+        {\n+            throw \"Provided Key and SigningAlgorithm : $SigningAlgorithm is not compatible.\"\n+        }\n+    \n+\n+    if($HttpSigningHeader -contains \"(expires)\" -and $SignatureValidityPeriod -le 0){\n+        throw \"SignatureValidityPeriod must be greater that 0 seconds.\"", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMzMyNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429303326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SignatureValidityPeriod specifies the signature maximum validity time in seconds. It accepts interger value \n          \n          \n            \n            SignatureValidityPeriod specifies the signature maximum validity time in seconds. It accepts integer value", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:08:18Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the http signing key is protected\n+\n+.PARAMETER HttpSigningHeader\n+HttpSigningHeader list of http headers used to calculate the signature, Accepted values are \n+\"(request-target), (created), (expires), Host, Date, Digest\". If no headers are specified then '(created)' sets as default.\n+\n+.PARAMETER HashAlgorithm\n+HashAlgrithm to calculate the hash, Supported values are \"sha256\" and \"sha512\"\n+\n+.PARAMETER SigningAlgorithm\n+SigningAlgorithm specifies the signature algorithm, supported values are \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\" \n+RSA key : Supported values \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\", for ECDSA key this parameter is not applicable\n+\n+.PARAMETER SignatureValidityPeriod\n+SignatureValidityPeriod specifies the signature maximum validity time in seconds. It accepts interger value ", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMzk2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429303961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            KeyId for http signing \n          \n          \n            \n            KeyId for HTTP signing", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:09:33Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing ", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNDA2NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429304065", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            KeyFilePath for http signing\n          \n          \n            \n            KeyFilePath for HTTP signing", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:09:43Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNDE1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429304159", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            KeyPassPhrase, if the http signing key is protected\n          \n          \n            \n            KeyPassPhrase, if the HTTP signing key is protected", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:09:54Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the http signing key is protected", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNDM0Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429304346", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            HttpSigningHeader list of http headers used to calculate the signature, Accepted values are \n          \n          \n            \n            HttpSigningHeader list of HTTP headers used to calculate the signature, Accepted values are", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:10:15Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the http signing key is protected\n+\n+.PARAMETER HttpSigningHeader\n+HttpSigningHeader list of http headers used to calculate the signature, Accepted values are ", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTIxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429305216", "bodyText": "User should be allowed to set any HTTP header present in the request, plus the special HTTP header fields. For example, they should be able to include Content-Type in the HTTP signature.", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:11:58Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -373,3 +373,134 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for http signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for http signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the http signing key is protected\n+\n+.PARAMETER HttpSigningHeader\n+HttpSigningHeader list of http headers used to calculate the signature, Accepted values are \n+\"(request-target), (created), (expires), Host, Date, Digest\". If no headers are specified then '(created)' sets as default.", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNjYyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429306623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n          \n          \n            \n                        -KeyPassPhrase $httpSigningConfiguration.KeyPassPhrase `", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:14:21Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNjkwNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429306904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n          \n          \n            \n                    $headerSignatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:14:52Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNzI4NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429307284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Gets the RSA signature for the http signing \n          \n          \n            \n                Gets the RSA signature for the HTTP signing", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:15:32Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing ", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNzUyOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429307528", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .PARAMETER KeyPassPharse\n          \n          \n            \n            .PARAMETER KeyPassPhrase", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:16:01Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNzgxOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429307819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                KeyPassPharse for the encrypted key\n          \n          \n            \n                KeyPassPhrase for the encrypted key", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:16:35Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNzk1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429307956", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    [securestring]$KeyPassPharse\n          \n          \n            \n                    [securestring]$KeyPassPhrase", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:16:52Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwODM2Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429308363", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Gets the ECDSA signature for the http signing \n          \n          \n            \n                Gets the ECDSA signature for the HTTP signing", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:17:40Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse\n     )\n     try {\n         \n-        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n-        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n-        Add-Type -TypeDefinition $rsa_provider_sourceCode\n-        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n-        if ($null -eq $signed_string) {\n-            throw \"Unable to sign the header using the API key\"\n+        if ($hashAlgorithmName -eq \"sha256\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA256\n+        }\n+        elseif ($hashAlgorithmName -eq \"sha512\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA512\n+        }\n+\n+        if ($PSVersionTable.PSVersion.Major -ge 7) {\n+            $ecKeyHeader = \"-----BEGIN RSA PRIVATE KEY-----\"\n+            $ecKeyFooter = \"-----END RSA PRIVATE KEY-----\"\n+            $keyStr = Get-Content -Path $PrivateKeyFilePath -Raw\n+            $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+            $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+            $rsa = [System.Security.Cryptography.RSACng]::new()\n+            [int]$bytCount = 0\n+            $rsa.ImportRSAPrivateKey($keyBytes, [ref] $bytCount)\n+\n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pss)\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+        }\n+        else {\n+            $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{apiNamePrefix}}RSAEncryptionProvider.cs\"\n+            $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+            Add-Type -TypeDefinition $rsa_provider_sourceCode \n+    \n+            [System.Security.Cryptography.RSA]$rsa = [RSAEncryption.RSAEncryptionProvider]::GetRSAProviderFromPemFile($PrivateKeyFilePath, $KeyPassPharse)\n+            \n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                throw \"$SigningAlgorithm is not supported on $($PSVersionTable.PSVersion)\"\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+           \n         }\n-        return $signed_string\n+\n+        $signedString = [Convert]::ToBase64String($signedBytes)\n+        return $signedString\n     }\n     catch {\n         throw $_\n     }\n }\n+\n+<#\n+.SYNOPSIS\n+    Gets the ECDSA signature\n+\n+.DESCRIPTION\n+    Gets the ECDSA signature for the http signing ", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwODU2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429308561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .PARAMETER KeyPassPharse\n          \n          \n            \n            .PARAMETER KeyPassPhrase", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:18:04Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse\n     )\n     try {\n         \n-        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n-        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n-        Add-Type -TypeDefinition $rsa_provider_sourceCode\n-        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n-        if ($null -eq $signed_string) {\n-            throw \"Unable to sign the header using the API key\"\n+        if ($hashAlgorithmName -eq \"sha256\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA256\n+        }\n+        elseif ($hashAlgorithmName -eq \"sha512\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA512\n+        }\n+\n+        if ($PSVersionTable.PSVersion.Major -ge 7) {\n+            $ecKeyHeader = \"-----BEGIN RSA PRIVATE KEY-----\"\n+            $ecKeyFooter = \"-----END RSA PRIVATE KEY-----\"\n+            $keyStr = Get-Content -Path $PrivateKeyFilePath -Raw\n+            $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+            $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+            $rsa = [System.Security.Cryptography.RSACng]::new()\n+            [int]$bytCount = 0\n+            $rsa.ImportRSAPrivateKey($keyBytes, [ref] $bytCount)\n+\n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pss)\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+        }\n+        else {\n+            $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{apiNamePrefix}}RSAEncryptionProvider.cs\"\n+            $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+            Add-Type -TypeDefinition $rsa_provider_sourceCode \n+    \n+            [System.Security.Cryptography.RSA]$rsa = [RSAEncryption.RSAEncryptionProvider]::GetRSAProviderFromPemFile($PrivateKeyFilePath, $KeyPassPharse)\n+            \n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                throw \"$SigningAlgorithm is not supported on $($PSVersionTable.PSVersion)\"\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+           \n         }\n-        return $signed_string\n+\n+        $signedString = [Convert]::ToBase64String($signedBytes)\n+        return $signedString\n     }\n     catch {\n         throw $_\n     }\n }\n+\n+<#\n+.SYNOPSIS\n+    Gets the ECDSA signature\n+\n+.DESCRIPTION\n+    Gets the ECDSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwODY5Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429308697", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                KeyPassPharse for the encrypted key\n          \n          \n            \n                KeyPassPhrase for the encrypted key", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:18:21Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse\n     )\n     try {\n         \n-        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n-        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n-        Add-Type -TypeDefinition $rsa_provider_sourceCode\n-        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n-        if ($null -eq $signed_string) {\n-            throw \"Unable to sign the header using the API key\"\n+        if ($hashAlgorithmName -eq \"sha256\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA256\n+        }\n+        elseif ($hashAlgorithmName -eq \"sha512\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA512\n+        }\n+\n+        if ($PSVersionTable.PSVersion.Major -ge 7) {\n+            $ecKeyHeader = \"-----BEGIN RSA PRIVATE KEY-----\"\n+            $ecKeyFooter = \"-----END RSA PRIVATE KEY-----\"\n+            $keyStr = Get-Content -Path $PrivateKeyFilePath -Raw\n+            $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+            $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+            $rsa = [System.Security.Cryptography.RSACng]::new()\n+            [int]$bytCount = 0\n+            $rsa.ImportRSAPrivateKey($keyBytes, [ref] $bytCount)\n+\n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pss)\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+        }\n+        else {\n+            $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{apiNamePrefix}}RSAEncryptionProvider.cs\"\n+            $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+            Add-Type -TypeDefinition $rsa_provider_sourceCode \n+    \n+            [System.Security.Cryptography.RSA]$rsa = [RSAEncryption.RSAEncryptionProvider]::GetRSAProviderFromPemFile($PrivateKeyFilePath, $KeyPassPharse)\n+            \n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                throw \"$SigningAlgorithm is not supported on $($PSVersionTable.PSVersion)\"\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+           \n         }\n-        return $signed_string\n+\n+        $signedString = [Convert]::ToBase64String($signedBytes)\n+        return $signedString\n     }\n     catch {\n         throw $_\n     }\n }\n+\n+<#\n+.SYNOPSIS\n+    Gets the ECDSA signature\n+\n+.DESCRIPTION\n+    Gets the ECDSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwOTU0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429309544", "bodyText": "Add a comment indicating SHA1 should not be used.", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:20:00Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse\n     )\n     try {\n         \n-        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n-        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n-        Add-Type -TypeDefinition $rsa_provider_sourceCode\n-        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n-        if ($null -eq $signed_string) {\n-            throw \"Unable to sign the header using the API key\"\n+        if ($hashAlgorithmName -eq \"sha256\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA256\n+        }\n+        elseif ($hashAlgorithmName -eq \"sha512\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA512\n+        }\n+\n+        if ($PSVersionTable.PSVersion.Major -ge 7) {\n+            $ecKeyHeader = \"-----BEGIN RSA PRIVATE KEY-----\"\n+            $ecKeyFooter = \"-----END RSA PRIVATE KEY-----\"\n+            $keyStr = Get-Content -Path $PrivateKeyFilePath -Raw\n+            $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+            $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+            $rsa = [System.Security.Cryptography.RSACng]::new()\n+            [int]$bytCount = 0\n+            $rsa.ImportRSAPrivateKey($keyBytes, [ref] $bytCount)\n+\n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pss)\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+        }\n+        else {\n+            $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{apiNamePrefix}}RSAEncryptionProvider.cs\"\n+            $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+            Add-Type -TypeDefinition $rsa_provider_sourceCode \n+    \n+            [System.Security.Cryptography.RSA]$rsa = [RSAEncryption.RSAEncryptionProvider]::GetRSAProviderFromPemFile($PrivateKeyFilePath, $KeyPassPharse)\n+            \n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                throw \"$SigningAlgorithm is not supported on $($PSVersionTable.PSVersion)\"\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+           \n         }\n-        return $signed_string\n+\n+        $signedString = [Convert]::ToBase64String($signedBytes)\n+        return $signedString\n     }\n     catch {\n         throw $_\n     }\n }\n+\n+<#\n+.SYNOPSIS\n+    Gets the ECDSA signature\n+\n+.DESCRIPTION\n+    Gets the ECDSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n+.OUTPUTS\n+    Base64String\n+#>\n+function Get-{{apiNamePrefix}}ECDSASignature {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [string]$ECKeyFilePath,\n+        [Parameter(Mandatory = $true)]\n+        [byte[]]$DataToSign,\n+        [Parameter(Mandatory = $false)]\n+        [String]$HashAlgorithmName,\n+        [Parameter(Mandatory = $false)]\n+        [securestring]$KeyPassPharse\n+    )\n+    if (!(Test-Path -Path $ECKeyFilePath)) {\n+        throw \"key file path does not exist.\"\n+    }\n+\n+    if($PSVersionTable.PSVersion.Major -lt 7){\n+        throw \"ECDSA key is not supported on $($PSVersionTable.PSVersion), Use PSVersion 7.0 and above\"\n+    }\n+\n+    $ecKeyHeader = \"-----BEGIN EC PRIVATE KEY-----\"\n+    $ecKeyFooter = \"-----END EC PRIVATE KEY-----\"\n+    $keyStr = Get-Content -Path $ECKeyFilePath -Raw\n+    $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+    $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+\n+    #$cngKey = [System.Security.Cryptography.CngKey]::Import($keyBytes,[System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob)\n+    #$ecdsa = [System.Security.Cryptography.ECDsaCng]::New($cngKey)\n+    $ecdsa = [System.Security.Cryptography.ECDsaCng]::New()\n+    [int]$bytCount =0\n+    if(![string]::IsNullOrEmpty($KeyPassPharse)){\n+        $ecdsa.ImportEncryptedPkcs8PrivateKey($KeyPassPharse,$keyBytes,[ref]$bytCount)\n+    }\n+    else{\n+    $ecdsa.ImportPkcs8PrivateKey($keyBytes,[ref]$bytCount)\n+    }\n+    \n+    if ($HashAlgorithmName -eq \"sha512\") {\n+        $ecdsa.HashAlgorithm = [System.Security.Cryptography.CngAlgorithm]::Sha512\n+    }\n+    else {\n+        $ecdsa.HashAlgorithm = [System.Security.Cryptography.CngAlgorithm]::Sha256\n+    }\n+\n+    $signedBytes = $ecdsa.SignHash($DataToSign)\n+    $signedString = [System.Convert]::ToBase64String($signedBytes)\n+    return $signedString\n+\n+}\n+\n+\n <#\n .Synopsis\n     Gets the hash of string.\n .Description\n     Gets the hash of string\n+.Parameter String\n+    Specifies the string to calculate the hash\n+.Parameter HashName\n+    Specifies the hash name to calculate the hash, Accepted values are \"SHA1\", \"SHA256\" and \"SHA512\"", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwOTg5Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r429309897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <#this type of key can hold many type different types of private key, but here due lack of pem eader\n          \n          \n            \n                    <#this type of key can hold many type different types of private key, but here due lack of pem header", "author": "sebastien-rosset", "createdAt": "2020-05-22T15:20:43Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -66,97 +13,390 @@ function Get-{{{apiNamePrefix}}}APIKeyInfo {\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n         [string]$Body\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {\n+        $Digest = [String]::Format(\"SHA-512={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    \n+    $dateTime = Get-Date\n+    #get the date in UTC\n+    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+\n+    foreach ($headerItem in $httpSigningConfiguration.HttpSigningHeader) {\n+       \n+        if ($headerItem -eq $HEADER_REQUEST_TARGET) { \n+            $requestTargetPath = [string]::Format(\"{0} {1}{2}\", $Method.ToLower(), $UriBuilder.Path, $UriBuilder.Query)\n+            $HttpSignatureHeader.Add($HEADER_REQUEST_TARGET, $requestTargetPath)\n+        }\n+        elseif ($headerItem -eq $HEADER_CREATED) {\n+            $created = Get-{{apiNamePrefix}}UnixTime -Date $dateTime -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_CREATED, $created)\n+        }\n+        elseif ($headerItem -eq $HEADER_EXPIRES) {\n+            $expire = $dateTime.AddSeconds($httpSigningConfiguration.SignatureValidityPeriod)\n+            $expireEpocTime = Get-{{apiNamePrefix}}UnixTime -Date $expire -TotalTime TotalSeconds\n+            $HttpSignatureHeader.Add($HEADER_EXPIRES, $expireEpocTime)\n+        }\n+        elseif ($headerItem -eq $HEADER_HOST) {\n+            $HttpSignedRequestHeader[$HEADER_HOST] = $TargetHost\n+            $HttpSignatureHeader.Add($HEADER_HOST.ToLower(), $TargetHost)\n+        }\n+        elseif ($headerItem -eq $HEADER_DATE) {\n+            $HttpSignedRequestHeader[$HEADER_DATE] = $currentDate\n+            $HttpSignatureHeader.Add($HEADER_DATE.ToLower(), $currentDate)\n+        }\n+        elseif ($headerItem -eq $HEADER_DIGEST) {\n+            $HttpSignedRequestHeader[$HEADER_DIGEST] = $Digest\n+            $HttpSignatureHeader.Add($HEADER_DIGEST.ToLower(), $Digest)\n+        }\n+    }\n \n-    #Check for Authentication type\n-    $apiKeyInfo = Get-{{{apiNamePrefix}}}APIKeyInfo\n-    if ($null -eq $apiKeyInfo) {\n-        throw \"Unable to reterieve the api key info \"\n+    # header's name separated by space\n+    $headersKeysString = $HttpSignatureHeader.Keys -join \" \"\n+    $headerValuesList = @()\n+    foreach ($item in $HttpSignatureHeader.GetEnumerator()) {\n+        $headerValuesList += [string]::Format(\"{0}: {1}\", $item.Name, $item.Value)\n     }\n+    #Concatinate headers value separated by new line\n+    $headerValuesString = $headerValuesList -join \"`n\"\n+    \n+    #Gets the hash of the headers value\n+    $signatureHashString = Get-{{apiNamePrefix}}StringHash -String $headerValuesString -HashName $httpSigningConfiguration.HashAlgorithm\n \n-    #get the body digest\n-    $bodyHash = Get-{{{apiNamePrefix}}}StringHash -String $Body\n-    $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    #Gets the Key type to select the correct signing alogorithm\n+    $KeyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $httpSigningConfiguration.KeyFilePath\n \n-    #get the date in UTC\n-    $dateTime = Get-Date\n-    $currentDate = $dateTime.ToUniversalTime().ToString(\"r\")\n+    if ($keyType -eq \"RSA\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}RSASignature -PrivateKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm `\n+            -KeyPassPharse $httpSigningConfiguration.KeyPassPharse `\n+            -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm\n+    }\n+    elseif ($KeyType -eq \"EC\") {\n+        $headerSinatureStr = Get-{{apiNamePrefix}}ECDSASignature -ECKeyFilePath $httpSigningConfiguration.KeyFilePath `\n+            -DataToSign $signatureHashString `\n+            -HashAlgorithmName $httpSigningConfiguration.HashAlgorithm\n+    }\n+    #Depricated\n+    <#$cryptographicScheme = Get-{{apiNamePrefix}}CryptographicScheme -SigningAlgorithm $httpSigningConfiguration.SigningAlgorithm `\n+                                                 -HashAlgorithm $httpSigningConfiguration.HashAlgorithm\n+    #>\n+    $cryptographicScheme = \"hs2019\"\n+    $authorizationHeaderValue = [string]::Format(\"Signature keyId=\"\"{0}\"\",algorithm=\"\"{1}\"\"\",\n+        $httpSigningConfiguration.KeyId, $cryptographicScheme)\n \n-    $requestTargetPath = [string]::Format(\"{0} {1}{2}\",$Method.ToLower(),$UriBuilder.Path.ToLower(),$UriBuilder.Query)\n-    $h_requestTarget = [string]::Format(\"(request-target): {0}\",$requestTargetPath)\n-    $h_cdate = [string]::Format(\"date: {0}\",$currentDate)\n-    $h_digest = [string]::Format(\"digest: {0}\",$Digest)\n-    $h_targetHost = [string]::Format(\"host: {0}\",$TargetHost)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_CREATED)) {\n+        $authorizationHeaderValue += [string]::Format(\",created={0}\", $HttpSignatureHeader[$HEADER_CREATED])\n+    }\n \n-    $stringToSign = [String]::Format(\"{0}`n{1}`n{2}`n{3}\",\n-                                    $h_requestTarget,$h_cdate,\n-                                    $h_targetHost,$h_digest)\n+    if ($HttpSignatureHeader.ContainsKey($HEADER_EXPIRES)) {\n+        $authorizationHeaderValue += [string]::Format(\",expires={0}\", $HttpSignatureHeader[$HEADER_EXPIRES])\n+    }\n     \n-    $hashedString = Get-{{{apiNamePrefix}}}StringHash -String $stringToSign\n-    $signedHeader = Get-{{{apiNamePrefix}}}RSASHA256SignedString -APIKeyFilePath $apiKeyInfo.ApiKeyFilePath -DataToSign $hashedString\n-    $authorizationHeader = [string]::Format(\"{0} keyId=\"\"{1}\"\",algorithm=\"\"rsa-sha256\"\",headers=\"\"(request-target) date host digest\"\",signature=\"\"{2}\"\"\", \n-        $apiKeyInfo.ApiKeyPrefix, $apiKeyInfo.ApiKeyId, $signedHeader)\n+    $authorizationHeaderValue += [string]::Format(\",headers=\"\"{0}\"\",signature=\"\"{1}\"\"\", \n+        $headersKeysString , $headerSinatureStr)\n     \n-    $HttpSignedHeader[\"Date\"] = $currentDate\n-    $HttpSignedHeader[\"Host\"] = $TargetHost\n-    $HttpSignedHeader[\"Content-Type\"] = \"application/json\"\n-    $HttpSignedHeader[\"Digest\"] = $Digest\n-    $HttpSignedHeader[\"Authorization\"] = $authorizationHeader   \n-    return $HttpSignedHeader\n+    $HttpSignedRequestHeader[$HEADER_AUTHORIZATION] = $authorizationHeaderValue\n+    return $HttpSignedRequestHeader\n }\n \n <#\n .SYNOPSIS\n-    Gets the headers for http signed auth.\n+    Gets the RSA signature\n \n .DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n-.PARAMETER APIKeyFilePath\n+    Gets the RSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n     Specify the API key file path\n .PARAMETER DataToSign\n     Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n .OUTPUTS\n-    String\n+    Base64String\n #>\n-function Get-{{{apiNamePrefix}}}RSASHA256SignedString {\n+function Get-{{apiNamePrefix}}RSASignature {\n     Param(\n-        [string]$APIKeyFilePath,\n-        [byte[]]$DataToSign\n+        [string]$PrivateKeyFilePath,\n+        [byte[]]$DataToSign,\n+        [string]$HashAlgorithmName,\n+        [string]$SigningAlgorithm,\n+        [securestring]$KeyPassPharse\n     )\n     try {\n         \n-        $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{{apiNamePrefix}}}RSAEncryptionProvider.cs\"\n-        $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n-        Add-Type -TypeDefinition $rsa_provider_sourceCode\n-        $signed_string = [RSAEncryption.RSAEncryptionProvider]::GetRSASignb64encode($APIKeyFilePath, $DataToSign)\n-        if ($null -eq $signed_string) {\n-            throw \"Unable to sign the header using the API key\"\n+        if ($hashAlgorithmName -eq \"sha256\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA256\n+        }\n+        elseif ($hashAlgorithmName -eq \"sha512\") {\n+            $hashAlgo = [System.Security.Cryptography.HashAlgorithmName]::SHA512\n+        }\n+\n+        if ($PSVersionTable.PSVersion.Major -ge 7) {\n+            $ecKeyHeader = \"-----BEGIN RSA PRIVATE KEY-----\"\n+            $ecKeyFooter = \"-----END RSA PRIVATE KEY-----\"\n+            $keyStr = Get-Content -Path $PrivateKeyFilePath -Raw\n+            $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+            $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+            $rsa = [System.Security.Cryptography.RSACng]::new()\n+            [int]$bytCount = 0\n+            $rsa.ImportRSAPrivateKey($keyBytes, [ref] $bytCount)\n+\n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pss)\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+        }\n+        else {\n+            $rsa_provider_path = Join-Path -Path $PSScriptRoot -ChildPath \"{{apiNamePrefix}}RSAEncryptionProvider.cs\"\n+            $rsa_provider_sourceCode = Get-Content -Path $rsa_provider_path -Raw\n+            Add-Type -TypeDefinition $rsa_provider_sourceCode \n+    \n+            [System.Security.Cryptography.RSA]$rsa = [RSAEncryption.RSAEncryptionProvider]::GetRSAProviderFromPemFile($PrivateKeyFilePath, $KeyPassPharse)\n+            \n+            if ($SigningAlgorithm -eq \"RSASSA-PSS\") {\n+                throw \"$SigningAlgorithm is not supported on $($PSVersionTable.PSVersion)\"\n+            }\n+            else {\n+                $signedBytes = $rsa.SignHash($DataToSign, $hashAlgo, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)\n+            }\n+           \n         }\n-        return $signed_string\n+\n+        $signedString = [Convert]::ToBase64String($signedBytes)\n+        return $signedString\n     }\n     catch {\n         throw $_\n     }\n }\n+\n+<#\n+.SYNOPSIS\n+    Gets the ECDSA signature\n+\n+.DESCRIPTION\n+    Gets the ECDSA signature for the http signing \n+.PARAMETER PrivateKeyFilePath\n+    Specify the API key file path\n+.PARAMETER DataToSign\n+    Specify the data to sign\n+.PARAMETER HashAlgorithmName\n+    HashAlgorithm to calculate the hash\n+.PARAMETER KeyPassPharse\n+    KeyPassPharse for the encrypted key\n+.OUTPUTS\n+    Base64String\n+#>\n+function Get-{{apiNamePrefix}}ECDSASignature {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [string]$ECKeyFilePath,\n+        [Parameter(Mandatory = $true)]\n+        [byte[]]$DataToSign,\n+        [Parameter(Mandatory = $false)]\n+        [String]$HashAlgorithmName,\n+        [Parameter(Mandatory = $false)]\n+        [securestring]$KeyPassPharse\n+    )\n+    if (!(Test-Path -Path $ECKeyFilePath)) {\n+        throw \"key file path does not exist.\"\n+    }\n+\n+    if($PSVersionTable.PSVersion.Major -lt 7){\n+        throw \"ECDSA key is not supported on $($PSVersionTable.PSVersion), Use PSVersion 7.0 and above\"\n+    }\n+\n+    $ecKeyHeader = \"-----BEGIN EC PRIVATE KEY-----\"\n+    $ecKeyFooter = \"-----END EC PRIVATE KEY-----\"\n+    $keyStr = Get-Content -Path $ECKeyFilePath -Raw\n+    $ecKeyBase64String = $keyStr.Replace($ecKeyHeader, \"\").Replace($ecKeyFooter, \"\").Trim()\n+    $keyBytes = [System.Convert]::FromBase64String($ecKeyBase64String)\n+\n+    #$cngKey = [System.Security.Cryptography.CngKey]::Import($keyBytes,[System.Security.Cryptography.CngKeyBlobFormat]::Pkcs8PrivateBlob)\n+    #$ecdsa = [System.Security.Cryptography.ECDsaCng]::New($cngKey)\n+    $ecdsa = [System.Security.Cryptography.ECDsaCng]::New()\n+    [int]$bytCount =0\n+    if(![string]::IsNullOrEmpty($KeyPassPharse)){\n+        $ecdsa.ImportEncryptedPkcs8PrivateKey($KeyPassPharse,$keyBytes,[ref]$bytCount)\n+    }\n+    else{\n+    $ecdsa.ImportPkcs8PrivateKey($keyBytes,[ref]$bytCount)\n+    }\n+    \n+    if ($HashAlgorithmName -eq \"sha512\") {\n+        $ecdsa.HashAlgorithm = [System.Security.Cryptography.CngAlgorithm]::Sha512\n+    }\n+    else {\n+        $ecdsa.HashAlgorithm = [System.Security.Cryptography.CngAlgorithm]::Sha256\n+    }\n+\n+    $signedBytes = $ecdsa.SignHash($DataToSign)\n+    $signedString = [System.Convert]::ToBase64String($signedBytes)\n+    return $signedString\n+\n+}\n+\n+\n <#\n .Synopsis\n     Gets the hash of string.\n .Description\n     Gets the hash of string\n+.Parameter String\n+    Specifies the string to calculate the hash\n+.Parameter HashName\n+    Specifies the hash name to calculate the hash, Accepted values are \"SHA1\", \"SHA256\" and \"SHA512\"\n .Outputs\n String \n #>\n-Function Get-{{{apiNamePrefix}}}StringHash([String] $String, $HashName = \"SHA256\") { \n-\n+Function Get-{{apiNamePrefix}}StringHash {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [AllowEmptyString()]\n+        [string]$String,\n+        [Parameter(Mandatory = $true)]\n+        [ValidateSet(\"SHA1\", \"SHA256\", \"SHA512\")]\n+        $HashName\n+    ) \n     $hashAlogrithm = [System.Security.Cryptography.HashAlgorithm]::Create($HashName)\n     $hashAlogrithm.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($String)) \n+}\n+\n+<#\n+.Synopsis\n+    Gets the Unix time.\n+.Description\n+    Gets the Unix time\n+.Parameter Date\n+    Specifies the date to calculate the unix time\n+.Parameter ToTalTime\n+    Specifies the total time , Accepted values are \"TotalDays\", \"TotalHours\", \"TotalMinutes\", \"TotalSeconds\" and \"TotalMilliseconds\"\n+.Outputs\n+Integer\n+#>\n+function Get-{{apiNamePrefix}}UnixTime {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [DateTime]$Date,\n+        [Parameter(Mandatory = $false)]\n+        [ValidateSet(\"TotalDays\", \"TotalHours\", \"TotalMinutes\", \"TotalSeconds\", \"TotalMilliseconds\")]\n+        [string]$TotalTime = \"TotalSeconds\"\n+    )\n+    $date1 = Get-Date -Date \"01/01/1970\"\n+    $timespan = New-TimeSpan -Start $date1 -End $Date\n+    switch ($TotalTime) {\n+        \"TotalDays\" { [int]$timespan.TotalDays }\n+        \"TotalHours\" { [int]$timespan.TotalHours }\n+        \"TotalMinutes\" { [int]$timespan.TotalMinutes }\n+        \"TotalSeconds\" { [int]$timespan.TotalSeconds }\n+        \"TotalMilliseconds\" { [int]$timespan.TotalMilliseconds }\n+    }\n+}\n+\n+function Get-{{apiNamePrefix}}CryptographicScheme {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [string]$SigningAlgorithm,\n+        [Parameter(Mandatory = $true)]\n+        [string]$HashAlgorithm\n+    )\n+    $rsaSigntureType = @(\"RSASSA-PKCS1-v1_5\", \"RSASSA-PSS\")\n+    $SigningAlgorithm = $null\n+    if ($rsaSigntureType -contains $SigningAlgorithm) {\n+        switch ($HashAlgorithm) {\n+            \"sha256\" { $SigningAlgorithm = \"rsa-sha256\" }\n+            \"sha512\" { $SigningAlgorithm = \"rsa-sha512\" }\n+        }\n+    }\n+    return $SigningAlgorithm\n+}\n+\n+\n+<#\n+.Synopsis\n+    Gets the key type from the pem file.\n+.Description\n+    Gets the key type from the pem file.\n+.Parameter KeyFilePath\n+    Specifies the key file path (pem file)\n+.Outputs\n+String\n+#>\n+function Get-{{apiNamePrefix}}KeyTypeFromFile {\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [string]$KeyFilePath\n+    )\n+\n+    if (-not(Test-Path -Path $KeyFilePath)) {\n+        throw \"Key file path does not exist.\"\n+    }\n+    $ecPrivateKeyHeader = \"BEGIN EC PRIVATE KEY\"\n+    $ecPrivateKeyFooter = \"END EC PRIVATE KEY\"\n+    $rsaPrivateKeyHeader = \"BEGIN RSA PRIVATE KEY\"\n+    $rsaPrivateFooter = \"END RSA PRIVATE KEY\"\n+    $pkcs8Header = \"BEGIN PRIVATE KEY\"\n+    $pkcs8Footer = \"END PRIVATE KEY\"\n+    $keyType = $null\n+    $key = Get-Content -Path $KeyFilePath\n+\n+    if ($key[0] -match $rsaPrivateKeyHeader -and $key[$key.Length - 1] -match $rsaPrivateFooter) {\n+        $KeyType = \"RSA\"\n+\n+    }\n+    elseif ($key[0] -match $ecPrivateKeyHeader -and $key[$key.Length - 1] -match $ecPrivateKeyFooter) {\n+        $keyType = \"EC\"\n+    }\n+    elseif ($key[0] -match $ecPrivateKeyHeader -and $key[$key.Length - 1] -match $ecPrivateKeyFooter) {\n+        <#this type of key can hold many type different types of private key, but here due lack of pem eader", "originalCommit": "0d66824619223487bd519b0bceb243621a0df8ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "206be22c80674d4d5d7be6bda30ede2b7bba8642", "url": "https://github.com/OpenAPITools/openapi-generator/commit/206be22c80674d4d5d7be6bda30ede2b7bba8642", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-26T06:23:36Z", "type": "commit"}, {"oid": "7c67a2afec1555568ad1917495463ba81a083a66", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7c67a2afec1555568ad1917495463ba81a083a66", "message": "Update modules/openapi-generator/src/main/resources/powershell/configuration.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T06:36:36Z", "type": "commit"}, {"oid": "c1f19a20d171fcd8d178cf31922443d78d2da056", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c1f19a20d171fcd8d178cf31922443d78d2da056", "message": "Update modules/openapi-generator/src/main/resources/powershell/configuration.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T06:37:51Z", "type": "commit"}, {"oid": "1381f3bfa385ae43dc82de5ced662226eaee0dac", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1381f3bfa385ae43dc82de5ced662226eaee0dac", "message": "Update modules/openapi-generator/src/main/resources/powershell/configuration.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T06:39:41Z", "type": "commit"}, {"oid": "83e81bc52971de380aebae999438151a04c18130", "url": "https://github.com/OpenAPITools/openapi-generator/commit/83e81bc52971de380aebae999438151a04c18130", "message": "Update modules/openapi-generator/src/main/resources/powershell/configuration.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T06:39:57Z", "type": "commit"}, {"oid": "dd6d0b5576fa525e1b19c5d504260cc3c694bf8b", "url": "https://github.com/OpenAPITools/openapi-generator/commit/dd6d0b5576fa525e1b19c5d504260cc3c694bf8b", "message": "Update modules/openapi-generator/src/main/resources/powershell/configuration.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T06:40:15Z", "type": "commit"}, {"oid": "984f77f9475da5a4965d6c2952ece69f02bbc790", "url": "https://github.com/OpenAPITools/openapi-generator/commit/984f77f9475da5a4965d6c2952ece69f02bbc790", "message": "HttpSigningHeader accepts any header available in request to calculate the signature.", "committedDate": "2020-05-26T10:55:17Z", "type": "commit"}, {"oid": "c8676f5c5b0dbed18399da8107409438a4883402", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c8676f5c5b0dbed18399da8107409438a4883402", "message": "Merge branch 'master' of github.com:Ghufz/openapi-generator", "committedDate": "2020-05-26T11:02:32Z", "type": "commit"}, {"oid": "e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "message": "Update modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache\n\nCo-authored-by: Sebastien Rosset <serosset@cisco.com>", "committedDate": "2020-05-26T11:05:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjA4NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r430846084", "bodyText": "FYI. {{{ ... }}} will use the original value while {{...}} will use the HTML-escaped value.", "author": "wing328", "createdAt": "2020-05-27T04:09:04Z", "path": "modules/openapi-generator/src/main/resources/powershell/api_client.mustache", "diffHunk": "@@ -91,13 +91,15 @@ function Invoke-{{{apiNamePrefix}}}ApiClient {\n \n     {{#hasHttpSignatureMethods}}\n     # http signature authentication\n-    if ($null -ne $Configuration['ApiKey'] -and $Configuration['ApiKey'].Count -gt 0) {\n+    $httpSigningConfig = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    if ($null -ne $httpSigningConfig) {\n         $httpSignHeaderArgument = @{\n             Method     = $Method\n             UriBuilder = $UriBuilder\n             Body       = $Body\n+            RequestHeader = $HeaderParameters\n         }\n-        $signedHeader = Get-{{{apiNamePrefix}}}HttpSignedHeader @httpSignHeaderArgument\n+        $signedHeader = Get-{{apiNamePrefix}}HttpSignedHeader @httpSignHeaderArgument", "originalCommit": "e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjM2OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r430846369", "bodyText": "It looks like the code block ending at line 492 is not indented correctly.", "author": "wing328", "createdAt": "2020-05-27T04:10:13Z", "path": "modules/openapi-generator/src/main/resources/powershell/configuration.mustache", "diffHunk": "@@ -372,3 +372,141 @@ function Get-{{apiNamePrefix}}UrlFromHostSetting {\n \n     }\n }\n+\n+<#\n+.SYNOPSIS\n+Sets the configuration for http signing.\n+.DESCRIPTION\n+\n+Sets the configuration for the HTTP signature security scheme.\n+The HTTP signature security scheme is used to sign HTTP requests with a key\n+which is in possession of the API client.\n+An 'Authorization' header is calculated by creating a hash of select headers,\n+and optionally the body of the HTTP request, then signing the hash value using\n+a key. The 'Authorization' header is added to outbound HTTP requests.\n+\n+Ref: https://openapi-generator.tech\n+\n+.PARAMETER KeyId\n+KeyId for HTTP signing \n+\n+.PARAMETER KeyFilePath\n+KeyFilePath for HTTP signing\n+\n+.PARAMETER KeyPassPhrase\n+KeyPassPhrase, if the HTTP signing key is protected\n+\n+.PARAMETER HttpSigningHeader\n+HttpSigningHeader list of HTTP headers used to calculate the signature. The two special signature headers '(request-target)' and '(created)' \n+SHOULD be included.\n+    The '(created)' header expresses when the signature was created.\n+    The '(request-target)' header is a concatenation of the lowercased :method, an\n+    ASCII space, and the :path pseudo-headers.\n+If no headers are specified then '(created)' sets as default.\n+\n+.PARAMETER HashAlgorithm\n+HashAlgrithm to calculate the hash, Supported values are \"sha256\" and \"sha512\"\n+\n+.PARAMETER SigningAlgorithm\n+SigningAlgorithm specifies the signature algorithm, supported values are \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\" \n+RSA key : Supported values \"RSASSA-PKCS1-v1_5\" and \"RSASSA-PSS\", for ECDSA key this parameter is not applicable\n+\n+.PARAMETER SignatureValidityPeriod\n+SignatureValidityPeriod specifies the signature maximum validity time in seconds. It accepts integer value \n+\n+.OUTPUTS\n+\n+System.Collections.Hashtable\n+#>\n+function Set-{{apiNamePrefix}}ConfigurationHttpSigning{\n+    [CmdletBinding()]\n+    param(\n+        [Parameter(Mandatory = $true)]\n+        [ValidateNotNullOrEmpty()]\n+        [string]$KeyId,\n+        [Parameter(Mandatory = $true)]\n+        [string]$KeyFilePath,\n+        [Parameter(Mandatory = $false)]\n+        [securestring]$KeyPassPhrase,\n+        [Parameter(Mandatory = $false)]\n+        [ValidateNotNullOrEmpty()]\n+        [string[]] $HttpSigningHeader = @(\"(created)\"),\n+        [Parameter(Mandatory = $false)]\n+        [ValidateSet(\"sha256\",\"sha512\")]\n+        [string] $HashAlgorithm = \"sha256\",\n+        [Parameter(Mandatory = $false)]\n+        [ValidateSet(\"RSASSA-PKCS1-v1_5\",\"RSASSA-PSS\")]\n+        [string]$SigningAlgorithm ,\n+        [Parameter(Mandatory = $false)]\n+        [int]$SignatureValidityPeriod\n+    )\n+\n+    Process{\n+    $httpSignatureConfiguration = @{}\n+\n+    if(Test-Path -Path $KeyFilePath){\n+        $httpSignatureConfiguration[\"KeyId\"] = $KeyId\n+        $httpSignatureConfiguration[\"KeyFilePath\"] = $KeyFilePath\n+    }else{\n+        throw \"Private key file path does not exist\"\n+    }\n+\n+    $keyType = Get-{{apiNamePrefix}}KeyTypeFromFile -KeyFilePath $KeyFilePath\n+    if([String]::IsNullOrEmpty($SigningAlgorithm)){\n+        if($keyType -eq \"RSA\"){\n+            $SigningAlgorithm = \"RSASSA-PKCS1-v1_5\"\n+        }\n+    }\n+\n+    if($keyType -eq \"RSA\" -and \n+        ($SigningAlgorithm -ne \"RSASSA-PKCS1-v1_5\" -and $SigningAlgorithm -ne \"RSASSA-PSS\" ))\n+        {\n+            throw \"Provided Key and SigningAlgorithm : $SigningAlgorithm is not compatible.\"\n+        }\n+    \n+\n+    if($HttpSigningHeader -contains \"(expires)\" -and $SignatureValidityPeriod -le 0){\n+        throw \"SignatureValidityPeriod must be greater than 0 seconds.\"\n+    }\n+\n+    if($HttpSigningHeader -contains \"(expires)\"){\n+        $httpSignatureConfiguration[\"SignatureValidityPeriod\"] = $SignatureValidityPeriod\n+    }\n+    if($null -ne $HttpSigningHeader -and $HttpSigningHeader.Length -gt 0){\n+        $httpSignatureConfiguration[\"HttpSigningHeader\"] = $HttpSigningHeader\n+    }\n+\n+    if($null -ne $HashAlgorithm ){\n+        $httpSignatureConfiguration[\"HashAlgorithm\"] = $HashAlgorithm\n+    }\n+\n+    if($null -ne $SigningAlgorithm){\n+        $httpSignatureConfiguration[\"SigningAlgorithm\"] = $SigningAlgorithm\n+    }\n+\n+    if($null -ne $KeyPassPhrase){\n+        $httpSignatureConfiguration[\"KeyPassPhrase\"] = $KeyPassPhrase\n+    }\n+    \n+    $Script:Configuration[\"HttpSigning\"] = New-Object -TypeName PSCustomObject -Property $httpSignatureConfiguration\n+}\n+}", "originalCommit": "e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjU4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r430846581", "bodyText": "I think elseif should go with the previous line (53 in this case) instead of a new line on its own.", "author": "wing328", "createdAt": "2020-05-27T04:11:22Z", "path": "modules/openapi-generator/src/main/resources/powershell/http_signature_auth.mustache", "diffHunk": "@@ -1,162 +1,409 @@\n {{>partial_header}}\n <#\n .SYNOPSIS\n-Get the API key Id and API key file path.\n-\n+    Gets the headers for HTTP signature.\n .DESCRIPTION\n-Get the API key Id and API key file path. If no api prefix is provided then it use default api key prefix 'Signature'\n-.OUTPUTS\n-PSCustomObject : This contains APIKeyId, APIKeyFilePath, APIKeyPrefix\n-#>\n-function Get-{{{apiNamePrefix}}}APIKeyInfo {\n-    $ApiKeysList = $Script:Configuration['ApiKey']\n-    $ApiKeyPrefixList = $Script:Configuration['ApiKeyPrefix']\n-    $apiPrefix = \"Signature\"\n-\n-    if ($null -eq $ApiKeysList -or $ApiKeysList.Count -eq 0) {\n-        throw \"Unable to reterieve the api key details\"\n-    }\n-\n-    if ($null -eq $ApiKeyPrefixList -or $ApiKeyPrefixList.Count -eq 0) {\n-        Write-Verbose \"Unable to reterieve the api key prefix details,setting it to default \"\"Signature\"\"\"\n-    }\n-\n-    foreach ($item in $ApiKeysList.GetEnumerator()) {\n-        if (![string]::IsNullOrEmpty($item.Name)) {\n-            if (Test-Path -Path $item.Value) {\n-                $apiKey = $item.Value\n-                $apikeyId = $item.Name\n-                break;\n-            }\n-            else {\n-                throw \"API key file path does not exist.\"\n-            }\n-        }\n-    }\n-\n-    if ($ApiKeyPrefixList.ContainsKey($apikeyId)) {\n-        $apiPrefix = ApiKeyPrefixList[$apikeyId]\n-    }\n-\n-    if ($apikeyId -and $apiKey -and $apiPrefix) {\n-        $result = New-Object -Type PSCustomObject -Property @{ \n-            ApiKeyId       = $apikeyId;\n-            ApiKeyFilePath = $apiKey\n-            ApiKeyPrefix   = $apiPrefix\n-        }\n-    }\n-    else {\n-        return $null\n-    }\n-    return $result\n-}\n-\n-<#\n-.SYNOPSIS\n-    Gets the headers for http signed auth.\n-\n-.DESCRIPTION\n-    Gets the headers for the http signed auth. It use (targetpath), date, host and body digest to create authorization header.\n+    Gets the headers for the http sigature. \n .PARAMETER Method\n-    Http method\n+    HTTP method\n .PARAMETER UriBuilder\n     UriBuilder for url and query parameter\n .PARAMETER Body\n     Request body\n .OUTPUTS\n     Hashtable\n #>\n-function Get-{{{apiNamePrefix}}}HttpSignedHeader {\n+function Get-{{apiNamePrefix}}HttpSignedHeader {\n     param(\n         [string]$Method,\n         [System.UriBuilder]$UriBuilder,\n-        [string]$Body\n+        [string]$Body,\n+        [hashtable]$RequestHeader\n     )\n \n+    $HEADER_REQUEST_TARGET = '(request-target)'\n+    # The time when the HTTP signature was generated.\n+    $HEADER_CREATED = '(created)'\n+    # The time when the HTTP signature expires. The API server should reject HTTP requests\n+    # that have expired.\n+    $HEADER_EXPIRES = '(expires)'\n+    # The 'Host' header.\n+    $HEADER_HOST = 'Host'\n+    # The 'Date' header.\n+    $HEADER_DATE = 'Date'\n+    # When the 'Digest' header is included in the HTTP signature, the client automatically\n+    # computes the digest of the HTTP request body, per RFC 3230.\n+    $HEADER_DIGEST = 'Digest'\n+    # The 'Authorization' header is automatically generated by the client. It includes\n+    # the list of signed headers and a base64-encoded signature.\n+    $HEADER_AUTHORIZATION = 'Authorization'\n+\n     #Hash table to store singed headers\n-    $HttpSignedHeader = @{}\n+    $HttpSignedRequestHeader = @{ }\n+    $HttpSignatureHeader = @{ }\n     $TargetHost = $UriBuilder.Host\n+    $httpSigningConfiguration = Get-{{apiNamePrefix}}ConfigurationHttpSigning\n+    $Digest = $null\n+    \n+    #get the body digest\n+    $bodyHash = Get-{{apiNamePrefix}}StringHash -String $Body -HashName $httpSigningConfiguration.HashAlgorithm\n+    if ($httpSigningConfiguration.HashAlgorithm -eq \"SHA256\") {\n+        $Digest = [String]::Format(\"SHA-256={0}\", [Convert]::ToBase64String($bodyHash))\n+    }\n+    elseif ($httpSigningConfiguration.HashAlgorithm -eq \"SHA512\") {", "originalCommit": "e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjcxMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/6397#discussion_r430846710", "bodyText": "What about replacing tabs with 4-space instead?\nRef: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions#layout-conventions", "author": "wing328", "createdAt": "2020-05-27T04:12:02Z", "path": "modules/openapi-generator/src/main/resources/powershell/rsa_provider.mustache", "diffHunk": "@@ -1,377 +1,279 @@\n using System;\n using System.Collections.Generic;\n using System.IO;\n+using System.Net;\n using System.Runtime.InteropServices;\n using System.Security;\n using System.Security.Cryptography;\n using System.Text;\n \n namespace RSAEncryption\n {\n-    public class RSAEncryptionProvider\n-    {\n-\n-        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n-        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n-        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n-        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n-        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n-        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n-        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n-        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n-        public static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n-        {\n-            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n-\n-            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n-            MemoryStream mem = new MemoryStream(privkey);\n-            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n-            byte bt = 0;\n-            ushort twobytes = 0;\n-            int elems = 0;\n-            try\n-            {\n-                twobytes = binr.ReadUInt16();\n-                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n-                    binr.ReadByte();    //advance 1 byte\n-                else if (twobytes == 0x8230)\n-                    binr.ReadInt16();   //advance 2 bytes\n-                else\n-                    return null;\n-\n-                twobytes = binr.ReadUInt16();\n-                if (twobytes != 0x0102) //version number\n-                    return null;\n-                bt = binr.ReadByte();\n-                if (bt != 0x00)\n-                    return null;\n-\n-\n-                //------  all private key components are Integer sequences ----\n-                elems = GetIntegerSize(binr);\n-                MODULUS = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                E = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                D = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                P = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                Q = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                DP = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                DQ = binr.ReadBytes(elems);\n-\n-                elems = GetIntegerSize(binr);\n-                IQ = binr.ReadBytes(elems);\n-\n-                /*Console.WriteLine(\"showing components ..\");\n-                if (true)\n-                {\n-                    showBytes(\"\\nModulus\", MODULUS);\n-                    showBytes(\"\\nExponent\", E);\n-                    showBytes(\"\\nD\", D);\n-                    showBytes(\"\\nP\", P);\n-                    showBytes(\"\\nQ\", Q);\n-                    showBytes(\"\\nDP\", DP);\n-                    showBytes(\"\\nDQ\", DQ);\n-                    showBytes(\"\\nIQ\", IQ);\n-                }*/\n-\n-                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n-                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n-                RSAParameters RSAparams = new RSAParameters();\n-                RSAparams.Modulus = MODULUS;\n-                RSAparams.Exponent = E;\n-                RSAparams.D = D;\n-                RSAparams.P = P;\n-                RSAparams.Q = Q;\n-                RSAparams.DP = DP;\n-                RSAparams.DQ = DQ;\n-                RSAparams.InverseQ = IQ;\n-                RSA.ImportParameters(RSAparams);\n-                return RSA;\n-            }\n-            catch (Exception)\n-            {\n-                return null;\n-            }\n-            finally { binr.Close(); }\n-        }\n-\n-        private static int GetIntegerSize(BinaryReader binr)\n-        {\n-            byte bt = 0;\n-            byte lowbyte = 0x00;\n-            byte highbyte = 0x00;\n-            int count = 0;\n-            bt = binr.ReadByte();\n-            if (bt != 0x02)     //expect integer\n-                return 0;\n-            bt = binr.ReadByte();\n-\n-            if (bt == 0x81)\n-                count = binr.ReadByte();    // data size in next byte\n-            else\n-                if (bt == 0x82)\n-            {\n-                highbyte = binr.ReadByte(); // data size in next 2 bytes\n-                lowbyte = binr.ReadByte();\n-                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n-                count = BitConverter.ToInt32(modint, 0);\n-            }\n-            else\n-            {\n-                count = bt;     // we already have the data size\n-            }\n-            while (binr.ReadByte() == 0x00)\n-            {   //remove high order zeros in data\n-                count -= 1;\n-            }\n-            binr.BaseStream.Seek(-1, SeekOrigin.Current);\n-            //last ReadByte wasn't a removed zero, so back up a byte\n-            return count;\n-        }\n-\n-        static byte[] DecodeOpenSSLPrivateKey(String instr)\n-        {\n-            const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n-            const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n-            String pemstr = instr.Trim();\n-            byte[] binkey;\n-            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n-                return null;\n-\n-            StringBuilder sb = new StringBuilder(pemstr);\n-            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n-            sb.Replace(pemprivfooter, \"\");\n-\n-            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n-\n-            try\n-            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n-                binkey = Convert.FromBase64String(pvkstr);\n-                return binkey;\n-            }\n-            catch (System.FormatException)\n-            {       //if can't b64 decode, it must be an encrypted private key\n-                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n-            }\n-\n-            StringReader str = new StringReader(pvkstr);\n-\n-            //-------- read PEM encryption info. lines and extract salt -----\n-            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n-                return null;\n-            String saltline = str.ReadLine();\n-            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n-                return null;\n-            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n-            byte[] salt = new byte[saltstr.Length / 2];\n-            for (int i = 0; i < salt.Length; i++)\n-                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n-            if (!(str.ReadLine() == \"\"))\n-                return null;\n-\n-            //------ remaining b64 data is encrypted RSA key ----\n-            String encryptedstr = str.ReadToEnd();\n-\n-            try\n-            {   //should have b64 encrypted RSA key now\n-                binkey = Convert.FromBase64String(encryptedstr);\n-            }\n-            catch (System.FormatException)\n-            {  // bad b64 data.\n-                return null;\n-            }\n-\n-            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n-\n-            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n-            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n-            //String pswd = Console.ReadLine();\n-            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n-            if (deskey == null)\n-                return null;\n-            //showBytes(\"3DES key\", deskey) ;\n-\n-            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n-            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n-            if (rsakey != null)\n-                return rsakey;  //we have a decrypted RSA private key\n-            else\n-            {\n-                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n-                return null;\n-            }\n-        }\n-\n-        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n-        {\n-            IntPtr unmanagedPswd = IntPtr.Zero;\n-            int HASHLENGTH = 16;    //MD5 bytes\n-            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n-\n-\n-            byte[] psbytes = new byte[secpswd.Length];\n-            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n-            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n-            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n-\n-            //UTF8Encoding utf8 = new UTF8Encoding();\n-            //byte[] psbytes = utf8.GetBytes(pswd);\n-\n-            // --- contatenate salt and pswd bytes into fixed data array ---\n-            byte[] data00 = new byte[psbytes.Length + salt.Length];\n-            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n-            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n-\n-            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n-            MD5 md5 = new MD5CryptoServiceProvider();\n-            byte[] result = null;\n-            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n-\n-            for (int j = 0; j < miter; j++)\n-            {\n-                // ----  Now hash consecutively for count times ------\n-                if (j == 0)\n-                    result = data00;    //initialize \n-                else\n-                {\n-                    Array.Copy(result, hashtarget, result.Length);\n-                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n-                    result = hashtarget;\n-                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n-                    //showBytes(result) ;\n-                }\n-\n-                for (int i = 0; i < count; i++)\n-                    result = md5.ComputeHash(result);\n-                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n-            }\n-            //showBytes(\"Final key material\", keymaterial);\n-            byte[] deskey = new byte[24];\n-            Array.Copy(keymaterial, deskey, deskey.Length);\n-\n-            Array.Clear(psbytes, 0, psbytes.Length);\n-            Array.Clear(data00, 0, data00.Length);\n-            Array.Clear(result, 0, result.Length);\n-            Array.Clear(hashtarget, 0, hashtarget.Length);\n-            Array.Clear(keymaterial, 0, keymaterial.Length);\n-\n-            return deskey;\n-        }\n-\n-        public static string GetRSASignb64encode(string private_key_path, byte[] digest)\n-        {\n-            RSACryptoServiceProvider cipher = new RSACryptoServiceProvider();\n-            cipher = GetRSAProviderFromPemFile(private_key_path);\n-            RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(cipher);\n-            RSAFormatter.SetHashAlgorithm(\"SHA256\");\n-            byte[] signedHash = RSAFormatter.CreateSignature(digest);\n-            return Convert.ToBase64String(signedHash);\n-        }\n-\n-        public static RSACryptoServiceProvider GetRSAProviderFromPemFile(String pemfile)\n-        {\n-            bool isPrivateKeyFile = true;\n-            if (!File.Exists(pemfile))\n-            {\n-                throw new Exception(\"pemfile does not exist.\");\n-            }\n-            string pemstr = File.ReadAllText(pemfile).Trim();\n-            if (pemstr.StartsWith(pempubheader) && pemstr.EndsWith(pempubfooter))\n-                isPrivateKeyFile = false;\n-\n-            byte[] pemkey = null;\n-            if (isPrivateKeyFile)\n-                pemkey = DecodeOpenSSLPrivateKey(pemstr);\n-\n-\n-            if (pemkey == null)\n-                return null;\n-\n-            if (isPrivateKeyFile)\n-            {\n-                return DecodeRSAPrivateKey(pemkey);\n-            }\n-            return null;\n-        }\n-\n-        static byte[] DecryptKey(byte[] cipherData, byte[] desKey, byte[] IV)\n-        {\n-            MemoryStream memst = new MemoryStream();\n-            TripleDES alg = TripleDES.Create();\n-            alg.Key = desKey;\n-            alg.IV = IV;\n-            try\n-            {\n-                CryptoStream cs = new CryptoStream(memst, alg.CreateDecryptor(), CryptoStreamMode.Write);\n-                cs.Write(cipherData, 0, cipherData.Length);\n-                cs.Close();\n-            }\n-            catch (Exception exc)\n-            {\n-                Console.WriteLine(exc.Message);\n-                return null;\n-            }\n-            byte[] decryptedData = memst.ToArray();\n-            return decryptedData;\n-        }\n-\n-        static SecureString GetSecPswd(String prompt)\n-        {\n-            SecureString password = new SecureString();\n-\n-            Console.ForegroundColor = ConsoleColor.Gray;\n-            Console.ForegroundColor = ConsoleColor.Magenta;\n-\n-            while (true)\n-            {\n-                ConsoleKeyInfo cki = Console.ReadKey(true);\n-                if (cki.Key == ConsoleKey.Enter)\n-                {\n-                    Console.ForegroundColor = ConsoleColor.Gray;\n-                    return password;\n-                }\n-                else if (cki.Key == ConsoleKey.Backspace)\n-                {\n-                    // remove the last asterisk from the screen...\n-                    if (password.Length > 0)\n-                    {\n-                        Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);\n-                        Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);\n-                        password.RemoveAt(password.Length - 1);\n-                    }\n-                }\n-                else if (cki.Key == ConsoleKey.Escape)\n-                {\n-                    Console.ForegroundColor = ConsoleColor.Gray;\n-                    return password;\n-                }\n-                else if (Char.IsLetterOrDigit(cki.KeyChar) || Char.IsSymbol(cki.KeyChar))\n-                {\n-                    if (password.Length < 20)\n-                    {\n-                        password.AppendChar(cki.KeyChar);\n-                    }\n-                    else\n-                    {\n-                        Console.Beep();\n-                    }\n-                }\n-                else\n-                {\n-                    Console.Beep();\n-                }\n-            }\n-        }\n-    }\n-}\n+\tpublic class RSAEncryptionProvider\n+\t{\n+\t\tpublic static RSACryptoServiceProvider GetRSAProviderFromPemFile(String pemfile,SecureString keyPassPharse = null)\n+\t\t{\n+\t\t\tconst String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n+\t\t\tconst String pempubfooter = \"-----END PUBLIC KEY-----\";\n+\t\t\tbool isPrivateKeyFile = true;\n+\t\t\tbyte[] pemkey = null;\n+\n+\t\t\tif (!File.Exists(pemfile))\n+\t\t\t{\n+\t\t\t\tthrow new Exception(\"private key file does not exist.\");\n+\t\t\t}\n+\t\t\tstring pemstr = File.ReadAllText(pemfile).Trim();\n+\n+\t\t\tif (pemstr.StartsWith(pempubheader) && pemstr.EndsWith(pempubfooter))\n+\t\t\t{\n+\t\t\t\tisPrivateKeyFile = false;\n+\t\t\t}\n+\n+\t\t\tif (isPrivateKeyFile)\n+\t\t\t{\n+\t\t\t\tpemkey = ConvertPrivateKeyToBytes(pemstr,keyPassPharse);\n+\t\t\t\tif (pemkey == null)\n+\t\t\t\t{\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\treturn DecodeRSAPrivateKey(pemkey);\n+\t\t\t}\n+\t\t\treturn null ;\n+\t\t}\n+\n+\t\tstatic byte[] ConvertPrivateKeyToBytes(String instr, SecureString keyPassPharse = null)\n+\t\t{\n+\t\t\tconst String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n+\t\t\tconst String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n+\t\t\tString pemstr = instr.Trim();\n+\t\t\tbyte[] binkey;\n+\n+\t\t\tif (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tStringBuilder sb = new StringBuilder(pemstr);\n+\t\t\tsb.Replace(pemprivheader, \"\");\n+\t\t\tsb.Replace(pemprivfooter, \"\");\n+\t\t\tString pvkstr = sb.ToString().Trim();\n+\n+\t\t\ttry\n+\t\t\t{   // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n+\t\t\t\tbinkey = Convert.FromBase64String(pvkstr);\n+\t\t\t\treturn binkey;\n+\t\t\t}\n+\t\t\tcatch (System.FormatException)\n+\t\t\t{       \n+\t\t\t\tStringReader str = new StringReader(pvkstr);\n+\n+\t\t\t\t//-------- read PEM encryption info. lines and extract salt -----\n+\t\t\t\tif (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n+\t\t\t\t\treturn null;\n+\t\t\t\tString saltline = str.ReadLine();\n+\t\t\t\tif (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n+\t\t\t\t\treturn null;\n+\t\t\t\tString saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n+\t\t\t\tbyte[] salt = new byte[saltstr.Length / 2];\n+\t\t\t\tfor (int i = 0; i < salt.Length; i++)\n+\t\t\t\t\tsalt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n+\t\t\t\tif (!(str.ReadLine() == \"\"))\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\t//------ remaining b64 data is encrypted RSA key ----\n+\t\t\t\tString encryptedstr = str.ReadToEnd();\n+\n+\t\t\t\ttry\n+\t\t\t\t{   //should have b64 encrypted RSA key now\n+\t\t\t\t\tbinkey = Convert.FromBase64String(encryptedstr);\n+\t\t\t\t}\n+\t\t\t\tcatch (System.FormatException)\n+\t\t\t\t{   //data is not in base64 fromat\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\n+\t\t\t\tbyte[] deskey = GetEncryptedKey(salt, keyPassPharse, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes\n+\t\t\t\tif (deskey == null)\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\t//------ Decrypt the encrypted 3des-encrypted RSA private key ------\n+\t\t\t\tbyte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n+\t\t\t\treturn rsakey;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n+\t\t{\n+\t\t\tbyte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n+\n+\t\t\t// ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n+\t\t\tMemoryStream mem = new MemoryStream(privkey);\n+\t\t\tBinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n+\t\t\tbyte bt = 0;\n+\t\t\tushort twobytes = 0;\n+\t\t\tint elems = 0;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\ttwobytes = binr.ReadUInt16();\n+\t\t\t\tif (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n+\t\t\t\t\tbinr.ReadByte();    //advance 1 byte\n+\t\t\t\telse if (twobytes == 0x8230)\n+\t\t\t\t\tbinr.ReadInt16();   //advance 2 bytes\n+\t\t\t\telse\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\ttwobytes = binr.ReadUInt16();\n+\t\t\t\tif (twobytes != 0x0102) //version number\n+\t\t\t\t\treturn null;\n+\t\t\t\tbt = binr.ReadByte();\n+\t\t\t\tif (bt != 0x00)\n+\t\t\t\t\treturn null;\n+\n+\t\t\t\t//------  all private key components are Integer sequences ----\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tMODULUS = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tE = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tD = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tP = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tQ = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tDP = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tDQ = binr.ReadBytes(elems);\n+\n+\t\t\t\telems = GetIntegerSize(binr);\n+\t\t\t\tIQ = binr.ReadBytes(elems);\n+\n+\t\t\t\t// ------- create RSACryptoServiceProvider instance and initialize with public key -----\n+\t\t\t\tRSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n+\t\t\t\tRSAParameters RSAparams = new RSAParameters();\n+\t\t\t\tRSAparams.Modulus = MODULUS;\n+\t\t\t\tRSAparams.Exponent = E;\n+\t\t\t\tRSAparams.D = D;\n+\t\t\t\tRSAparams.P = P;\n+\t\t\t\tRSAparams.Q = Q;\n+\t\t\t\tRSAparams.DP = DP;\n+\t\t\t\tRSAparams.DQ = DQ;\n+\t\t\t\tRSAparams.InverseQ = IQ;\n+\t\t\t\tRSA.ImportParameters(RSAparams);\n+\t\t\t\treturn RSA;\n+\t\t\t}\n+\t\t\tcatch (Exception)\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tfinally { binr.Close(); }\n+\t\t}\n+\n+\t\tprivate static int GetIntegerSize(BinaryReader binr)\n+\t\t{\n+\t\t\tbyte bt = 0;\n+\t\t\tbyte lowbyte = 0x00;\n+\t\t\tbyte highbyte = 0x00;\n+\t\t\tint count = 0;\n+\t\t\tbt = binr.ReadByte();\n+\t\t\tif (bt != 0x02)     //expect integer\n+\t\t\t\treturn 0;\n+\t\t\tbt = binr.ReadByte();\n+\n+\t\t\tif (bt == 0x81)\n+\t\t\t\tcount = binr.ReadByte();    // data size in next byte\n+\t\t\telse\n+\t\t\t\tif (bt == 0x82)\n+\t\t\t{\n+\t\t\t\thighbyte = binr.ReadByte(); // data size in next 2 bytes\n+\t\t\t\tlowbyte = binr.ReadByte();\n+\t\t\t\tbyte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n+\t\t\t\tcount = BitConverter.ToInt32(modint, 0);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcount = bt;     // we already have the data size\n+\t\t\t}\n+\t\t\twhile (binr.ReadByte() == 0x00)\n+\t\t\t{   //remove high order zeros in data\n+\t\t\t\tcount -= 1;\n+\t\t\t}\n+\t\t\tbinr.BaseStream.Seek(-1, SeekOrigin.Current);\n+\t\t\t//last ReadByte wasn't a removed zero, so back up a byte\n+\t\t\treturn count;\n+\t\t}\n+\n+\t\tstatic byte[] GetEncryptedKey(byte[] salt, SecureString secpswd, int count, int miter)\n+\t\t{\n+\t\t\tIntPtr unmanagedPswd = IntPtr.Zero;\n+\t\t\tint HASHLENGTH = 16;    //MD5 bytes\n+\t\t\tbyte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n+\n+\t\t\tbyte[] psbytes = new byte[secpswd.Length];\n+\t\t\tunmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n+\t\t\tMarshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n+\t\t\tMarshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n+\n+\t\t\t// --- contatenate salt and pswd bytes into fixed data array ---\n+\t\t\tbyte[] data00 = new byte[psbytes.Length + salt.Length];\n+\t\t\tArray.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n+\t\t\tArray.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n+\n+\t\t\t// ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n+\t\t\tMD5 md5 = new MD5CryptoServiceProvider();\n+\t\t\tbyte[] result = null;\n+\t\t\tbyte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n+\n+\t\t\tfor (int j = 0; j < miter; j++)\n+\t\t\t{\n+\t\t\t\t// ----  Now hash consecutively for count times ------\n+\t\t\t\tif (j == 0)\n+\t\t\t\t\tresult = data00;    //initialize \n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tArray.Copy(result, hashtarget, result.Length);\n+\t\t\t\t\tArray.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n+\t\t\t\t\tresult = hashtarget;\n+\t\t\t\t}\n+\n+\t\t\t\tfor (int i = 0; i < count; i++)\n+\t\t\t\t\tresult = md5.ComputeHash(result);\n+\t\t\t\tArray.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n+\t\t\t}\n+\t\t\tbyte[] deskey = new byte[24];\n+\t\t\tArray.Copy(keymaterial, deskey, deskey.Length);\n+\n+\t\t\tArray.Clear(psbytes, 0, psbytes.Length);\n+\t\t\tArray.Clear(data00, 0, data00.Length);\n+\t\t\tArray.Clear(result, 0, result.Length);\n+\t\t\tArray.Clear(hashtarget, 0, hashtarget.Length);\n+\t\t\tArray.Clear(keymaterial, 0, keymaterial.Length);\n+\t\t\treturn deskey;\n+\t\t}\n+\n+\t\tstatic byte[] DecryptKey(byte[] cipherData, byte[] desKey, byte[] IV)\n+\t\t{\n+\t\t\tMemoryStream memst = new MemoryStream();\n+\t\t\tTripleDES alg = TripleDES.Create();\n+\t\t\talg.Key = desKey;\n+\t\t\talg.IV = IV;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tCryptoStream cs = new CryptoStream(memst, alg.CreateDecryptor(), CryptoStreamMode.Write);\n+\t\t\t\tcs.Write(cipherData, 0, cipherData.Length);\n+\t\t\t\tcs.Close();\n+\t\t\t}\n+\t\t\tcatch (Exception){\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tbyte[] decryptedData = memst.ToArray();\n+\t\t\treturn decryptedData;\n+\t\t}\n+\t}\n+}", "originalCommit": "e954b4ff2cb31304daa8f6eab8b7786e9dc2db1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ef5ac6c13b59e918c75eb8ab206b769e7a0c99c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9ef5ac6c13b59e918c75eb8ab206b769e7a0c99c", "message": "Incorporated the review comments", "committedDate": "2020-05-27T06:24:26Z", "type": "commit"}, {"oid": "979b6d1c03ca1e9365549fca4ffed7b678fd601f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/979b6d1c03ca1e9365549fca4ffed7b678fd601f", "message": "Merge branch 'master' of github.com:Ghufz/openapi-generator", "committedDate": "2020-05-27T06:24:45Z", "type": "commit"}, {"oid": "a78a8dd75b17355c633a8df9edab16635faf8c55", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a78a8dd75b17355c633a8df9edab16635faf8c55", "message": "addressed the merge conflict", "committedDate": "2020-05-27T06:30:49Z", "type": "commit"}, {"oid": "1096e494f7b3f00fd9106b8c64251c7afaf032cc", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1096e494f7b3f00fd9106b8c64251c7afaf032cc", "message": "fix the pester issueMerge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-29T07:48:16Z", "type": "commit"}]}