{"pr_number": 1458, "pr_title": "(#1287) TextEnvelope is a real envelope", "pr_createdAt": "2020-09-13T14:44:21Z", "pr_url": "https://github.com/yegor256/cactoos/pull/1458", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NzM2Nw==", "url": "https://github.com/yegor256/cactoos/pull/1458#discussion_r487547367", "bodyText": "@victornoel Can we reuse scalar.Synched here?", "author": "andreoss", "createdAt": "2020-09-13T16:09:56Z", "path": "src/main/java/org/cactoos/text/Synced.java", "diffHunk": "@@ -48,13 +47,14 @@ public Synced(final Text text) {\n      * @param lck The lock\n      */\n     public Synced(final Text text, final Object lck) {\n-        super(new Scalar<String>() {\n-            @Override\n-            public String value() throws Exception {\n-                synchronized (lck) {\n-                    return text.asString();\n+        super(\n+            new TextOf(\n+                () -> {", "originalCommit": "83ef5f4d117b6e3ab44ee80f7406f1b0bf6a23d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MjY0NA==", "url": "https://github.com/yegor256/cactoos/pull/1458#discussion_r487552644", "bodyText": "@andreoss good catch", "author": "victornoel", "createdAt": "2020-09-13T17:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NzM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0ODI4Mw==", "url": "https://github.com/yegor256/cactoos/pull/1458#discussion_r487548283", "bodyText": "@victornoel Wouldn't this definition of equals cause problems? The operation seems to loose symmetric properties.\nFor example\nnew TextEnvelope(x).equals(x) == true, but  not necessarily x.equals(new TextEnvelope(x))", "author": "andreoss", "createdAt": "2020-09-13T16:17:28Z", "path": "src/main/java/org/cactoos/text/TextEnvelope.java", "diffHunk": "@@ -23,71 +23,46 @@\n  */\n package org.cactoos.text;\n \n-import java.io.IOException;\n-import org.cactoos.Scalar;\n import org.cactoos.Text;\n-import org.cactoos.scalar.And;\n-import org.cactoos.scalar.IoChecked;\n-import org.cactoos.scalar.Or;\n-import org.cactoos.scalar.Unchecked;\n \n /**\n- * Text envelope that provides {@link #equals(Object)} and {@link #hashCode()}\n- * methods.\n+ * {@link Text} envelope.\n+ *\n  * @since 0.32\n  * @checkstyle AbstractClassNameCheck (500 lines)\n  */\n public abstract class TextEnvelope implements Text {\n \n     /**\n-     * String value of the envelope.\n+     * Wrapped Text.\n      */\n-    private final IoChecked<String> origin;\n+    private final Text origin;\n \n     /**\n      * Ctor.\n      * @param text Text representing the text value.\n      */\n     public TextEnvelope(final Text text) {\n-        this(new IoChecked<>(text::asString));\n-    }\n-\n-    /**\n-     * Ctor.\n-     * @param scalar Scalar representing the text value.\n-     */\n-    public TextEnvelope(final Scalar<String> scalar) {\n-        this.origin = new IoChecked<>(scalar);\n+        this.origin = text;\n     }\n \n     @Override\n-    public final String asString() throws IOException {\n-        return this.origin.value();\n+    public final String asString() throws Exception {\n+        return this.origin.asString();\n     }\n \n     @Override\n     public final String toString() {\n-        return new UncheckedText(this).asString();\n+        return this.origin.toString();\n     }\n \n     @Override\n-    public final int hashCode() {\n-        return new Unchecked<>(this.origin).value().hashCode();\n+    public final boolean equals(final Object obj) {\n+        return this.origin.equals(obj);", "originalCommit": "83ef5f4d117b6e3ab44ee80f7406f1b0bf6a23d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MDU3Mg==", "url": "https://github.com/yegor256/cactoos/pull/1458#discussion_r487550572", "bodyText": "@andreoss this is a known limitation of equals actually when an interface has many different implementations. This subject has been discussed many times in the EO community, i.e., what does method equals mean for objects (you can search for \"equals\" in cactoos issues for example).\nMy take on it is that if you start having multiple implementations of the same interface, then you can't just expect equals to rely on some internal state, and thus, when you implement it, you have to rely on the exposed behaviour of the interface.\nIn the case of Text, it means that all implementations of Text should rely on Text.asString to implement equals, so in that case, the symmetry will be conserved. It is the same for MapOf, IterableOf and the other collection-related classes for example. Also sometimes it's better not to implement equals at all (e.g., Iterator).", "author": "victornoel", "createdAt": "2020-09-13T16:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0ODI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1MTcxNg==", "url": "https://github.com/yegor256/cactoos/pull/1458#discussion_r487551716", "bodyText": "@andreoss see for example #1156 (comment) where I made the same kind of comment. Also I started a discussion on all that matter in #1241, don't hesitate to chime in.", "author": "victornoel", "createdAt": "2020-09-13T16:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0ODI4Mw=="}], "type": "inlineReview"}, {"oid": "800fd3e151a17e60dd259abe273f070f3528af14", "url": "https://github.com/yegor256/cactoos/commit/800fd3e151a17e60dd259abe273f070f3528af14", "message": "(#1287) TextEnvelope is a real envelope", "committedDate": "2020-09-13T17:01:33Z", "type": "commit"}, {"oid": "800fd3e151a17e60dd259abe273f070f3528af14", "url": "https://github.com/yegor256/cactoos/commit/800fd3e151a17e60dd259abe273f070f3528af14", "message": "(#1287) TextEnvelope is a real envelope", "committedDate": "2020-09-13T17:01:33Z", "type": "forcePushed"}]}