{"pr_number": 1881, "pr_title": "[feature] data synchronization function , through datax", "pr_createdAt": "2020-02-02T04:48:06Z", "pr_url": "https://github.com/apache/dolphinscheduler/pull/1881", "timeline": [{"oid": "b50116b2a428c227debe71fc043f13e1756b6cac", "url": "https://github.com/apache/dolphinscheduler/commit/b50116b2a428c227debe71fc043f13e1756b6cac", "message": "feature\uff1adata synchronization function", "committedDate": "2020-02-02T04:28:38Z", "type": "commit"}, {"oid": "8dfa36a65b97bae6613772778adbbddc2aa84981", "url": "https://github.com/apache/dolphinscheduler/commit/8dfa36a65b97bae6613772778adbbddc2aa84981", "message": "feature\uff1adata synchronization function", "committedDate": "2020-02-02T04:38:06Z", "type": "commit"}, {"oid": "41370394cff677d261df0452d48bdd46c88f9722", "url": "https://github.com/apache/dolphinscheduler/commit/41370394cff677d261df0452d48bdd46c88f9722", "message": "feature\uff1adata synchronization function", "committedDate": "2020-02-02T04:45:38Z", "type": "commit"}, {"oid": "be1b11aa46ca401cdac93f6ed7f51c35ddbc6220", "url": "https://github.com/apache/dolphinscheduler/commit/be1b11aa46ca401cdac93f6ed7f51c35ddbc6220", "message": "fix\uff1aadd license", "committedDate": "2020-02-02T04:58:39Z", "type": "commit"}, {"oid": "a6459347a4bb12c747148ccda11bd4cdf270ebf2", "url": "https://github.com/apache/dolphinscheduler/commit/a6459347a4bb12c747148ccda11bd4cdf270ebf2", "message": "fix\uff1aresource close bug", "committedDate": "2020-02-02T07:16:30Z", "type": "commit"}, {"oid": "f6740385fe090a6ba789a446381e096f530667a3", "url": "https://github.com/apache/dolphinscheduler/commit/f6740385fe090a6ba789a446381e096f530667a3", "message": "fix\uff1aremove class author", "committedDate": "2020-02-02T07:22:38Z", "type": "commit"}, {"oid": "72c29116ea08237d4380b9ce18a5799e5a31e93d", "url": "https://github.com/apache/dolphinscheduler/commit/72c29116ea08237d4380b9ce18a5799e5a31e93d", "message": "fix\uff1aImprove test coverage", "committedDate": "2020-02-02T08:57:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDkzOQ==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373834939", "bodyText": "datasource -> dataSource", "author": "Eights-Li", "createdAt": "2020-02-02T10:27:35Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;", "originalCommit": "72c29116ea08237d4380b9ce18a5799e5a31e93d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0NzM1Ng==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373947356", "bodyText": "thx, let me fix it", "author": "wen-hemin", "createdAt": "2020-02-03T07:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDk3Nw==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373834977", "bodyText": "datatarget -> dataTarget", "author": "Eights-Li", "createdAt": "2020-02-02T10:28:19Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;", "originalCommit": "72c29116ea08237d4380b9ce18a5799e5a31e93d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0NzQwMA==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373947400", "bodyText": "thx, let me fix it", "author": "wen-hemin", "createdAt": "2020-02-03T07:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQzNw==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373835437", "bodyText": "Whether these two if condition are considered to be combined into one\uff1f", "author": "Eights-Li", "createdAt": "2020-02-02T10:36:56Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/task/etl/EtlParameters.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.common.task.etl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.dolphinscheduler.common.task.AbstractParameters;\n+\n+/**\n+ * Sql/Hql parameter\n+ */\n+public class EtlParameters extends AbstractParameters {\n+\n+    /**\n+     * data source type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dsType;\n+\n+    /**\n+     * datasource id\n+     */\n+    private int datasource;\n+\n+    /**\n+     * data target type\uff0ceg  MYSQL, POSTGRES ...\n+     */\n+    private String dtType;\n+\n+    /**\n+     * datatarget id\n+     */\n+    private int datatarget;\n+\n+    /**\n+     * sql\n+     */\n+    private String sql;\n+\n+    /**\n+     * target table\n+     */\n+    private String targetTable;\n+\n+    /**\n+     * Pre Statements\n+     */\n+    private List<String> preStatements;\n+\n+    /**\n+     * Post Statements\n+     */\n+    private List<String> postStatements;\n+\n+    /**\n+     * speed byte num\n+     */\n+    private int jobSpeedByte;\n+\n+    /**\n+     * speed record count\n+     */\n+    private int jobSpeedRecord;\n+\n+    public String getDsType() {\n+        return dsType;\n+    }\n+\n+    public void setDsType(String dsType) {\n+        this.dsType = dsType;\n+    }\n+\n+    public int getDatasource() {\n+        return datasource;\n+    }\n+\n+    public void setDatasource(int datasource) {\n+        this.datasource = datasource;\n+    }\n+\n+    public String getDtType() {\n+        return dtType;\n+    }\n+\n+    public void setDtType(String dtType) {\n+        this.dtType = dtType;\n+    }\n+\n+    public int getDatatarget() {\n+        return datatarget;\n+    }\n+\n+    public void setDatatarget(int datatarget) {\n+        this.datatarget = datatarget;\n+    }\n+\n+    public String getSql() {\n+        return sql;\n+    }\n+\n+    public void setSql(String sql) {\n+        this.sql = sql;\n+    }\n+\n+    public String getTargetTable() {\n+        return targetTable;\n+    }\n+\n+    public void setTargetTable(String targetTable) {\n+        this.targetTable = targetTable;\n+    }\n+\n+    public List<String> getPreStatements() {\n+        return preStatements;\n+    }\n+\n+    public void setPreStatements(List<String> preStatements) {\n+        this.preStatements = preStatements;\n+    }\n+\n+    public List<String> getPostStatements() {\n+        return postStatements;\n+    }\n+\n+    public void setPostStatements(List<String> postStatements) {\n+        this.postStatements = postStatements;\n+    }\n+\n+    public int getJobSpeedByte() {\n+        return jobSpeedByte;\n+    }\n+\n+    public void setJobSpeedByte(int jobSpeedByte) {\n+        this.jobSpeedByte = jobSpeedByte;\n+    }\n+\n+    public int getJobSpeedRecord() {\n+        return jobSpeedRecord;\n+    }\n+\n+    public void setJobSpeedRecord(int jobSpeedRecord) {\n+        this.jobSpeedRecord = jobSpeedRecord;\n+    }\n+\n+    @Override\n+    public boolean checkParameters() {\n+        if (!(datasource != 0 && StringUtils.isNotEmpty(dsType) && StringUtils.isNotEmpty(sql))) {", "originalCommit": "72c29116ea08237d4380b9ce18a5799e5a31e93d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk0ODgxOA==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r373948818", "bodyText": "thx, let me fix it", "author": "wen-hemin", "createdAt": "2020-02-03T07:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQzNw=="}], "type": "inlineReview"}, {"oid": "ed5bc8cd4d869a414b8bf9c54dc31cb0d05d901b", "url": "https://github.com/apache/dolphinscheduler/commit/ed5bc8cd4d869a414b8bf9c54dc31cb0d05d901b", "message": "fix\uff1aadd UT", "committedDate": "2020-02-03T04:58:05Z", "type": "commit"}, {"oid": "b32b53156706e140f1300d4b9d564f4ff69bd674", "url": "https://github.com/apache/dolphinscheduler/commit/b32b53156706e140f1300d4b9d564f4ff69bd674", "message": "Merge branch 'dev' into dev-etl_node\n\n# Conflicts:\n#\tpom.xml", "committedDate": "2020-02-03T07:04:14Z", "type": "commit"}, {"oid": "c874c9f519b200cd5d9a97d7b1b32c2b0fa57c93", "url": "https://github.com/apache/dolphinscheduler/commit/c874c9f519b200cd5d9a97d7b1b32c2b0fa57c93", "message": "fix\uff1aadd UT", "committedDate": "2020-02-03T07:16:24Z", "type": "commit"}, {"oid": "96ead4d4bd942422fb8359e09f1604e6525ec4d2", "url": "https://github.com/apache/dolphinscheduler/commit/96ead4d4bd942422fb8359e09f1604e6525ec4d2", "message": "fix\uff1adata sync node renamed to datax", "committedDate": "2020-02-04T08:13:39Z", "type": "commit"}, {"oid": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "url": "https://github.com/apache/dolphinscheduler/commit/b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "message": "fix\uff1aadd UT", "committedDate": "2020-02-04T08:50:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTA1Nw==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374561057", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "author": "Eights-Li", "createdAt": "2020-02-04T09:34:14Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "diffHunk": "@@ -84,9 +99,10 @@ public void testConvertKeywordsColumns() throws Exception {\n      */\n     @Test\n     public void testDoConvertKeywordsColumn() throws Exception {\n-        String fromColumn = \" \\\"`select`\\\" \";\n-        String targetColumn = \"`select`\";\n-\n-        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, fromColumn), targetColumn);\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, \" \\\"`select`\\\" \"), \"`select`\");", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3NTkwMA==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374675900", "bodyText": "thx, I fixed", "author": "wen-hemin", "createdAt": "2020-02-04T13:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2MTM1OQ==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374561359", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params, from 102-105 lines.", "author": "Eights-Li", "createdAt": "2020-02-04T09:34:48Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/utils/DataxUtilsTest.java", "diffHunk": "@@ -84,9 +99,10 @@ public void testConvertKeywordsColumns() throws Exception {\n      */\n     @Test\n     public void testDoConvertKeywordsColumn() throws Exception {\n-        String fromColumn = \" \\\"`select`\\\" \";\n-        String targetColumn = \"`select`\";\n-\n-        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, fromColumn), targetColumn);\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.MYSQL, \" \\\"`select`\\\" \"), \"`select`\");\n+        assertEquals(DataxUtils.doConvertKeywordsColumn(DbType.POSTGRESQL, \" \\\"`select`\\\" \"), \"\\\"select\\\"\");", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NTU4NA==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374565584", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "author": "Eights-Li", "createdAt": "2020-02-04T09:43:20Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NTkxMQ==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374565911", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "author": "Eights-Li", "createdAt": "2020-02-04T09:43:55Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjAyOQ==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566029", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "author": "Eights-Li", "createdAt": "2020-02-04T09:44:10Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjEwMA==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566100", "bodyText": "assertEquals first param is expected value, sceond param is actual value, please swap there params.", "author": "Eights-Li", "createdAt": "2020-02-04T09:44:19Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);\n+\n+            JSONObject writer = (JSONObject) content.get(\"writer\");\n+            Assert.assertNotNull(writer);\n+\n+            String writerPluginName = (String) writer.get(\"name\");\n+            Assert.assertEquals(writerPluginName, DataxUtils.DATAX_WRITER_PLUGIN_MYSQL);", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU2NjYzNQ==", "url": "https://github.com/apache/dolphinscheduler/pull/1881#discussion_r374566635", "bodyText": "this Test no assert?", "author": "Eights-Li", "createdAt": "2020-02-04T09:45:21Z", "path": "dolphinscheduler-server/src/test/java/org/apache/dolphinscheduler/server/worker/task/datax/DataxTaskTest.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dolphinscheduler.server.worker.task.datax;\n+\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import com.alibaba.fastjson.JSONObject;\n+import org.apache.dolphinscheduler.common.enums.CommandType;\n+import org.apache.dolphinscheduler.common.enums.DbType;\n+import org.apache.dolphinscheduler.common.job.db.BaseDataSource;\n+import org.apache.dolphinscheduler.common.job.db.DataSourceFactory;\n+import org.apache.dolphinscheduler.common.utils.SpringApplicationContext;\n+import org.apache.dolphinscheduler.dao.ProcessDao;\n+import org.apache.dolphinscheduler.dao.entity.DataSource;\n+import org.apache.dolphinscheduler.dao.entity.ProcessInstance;\n+import org.apache.dolphinscheduler.server.utils.DataxUtils;\n+import org.apache.dolphinscheduler.server.worker.task.ShellCommandExecutor;\n+import org.apache.dolphinscheduler.server.worker.task.TaskProps;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+\n+/**\n+ * DataxTask Tester.\n+ */\n+public class DataxTaskTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DataxTaskTest.class);\n+\n+    private DataxTask dataxTask;\n+\n+    private ProcessDao processDao;\n+\n+    private ShellCommandExecutor shellCommandExecutor;\n+\n+    private ApplicationContext applicationContext;\n+\n+    @Before\n+    public void before()\n+        throws Exception {\n+        processDao = Mockito.mock(ProcessDao.class);\n+        shellCommandExecutor = Mockito.mock(ShellCommandExecutor.class);\n+\n+        applicationContext = Mockito.mock(ApplicationContext.class);\n+        SpringApplicationContext springApplicationContext = new SpringApplicationContext();\n+        springApplicationContext.setApplicationContext(applicationContext);\n+        Mockito.when(applicationContext.getBean(ProcessDao.class)).thenReturn(processDao);\n+\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        props.setEnvFile(\".dolphinscheduler_env.sh\");\n+        props.setTaskStartTime(new Date());\n+        props.setTaskTimeout(0);\n+        props.setTaskParams(\n+            \"{\\\"targetTable\\\":\\\"test\\\",\\\"postStatements\\\":[],\\\"jobSpeedByte\\\":1024,\\\"jobSpeedRecord\\\":1000,\\\"dtType\\\":\\\"MYSQL\\\",\\\"datasource\\\":1,\\\"dsType\\\":\\\"MYSQL\\\",\\\"datatarget\\\":2,\\\"jobSpeedByte\\\":0,\\\"sql\\\":\\\"select 1 as test from dual\\\",\\\"preStatements\\\":[\\\"delete from test\\\"],\\\"postStatements\\\":[\\\"delete from test\\\"]}\");\n+        dataxTask = PowerMockito.spy(new DataxTask(props, logger));\n+        dataxTask.init();\n+\n+        Mockito.when(processDao.findDataSourceById(1)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findDataSourceById(2)).thenReturn(getDataSource());\n+        Mockito.when(processDao.findProcessInstanceByTaskId(1)).thenReturn(getProcessInstance());\n+\n+        String fileName = String.format(\"%s/%s_node.sh\", props.getTaskDir(), props.getTaskAppId());\n+        Mockito.when(shellCommandExecutor.run(fileName, processDao)).thenReturn(0);\n+    }\n+\n+    private DataSource getDataSource() {\n+        DataSource dataSource = new DataSource();\n+        dataSource.setType(DbType.MYSQL);\n+        dataSource.setConnectionParams(\n+                \"{\\\"user\\\":\\\"root\\\",\\\"password\\\":\\\"123456\\\",\\\"address\\\":\\\"jdbc:mysql://127.0.0.1:3306\\\",\\\"database\\\":\\\"test\\\",\\\"jdbcUrl\\\":\\\"jdbc:mysql://127.0.0.1:3306/test\\\"}\");\n+        dataSource.setUserId(1);\n+        return dataSource;\n+    }\n+\n+    private ProcessInstance getProcessInstance() {\n+        ProcessInstance processInstance = new ProcessInstance();\n+        processInstance.setCommandType(CommandType.START_PROCESS);\n+        processInstance.setScheduleTime(new Date());\n+        return processInstance;\n+    }\n+\n+    @After\n+    public void after()\n+        throws Exception {}\n+\n+    /**\n+     * Method: DataxTask()\n+     */\n+    @Test\n+    public void testDataxTask()\n+            throws Exception {\n+        TaskProps props = new TaskProps();\n+        props.setTaskDir(\"/tmp\");\n+        props.setTaskAppId(String.valueOf(System.currentTimeMillis()));\n+        props.setTaskInstId(1);\n+        props.setTenantCode(\"1\");\n+        dataxTask = new DataxTask(props, logger);\n+    }\n+\n+    /**\n+     * Method: init\n+     */\n+    @Test\n+    public void testInit()\n+            throws Exception {\n+        dataxTask.init();\n+    }\n+\n+    /**\n+     * Method: handle()\n+     */\n+    @Test\n+    public void testHandle()\n+            throws Exception {\n+        try {\n+            dataxTask.handle();\n+        } catch (RuntimeException e) {\n+            if (e.getMessage().indexOf(\"process error . exitCode is :  -1\") < 0) {\n+                Assert.fail();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method: cancelApplication()\n+     */\n+    @Test\n+    public void testCancelApplication()\n+            throws Exception {\n+        dataxTask.cancelApplication(true);\n+    }\n+\n+    /**\n+     * Method: parsingSqlColumnNames(DbType dsType, DbType dtType, BaseDataSource\n+     * dataSourceCfg, String sql)\n+     */\n+    @Test\n+    public void testParsingSqlColumnNames()\n+        throws Exception {\n+        try {\n+\n+            BaseDataSource dataSource = DataSourceFactory.getDatasource(getDataSource().getType(),\n+                    getDataSource().getConnectionParams());\n+\n+            Method method = DataxTask.class.getDeclaredMethod(\"parsingSqlColumnNames\", DbType.class, DbType.class, BaseDataSource.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, DbType.MYSQL, dataSource, \"select 1 as a, 2 as `table` from dual\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[`a`, `table`]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryGrammaticalParsingSqlColumnNames(DbType dbType, String sql)\n+     */\n+    @Test\n+    public void testTryGrammaticalAnalysisSqlColumnNames()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"tryGrammaticalAnalysisSqlColumnNames\", DbType.class, String.class);\n+            method.setAccessible(true);\n+            String[] columns = (String[]) method.invoke(dataxTask, DbType.MYSQL, \"select t1.a, t1.b from test t1 union all select a, t2.b from (select a, b from test) t2\");\n+\n+            Assert.assertNotNull(columns);\n+\n+            Assert.assertTrue(columns.length == 2);\n+\n+            Assert.assertEquals(Arrays.toString(columns), \"[a, b]\");\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: tryExecuteSqlResolveColumnNames(BaseDataSource baseDataSource,\n+     * String sql)\n+     */\n+    @Test\n+    public void testTryExecuteSqlResolveColumnNames()\n+        throws Exception {\n+        // TODO: Test goes here...\n+    }\n+\n+    /**\n+     * Method: buildDataxJsonFile()\n+     */\n+    @Test\n+    public void testBuildDataxJsonFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJsonFile\");\n+            method.setAccessible(true);\n+            String filePath = (String) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(filePath);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobContentJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobContentJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobContentJson\");\n+            method.setAccessible(true);\n+            List<JSONObject> contentList = (List<JSONObject>) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(contentList);\n+\n+            JSONObject content = contentList.get(0);\n+            JSONObject reader = (JSONObject) content.get(\"reader\");\n+            Assert.assertNotNull(reader);\n+\n+            String readerPluginName = (String) reader.get(\"name\");\n+            Assert.assertEquals(readerPluginName, DataxUtils.DATAX_READER_PLUGIN_MYSQL);\n+\n+            JSONObject writer = (JSONObject) content.get(\"writer\");\n+            Assert.assertNotNull(writer);\n+\n+            String writerPluginName = (String) writer.get(\"name\");\n+            Assert.assertEquals(writerPluginName, DataxUtils.DATAX_WRITER_PLUGIN_MYSQL);\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxJobSettingJson()\n+     */\n+    @Test\n+    public void testBuildDataxJobSettingJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxJobSettingJson\");\n+            method.setAccessible(true);\n+            JSONObject setting = (JSONObject) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(setting);\n+            Assert.assertNotNull(setting.get(\"speed\"));\n+            Assert.assertNotNull(setting.get(\"errorLimit\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildDataxCoreJson()\n+     */\n+    @Test\n+    public void testBuildDataxCoreJson()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildDataxCoreJson\");\n+            method.setAccessible(true);\n+            JSONObject coreConfig = (JSONObject) method.invoke(dataxTask, null);\n+            Assert.assertNotNull(coreConfig);\n+            Assert.assertNotNull(coreConfig.get(\"transport\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: buildShellCommandFile(String jobConfigFilePath)\n+     */\n+    @Test\n+    public void testBuildShellCommandFile()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"buildShellCommandFile\", String.class);\n+            method.setAccessible(true);\n+            Assert.assertNotNull(method.invoke(dataxTask, \"test.json\"));\n+        }\n+        catch (Exception e) {\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Method: getParameters\n+     */\n+    @Test\n+    public void testGetParameters()\n+            throws Exception {\n+        Assert.assertTrue(dataxTask.getParameters() != null);\n+    }\n+\n+    /**\n+     * Method: notNull(Object obj, String message)\n+     */\n+    @Test\n+    public void testNotNull()\n+        throws Exception {\n+        try {\n+            Method method = DataxTask.class.getDeclaredMethod(\"notNull\", Object.class, String.class);", "originalCommit": "b1003c600fca6ad1ffe57e76f4a591b0e98c7c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "47ecfa1afc852650b518a21a04b75673d5daff51", "url": "https://github.com/apache/dolphinscheduler/commit/47ecfa1afc852650b518a21a04b75673d5daff51", "message": "fix: UT bug", "committedDate": "2020-02-04T13:38:31Z", "type": "commit"}, {"oid": "622d40fd9f76522a4d7a6472f5c591d3451fe0b1", "url": "https://github.com/apache/dolphinscheduler/commit/622d40fd9f76522a4d7a6472f5c591d3451fe0b1", "message": "fix\uff1aOptimize variable name", "committedDate": "2020-02-04T14:29:23Z", "type": "commit"}, {"oid": "ca7b8814f2085c9507fc1bd00334b9ecff30e304", "url": "https://github.com/apache/dolphinscheduler/commit/ca7b8814f2085c9507fc1bd00334b9ecff30e304", "message": "fix\uff1apom", "committedDate": "2020-02-05T01:12:46Z", "type": "commit"}, {"oid": "0b427f20f503d80e42cce1e52dca4d4b9850e644", "url": "https://github.com/apache/dolphinscheduler/commit/0b427f20f503d80e42cce1e52dca4d4b9850e644", "message": "fix\uff1aVariable name error", "committedDate": "2020-02-05T02:21:34Z", "type": "commit"}, {"oid": "ec234ee61bfaca175e2ce7f4ce0cb82c2614d56d", "url": "https://github.com/apache/dolphinscheduler/commit/ec234ee61bfaca175e2ce7f4ce0cb82c2614d56d", "message": "fix\uff1aoptimize the code", "committedDate": "2020-02-05T11:43:14Z", "type": "commit"}]}