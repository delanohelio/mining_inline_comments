{"pr_number": 1659, "pr_title": "WebClient Intro doc updated with changes", "pr_createdAt": "2020-04-17T07:00:34Z", "pr_url": "https://github.com/oracle/helidon/pull/1659", "timeline": [{"oid": "b800ad4e7481fb067bfc1ba4fab3c3c87f450b92", "url": "https://github.com/oracle/helidon/commit/b800ad4e7481fb067bfc1ba4fab3c3c87f450b92", "message": "WebClient intro doc first draft", "committedDate": "2020-04-17T06:05:56Z", "type": "commit"}, {"oid": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "url": "https://github.com/oracle/helidon/commit/1f5715751dc6ef73f39019a35f6f8f6d083233e6", "message": "Updated the doc with additional info", "committedDate": "2020-04-22T07:15:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MDg5NA==", "url": "https://github.com/oracle/helidon/pull/1659#discussion_r412990894", "bodyText": "This is from README file of WebClient standalone example. I am not sure if this should be here since this is doc and not that particular example. This does not describe how you should use WebClient. It is description of how to execute that example.", "author": "Verdent", "createdAt": "2020-04-22T13:39:17Z", "path": "docs/se/webclient/01_introduction.adoc", "diffHunk": "@@ -16,10 +16,232 @@\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-= Helidon WebClient\n-:toc:\n-:toc-placement: preamble\n+\n+\n+= WebClient Introduction\n+:pagename: WebClient-Introduction\n :description: Helidon WebClient\n-:keywords: helidon, se, rest, httpclient, webclient\n+:keywords: helidon, se, rest, httpclient, webclient, reactive\n+\n+\n+WebClient is an HTTP client for Helidon SE 2.0. It handles the responses to the HTTP requests in a reactive way.\n+\n+Helidon WebClient provides the following features:\n+\n+* *Reactive approach* +\n+Allows you to execute HTTP requests and handle the responses without having to wait for the server response. When the response is received, the client requests only the amount of data that it can handle at that time. So, there is no overflow of memory.\n+\n+* *Builder-like setup and execution* +\n+Creates every client and request as a builder pattern. This improves readability and code maintenance.\n+\n+* *Redirect chain* +\n+Follows the redirect chain and perform requests on the correct endpoint by itself.\n+\n+* *Tracing, metrics and security propagation* +\n+Automatically propogates the configured tracing, metrics and security settings of the Helidon WebServer to the WebClient and uses them during request and response.\n+\n+== Configuring the WebClient\n+\n+The WebClient default configuration may be suitable in most use cases. However, you can configure it to suit your specific requirements.\n+\n+=== Example of a WebClient Configuration\n+\n+[source,java]\n+----\n+Config config = Config.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .config(config.get(\"client\"))\n+        .build();\n+----\n+\n+=== Example of Yaml WebClient Configuration\n+\n+[source, java]\n+----\n+client:\n+  connect-timeout-millis: 2000\n+  read-timeout-millis: 2000\n+  follow-redirects: true <1>\n+  max-redirects: 5\n+  cookies:\n+    automatic-store-enabled: true\n+    default-cookies:\n+      - name: \"env\"\n+        value: \"dev\"\n+  headers:\n+    - name: \"Accept\"\n+      value: [\"application/json\",\"text/plain\"] <2>\n+  services:\n+    exclude: [\"io.helidon.webclient.DefaultServiceRegistry\"]\n+    config:\n+      metrics: \n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+        - type: METER\n+          name-format: \"client.meter.overall\"\n+        - type: TIMER\n+          # meter per method\n+          name-format: \"client.meter.%1$s\"\n+        - methods: [\"GET\"]\n+          type: COUNTER\n+          errors: false\n+          name-format: \"client.counter.%1$s.success\"\n+          description: \"Counter of successful GET requests\"\n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+          type: COUNTER\n+          success: false\n+          name-format: \"wc.counter.%1$s.error\"\n+          description: \"Counter of failed PUT, POST and DELETE requests\"\n+        - methods: [\"GET\"]\n+          type: GAUGE_IN_PROGRESS\n+          name-format: \"client.inprogress.%2$s\"\n+          description: \"In progress requests to host\"\n+      tracing:\n+  proxy:\n+    use-system-selector: false\n+    host: \"hostName\"\n+    port: 80\n+    no-proxy: [\"localhost:8080\", \".helidon.io\", \"192.168.1.1\"] <3>\n+  ssl:\n+    server:\n+      disable-hostname-verification: false\n+      trust-all: false\n+      truststore:\n+        keystore-resource-path: \"path to the keystore\"\n+        keystore-type: \"JKS\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <4>\n+    client:\n+      keystore:\n+        keystore-resource-path: \"path to client keystore\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <5>\n+----\n+\n+<1> Client functional settings\n+<2> Default client headers and cookies\n+<3> Proxy configuration\n+<4> SSL configuration\n+<5> Client service configuration\n+\n+== Creating the WebClient\n+\n+You can create WebClient by executing `WebClient.create()` method. This will create an instance of client with default settings and without a base uri set.\n+\n+To change the default settings and register\n+additional services, you can use simple builder that allows you to customize the client behavior.\n+\n+=== Example\n+.Create a WebClient with simple builder:\n+[source,java]\n+----\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+----\n+\n+== Creating and Executing the WebClient Request\n+\n+WebClient executes requests to the target endpoints and returns specific response type.\n+\n+It offers the following methods to specify the type of request you want to execute:\n+\n+* `put()`\n+* `get()`\n+* `method(String methodName)`\n+\n+These methods set specific request type based on their name or parameter to the new instance of `WebClientRequesBuilder` and return this instance based on configurations for specific request type.\n+\n+You can set configuration for every request type before it is sent.\n+\n+// Do we need to include how to configure the request. If so, please provide info for request type.\n+\n+For the final execution, use the following methods with variations and different parameters:\n+\n+* `CompletionStage<T> submit(Object entity, Class<T> responseType)`\n+* `CompletionStage<T> request(Class<T> responseType)`\n+\n+=== Example\n+.Execute a simple GET request to endpoint:\n+[source,java]\n+----\n+CompletionStage<String> response = client.get()\n+        .path(\"/endpoint\")\n+        .request(String.class);\n+----\n+\n+== Designing the WebClient for JsonObject\n+\n+JsonObject processing is not present in the WebClient by default. So, you must first register the JsonObject before making a request.\n+\n+[source,java]\n+.Register JsonObject to the request builder using the register method.\n+----\n+JsonProcessing jsonProcessing = JsonProcessing.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+\n+CompletionStage<JsonObject> response = client.get()\n+        .path(\"/endpoint\")\n+        .register(jsonProcessing.newReader())\n+        .request(JsonObject.class);\n+---- \n+\n+[source,java]\n+.Make a GET or PUT request to the endpoint.\n+----\n+JsonProcessing jsonProcessing = JsonProcessing.create();\n+JsonObject entity = //some JsonObject entity\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+\n+CompletionStage<WebClientResponse> response = client.put()\n+        .path(\"/endpoint\")\n+        .register(jsonProcessing.newWriter())\n+        .submit(entity);\n+----\n+\n+== Using a Sample WebClient\n+\n+The sample setup shows you how to use the WebClient.\n+\n+. Set the port that will be used in one of folowing ways:\n+.. Set explicit port to `application.yaml` in section `server.port`.\n+.. Pass server port as the main method parameter to `ClientMain`.\n+. Start `WebServer` by calling `ServerMain.main()`.\n+. Start `WebClientExample` by calling `ClientMain.main()`.\n+\n+If you did not set port using config file, pass generated server port to the main method as a parameter.\n+", "originalCommit": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAxNzk0MA==", "url": "https://github.com/oracle/helidon/pull/1659#discussion_r413017940", "bodyText": "The following settings of the request are changing how the particular request will be executed and with what parameters. All of these parameters are optional.\n\nuri(\"http://example.com\") - Overrides baseUri from WebClient\npath(\"/path\") - Adds path to the uri\nqueryParam(\"query\", \"parameter\") - Adds query parameter to the request\nfragment(\"someFragment\") - Adds fragment to the request\nheaders(headers -> headers.addAccept(MediaType.APPLICATION_JSON)) - Adds header to the request\n\nWebClientRequestBuilder class also provides several specific header methods which will help user to set particular header correctly, such as:\n\ncontentType(MediaType contentType)\naccept(MediaType... mediaTypes)\netc.\n\nIt is also possible to add some readers and writers which helps with handling of the entity of the response and request.\n\naddReader(MessageBodyReader<?> reader) - Registers specific response entity reader\naddWriter(MessageBodyWriter<?> writer) - Registers specific response entity writer\naddMediaService(MediaService mediaService) - Calls register method on mediaService instance so every MediaService implementation can register desired support", "author": "Verdent", "createdAt": "2020-04-22T14:11:32Z", "path": "docs/se/webclient/01_introduction.adoc", "diffHunk": "@@ -16,10 +16,232 @@\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-= Helidon WebClient\n-:toc:\n-:toc-placement: preamble\n+\n+\n+= WebClient Introduction\n+:pagename: WebClient-Introduction\n :description: Helidon WebClient\n-:keywords: helidon, se, rest, httpclient, webclient\n+:keywords: helidon, se, rest, httpclient, webclient, reactive\n+\n+\n+WebClient is an HTTP client for Helidon SE 2.0. It handles the responses to the HTTP requests in a reactive way.\n+\n+Helidon WebClient provides the following features:\n+\n+* *Reactive approach* +\n+Allows you to execute HTTP requests and handle the responses without having to wait for the server response. When the response is received, the client requests only the amount of data that it can handle at that time. So, there is no overflow of memory.\n+\n+* *Builder-like setup and execution* +\n+Creates every client and request as a builder pattern. This improves readability and code maintenance.\n+\n+* *Redirect chain* +\n+Follows the redirect chain and perform requests on the correct endpoint by itself.\n+\n+* *Tracing, metrics and security propagation* +\n+Automatically propogates the configured tracing, metrics and security settings of the Helidon WebServer to the WebClient and uses them during request and response.\n+\n+== Configuring the WebClient\n+\n+The WebClient default configuration may be suitable in most use cases. However, you can configure it to suit your specific requirements.\n+\n+=== Example of a WebClient Configuration\n+\n+[source,java]\n+----\n+Config config = Config.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .config(config.get(\"client\"))\n+        .build();\n+----\n+\n+=== Example of Yaml WebClient Configuration\n+\n+[source, java]\n+----\n+client:\n+  connect-timeout-millis: 2000\n+  read-timeout-millis: 2000\n+  follow-redirects: true <1>\n+  max-redirects: 5\n+  cookies:\n+    automatic-store-enabled: true\n+    default-cookies:\n+      - name: \"env\"\n+        value: \"dev\"\n+  headers:\n+    - name: \"Accept\"\n+      value: [\"application/json\",\"text/plain\"] <2>\n+  services:\n+    exclude: [\"io.helidon.webclient.DefaultServiceRegistry\"]\n+    config:\n+      metrics: \n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+        - type: METER\n+          name-format: \"client.meter.overall\"\n+        - type: TIMER\n+          # meter per method\n+          name-format: \"client.meter.%1$s\"\n+        - methods: [\"GET\"]\n+          type: COUNTER\n+          errors: false\n+          name-format: \"client.counter.%1$s.success\"\n+          description: \"Counter of successful GET requests\"\n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+          type: COUNTER\n+          success: false\n+          name-format: \"wc.counter.%1$s.error\"\n+          description: \"Counter of failed PUT, POST and DELETE requests\"\n+        - methods: [\"GET\"]\n+          type: GAUGE_IN_PROGRESS\n+          name-format: \"client.inprogress.%2$s\"\n+          description: \"In progress requests to host\"\n+      tracing:\n+  proxy:\n+    use-system-selector: false\n+    host: \"hostName\"\n+    port: 80\n+    no-proxy: [\"localhost:8080\", \".helidon.io\", \"192.168.1.1\"] <3>\n+  ssl:\n+    server:\n+      disable-hostname-verification: false\n+      trust-all: false\n+      truststore:\n+        keystore-resource-path: \"path to the keystore\"\n+        keystore-type: \"JKS\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <4>\n+    client:\n+      keystore:\n+        keystore-resource-path: \"path to client keystore\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <5>\n+----\n+\n+<1> Client functional settings\n+<2> Default client headers and cookies\n+<3> Proxy configuration\n+<4> SSL configuration\n+<5> Client service configuration\n+\n+== Creating the WebClient\n+\n+You can create WebClient by executing `WebClient.create()` method. This will create an instance of client with default settings and without a base uri set.\n+\n+To change the default settings and register\n+additional services, you can use simple builder that allows you to customize the client behavior.\n+\n+=== Example\n+.Create a WebClient with simple builder:\n+[source,java]\n+----\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+----\n+\n+== Creating and Executing the WebClient Request\n+\n+WebClient executes requests to the target endpoints and returns specific response type.\n+\n+It offers the following methods to specify the type of request you want to execute:\n+\n+* `put()`\n+* `get()`\n+* `method(String methodName)`\n+\n+These methods set specific request type based on their name or parameter to the new instance of `WebClientRequesBuilder` and return this instance based on configurations for specific request type.\n+\n+You can set configuration for every request type before it is sent.\n+\n+// Do we need to include how to configure the request. If so, please provide info for request type.", "originalCommit": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAyMzY3Mg==", "url": "https://github.com/oracle/helidon/pull/1659#discussion_r413023672", "bodyText": "I am not sure if word designing is what should be here. I might suggest something like:\nAdding JSON-P media support to the WebClient", "author": "Verdent", "createdAt": "2020-04-22T14:18:27Z", "path": "docs/se/webclient/01_introduction.adoc", "diffHunk": "@@ -16,10 +16,232 @@\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-= Helidon WebClient\n-:toc:\n-:toc-placement: preamble\n+\n+\n+= WebClient Introduction\n+:pagename: WebClient-Introduction\n :description: Helidon WebClient\n-:keywords: helidon, se, rest, httpclient, webclient\n+:keywords: helidon, se, rest, httpclient, webclient, reactive\n+\n+\n+WebClient is an HTTP client for Helidon SE 2.0. It handles the responses to the HTTP requests in a reactive way.\n+\n+Helidon WebClient provides the following features:\n+\n+* *Reactive approach* +\n+Allows you to execute HTTP requests and handle the responses without having to wait for the server response. When the response is received, the client requests only the amount of data that it can handle at that time. So, there is no overflow of memory.\n+\n+* *Builder-like setup and execution* +\n+Creates every client and request as a builder pattern. This improves readability and code maintenance.\n+\n+* *Redirect chain* +\n+Follows the redirect chain and perform requests on the correct endpoint by itself.\n+\n+* *Tracing, metrics and security propagation* +\n+Automatically propogates the configured tracing, metrics and security settings of the Helidon WebServer to the WebClient and uses them during request and response.\n+\n+== Configuring the WebClient\n+\n+The WebClient default configuration may be suitable in most use cases. However, you can configure it to suit your specific requirements.\n+\n+=== Example of a WebClient Configuration\n+\n+[source,java]\n+----\n+Config config = Config.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .config(config.get(\"client\"))\n+        .build();\n+----\n+\n+=== Example of Yaml WebClient Configuration\n+\n+[source, java]\n+----\n+client:\n+  connect-timeout-millis: 2000\n+  read-timeout-millis: 2000\n+  follow-redirects: true <1>\n+  max-redirects: 5\n+  cookies:\n+    automatic-store-enabled: true\n+    default-cookies:\n+      - name: \"env\"\n+        value: \"dev\"\n+  headers:\n+    - name: \"Accept\"\n+      value: [\"application/json\",\"text/plain\"] <2>\n+  services:\n+    exclude: [\"io.helidon.webclient.DefaultServiceRegistry\"]\n+    config:\n+      metrics: \n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+        - type: METER\n+          name-format: \"client.meter.overall\"\n+        - type: TIMER\n+          # meter per method\n+          name-format: \"client.meter.%1$s\"\n+        - methods: [\"GET\"]\n+          type: COUNTER\n+          errors: false\n+          name-format: \"client.counter.%1$s.success\"\n+          description: \"Counter of successful GET requests\"\n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+          type: COUNTER\n+          success: false\n+          name-format: \"wc.counter.%1$s.error\"\n+          description: \"Counter of failed PUT, POST and DELETE requests\"\n+        - methods: [\"GET\"]\n+          type: GAUGE_IN_PROGRESS\n+          name-format: \"client.inprogress.%2$s\"\n+          description: \"In progress requests to host\"\n+      tracing:\n+  proxy:\n+    use-system-selector: false\n+    host: \"hostName\"\n+    port: 80\n+    no-proxy: [\"localhost:8080\", \".helidon.io\", \"192.168.1.1\"] <3>\n+  ssl:\n+    server:\n+      disable-hostname-verification: false\n+      trust-all: false\n+      truststore:\n+        keystore-resource-path: \"path to the keystore\"\n+        keystore-type: \"JKS\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <4>\n+    client:\n+      keystore:\n+        keystore-resource-path: \"path to client keystore\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <5>\n+----\n+\n+<1> Client functional settings\n+<2> Default client headers and cookies\n+<3> Proxy configuration\n+<4> SSL configuration\n+<5> Client service configuration\n+\n+== Creating the WebClient\n+\n+You can create WebClient by executing `WebClient.create()` method. This will create an instance of client with default settings and without a base uri set.\n+\n+To change the default settings and register\n+additional services, you can use simple builder that allows you to customize the client behavior.\n+\n+=== Example\n+.Create a WebClient with simple builder:\n+[source,java]\n+----\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+----\n+\n+== Creating and Executing the WebClient Request\n+\n+WebClient executes requests to the target endpoints and returns specific response type.\n+\n+It offers the following methods to specify the type of request you want to execute:\n+\n+* `put()`\n+* `get()`\n+* `method(String methodName)`\n+\n+These methods set specific request type based on their name or parameter to the new instance of `WebClientRequesBuilder` and return this instance based on configurations for specific request type.\n+\n+You can set configuration for every request type before it is sent.\n+\n+// Do we need to include how to configure the request. If so, please provide info for request type.\n+\n+For the final execution, use the following methods with variations and different parameters:\n+\n+* `CompletionStage<T> submit(Object entity, Class<T> responseType)`\n+* `CompletionStage<T> request(Class<T> responseType)`\n+\n+=== Example\n+.Execute a simple GET request to endpoint:\n+[source,java]\n+----\n+CompletionStage<String> response = client.get()\n+        .path(\"/endpoint\")\n+        .request(String.class);\n+----\n+\n+== Designing the WebClient for JsonObject", "originalCommit": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAzMDM3OA==", "url": "https://github.com/oracle/helidon/pull/1659#discussion_r413030378", "bodyText": "I might suggest avoid using JsonObject word as description of the functionality. JsonObject is just one type which JsonProcessing class supports. I think that saying something like this is more suitable:\nJSON-P media support is not present in the WebClient by default. So, you must first register it before making a request. JSON-P support can be added for example by the class JsonProcessing as described in the following example.", "author": "Verdent", "createdAt": "2020-04-22T14:26:29Z", "path": "docs/se/webclient/01_introduction.adoc", "diffHunk": "@@ -16,10 +16,232 @@\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-= Helidon WebClient\n-:toc:\n-:toc-placement: preamble\n+\n+\n+= WebClient Introduction\n+:pagename: WebClient-Introduction\n :description: Helidon WebClient\n-:keywords: helidon, se, rest, httpclient, webclient\n+:keywords: helidon, se, rest, httpclient, webclient, reactive\n+\n+\n+WebClient is an HTTP client for Helidon SE 2.0. It handles the responses to the HTTP requests in a reactive way.\n+\n+Helidon WebClient provides the following features:\n+\n+* *Reactive approach* +\n+Allows you to execute HTTP requests and handle the responses without having to wait for the server response. When the response is received, the client requests only the amount of data that it can handle at that time. So, there is no overflow of memory.\n+\n+* *Builder-like setup and execution* +\n+Creates every client and request as a builder pattern. This improves readability and code maintenance.\n+\n+* *Redirect chain* +\n+Follows the redirect chain and perform requests on the correct endpoint by itself.\n+\n+* *Tracing, metrics and security propagation* +\n+Automatically propogates the configured tracing, metrics and security settings of the Helidon WebServer to the WebClient and uses them during request and response.\n+\n+== Configuring the WebClient\n+\n+The WebClient default configuration may be suitable in most use cases. However, you can configure it to suit your specific requirements.\n+\n+=== Example of a WebClient Configuration\n+\n+[source,java]\n+----\n+Config config = Config.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .config(config.get(\"client\"))\n+        .build();\n+----\n+\n+=== Example of Yaml WebClient Configuration\n+\n+[source, java]\n+----\n+client:\n+  connect-timeout-millis: 2000\n+  read-timeout-millis: 2000\n+  follow-redirects: true <1>\n+  max-redirects: 5\n+  cookies:\n+    automatic-store-enabled: true\n+    default-cookies:\n+      - name: \"env\"\n+        value: \"dev\"\n+  headers:\n+    - name: \"Accept\"\n+      value: [\"application/json\",\"text/plain\"] <2>\n+  services:\n+    exclude: [\"io.helidon.webclient.DefaultServiceRegistry\"]\n+    config:\n+      metrics: \n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+        - type: METER\n+          name-format: \"client.meter.overall\"\n+        - type: TIMER\n+          # meter per method\n+          name-format: \"client.meter.%1$s\"\n+        - methods: [\"GET\"]\n+          type: COUNTER\n+          errors: false\n+          name-format: \"client.counter.%1$s.success\"\n+          description: \"Counter of successful GET requests\"\n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+          type: COUNTER\n+          success: false\n+          name-format: \"wc.counter.%1$s.error\"\n+          description: \"Counter of failed PUT, POST and DELETE requests\"\n+        - methods: [\"GET\"]\n+          type: GAUGE_IN_PROGRESS\n+          name-format: \"client.inprogress.%2$s\"\n+          description: \"In progress requests to host\"\n+      tracing:\n+  proxy:\n+    use-system-selector: false\n+    host: \"hostName\"\n+    port: 80\n+    no-proxy: [\"localhost:8080\", \".helidon.io\", \"192.168.1.1\"] <3>\n+  ssl:\n+    server:\n+      disable-hostname-verification: false\n+      trust-all: false\n+      truststore:\n+        keystore-resource-path: \"path to the keystore\"\n+        keystore-type: \"JKS\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <4>\n+    client:\n+      keystore:\n+        keystore-resource-path: \"path to client keystore\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <5>\n+----\n+\n+<1> Client functional settings\n+<2> Default client headers and cookies\n+<3> Proxy configuration\n+<4> SSL configuration\n+<5> Client service configuration\n+\n+== Creating the WebClient\n+\n+You can create WebClient by executing `WebClient.create()` method. This will create an instance of client with default settings and without a base uri set.\n+\n+To change the default settings and register\n+additional services, you can use simple builder that allows you to customize the client behavior.\n+\n+=== Example\n+.Create a WebClient with simple builder:\n+[source,java]\n+----\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+----\n+\n+== Creating and Executing the WebClient Request\n+\n+WebClient executes requests to the target endpoints and returns specific response type.\n+\n+It offers the following methods to specify the type of request you want to execute:\n+\n+* `put()`\n+* `get()`\n+* `method(String methodName)`\n+\n+These methods set specific request type based on their name or parameter to the new instance of `WebClientRequesBuilder` and return this instance based on configurations for specific request type.\n+\n+You can set configuration for every request type before it is sent.\n+\n+// Do we need to include how to configure the request. If so, please provide info for request type.\n+\n+For the final execution, use the following methods with variations and different parameters:\n+\n+* `CompletionStage<T> submit(Object entity, Class<T> responseType)`\n+* `CompletionStage<T> request(Class<T> responseType)`\n+\n+=== Example\n+.Execute a simple GET request to endpoint:\n+[source,java]\n+----\n+CompletionStage<String> response = client.get()\n+        .path(\"/endpoint\")\n+        .request(String.class);\n+----\n+\n+== Designing the WebClient for JsonObject\n+\n+JsonObject processing is not present in the WebClient by default. So, you must first register the JsonObject before making a request.", "originalCommit": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1Njk2NA==", "url": "https://github.com/oracle/helidon/pull/1659#discussion_r413056964", "bodyText": "This example is fine, but I am making currently some changes to it to make it much simple to use. There is no need for line 180 to be present in my new version.\n\nAdding reader and writer directly on WebClient builder. Readers and writers added this way are shared across all of the requests of the specific WebClient. (Not between other WebClients)\n\nWebClient client = WebClient.builder()\n        .baseUri(\"http://localhost\")\n        .addReader(JsonProcessing.reader()) //Adds JSON-P reader to all client requests\n        .addWriter(JsonProcessing.writer()) //Adds JSON-P writer to all client requests\n        .addMediaService(JsonProcessing.create()) //Adds JSON-P writer and reader to all client requests\n        .build();\n\n\nVery similar configuration can be also done on each request. Registered readers and writers on request are not propagated to other requests.\n\nCompletionStage<JsonObject> response = client.get()\n        .path(\"/endpoint\")\n        .addReader(JsonProcessing.reader()) //Adds JSON-P reader to this specific request\n        .addWriter(JsonProcessing.writer()) //Adds JSON-P writer to this specific request\n        .addMediaService(JsonProcessing.create()) //Adds JSON-P writer and reader to this specific request\n        .request(JsonObject.class);", "author": "Verdent", "createdAt": "2020-04-22T14:56:57Z", "path": "docs/se/webclient/01_introduction.adoc", "diffHunk": "@@ -16,10 +16,232 @@\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-= Helidon WebClient\n-:toc:\n-:toc-placement: preamble\n+\n+\n+= WebClient Introduction\n+:pagename: WebClient-Introduction\n :description: Helidon WebClient\n-:keywords: helidon, se, rest, httpclient, webclient\n+:keywords: helidon, se, rest, httpclient, webclient, reactive\n+\n+\n+WebClient is an HTTP client for Helidon SE 2.0. It handles the responses to the HTTP requests in a reactive way.\n+\n+Helidon WebClient provides the following features:\n+\n+* *Reactive approach* +\n+Allows you to execute HTTP requests and handle the responses without having to wait for the server response. When the response is received, the client requests only the amount of data that it can handle at that time. So, there is no overflow of memory.\n+\n+* *Builder-like setup and execution* +\n+Creates every client and request as a builder pattern. This improves readability and code maintenance.\n+\n+* *Redirect chain* +\n+Follows the redirect chain and perform requests on the correct endpoint by itself.\n+\n+* *Tracing, metrics and security propagation* +\n+Automatically propogates the configured tracing, metrics and security settings of the Helidon WebServer to the WebClient and uses them during request and response.\n+\n+== Configuring the WebClient\n+\n+The WebClient default configuration may be suitable in most use cases. However, you can configure it to suit your specific requirements.\n+\n+=== Example of a WebClient Configuration\n+\n+[source,java]\n+----\n+Config config = Config.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .config(config.get(\"client\"))\n+        .build();\n+----\n+\n+=== Example of Yaml WebClient Configuration\n+\n+[source, java]\n+----\n+client:\n+  connect-timeout-millis: 2000\n+  read-timeout-millis: 2000\n+  follow-redirects: true <1>\n+  max-redirects: 5\n+  cookies:\n+    automatic-store-enabled: true\n+    default-cookies:\n+      - name: \"env\"\n+        value: \"dev\"\n+  headers:\n+    - name: \"Accept\"\n+      value: [\"application/json\",\"text/plain\"] <2>\n+  services:\n+    exclude: [\"io.helidon.webclient.DefaultServiceRegistry\"]\n+    config:\n+      metrics: \n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+        - type: METER\n+          name-format: \"client.meter.overall\"\n+        - type: TIMER\n+          # meter per method\n+          name-format: \"client.meter.%1$s\"\n+        - methods: [\"GET\"]\n+          type: COUNTER\n+          errors: false\n+          name-format: \"client.counter.%1$s.success\"\n+          description: \"Counter of successful GET requests\"\n+        - methods: [\"PUT\", \"POST\", \"DELETE\"]\n+          type: COUNTER\n+          success: false\n+          name-format: \"wc.counter.%1$s.error\"\n+          description: \"Counter of failed PUT, POST and DELETE requests\"\n+        - methods: [\"GET\"]\n+          type: GAUGE_IN_PROGRESS\n+          name-format: \"client.inprogress.%2$s\"\n+          description: \"In progress requests to host\"\n+      tracing:\n+  proxy:\n+    use-system-selector: false\n+    host: \"hostName\"\n+    port: 80\n+    no-proxy: [\"localhost:8080\", \".helidon.io\", \"192.168.1.1\"] <3>\n+  ssl:\n+    server:\n+      disable-hostname-verification: false\n+      trust-all: false\n+      truststore:\n+        keystore-resource-path: \"path to the keystore\"\n+        keystore-type: \"JKS\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <4>\n+    client:\n+      keystore:\n+        keystore-resource-path: \"path to client keystore\"\n+        keystore-passphrase: \"password\"\n+        trust-store: true <5>\n+----\n+\n+<1> Client functional settings\n+<2> Default client headers and cookies\n+<3> Proxy configuration\n+<4> SSL configuration\n+<5> Client service configuration\n+\n+== Creating the WebClient\n+\n+You can create WebClient by executing `WebClient.create()` method. This will create an instance of client with default settings and without a base uri set.\n+\n+To change the default settings and register\n+additional services, you can use simple builder that allows you to customize the client behavior.\n+\n+=== Example\n+.Create a WebClient with simple builder:\n+[source,java]\n+----\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+----\n+\n+== Creating and Executing the WebClient Request\n+\n+WebClient executes requests to the target endpoints and returns specific response type.\n+\n+It offers the following methods to specify the type of request you want to execute:\n+\n+* `put()`\n+* `get()`\n+* `method(String methodName)`\n+\n+These methods set specific request type based on their name or parameter to the new instance of `WebClientRequesBuilder` and return this instance based on configurations for specific request type.\n+\n+You can set configuration for every request type before it is sent.\n+\n+// Do we need to include how to configure the request. If so, please provide info for request type.\n+\n+For the final execution, use the following methods with variations and different parameters:\n+\n+* `CompletionStage<T> submit(Object entity, Class<T> responseType)`\n+* `CompletionStage<T> request(Class<T> responseType)`\n+\n+=== Example\n+.Execute a simple GET request to endpoint:\n+[source,java]\n+----\n+CompletionStage<String> response = client.get()\n+        .path(\"/endpoint\")\n+        .request(String.class);\n+----\n+\n+== Designing the WebClient for JsonObject\n+\n+JsonObject processing is not present in the WebClient by default. So, you must first register the JsonObject before making a request.\n+\n+[source,java]\n+.Register JsonObject to the request builder using the register method.\n+----\n+JsonProcessing jsonProcessing = JsonProcessing.create();\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+\n+CompletionStage<JsonObject> response = client.get()\n+        .path(\"/endpoint\")\n+        .register(jsonProcessing.newReader())\n+        .request(JsonObject.class);\n+---- \n+\n+[source,java]\n+.Make a GET or PUT request to the endpoint.\n+----\n+JsonProcessing jsonProcessing = JsonProcessing.create();\n+JsonObject entity = //some JsonObject entity\n+WebClient client = WebClient.builder()\n+        .baseUri(\"http://localhost\")\n+        .build();\n+\n+CompletionStage<WebClientResponse> response = client.put()\n+        .path(\"/endpoint\")\n+        .register(jsonProcessing.newWriter())\n+        .submit(entity);\n+----", "originalCommit": "1f5715751dc6ef73f39019a35f6f8f6d083233e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aac753d057c1f792c4ceafb63b5ebba1b963ab72", "url": "https://github.com/oracle/helidon/commit/aac753d057c1f792c4ceafb63b5ebba1b963ab72", "message": "Worked on the suggested changes", "committedDate": "2020-04-23T17:21:15Z", "type": "commit"}, {"oid": "cd07a04f6a502bf599ae50ee151040f89c525243", "url": "https://github.com/oracle/helidon/commit/cd07a04f6a502bf599ae50ee151040f89c525243", "message": "Updated JSON Support to WebClient Examples", "committedDate": "2020-05-18T17:53:58Z", "type": "commit"}]}