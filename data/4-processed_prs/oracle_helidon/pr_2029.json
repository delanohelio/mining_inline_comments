{"pr_number": 2029, "pr_title": "SE Messaging doc", "pr_createdAt": "2020-06-17T12:54:38Z", "pr_url": "https://github.com/oracle/helidon/pull/2029", "timeline": [{"oid": "b8b530f4f8574b21ab9f0f2fb0546faaf2e8eb82", "url": "https://github.com/oracle/helidon/commit/b8b530f4f8574b21ab9f0f2fb0546faaf2e8eb82", "message": "SE Messaging doc\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-18T12:27:51Z", "type": "forcePushed"}, {"oid": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "url": "https://github.com/oracle/helidon/commit/2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "message": "SE Messaging doc\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-18T12:57:21Z", "type": "forcePushed"}, {"oid": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "url": "https://github.com/oracle/helidon/commit/2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "message": "SE Messaging doc\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-18T12:57:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyOTY0Mg==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442229642", "bodyText": ":h1Prefix: MP", "author": "ljamen", "createdAt": "2020-06-18T13:34:36Z", "path": "docs/mp/reactivemessaging/04_kafka.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Kafka Connector\n+:toc:\n+:toc-placement: preamble\n+:description: Reactive Messaging support for Kafka in Helidon MP\n+:keywords: helidon, mp, messaging, kafka\n+", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NDQ1MA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442274450", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyOTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMTEzNA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442231134", "bodyText": "Connecting streams to Kafka with Reactive Messaging couldn't be easier.", "author": "ljamen", "createdAt": "2020-06-18T13:36:46Z", "path": "docs/mp/reactivemessaging/04_kafka.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Kafka Connector\n+:toc:\n+:toc-placement: preamble\n+:description: Reactive Messaging support for Kafka in Helidon MP\n+:keywords: helidon, mp, messaging, kafka\n+\n+== Reactive Kafka Connector\n+Connecting streams to Kafka via Reactive Messaging just can't be easier. \n+", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NDYwNA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442274604", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMTQ5NA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442231494", "bodyText": ":h1Prefix: SE", "author": "ljamen", "createdAt": "2020-06-18T13:37:19Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,96 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NDczNQ==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442274735", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzMTQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzNTQ1NQ==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442235455", "bodyText": "While its possible to start building your reactive streams directly by combining operators and connecting them to reactive APIs, with Helidon SE Reactive Messaging, you can now use prepared tools for repetitive use case scenarios .", "author": "ljamen", "createdAt": "2020-06-18T13:42:57Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,96 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While it may seem natural in Helidon SE to start building your reactive streams directly\n+by combining operators and connecting them to reactive APIs.\n+There are repetitive use-cases you can use prepared tools for, and that is Helidon SE Reactive Messaging.\n+", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3Njc2Nw==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442276767", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzNTQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzOTIxNg==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442239216", "bodyText": "Reactive Messaging in Helidon SE uses the same concept of messaging wrapping as Microprofile messaging. The only notable difference is that ....", "author": "ljamen", "createdAt": "2020-06-18T13:48:13Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,96 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While it may seem natural in Helidon SE to start building your reactive streams directly\n+by combining operators and connecting them to reactive APIs.\n+There are repetitive use-cases you can use prepared tools for, and that is Helidon SE Reactive Messaging.\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate code for\n+configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring\n+Connectors and Emitters with your reactive streams thru so called <<Channel,Channels>>.\n+\n+You may wonder how *Reactive Messaging* relates to\n+<<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>>.\n+As the making of connectors or even configuring them can be repetitive task leading to\n+the same results, Helidon SE Reactive Messaging supports very same configuration format\n+for connectors as its MicroProfile counterpart does. Also, MP Connectors are reusable in\n+Helidon SE Messaging with some limitation(there is no CDI in Helidon SE).\n+All Messaging connectors in Helidon are made to be universally usable by Helidon MP and SE.\n+\n+=== Channel\n+Channel is a named pair of `Publisher` and `Subscriber`, channels can be connected together by <<Processors,processors>>. Registering of `Publisher` or `Subscriber` for a channel can be done by Messaging API, or configured implicitly for using registered <<se/03_connector.adoc,connector>> for generating such `Publisher` or `Subscriber`.\n+\n+[source,java]\n+.Example of simple channel:\n+----\n+Channel<String> channel1 = Channel.create(\"channel1\");\n+\n+Messaging.builder()\n+        .publisher(channel1, Multi.just(\"message 1\", \"message 2\")\n+                                  .map(Message::of))\n+        .listener(channel1, s -> System.out.println(\"Intecepted message \" + s))\n+        .build()\n+        .start();\n+----\n+\n+=== Processor\n+Processor is a typical reactive processor acting as a `Subscriber` to upstream and as a `Publisher` to downstream. In terms of reactive messaging it is able to connect two <<Channel,channels>> to one reactive stream.\n+\n+[source,java]\n+.Example of processor usage:\n+----\n+Channel<String> firstChannel = Channel.create(\"first-channel\");\n+Channel<String> secondChannel = Channel.create(\"second-channel\");\n+\n+Messaging.builder()\n+        .publisher(secondChannel, ReactiveStreams.of(\"test1\", \"test2\", \"test3\")\n+                .map(Message::of))\n+        .processor(secondChannel, firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .map(Message::getPayload)\n+                .map(String::toUpperCase)\n+                .map(Message::of)\n+        )\n+        .subscriber(firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .peek(Message::ack)\n+                .map(Message::getPayload)\n+                .forEach(s -> System.out.println(\"Consuming message \" + s)))\n+        .build()\n+        .start();\n+\n+>Consuming message TEST1 \n+>Consuming message TEST2\n+>Consuming message TEST3\n+----\n+\n+=== Message\n+Reactive Messaging in Helidon SE is using same concept of <<mp/reactivemessaging/02_message.adoc,Message wrapper>> as Microprofile messaging, only notable difference is that SE Messaging does almost no implicit or automatic acknowledgement due to _no magic_ phylosophy of Helidon SE. \n+\n+Only exception to this are variants of methods `Messaging.Builder#listener` and `Messaging.Builder#processor` with consumer or function params, conviniently unwraping payload for you. After such implicit unwraping is not possible to do manual acknowledgement, therefore implicit ack before callback is executed is necessary.   ", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NTYwNQ==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442275605", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzOTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzOTg3Mw==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442239873", "bodyText": "typo: both flavors of Helidon...", "author": "ljamen", "createdAt": "2020-06-18T13:49:05Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,96 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While it may seem natural in Helidon SE to start building your reactive streams directly\n+by combining operators and connecting them to reactive APIs.\n+There are repetitive use-cases you can use prepared tools for, and that is Helidon SE Reactive Messaging.\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate code for\n+configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring\n+Connectors and Emitters with your reactive streams thru so called <<Channel,Channels>>.\n+\n+You may wonder how *Reactive Messaging* relates to\n+<<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>>.\n+As the making of connectors or even configuring them can be repetitive task leading to\n+the same results, Helidon SE Reactive Messaging supports very same configuration format\n+for connectors as its MicroProfile counterpart does. Also, MP Connectors are reusable in\n+Helidon SE Messaging with some limitation(there is no CDI in Helidon SE).\n+All Messaging connectors in Helidon are made to be universally usable by Helidon MP and SE.\n+\n+=== Channel\n+Channel is a named pair of `Publisher` and `Subscriber`, channels can be connected together by <<Processors,processors>>. Registering of `Publisher` or `Subscriber` for a channel can be done by Messaging API, or configured implicitly for using registered <<se/03_connector.adoc,connector>> for generating such `Publisher` or `Subscriber`.\n+\n+[source,java]\n+.Example of simple channel:\n+----\n+Channel<String> channel1 = Channel.create(\"channel1\");\n+\n+Messaging.builder()\n+        .publisher(channel1, Multi.just(\"message 1\", \"message 2\")\n+                                  .map(Message::of))\n+        .listener(channel1, s -> System.out.println(\"Intecepted message \" + s))\n+        .build()\n+        .start();\n+----\n+\n+=== Processor\n+Processor is a typical reactive processor acting as a `Subscriber` to upstream and as a `Publisher` to downstream. In terms of reactive messaging it is able to connect two <<Channel,channels>> to one reactive stream.\n+\n+[source,java]\n+.Example of processor usage:\n+----\n+Channel<String> firstChannel = Channel.create(\"first-channel\");\n+Channel<String> secondChannel = Channel.create(\"second-channel\");\n+\n+Messaging.builder()\n+        .publisher(secondChannel, ReactiveStreams.of(\"test1\", \"test2\", \"test3\")\n+                .map(Message::of))\n+        .processor(secondChannel, firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .map(Message::getPayload)\n+                .map(String::toUpperCase)\n+                .map(Message::of)\n+        )\n+        .subscriber(firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .peek(Message::ack)\n+                .map(Message::getPayload)\n+                .forEach(s -> System.out.println(\"Consuming message \" + s)))\n+        .build()\n+        .start();\n+\n+>Consuming message TEST1 \n+>Consuming message TEST2\n+>Consuming message TEST3\n+----\n+\n+=== Message\n+Reactive Messaging in Helidon SE is using same concept of <<mp/reactivemessaging/02_message.adoc,Message wrapper>> as Microprofile messaging, only notable difference is that SE Messaging does almost no implicit or automatic acknowledgement due to _no magic_ phylosophy of Helidon SE. \n+\n+Only exception to this are variants of methods `Messaging.Builder#listener` and `Messaging.Builder#processor` with consumer or function params, conviniently unwraping payload for you. After such implicit unwraping is not possible to do manual acknowledgement, therefore implicit ack before callback is executed is necessary.   \n+\n+=== Connector\n+Connector concept is a way for connecting <<Channel,channels>> to external sources. To make <<se/reactivemessaging/03_connector.adoc,creation and usage of connectors>> as easy and versatile as possible, Helidon SE Messaging uses same API for connectors like <<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>> does. This allows connectors to be usable in both flawors of Helidon with one limitation which is that connector has to be able to work without CDI. ", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NTc3NA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442275774", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIzOTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0MTU5Mg==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442241592", "bodyText": ":h1Prefix: SE", "author": "ljamen", "createdAt": "2020-06-18T13:51:14Z", "path": "docs/se/reactivemessaging/04_kafka.adoc", "diffHunk": "@@ -0,0 +1,165 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Kafka Connector\n+:toc:\n+:toc-placement: preamble\n+:description: Reactive Messaging support for Kafka in Helidon SE\n+:keywords: helidon, se, messaging, kafka", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NjM0Ng==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442276346", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0MTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0MjAyNA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442242024", "bodyText": "Connecting streams to Kafka with Reactive Messaging couldn't be easier.", "author": "ljamen", "createdAt": "2020-06-18T13:51:48Z", "path": "docs/se/reactivemessaging/04_kafka.adoc", "diffHunk": "@@ -0,0 +1,165 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Kafka Connector\n+:toc:\n+:toc-placement: preamble\n+:description: Reactive Messaging support for Kafka in Helidon SE\n+:keywords: helidon, se, messaging, kafka\n+\n+== Reactive Kafka Connector\n+Connecting streams to Kafka via Reactive Messaging just can't be easier. \n+", "originalCommit": "2f54510e52c84f077503b9e5f0ca69cfec9dc68e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3NjEyMQ==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442276121", "bodyText": "thx fixed", "author": "danielkec", "createdAt": "2020-06-18T14:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0MjAyNA=="}], "type": "inlineReview"}, {"oid": "2a4f7d164832eca873436989dea3c0bd64f2d287", "url": "https://github.com/oracle/helidon/commit/2a4f7d164832eca873436989dea3c0bd64f2d287", "message": "Review issues fix 1\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-18T14:36:24Z", "type": "commit"}, {"oid": "aca86e83d73fe415a9457c1f45495074a3c7bf82", "url": "https://github.com/oracle/helidon/commit/aca86e83d73fe415a9457c1f45495074a3c7bf82", "message": "Review issues 2\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-19T14:37:01Z", "type": "commit"}, {"oid": "f99cc17019547c172a62ff98dabe99b762c609fa", "url": "https://github.com/oracle/helidon/commit/f99cc17019547c172a62ff98dabe99b762c609fa", "message": "Review issues 3\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-19T14:45:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MTc2Nw==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442891767", "bodyText": "Typo: \"Reative\" should be \"Reactive\"", "author": "tjquinno", "createdAt": "2020-06-19T15:02:28Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,113 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n+:h1Prefix: SE\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While its possible to start building your reactive streams directly by combining operators and\n+connecting them to reactive APIs, with Helidon SE Reactive Messaging, you can now use prepared\n+tools for repetitive use case scenarios .\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate\n+code for configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring", "originalCommit": "f99cc17019547c172a62ff98dabe99b762c609fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxNTQ2Ng==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442915466", "bodyText": "thx a lot , fixed", "author": "danielkec", "createdAt": "2020-06-19T15:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5NzkwNQ==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442897905", "bodyText": "Maybe split into two sentences?\nFrom\nand Subscriber, channels\nto\nand Subscriber. Channels", "author": "tjquinno", "createdAt": "2020-06-19T15:13:59Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,113 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n+:h1Prefix: SE\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While its possible to start building your reactive streams directly by combining operators and\n+connecting them to reactive APIs, with Helidon SE Reactive Messaging, you can now use prepared\n+tools for repetitive use case scenarios .\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate\n+code for configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring\n+Connectors and Emitters with your reactive streams thru so called <<Channel,Channels>>.\n+\n+You may wonder how *Reactive Messaging* relates to\n+<<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>>.\n+As the making of connectors or even configuring them can be repetitive task leading to\n+the same results, Helidon SE Reactive Messaging supports very same configuration format\n+for connectors as its MicroProfile counterpart does. Also, MP Connectors are reusable in\n+Helidon SE Messaging with some limitation(there is no CDI in Helidon SE).\n+All Messaging connectors in Helidon are made to be universally usable by Helidon MP and SE.\n+\n+=== Channel\n+Channel is a named pair of `Publisher` and `Subscriber`, channels can be connected together by", "originalCommit": "f99cc17019547c172a62ff98dabe99b762c609fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5ODc0MA==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442898740", "bodyText": "MicroProfile should have an upper-case \"P\".", "author": "tjquinno", "createdAt": "2020-06-19T15:15:30Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,113 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n+:h1Prefix: SE\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While its possible to start building your reactive streams directly by combining operators and\n+connecting them to reactive APIs, with Helidon SE Reactive Messaging, you can now use prepared\n+tools for repetitive use case scenarios .\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate\n+code for configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring\n+Connectors and Emitters with your reactive streams thru so called <<Channel,Channels>>.\n+\n+You may wonder how *Reactive Messaging* relates to\n+<<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>>.\n+As the making of connectors or even configuring them can be repetitive task leading to\n+the same results, Helidon SE Reactive Messaging supports very same configuration format\n+for connectors as its MicroProfile counterpart does. Also, MP Connectors are reusable in\n+Helidon SE Messaging with some limitation(there is no CDI in Helidon SE).\n+All Messaging connectors in Helidon are made to be universally usable by Helidon MP and SE.\n+\n+=== Channel\n+Channel is a named pair of `Publisher` and `Subscriber`, channels can be connected together by\n+<<Processors,processors>>. Registering of `Publisher` or `Subscriber` for a channel can be done\n+by Messaging API, or configured implicitly for using registered <<se/03_connector.adoc,connector>>\n+for generating such `Publisher` or `Subscriber`.\n+\n+[source,java]\n+.Example of simple channel:\n+----\n+Channel<String> channel1 = Channel.create(\"channel1\");\n+\n+Messaging.builder()\n+        .publisher(channel1, Multi.just(\"message 1\", \"message 2\")\n+                                  .map(Message::of))\n+        .listener(channel1, s -> System.out.println(\"Intecepted message \" + s))\n+        .build()\n+        .start();\n+----\n+\n+=== Processor\n+Processor is a typical reactive processor acting as a `Subscriber` to upstream and as a `Publisher`\n+to downstream. In terms of reactive messaging it is able to connect two <<Channel,channels>> to one\n+reactive stream.\n+\n+[source,java]\n+.Example of processor usage:\n+----\n+Channel<String> firstChannel = Channel.create(\"first-channel\");\n+Channel<String> secondChannel = Channel.create(\"second-channel\");\n+\n+Messaging.builder()\n+        .publisher(secondChannel, ReactiveStreams.of(\"test1\", \"test2\", \"test3\")\n+                .map(Message::of))\n+        .processor(secondChannel, firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .map(Message::getPayload)\n+                .map(String::toUpperCase)\n+                .map(Message::of)\n+        )\n+        .subscriber(firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .peek(Message::ack)\n+                .map(Message::getPayload)\n+                .forEach(s -> System.out.println(\"Consuming message \" + s)))\n+        .build()\n+        .start();\n+\n+>Consuming message TEST1 \n+>Consuming message TEST2\n+>Consuming message TEST3\n+----\n+\n+=== Message\n+Reactive Messaging in Helidon SE uses the same concept of\n+<<mp/reactivemessaging/02_message.adoc,message wrapping>> as Microprofile messaging.", "originalCommit": "f99cc17019547c172a62ff98dabe99b762c609fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5OTA4Ng==", "url": "https://github.com/oracle/helidon/pull/2029#discussion_r442899086", "bodyText": "conviniently  should be conveniently", "author": "tjquinno", "createdAt": "2020-06-19T15:16:02Z", "path": "docs/se/reactivemessaging/01_introduction.adoc", "diffHunk": "@@ -20,6 +20,113 @@\n :toc:\n :toc-placement: preamble\n :description: Reactive Messaging support in Helidon SE\n-:keywords: helidon, mp, messaging\n+:keywords: helidon, se, messaging\n+:h1Prefix: SE\n \n-== This page is Under Construction and will be available soon\n+== Reactive Messaging\n+\n+Asynchronous messaging is a commonly used form of communication in the world of microservices.\n+While its possible to start building your reactive streams directly by combining operators and\n+connecting them to reactive APIs, with Helidon SE Reactive Messaging, you can now use prepared\n+tools for repetitive use case scenarios .\n+\n+For example connecting your streams to external services usually requires a lot of boiler-plate\n+code for configuration handling, backpressure propagation, acknowledgement and more.\n+\n+For such tasks there is a system of connectors, emitters and means to orchestrate them in Helidon,\n+called *Reative Messaging*. It's basically an API for connecting and configuring\n+Connectors and Emitters with your reactive streams thru so called <<Channel,Channels>>.\n+\n+You may wonder how *Reactive Messaging* relates to\n+<<mp/reactivemessaging/01_introduction.adoc,MicroProfile Reactive Messaging>>.\n+As the making of connectors or even configuring them can be repetitive task leading to\n+the same results, Helidon SE Reactive Messaging supports very same configuration format\n+for connectors as its MicroProfile counterpart does. Also, MP Connectors are reusable in\n+Helidon SE Messaging with some limitation(there is no CDI in Helidon SE).\n+All Messaging connectors in Helidon are made to be universally usable by Helidon MP and SE.\n+\n+=== Channel\n+Channel is a named pair of `Publisher` and `Subscriber`, channels can be connected together by\n+<<Processors,processors>>. Registering of `Publisher` or `Subscriber` for a channel can be done\n+by Messaging API, or configured implicitly for using registered <<se/03_connector.adoc,connector>>\n+for generating such `Publisher` or `Subscriber`.\n+\n+[source,java]\n+.Example of simple channel:\n+----\n+Channel<String> channel1 = Channel.create(\"channel1\");\n+\n+Messaging.builder()\n+        .publisher(channel1, Multi.just(\"message 1\", \"message 2\")\n+                                  .map(Message::of))\n+        .listener(channel1, s -> System.out.println(\"Intecepted message \" + s))\n+        .build()\n+        .start();\n+----\n+\n+=== Processor\n+Processor is a typical reactive processor acting as a `Subscriber` to upstream and as a `Publisher`\n+to downstream. In terms of reactive messaging it is able to connect two <<Channel,channels>> to one\n+reactive stream.\n+\n+[source,java]\n+.Example of processor usage:\n+----\n+Channel<String> firstChannel = Channel.create(\"first-channel\");\n+Channel<String> secondChannel = Channel.create(\"second-channel\");\n+\n+Messaging.builder()\n+        .publisher(secondChannel, ReactiveStreams.of(\"test1\", \"test2\", \"test3\")\n+                .map(Message::of))\n+        .processor(secondChannel, firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .map(Message::getPayload)\n+                .map(String::toUpperCase)\n+                .map(Message::of)\n+        )\n+        .subscriber(firstChannel, ReactiveStreams.<Message<String>>builder()\n+                .peek(Message::ack)\n+                .map(Message::getPayload)\n+                .forEach(s -> System.out.println(\"Consuming message \" + s)))\n+        .build()\n+        .start();\n+\n+>Consuming message TEST1 \n+>Consuming message TEST2\n+>Consuming message TEST3\n+----\n+\n+=== Message\n+Reactive Messaging in Helidon SE uses the same concept of\n+<<mp/reactivemessaging/02_message.adoc,message wrapping>> as Microprofile messaging.\n+The only notable difference is that SE Messaging does almost no implicit or automatic\n+acknowledgement due to _no magic_ phylosophy of Helidon SE.\n+\n+Only exception to this are variants of methods `Messaging.Builder#listener` and\n+`Messaging.Builder#processor` with consumer or function params, conviniently unwraping payload", "originalCommit": "f99cc17019547c172a62ff98dabe99b762c609fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3563e712212c5bf458af49bb99249bb4798f25e3", "url": "https://github.com/oracle/helidon/commit/3563e712212c5bf458af49bb99249bb4798f25e3", "message": "Review issues 4\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-06-19T15:46:49Z", "type": "commit"}]}