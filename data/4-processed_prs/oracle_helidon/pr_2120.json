{"pr_number": 2120, "pr_title": "Fault tolerance for SE", "pr_createdAt": "2020-07-01T23:29:17Z", "pr_url": "https://github.com/oracle/helidon/pull/2120", "timeline": [{"oid": "06d1c67f00d05a6e1f7a66a9e5e423539618045e", "url": "https://github.com/oracle/helidon/commit/06d1c67f00d05a6e1f7a66a9e5e423539618045e", "message": "FaultTolerance for SE.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "3b300214d0bd5680ea1f9b27240e26a99e437788", "url": "https://github.com/oracle/helidon/commit/3b300214d0bd5680ea1f9b27240e26a99e437788", "message": "Update to support multi.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "1c8304cf812ce6231060443b6e012b7a401a8db2", "url": "https://github.com/oracle/helidon/commit/1c8304cf812ce6231060443b6e012b7a401a8db2", "message": "Javadoc and finished all handlers.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "addc87e85972b5cf482b270fa3de8b06a5d2e0f2", "url": "https://github.com/oracle/helidon/commit/addc87e85972b5cf482b270fa3de8b06a5d2e0f2", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "9021d111e73aa552062f5c33d6843e8c11e2e6e9", "url": "https://github.com/oracle/helidon/commit/9021d111e73aa552062f5c33d6843e8c11e2e6e9", "message": "Sending an error now resolves error handlers.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "8ca08a867b3b68f36c4c1bbcc87c1e35519e43d4", "url": "https://github.com/oracle/helidon/commit/8ca08a867b3b68f36c4c1bbcc87c1e35519e43d4", "message": "Example for FT with webserver.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:40:29Z", "type": "commit"}, {"oid": "72accbbb0bff3984df0d2d2b5215345556901309", "url": "https://github.com/oracle/helidon/commit/72accbbb0bff3984df0d2d2b5215345556901309", "message": "Rebase and fix version.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:41:30Z", "type": "commit"}, {"oid": "72accbbb0bff3984df0d2d2b5215345556901309", "url": "https://github.com/oracle/helidon/commit/72accbbb0bff3984df0d2d2b5215345556901309", "message": "Rebase and fix version.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-01T23:41:30Z", "type": "forcePushed"}, {"oid": "f557c589a94399c1a2169e5d0f4af2a0e06f7b5e", "url": "https://github.com/oracle/helidon/commit/f557c589a94399c1a2169e5d0f4af2a0e06f7b5e", "message": "Fixed javadoc\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-02T10:02:57Z", "type": "commit"}, {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "url": "https://github.com/oracle/helidon/commit/0220ec94c2fa14c445c1ee9e0500ad64c9784993", "message": "Scope fix for test dependency.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-02T12:03:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025098", "bodyText": "Need it?", "author": "spericas", "createdAt": "2020-07-02T14:02:58Z", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNjkyMg==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449116922", "bodyText": "Need what? Sorry I do not see it", "author": "tomas-langer", "createdAt": "2020-07-02T15:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjUzMA==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449132530", "bodyText": ":) Meant if we need the variable it", "author": "spericas", "createdAt": "2020-07-02T16:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjA3MA==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449266070", "bodyText": "No :)", "author": "tomas-langer", "createdAt": "2020-07-02T21:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDY3Mw==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274673", "bodyText": "it not there anymore", "author": "tomas-langer", "createdAt": "2020-07-02T21:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTY3OQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025679", "bodyText": "Variable inProgressResult not used", "author": "spericas", "createdAt": "2020-07-02T14:03:51Z", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/BulkheadTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.IntStream;\n+\n+import io.helidon.common.LogConfig;\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class BulkheadTest {\n+    @BeforeAll\n+    static void setupTest() {\n+        LogConfig.configureRuntime();\n+    }\n+\n+    @Test\n+    void testBulkheadQueue() throws InterruptedException {\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(1000)\n+                .build();\n+\n+        Request inProgress = new Request(0);\n+        Single<Integer> inProgressResult = bulkhead.invoke(inProgress::invoke);", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDYxNw==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274617", "bodyText": "Removed", "author": "tomas-langer", "createdAt": "2020-07-02T21:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzYxNQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449027615", "bodyText": "Minor: can be static", "author": "spericas", "createdAt": "2020-07-02T14:06:33Z", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/FaultToleranceTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class FaultToleranceTest {\n+\n+    @Test\n+    void testCustomCombination() {\n+        CircuitBreaker breaker = CircuitBreaker.builder()\n+                .build();\n+\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(0)\n+                .build();\n+\n+        FtHandlerTyped<String> faultTolerance = FaultTolerance.builder()\n+                .addBreaker(breaker)\n+                .addBulkhead(bulkhead)\n+                .addTimeout(Timeout.builder().timeout(Duration.ofMillis(100)).build())\n+                .addFallback(Fallback.<String>builder()\n+                                     .fallback(this::fallback)\n+                                     .build())\n+                .build();\n+\n+        Single<String> result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(MyException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.OPEN);\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(CircuitBreakerOpenException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.CLOSED);\n+\n+        Manual m = new Manual();\n+        Single<String> manualResult = bulkhead.invoke(m::call);\n+\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(BulkheadException.class.getName()));\n+\n+        m.future.complete(\"result\");\n+        manualResult.await(1, TimeUnit.SECONDS);\n+\n+        m = new Manual();\n+        result = faultTolerance.invoke(m::call);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(TimeoutException.class.getName()));\n+\n+        m.future.complete(\"hu\");\n+    }\n+\n+    private Single<String> primary() {\n+        return Single.error(new MyException());\n+    }\n+\n+    private Single<String> fallback(Throwable throwable) {\n+        return Single.just(throwable.getClass().getName());\n+    }\n+\n+    static <T extends Throwable> T completionException(Single<?> result, Class<T> expected) {\n+        CompletionException completionException = assertThrows(CompletionException.class,\n+                                                               () -> result.await(1, TimeUnit.SECONDS));\n+        Throwable cause = completionException.getCause();\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(expected));\n+\n+        return expected.cast(cause);\n+    }\n+\n+    private class Manual {", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDU3NQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274575", "bodyText": "Static", "author": "tomas-langer", "createdAt": "2020-07-02T21:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449040566", "bodyText": "May be a bit more readable if methods had a suffix like \"M\", a bit difficult to read when named same as variables", "author": "spericas", "createdAt": "2020-07-02T14:25:04Z", "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.examples.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+import io.helidon.faulttolerance.Async;\n+import io.helidon.faulttolerance.Bulkhead;\n+import io.helidon.faulttolerance.CircuitBreaker;\n+import io.helidon.faulttolerance.Fallback;\n+import io.helidon.faulttolerance.Retry;\n+import io.helidon.faulttolerance.Timeout;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+/**\n+ * Simple service to demonstrate fault tolerance.\n+ */\n+public class FtService implements Service {", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNzYwNA==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449117604", "bodyText": "Will make it clear", "author": "tomas-langer", "createdAt": "2020-07-02T15:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjkyOQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449266929", "bodyText": "Changed method names to *Handler", "author": "tomas-langer", "createdAt": "2020-07-02T21:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NTQyNQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449075425", "bodyText": "Unused", "author": "spericas", "createdAt": "2020-07-02T15:16:03Z", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/AsyncTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AsyncTest {\n+    private final AtomicInteger syncCounter = new AtomicInteger();\n+\n+    @BeforeEach\n+    void reset() {\n+        syncCounter.set(0);\n+    }\n+\n+    @Test\n+    void testAsync() {\n+        Thread result = Async.create()\n+                .invoke(this::sync)\n+                .await(1, TimeUnit.SECONDS);\n+\n+        assertThat(result, is(not(Thread.currentThread())));\n+        assertThat(syncCounter.get(), is(1));\n+    }\n+\n+    @Test\n+    void testAsyncError() {\n+        Single<String> result = Async.create()\n+                .invoke(this::syncError);\n+\n+        CompletionException exception = assertThrows(CompletionException.class, () -> result.await(1, TimeUnit.SECONDS));\n+\n+        Throwable cause = exception.getCause();\n+\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(MyException.class));\n+    }\n+\n+    private List<String> syncList() {", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDUwMg==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274502", "bodyText": "Removed", "author": "tomas-langer", "createdAt": "2020-07-02T21:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MTU2OQ==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449091569", "bodyText": "Isn't this better?\n    final static class AtomicCycle {\n        private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n        private final int maxIndex;\n\n        AtomicCycle(int maxIndex) {\n            this.maxIndex = maxIndex + 1;\n        }\n\n        int incrementAndGet() {\n            return atomicInteger.accumulateAndGet(maxIndex, (current, max) -> (current + 1) % max);\n        }\n    }", "author": "spericas", "createdAt": "2020-07-02T15:33:48Z", "path": "fault-tolerance/src/main/java/io/helidon/faulttolerance/AtomicCycle.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class AtomicCycle {\n+    private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n+    private final int maxIndex;\n+\n+    AtomicCycle(int maxIndex) {\n+        this.maxIndex = maxIndex;\n+    }\n+\n+    int incrementAndGet() {\n+        int currentIndex;\n+        int nextIndex;\n+        do {\n+            currentIndex = atomicInteger.get();\n+            nextIndex = (currentIndex == maxIndex) ? 0 : currentIndex + 1;\n+        } while (!atomicInteger.compareAndSet(currentIndex, nextIndex));\n+\n+        return nextIndex;\n+    }", "originalCommit": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDQ0Mg==", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274442", "bodyText": "Yes, fixed.", "author": "tomas-langer", "createdAt": "2020-07-02T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MTU2OQ=="}], "type": "inlineReview"}, {"oid": "7908b57af9119a22bcb1ec0fca87157b583e377f", "url": "https://github.com/oracle/helidon/commit/7908b57af9119a22bcb1ec0fca87157b583e377f", "message": "Incorporated review changes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-07-02T21:29:09Z", "type": "commit"}]}