{"pr_number": 2413, "pr_title": "Multi discrepancies", "pr_createdAt": "2020-10-06T15:17:50Z", "pr_url": "https://github.com/oracle/helidon/pull/2413", "timeline": [{"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "url": "https://github.com/oracle/helidon/commit/b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "message": "Multi discrepancies\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-10-06T15:18:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTIwNg==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500405206", "bodyText": "I am not sure why you added the masking of the value. getAndUpdate returns the value that existed before - so comparing to just REQUEST_ARRIVED in the POC was intentional.\na. in the case that we support masking makes no difference.\nb. if the method is abused, and does get called more than once, the POC would still deliver only one value, and masking will deliver more than one value, and break the spec by delivering onNext after onComplete.", "author": "olotenko", "createdAt": "2020-10-06T15:45:08Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/DeferredScalarSubscription.java", "diffHunk": "@@ -31,91 +32,66 @@\n \n     private T value;\n \n-    static final int NO_VALUE_NO_REQUEST = 0;\n-    static final int NO_VALUE_HAS_REQUEST = 1;\n-    static final int HAS_VALUE_NO_REQUEST = 2;\n-    static final int HAS_VALUE_HAS_REQUEST = 3;\n-    static final int COMPLETE = 4;\n-    static final int CANCELED = 5;\n+    static final int REQUEST_ARRIVED = 1;\n+    static final int VALUE_ARRIVED = 2;\n+    static final int DONE = REQUEST_ARRIVED | VALUE_ARRIVED;\n+\n \n     DeferredScalarSubscription(Flow.Subscriber<? super T> downstream) {\n         this.downstream = downstream;\n     }\n \n     @Override\n     public void cancel() {\n-        if (getAndSet(CANCELED) != CANCELED) {\n+        if (getAndSet(DONE) != DONE) {\n             value = null;\n         }\n     }\n \n     @Override\n     public final void request(long n) {\n         if (n <= 0L) {\n-            if (getAndSet(CANCELED) != CANCELED) {\n+            if (getAndSet(DONE) != DONE) {\n+                value = null;\n                 downstream.onError(\n                         new IllegalArgumentException(\"Rule \u00a73.9 violated: non-positive requests are forbidden\"));\n             }\n-        } else {\n-            for (;;) {\n-                int state = get();\n-                if (state == HAS_VALUE_NO_REQUEST) {\n-                    T v = value;\n-                    value = null;\n-                    if (compareAndSet(HAS_VALUE_NO_REQUEST, HAS_VALUE_HAS_REQUEST)) {\n-                        downstream.onNext(v);\n-                        if (compareAndSet(HAS_VALUE_HAS_REQUEST, COMPLETE)) {\n-                            downstream.onComplete();\n-                        }\n-                        break;\n-                    }\n-                } else if (state == NO_VALUE_NO_REQUEST) {\n-                    if (compareAndSet(NO_VALUE_NO_REQUEST, NO_VALUE_HAS_REQUEST)) {\n-                        break;\n-                    }\n-                } else {\n-                    // state == COMPLETE\n-                    // state == HAS_VALUE_HAS_REQUEST\n-                    // state == NO_VALUE_HAS_REQUEST\n-                    // state == CANCELED\n-                    break;\n-                }\n-            }\n+            return;\n+        }\n+\n+        int state;\n+        T v;\n+        do {\n+            state = get();\n+            v = value;\n+        } while (!compareAndSet(state, state | REQUEST_ARRIVED));\n+\n+        if (state == VALUE_ARRIVED) {\n+            value = null;\n+            downstream.onNext(v);\n+            downstream.onComplete();\n         }\n     }\n \n     /**\n      * Signal the only item if possible or save it for later when there\n      * is a request for it.\n      * <p>\n-     *     This method should be called at most once and from only one thread.\n+     * This method should be called at most once and from only one thread.\n      * </p>\n+     *\n      * @param item the item to signal and then complete the downstream\n      */\n     public final void complete(T item) {\n-        for (;;) {\n-            int state = get();\n-            if (state == NO_VALUE_HAS_REQUEST) {\n-                if (compareAndSet(NO_VALUE_HAS_REQUEST, HAS_VALUE_HAS_REQUEST)) {\n-                    downstream.onNext(item);\n-                    if (compareAndSet(HAS_VALUE_HAS_REQUEST, COMPLETE)) {\n-                        downstream.onComplete();\n-                    }\n-                    break;\n-                }\n-            } else if (state == NO_VALUE_NO_REQUEST) {\n-                value = item;\n-                if (compareAndSet(NO_VALUE_NO_REQUEST, HAS_VALUE_NO_REQUEST)) {\n-                    break;\n-                }\n-                value = null;\n-            } else {\n-                // state == COMPLETE\n-                // state == HAS_VALUE_NO_REQUEST\n-                // state == HAS_VALUE_HAS_REQUEST\n-                // state == CANCELED\n-                break;\n-            }\n+        value = item; // assert: even if the race occurs, we will deliver one of the items with which complete()\n+        //         has been invoked - we support only the case with a single invocation of complete()\n+        int state = getAndUpdate(n -> n | VALUE_ARRIVED);\n+        if ((state & REQUEST_ARRIVED) == REQUEST_ARRIVED) {", "originalCommit": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MzgyNQ==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500553825", "bodyText": "I agree that the masking in line 89 is redundant.", "author": "spericas", "createdAt": "2020-10-06T19:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3MTk1MA==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500571950", "bodyText": "Aha I see, but it makes sense in the other complete() right?\n    public final void complete() {\n        int state = get();\n        if (((state & VALUE_ARRIVED) != VALUE_ARRIVED) && compareAndSet(state, DONE)){\n            downstream.onComplete();\n        }\n    }", "author": "danielkec", "createdAt": "2020-10-06T20:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNDczOQ==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500604739", "bodyText": "Yes, in the other complete it reflects the logic of the POC correctly: basically, in that complete it is \"if value has not arrived yet\" (was worded with different conditions with OR).\nBut in this complete the logic must be \"if request has been seen, but the value still not seen\" - only in that case we are allowed to deliver the signals to downstream.", "author": "olotenko", "createdAt": "2020-10-06T21:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTkzMQ==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500415931", "bodyText": "This is not sufficient for the problem that has been discovered. We'll have to address it better.", "author": "olotenko", "createdAt": "2020-10-06T15:59:48Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiConcatArray.java", "diffHunk": "@@ -98,6 +98,7 @@ public void nextSource() {\n         @Override\n         public void request(long n) {\n             if (n <= 0) {\n+                cancel();", "originalCommit": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1OTcwNg==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500559706", "bodyText": "@olotenko To be clear, your point is that the sequence onError onNext is still possible as cancellation is only a best-effort task.", "author": "spericas", "createdAt": "2020-10-06T19:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjg0Ng==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500606846", "bodyText": "Yes, you can view this as the best effort so far. But like I mentioned offline, there is another issue that needs addressing, so we may just as well postpone touching this class.", "author": "olotenko", "createdAt": "2020-10-06T21:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyNTk3NA==", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r501025974", "bodyText": "I see, sounds like for a future PR.", "author": "spericas", "createdAt": "2020-10-07T13:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTkzMQ=="}], "type": "inlineReview"}, {"oid": "693ad0157948f60b90673e609cd9b51108973ecc", "url": "https://github.com/oracle/helidon/commit/693ad0157948f60b90673e609cd9b51108973ecc", "message": "Review issues\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-10-06T20:23:15Z", "type": "commit"}, {"oid": "d3cb64cb1b6cdbe72554d152eb89679d0d8f1f9c", "url": "https://github.com/oracle/helidon/commit/d3cb64cb1b6cdbe72554d152eb89679d0d8f1f9c", "message": "Revert concat array changes\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-10-07T06:23:45Z", "type": "commit"}]}