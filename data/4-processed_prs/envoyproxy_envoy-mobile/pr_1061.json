{"pr_number": 1061, "pr_title": "http dispatcher: use stream map as source of truth", "pr_createdAt": "2020-09-01T01:24:45Z", "pr_url": "https://github.com/envoyproxy/envoy-mobile/pull/1061", "timeline": [{"oid": "ab42c753e9d8a6663452e49ebfab195dc72bc127", "url": "https://github.com/envoyproxy/envoy-mobile/commit/ab42c753e9d8a6663452e49ebfab195dc72bc127", "message": "api listener: use stream map as source of truth\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T01:24:09Z", "type": "commit"}, {"oid": "851b92691071bd941f217512cbd27004a9813b24", "url": "https://github.com/envoyproxy/envoy-mobile/commit/851b92691071bd941f217512cbd27004a9813b24", "message": "fixes\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T03:07:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNTc5Ng==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481305796", "bodyText": "I would somehow move this call back out to the calling function (either via return code or something else) so that all of the reset/closure logic is in one place.", "author": "mattklein123", "createdAt": "2020-09-01T17:15:53Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -96,131 +95,109 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n \n   ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n   if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    // If the stream is not locally closed, the HCM will fire resetStream subsequently. However, we will see\n+    // that the stream is already gone from the streams_ map, and direct Envoy to runResetCallbacks() without\n+    // redundantly calling on onReset().\n+    // @see Dispatcher::DirectStreamCallbacks::resetStream.\n+    onReset();", "originalCommit": "851b92691071bd941f217512cbd27004a9813b24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNjE1OQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481416159", "bodyText": "Sure - in fact, your suggestion led to me to realize I can simplify this even further, by checking success prior to this special handling.", "author": "goaway", "createdAt": "2020-09-01T20:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNjAzNw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481306037", "bodyText": "I would probably inline this where it's called. I don't think it's worth moving out, for the same reason I commented on above (all closure logic in one place).", "author": "mattklein123", "createdAt": "2020-09-01T17:16:19Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -96,131 +95,109 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n \n   ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n   if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    // If the stream is not locally closed, the HCM will fire resetStream subsequently. However, we will see\n+    // that the stream is already gone from the streams_ map, and direct Envoy to runResetCallbacks() without\n+    // redundantly calling on onReset().\n+    // @see Dispatcher::DirectStreamCallbacks::resetStream.\n+    onReset();\n   }\n }\n \n+void Dispatcher::DirectStreamCallbacks::mapLocalDataToError(Buffer::Instance& data, bool end_stream) {", "originalCommit": "851b92691071bd941f217512cbd27004a9813b24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a0be6c699848b87d0412cec1cd31d82660ed960", "url": "https://github.com/envoyproxy/envoy-mobile/commit/4a0be6c699848b87d0412cec1cd31d82660ed960", "message": "passing tests\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T20:28:00Z", "type": "commit"}, {"oid": "9c120100393016607c0cd84afc8da36196f41e80", "url": "https://github.com/envoyproxy/envoy-mobile/commit/9c120100393016607c0cd84afc8da36196f41e80", "message": "simplify error path\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T20:49:13Z", "type": "commit"}, {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "url": "https://github.com/envoyproxy/envoy-mobile/commit/faffc8cf42892ce1a7327d51ed9581c474ff4d37", "message": "format\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T20:55:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDI4Mg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481440282", "bodyText": "What was the failure here? Shouldn't the race two ordering possibilities between local and remote reset still be covered?", "author": "junr03", "createdAt": "2020-09-01T21:24:25Z", "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -1273,100 +1273,6 @@ TEST_F(DispatcherTest, StreamResetAfterOnComplete) {\n   ASSERT_EQ(cc.on_cancel_calls, 0);\n }\n \n-TEST_F(DispatcherTest, ResetStreamLocalHeadersRemoteRaceLocalWins) {", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzA3MQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481453071", "bodyText": "There is no more race - because of serialization, it's just a matter of ordering, which is covered elsewhere. The specific failure here was that the synchronization point no longer gated what it originally did - cleanup happened before it instead of after. But it's also no longer relevant to the implementation. And the test would no longer be meaningful for what it was covering if I were to simply move the sync point.", "author": "goaway", "createdAt": "2020-09-01T21:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MTg5Nw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481441897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n          \n          \n            \n              // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which Envoy Mobile treats as\n          \n      \n    \n    \n  \n\nnit", "author": "junr03", "createdAt": "2020-09-01T21:27:20Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,50 +34,59 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MjkzNg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481442936", "bodyText": "looks like in the 200 case we are firing onComplete() in mapLocalResponseToError and then onRese() here?", "author": "junr03", "createdAt": "2020-09-01T21:29:35Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,50 +34,59 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime) == nullptr) {\n+    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n+    mapLocalResponseToError(headers, end_stream);\n+    if (end_stream) {\n+      onReset();", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzMyNQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481453325", "bodyText": "Actually the 200 case will never match because I check success first - I just forgot to delete it.", "author": "goaway", "createdAt": "2020-09-01T21:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Njg4MA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481446880", "bodyText": "I wonder if we should move stats charging to closeStream so that it is only done there, and we don't have a chance of double counting?", "author": "junr03", "createdAt": "2020-09-01T21:38:29Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -93,134 +102,93 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n       absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count)) {\n     error_attempt_count_ = attempt_count;\n   }\n-\n-  ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n-  if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n-  }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeData(Buffer::Instance& data, bool end_stream) {\n   ENVOY_LOG(debug, \"[S{}] response data for stream (length={} end_stream={})\",\n             direct_stream_.stream_handle_, data.length(), end_stream);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  if (end_stream) {\n+    closeStream();\n   }\n \n-  if (!error_code_.has_value()) {\n-    // Testing hook.\n-    if (end_stream) {\n-      http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n-    }\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n-                direct_stream_.stream_handle_, data.length(), end_stream);\n-      bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n-                                bridge_callbacks_.context);\n-      closeRemote(end_stream);\n-    }\n-  } else {\n-    ASSERT(end_stream, \"local response has to end the stream with a data frame. If Envoy changes \"\n-                       \"this expectation, this code needs to be updated.\");\n+  // Error path.\n+  if (error_code_.has_value()) {\n+    ASSERT(end_stream,\n+           \"local response has to end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n     error_message_ = Buffer::Utility::toBridgeData(data);\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    onReset();\n+    return;\n+  }\n+\n+  // Normal path.\n+\n+  // Testing hook.\n+  if (end_stream) {\n+    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n+  }\n+\n+  ENVOY_LOG(debug,\n+            \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n+            direct_stream_.stream_handle_, data.length(), end_stream);\n+  bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n+                            bridge_callbacks_.context);\n+  if (end_stream) {\n+    onComplete();\n   }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeTrailers(const ResponseTrailerMap& trailers) {\n   ENVOY_LOG(debug, \"[S{}] response trailers for stream:\\n{}\", direct_stream_.stream_handle_,\n             trailers);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n-  }\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  closeStream(); // Trailers always indicate the end of the stream.\n \n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n-              direct_stream_.stream_handle_, trailers);\n-    bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n-    closeRemote(true);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n+            direct_stream_.stream_handle_, trailers);\n+  bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n+  onComplete();\n }\n \n-// n.b: all calls to closeRemote are guarded by a call to dispatchable. Hence the on_complete call\n-// here does not, and should not call dispatchable.\n-void Dispatcher::DirectStreamCallbacks::closeRemote(bool end_stream) {\n-  if (end_stream) {\n-    // Envoy itself does not currently allow half-open streams where the local half is open\n-    // but the remote half is closed. Therefore, we fire the on_complete callback\n-    // to the platform layer whenever remote closes.\n-    ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_,\n-              observed_success_);\n-    if (observed_success_) {\n-      http_dispatcher_.stats().stream_success_.inc();\n-    } else {\n-      http_dispatcher_.stats().stream_failure_.inc();\n-    }\n-    bridge_callbacks_.on_complete(bridge_callbacks_.context);\n-    // Likewise cleanup happens whenever remote closes even though\n-    // local might be open. Note that if local is open Envoy will reset the stream. Calling cleanup\n-    // here is fine because the stream reset will come through synchronously in the same thread as\n-    // this closeRemote code. Because DirectStream deletion is deferred, the deletion will happen\n-    // necessarily after the reset occurs. Thus Dispatcher::DirectStreamCallbacks::onReset will\n-    // **not** have a dangling reference.\n-    ENVOY_LOG(debug, \"[S{}] scheduling cleanup\", direct_stream_.stream_handle_);\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+void Dispatcher::DirectStreamCallbacks::closeStream() {\n+  // Envoy itself does not currently allow half-open streams where the local half is open\n+  // but the remote half is closed. Note that if local is open, Envoy will reset the stream.\n+  http_dispatcher_.removeStream(direct_stream_.stream_handle_);\n }\n \n-Stream& Dispatcher::DirectStreamCallbacks::getStream() { return direct_stream_; }\n+void Dispatcher::DirectStreamCallbacks::onComplete() {\n+  ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_, success_);\n+  if (success_) {\n+    http_dispatcher_.stats().stream_success_.inc();\n+  } else {\n+    http_dispatcher_.stats().stream_failure_.inc();\n+  }\n+  bridge_callbacks_.on_complete(bridge_callbacks_.context);\n+}\n \n void Dispatcher::DirectStreamCallbacks::onReset() {\n   ENVOY_LOG(debug, \"[S{}] remote reset stream\", direct_stream_.stream_handle_);\n+\n+  // The stream should no longer be preset in the map, because onReset() was either called from a\n+  // terminal callback that mapped to an error or it was called in response to a resetStream().\n+  ASSERT(!http_dispatcher_.getStream(direct_stream_.stream_handle_));\n   envoy_error_code_t code = error_code_.value_or(ENVOY_STREAM_RESET);\n   envoy_data message = error_message_.value_or(envoy_nodata);\n   int32_t attempt_count = error_attempt_count_.value_or(-1);\n \n   // Testing hook.\n   http_dispatcher_.synchronizer_.syncPoint(\"dispatch_on_error\");\n \n-  // direct_stream_ will not be a dangling reference even in the case that closeRemote cleaned up\n-  // because in that case this reset is happening synchronously, with the encoding call that called\n-  // closeRemote, in the Envoy Main thread. Hence DirectStream destruction which is posted on the\n-  // Envoy Main thread's event loop will strictly happen after this direct_stream_ reference is\n-  // used. @see Dispatcher::DirectStreamCallbacks::closeRemote() for more details.\n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n-              direct_stream_.stream_handle_);\n-    // Only count the on error if it is dispatchable. Otherwise, the onReset was caused due to a\n-    // client side cancel via Dispatcher::DirectStream::resetStream().\n-    http_dispatcher_.stats().stream_failure_.inc();\n-    bridge_callbacks_.on_error({code, message, attempt_count}, bridge_callbacks_.context);\n-\n-    // All the terminal callbacks only cleanup if they are dispatchable.\n-    // This ensures that cleanup will happen exactly one time.\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n+            direct_stream_.stream_handle_);\n+  http_dispatcher_.stats().stream_failure_.inc();", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1Njg1OA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481456858", "bodyText": "Stats are charged on each of the terminal paths of which only one will be called per stream - onReset, onComplete, and onCancel. closeStream on the other hand is not guaranteed to be called.", "author": "goaway", "createdAt": "2020-09-01T22:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Njg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzM1NA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447354", "bodyText": "drop a comment that this is the expectation in higher layers, like the h2 codec does?", "author": "junr03", "createdAt": "2020-09-01T21:39:36Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzU4NA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // our streams_ map due to the remote closure.\n          \n          \n            \n                // streams_ map due to the remote closure.\n          \n      \n    \n    \n  \n\nnit", "author": "junr03", "createdAt": "2020-09-01T21:40:09Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);\n+  if (!parent_.getStream(stream_handle_)) {\n+    // We don't assert here, because Envoy will issue a stream reset if a stream closes remotely\n+    // while still open locally. In this case the stream will already have been removed from\n+    // our streams_ map due to the remote closure.", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzgwNg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447806", "bodyText": "this is out of place now?", "author": "junr03", "createdAt": "2020-09-01T21:40:38Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);\n+  if (!parent_.getStream(stream_handle_)) {\n+    // We don't assert here, because Envoy will issue a stream reset if a stream closes remotely\n+    // while still open locally. In this case the stream will already have been removed from\n+    // our streams_ map due to the remote closure.\n+\n+    // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n+    // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n+    // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy\n+    // in ConnectionManagerImpl::ActiveStream::onResetStream.\n+    // TODO: explore an upstream fix to get the HCM to clean up ActiveStream itself.\n+    // runResetCallbacks(reason);", "originalCommit": "faffc8cf42892ce1a7327d51ed9581c474ff4d37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae725e2ad0ba168164e75329f85279d4a11cf19b", "url": "https://github.com/envoyproxy/envoy-mobile/commit/ae725e2ad0ba168164e75329f85279d4a11cf19b", "message": "updates for comments\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T22:07:48Z", "type": "commit"}, {"oid": "cf79f94c7c573a27c476d251dd366c5e336f97f0", "url": "https://github.com/envoyproxy/envoy-mobile/commit/cf79f94c7c573a27c476d251dd366c5e336f97f0", "message": "format\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T22:16:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg1MQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481473851", "bodyText": "unused param ^", "author": "junr03", "createdAt": "2020-09-01T22:47:33Z", "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,53 +34,53 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime) == nullptr) {\n+    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n+    mapLocalResponseToError(headers, end_stream);\n+    if (end_stream) {\n+      onReset();\n     }\n     return;\n   }\n \n+  // Normal response path.\n+\n+  // Testing hook.\n+  http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n+\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n+            direct_stream_.stream_handle_, end_stream, headers);\n+  bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n+                               bridge_callbacks_.context);\n+  if (end_stream) {\n+    onComplete();\n+  }\n+}\n+\n+void Dispatcher::DirectStreamCallbacks::mapLocalResponseToError(const ResponseHeaderMap& headers,\n+                                                                bool end_stream) {", "originalCommit": "cf79f94c7c573a27c476d251dd366c5e336f97f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "302c06b28ae22c683f0bcbad54d344c65af4b676", "url": "https://github.com/envoyproxy/envoy-mobile/commit/302c06b28ae22c683f0bcbad54d344c65af4b676", "message": "remove unneeded param\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-09-01T22:54:38Z", "type": "commit"}]}