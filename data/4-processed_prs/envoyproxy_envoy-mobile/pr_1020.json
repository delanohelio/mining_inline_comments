{"pr_number": 1020, "pr_title": "stats: add scope for external stats", "pr_createdAt": "2020-08-11T19:11:40Z", "pr_url": "https://github.com/envoyproxy/envoy-mobile/pull/1020", "timeline": [{"oid": "af02f52562f699a09ad7eab969513cb19582d146", "url": "https://github.com/envoyproxy/envoy-mobile/commit/af02f52562f699a09ad7eab969513cb19582d146", "message": "stats: add scope for external stats\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-11T19:12:08Z", "type": "commit"}, {"oid": "af02f52562f699a09ad7eab969513cb19582d146", "url": "https://github.com/envoyproxy/envoy-mobile/commit/af02f52562f699a09ad7eab969513cb19582d146", "message": "stats: add scope for external stats\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-11T19:12:08Z", "type": "forcePushed"}, {"oid": "446adedf3a8d5c81ac42d5763a1a2558b67dc477", "url": "https://github.com/envoyproxy/envoy-mobile/commit/446adedf3a8d5c81ac42d5763a1a2558b67dc477", "message": "make name more explicit\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-11T19:13:50Z", "type": "commit"}, {"oid": "5d153a93d7e70211ea5d13703122d08d9a78e671", "url": "https://github.com/envoyproxy/envoy-mobile/commit/5d153a93d7e70211ea5d13703122d08d9a78e671", "message": "missed reference\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-11T19:14:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1Mzg1Mg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r469553852", "bodyText": "nit: can we check if the string view can be built in place in the call below?", "author": "junr03", "createdAt": "2020-08-12T21:20:56Z", "path": "library/common/engine.cc", "diffHunk": "@@ -94,14 +95,10 @@ Engine::~Engine() {\n }\n \n void Engine::recordCounter(std::string elements, uint64_t count) {\n-  if (server_) {\n+  if (server_ && external_scope_) {\n     server_->dispatcher().post([this, elements, count]() -> void {\n-      static const std::string client = \"client\";\n-      absl::string_view prefix{client};\n       absl::string_view dynamic_elements{elements};", "originalCommit": "5d153a93d7e70211ea5d13703122d08d9a78e671", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyOTA2Ng==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470229066", "bodyText": "I checked it; it doesn't work. In fact, there's another transparent type being created here, which is an const InlinedVector<variant<Envoy::Stats::StatName, Envoy::Stats::DynamicName>.", "author": "goaway", "createdAt": "2020-08-13T20:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1Mzg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NDM0NQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r469554345", "bodyText": "maybe we can asset external_scope_? Because if the server is there but the scope is not that seems odd?", "author": "junr03", "createdAt": "2020-08-12T21:21:58Z", "path": "library/common/engine.cc", "diffHunk": "@@ -94,14 +95,10 @@ Engine::~Engine() {\n }\n \n void Engine::recordCounter(std::string elements, uint64_t count) {\n-  if (server_) {\n+  if (server_ && external_scope_) {", "originalCommit": "5d153a93d7e70211ea5d13703122d08d9a78e671", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYyOTI0NQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r469629245", "bodyText": "I chose to assert both because the server_ is still the sentinel for the dispatcher event loop, but the Scope could be constructed independently, and if someone changed it to be, it would silently cause a conditional on server_ to no longer guard against the null pointer deference.\nIn other words, the conditional guards exactly the two pointers that are dereferenced, and it's an unenforced detail that one happens to depend on the other right now.", "author": "goaway", "createdAt": "2020-08-13T00:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NDM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1NTA2MA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r469555060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Stats::ScopePtr external_scope_;\n          \n          \n            \n              Stats::ScopePtr stats_client_scope_;", "author": "junr03", "createdAt": "2020-08-12T21:23:37Z", "path": "library/common/engine.h", "diffHunk": "@@ -50,6 +50,7 @@ class Engine {\n private:\n   envoy_status_t run(std::string config, std::string log_level);\n \n+  Stats::ScopePtr external_scope_;", "originalCommit": "5d153a93d7e70211ea5d13703122d08d9a78e671", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "12f81c508e76405a54b83869cc0b90d4276307f5", "url": "https://github.com/envoyproxy/envoy-mobile/commit/12f81c508e76405a54b83869cc0b90d4276307f5", "message": "updates for comments\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-13T20:45:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODAwMQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470238001", "bodyText": "it's weird to have a scalar string called elements, but in any case I suggest passing it by const ref, or better yet, by string_view.\nBut IMO the higher level issue is that if you define your API to inc a counter based on a string, you are going to have to pay the cost of map lookups and/or locks. Is it not possible for you to have the Engine API offer a wrapper to create a handle that the caller can store, to quickly increment a counter?", "author": "jmarantz", "createdAt": "2020-08-13T20:46:02Z", "path": "library/common/engine.cc", "diffHunk": "@@ -94,14 +95,10 @@ Engine::~Engine() {\n }\n \n void Engine::recordCounter(std::string elements, uint64_t count) {", "originalCommit": "5d153a93d7e70211ea5d13703122d08d9a78e671", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0NjczMw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470246733", "bodyText": "I think this is ideally what we'd like to do, but we were going for something quick to iterate on here, and lacked the familiarity with the stats API to figure out how best to accomplish this. Would welcome your perspective on a sounder approach.", "author": "goaway", "createdAt": "2020-08-13T21:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc5NDc1NA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470794754", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            void Engine::recordCounter(std::string elements, uint64_t count) {\n          \n          \n            \n            void Engine::recordCounter(const std::string& elements, uint64_t count) {\n          \n      \n    \n    \n  \n\nper @jmarantz.", "author": "junr03", "createdAt": "2020-08-14T18:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTYyMw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470241623", "bodyText": "I would not have expected this to work, but I see the problem. I meant to make DynamicName an explicit but allow the implicit conversion from string literal to string_view.\nCan you change this to:\n  Stats::Utility::counterFromElements(*client_scope_, {Stats::DynamicName(elements)}).add(count);\n\nI'm going to write a quick PR to add the explicit qualifier to the DynamicName constructor which would make the form that you have here invalid.\nThe reason is that it is an anti-pattern to have a ton of DynamicName objects (due to string bloat) so I want to be able to search for them.\nOf course the better solution is really to get callers to create a Counter and keep a handle to it, rather than doing the name lookup all the time, but if you can't do that then please add the explicit qualifier.\nThen also you will not need the string_view declaration above.", "author": "jmarantz", "createdAt": "2020-08-13T20:52:34Z", "path": "library/common/engine.cc", "diffHunk": "@@ -94,14 +95,10 @@ Engine::~Engine() {\n }\n \n void Engine::recordCounter(std::string elements, uint64_t count) {\n-  if (server_) {\n+  if (server_ && client_scope_) {\n     server_->dispatcher().post([this, elements, count]() -> void {\n-      static const std::string client = \"client\";\n-      absl::string_view prefix{client};\n       absl::string_view dynamic_elements{elements};\n-      Stats::Utility::counterFromElements(server_->serverFactoryContext().scope(),\n-                                          {prefix, dynamic_elements})\n-          .add(count);\n+      Stats::Utility::counterFromElements(*client_scope_, {dynamic_elements}).add(count);", "originalCommit": "12f81c508e76405a54b83869cc0b90d4276307f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTgxMw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470241813", "bodyText": "why the post() here rather than just incrementing the counter directly at the call-site?\ncounters are thread-safe, at least once they are looked up.\nMaybe the issue is that the caller is in some thread that Envoy does not know about, so the TLS lookups underneath fail? In that case can you comment?", "author": "jmarantz", "createdAt": "2020-08-13T20:52:55Z", "path": "library/common/engine.cc", "diffHunk": "@@ -94,14 +95,10 @@ Engine::~Engine() {\n }\n \n void Engine::recordCounter(std::string elements, uint64_t count) {\n-  if (server_) {\n+  if (server_ && client_scope_) {\n     server_->dispatcher().post([this, elements, count]() -> void {", "originalCommit": "12f81c508e76405a54b83869cc0b90d4276307f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0Nzc0MQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470247741", "bodyText": "The issue is exactly what you suggest - this call is coming from a random application thread, Envoy has no knowledge of it, and there's no TLS state associated with it. I can definitely add a comment, though that's actually a common theme at this layer of the API.", "author": "goaway", "createdAt": "2020-08-13T21:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTgxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0ODY3Nw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470248677", "bodyText": "No worries just add a comment explaining the non-obvious delay.", "author": "jmarantz", "createdAt": "2020-08-13T21:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTgxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0ODY4OQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470248689", "bodyText": "On the other hand, if you see a way we could accomplish this without the dispatch in a thread-safe manner, would certainly be interested in hearing more.", "author": "goaway", "createdAt": "2020-08-13T21:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTgxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU5MzM5MQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470593391", "bodyText": "I don't think you can without changes to ThreadLocalStore...so we'll have to be content with a comment.\nAlso when you establish an API for creation of a Counter object for callers, the same issue will be there. You will have to populate the underlying Counter objects from a dispatch.\nI'll defer to @mattklein123 on what the best TLS strategy should be for accessing stat by name outside the context of worker threads. But in the current code I think it has to be done via post.", "author": "jmarantz", "createdAt": "2020-08-14T12:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0MTgxMw=="}], "type": "inlineReview"}, {"oid": "dd8d4e8feb0e6e5eba4150fe518225d3d12c318c", "url": "https://github.com/envoyproxy/envoy-mobile/commit/dd8d4e8feb0e6e5eba4150fe518225d3d12c318c", "message": "use Stats::DynamicName for recording\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-14T08:45:28Z", "type": "commit"}, {"oid": "be8e4d9090539685515fd56d21d81f2984ef3a86", "url": "https://github.com/envoyproxy/envoy-mobile/commit/be8e4d9090539685515fd56d21d81f2984ef3a86", "message": "format\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-14T10:36:32Z", "type": "commit"}, {"oid": "8d6bd382c63e68fa586b64adb12063468b02c9a4", "url": "https://github.com/envoyproxy/envoy-mobile/commit/8d6bd382c63e68fa586b64adb12063468b02c9a4", "message": "pass const string ref\n\nSigned-off-by: Mike Schore <mike.schore@gmail.com>", "committedDate": "2020-08-14T18:35:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyODAxMg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470828012", "bodyText": "now that I see this in its current form, it's worth a quick check whether 'elements' value gets copied into the lambda provided to post, or whether it holds a ref to an object that might potentially not live long enough for the dispatcher to execute the post.\nIt might not matter in your unit test, where the lifetime of the string you pass to recordCounter is long enough.\nIn any case I think the interface to this function should be a const ref, but you may need to copy it explicitly into storage saved in the lambda. Can you check?", "author": "jmarantz", "createdAt": "2020-08-14T19:32:16Z", "path": "library/common/engine.cc", "diffHunk": "@@ -93,14 +94,10 @@ Engine::~Engine() {\n   main_thread_.join();\n }\n \n-void Engine::recordCounter(std::string elements, uint64_t count) {\n-  if (server_) {\n+void Engine::recordCounter(const std::string& elements, uint64_t count) {", "originalCommit": "8d6bd382c63e68fa586b64adb12063468b02c9a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0NTgzNA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470845834", "bodyText": "Thanks @jmarantz, good callout.", "author": "goaway", "createdAt": "2020-08-14T20:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyODAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MDk5OA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470850998", "bodyText": "Yeah good point! \ud83e\udd26 the string could definitely be gone as the copy is just in the stack of the main interface function call. What's the least egregious way to minimize copies:\n\npass down the const char* all the way until we capture a copy in the lambda,\ncreate a unique ptr of a string at the main interface level that we pass down,\nsomething else?", "author": "junr03", "createdAt": "2020-08-14T20:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyODAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyODY2Nw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470928667", "bodyText": "My recommendation:\n\nleave the interface as is (or better yet, witch to a string_view to avoid copying while calling recordValue)\nmake a local copy in the function body (std::string name = elements;)\ncapture that copy by value in the lambda passed to post().", "author": "jmarantz", "createdAt": "2020-08-15T02:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyODAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5MzE3NQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1020#discussion_r470993175", "bodyText": "My apologies, what you have is fine. I tested it with:\nTEST(Foo, Bar) {\n  std::string foo = \"foo\";\n  std::string& fooref = foo;\n  auto test = [fooref]() { EXPECT_EQ(\"foo\", fooref); };\n  test();\n  foo = \"bar\";\n  test();\n}\n\nThat test passes, which means that the ref's value is captured by the lambda.", "author": "jmarantz", "createdAt": "2020-08-15T13:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyODAxMg=="}], "type": "inlineReview"}]}