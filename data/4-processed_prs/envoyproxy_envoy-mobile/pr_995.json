{"pr_number": 995, "pr_title": "assertion filter: initial filter implementation", "pr_createdAt": "2020-07-31T23:37:00Z", "pr_url": "https://github.com/envoyproxy/envoy-mobile/pull/995", "timeline": [{"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420", "url": "https://github.com/envoyproxy/envoy-mobile/commit/dff3d7eb5b19213befd2e140a64e61cb68eff420", "message": "assertion filter: initial filter implementation\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-07-31T23:34:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTgwNQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463895805", "bodyText": "I don't think this is accurate since the filter isn't being bubbled up to the platform", "author": "rebello95", "createdAt": "2020-08-01T00:26:41Z", "path": "library/common/extensions/filters/http/assertion/filter.h", "diffHunk": "@@ -0,0 +1,50 @@\n+#pragma once\n+\n+#include \"envoy/http/filter.h\"\n+\n+#include \"extensions/common/tap/tap_matcher.h\"\n+#include \"extensions/filters/http/common/pass_through_filter.h\"\n+\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+class AssertionFilterConfig {\n+public:\n+  AssertionFilterConfig(\n+      const envoymobile::extensions::filters::http::assertion::Assertion& proto_config);\n+\n+  Extensions::Common::Tap::Matcher& rootMatcher() const;\n+  size_t matchersSize() const { return matchers_.size(); }\n+\n+private:\n+  std::vector<Extensions::Common::Tap::MatcherPtr> matchers_;\n+};\n+\n+typedef std::shared_ptr<AssertionFilterConfig> AssertionFilterConfigSharedPtr;\n+\n+/**\n+ * Harness to bridge Envoy filter invocations up to the platform layer.\n+ */", "originalCommit": "dff3d7eb5b19213befd2e140a64e61cb68eff420", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMjczMw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463902733", "bodyText": "stale copy paste. Will refresh comment", "author": "junr03", "createdAt": "2020-08-01T01:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTkxMg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463895912", "bodyText": "These are super clever \ud83d\udc4f", "author": "rebello95", "createdAt": "2020-08-01T00:27:16Z", "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;", "originalCommit": "dff3d7eb5b19213befd2e140a64e61cb68eff420", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjA2OQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463896069", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // The match configuration. If the configuration matches the request frames the filter will send\n          \n          \n            \n              // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n          \n          \n            \n              // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n          \n          \n            \n              envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n          \n          \n            \n            }\n          \n          \n            \n              // The match configuration. If the configuration matches the request frames, the filter will send\n          \n          \n            \n              // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n          \n          \n            \n              // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n          \n          \n            \n              envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n          \n          \n            \n            }\n          \n      \n    \n    \n  \n\nIt'd be nice if we could validate here that there's at least 1 matcher rule within the config (since it's asserted above), but not a big deal. We should probably document it here though", "author": "rebello95", "createdAt": "2020-08-01T00:28:38Z", "path": "library/common/extensions/filters/http/assertion/filter.proto", "diffHunk": "@@ -0,0 +1,14 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.assertion;\n+\n+import \"envoy/config/tap/v3/common.proto\";\n+\n+import \"validate/validate.proto\";\n+\n+message Assertion {\n+  // The match configuration. If the configuration matches the request frames the filter will send\n+  // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n+  // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n+  envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n+}", "originalCommit": "dff3d7eb5b19213befd2e140a64e61cb68eff420", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NjMzNQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465246335", "bodyText": "Right, that would need a change to the upstream proto.", "author": "junr03", "createdAt": "2020-08-04T18:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjA2OQ=="}], "type": "inlineReview"}, {"oid": "f93c8f9d1a5fa30592b717803d740b1a5a2d51b8", "url": "https://github.com/envoyproxy/envoy-mobile/commit/f93c8f9d1a5fa30592b717803d740b1a5a2d51b8", "message": "bad copy paste\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-01T00:31:52Z", "type": "commit"}, {"oid": "f8dbc2a9f56bd233b56ce721ed33410473c538e2", "url": "https://github.com/envoyproxy/envoy-mobile/commit/f8dbc2a9f56bd233b56ce721ed33410473c538e2", "message": "stale comment\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-01T02:04:15Z", "type": "commit"}, {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae", "url": "https://github.com/envoyproxy/envoy-mobile/commit/5fadf096c802087f4f416a7ef386803fa08dfdae", "message": "proto comment\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-04T18:29:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzI5Ng==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377296", "bodyText": "I would probably suggest an inverted control flow, which I think simplifies the reading of the logic, and would also help you avoid some nesting.\nIn other words:\nif not matches -> 400\nif end_stream -> 200\ncontinue", "author": "goaway", "createdAt": "2020-08-04T23:02:14Z", "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NDA2OA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465384068", "bodyText": "Sure, can do", "author": "junr03", "createdAt": "2020-08-04T23:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzQ5Nw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377497", "bodyText": "Again, I would suggest inverting the control flow here, and removing the nesting.", "author": "goaway", "createdAt": "2020-08-04T23:02:50Z", "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;\n+    }\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Body does not match configured expectations\", nullptr,\n+                                     absl::nullopt, \"\");\n+  return Http::FilterDataStatus::StopIterationNoBuffer;", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3Nzg0MA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377840", "bodyText": "Same as above, also, additional return instead of else.", "author": "goaway", "createdAt": "2020-08-04T23:03:56Z", "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;\n+    }\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Body does not match configured expectations\", nullptr,\n+                                     absl::nullopt, \"\");\n+  return Http::FilterDataStatus::StopIterationNoBuffer;\n+}\n+\n+Http::FilterTrailersStatus AssertionFilter::decodeTrailers(Http::RequestTrailerMap& trailers) {\n+  config_->rootMatcher().onHttpRequestTrailers(trailers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                       \"Request Trailers match configured expectations\", nullptr,\n+                                       absl::nullopt, \"\");\n+  } else {\n+    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                       \"Request Trailers do not match configured expectations\",\n+                                       nullptr, absl::nullopt, \"\");\n+  }\n+  return Http::FilterTrailersStatus::StopIteration;", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUxNg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465378516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_ma\")};\n          \n          \n            \n              Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_me\")};", "author": "buildbreaker", "createdAt": "2020-08-04T23:05:50Z", "path": "test/common/extensions/filters/http/assertion/assertion_filter_test.cc", "diffHunk": "@@ -0,0 +1,167 @@\n+#include \"test/mocks/http/mocks.h\"\n+#include \"test/test_common/utility.h\"\n+\n+#include \"gtest/gtest.h\"\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+using testing::ByMove;\n+using testing::Return;\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+namespace {\n+\n+class AssertionFilterTest : public testing::Test {\n+public:\n+  void setUpFilter(std::string&& yaml) {\n+    envoymobile::extensions::filters::http::assertion::Assertion config;\n+    TestUtility::loadFromYaml(yaml, config);\n+    config_ = std::make_shared<AssertionFilterConfig>(config);\n+    filter_ = std::make_unique<AssertionFilter>(config_);\n+    filter_->setDecoderFilterCallbacks(decoder_callbacks_);\n+    filter_->setEncoderFilterCallbacks(encoder_callbacks_);\n+  }\n+\n+  AssertionFilterConfigSharedPtr config_{};\n+  std::unique_ptr<AssertionFilter> filter_{};\n+  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;\n+  NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;\n+};\n+\n+TEST_F(AssertionFilterTest, HeadersMatchWithEndStream) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"test.code\"}};\n+\n+  EXPECT_CALL(\n+      decoder_callbacks_,\n+      sendLocalReply(Http::Code::OK, \"Request Headers match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, true));\n+}\n+\n+TEST_F(AssertionFilterTest, HeadersMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"test.code\"}};\n+\n+  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n+}\n+\n+TEST_F(AssertionFilterTest, HeadersNoMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"no.match\"}};\n+\n+  EXPECT_CALL(decoder_callbacks_,\n+              sendLocalReply(Http::Code::BadRequest,\n+                             \"Request Headers do not match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, true));\n+}\n+\n+TEST_F(AssertionFilterTest, DataMatchWithEndStream) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"match_me\")};\n+\n+  EXPECT_CALL(\n+      decoder_callbacks_,\n+      sendLocalReply(Http::Code::OK, \"Request Body match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(*body, true));\n+}\n+\n+TEST_F(AssertionFilterTest, DataMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"match_me\")};\n+\n+  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(*body, false));\n+}\n+\n+TEST_F(AssertionFilterTest, DataNoMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_ma\")};", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUyMg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465378522", "bodyText": "Can we add a docstring to this? It would also be really helpful to link the matcher documentation (whatever there is).", "author": "goaway", "createdAt": "2020-08-04T23:05:51Z", "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MzMwNA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465383304", "bodyText": "Already exists in the header.", "author": "junr03", "createdAt": "2020-08-04T23:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5OTQzMQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465399431", "bodyText": "Yep, you're right. Can you still add a link to documentation on matchers?", "author": "goaway", "createdAt": "2020-08-05T00:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDk0NA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465420944", "bodyText": "The proto is linked. I think the larger issue is that we need to start generating docs from our protos, cut this issue to track: #1001", "author": "junr03", "createdAt": "2020-08-05T01:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTY2Mw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465379663", "bodyText": "Can we validate response as well? Do matchers work on responses?\nThe current implementation generates 200s on end_stream, but that could easily be handled by a different upstream filter. Meanwhile it would allow testing of, e.g., modification of responses via platform filters.", "author": "goaway", "createdAt": "2020-08-04T23:09:31Z", "path": "library/common/extensions/filters/http/assertion/filter.h", "diffHunk": "@@ -0,0 +1,50 @@\n+#pragma once\n+\n+#include \"envoy/http/filter.h\"\n+\n+#include \"extensions/common/tap/tap_matcher.h\"\n+#include \"extensions/filters/http/common/pass_through_filter.h\"\n+\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+class AssertionFilterConfig {\n+public:\n+  AssertionFilterConfig(\n+      const envoymobile::extensions::filters::http::assertion::Assertion& proto_config);\n+\n+  Extensions::Common::Tap::Matcher& rootMatcher() const;\n+  size_t matchersSize() const { return matchers_.size(); }\n+\n+private:\n+  std::vector<Extensions::Common::Tap::MatcherPtr> matchers_;\n+};\n+\n+typedef std::shared_ptr<AssertionFilterConfig> AssertionFilterConfigSharedPtr;\n+\n+/**\n+ * Filter to assert expectations on HTTP requests.\n+ */\n+class AssertionFilter final : public Http::PassThroughFilter {\n+public:\n+  AssertionFilter(AssertionFilterConfigSharedPtr config);\n+\n+  // StreamDecoderFilter\n+  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,\n+                                          bool end_stream) override;\n+  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;\n+  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap& trailers) override;\n+", "originalCommit": "5fadf096c802087f4f416a7ef386803fa08dfdae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NDAzMQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465384031", "bodyText": "Yeah the matcher can match responses. My thought was that for the initial commit I would do request validation as that is enough expressiveness to fulfill the e2e tests I had in mind for client->bridge->core interactions. The filter validates the request path and the client can validate what is returned on the response path.\nSo my plan was to land this, and then as you start writing tests we can modify the filter for added complexity.", "author": "junr03", "createdAt": "2020-08-04T23:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5OTc1Ng==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465399756", "bodyText": "Sounds good. \ud83d\udc4d", "author": "goaway", "createdAt": "2020-08-05T00:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTY2Mw=="}], "type": "inlineReview"}, {"oid": "5f766d30dfbbf24ad7ac47c851592cffa7a6cf70", "url": "https://github.com/envoyproxy/envoy-mobile/commit/5f766d30dfbbf24ad7ac47c851592cffa7a6cf70", "message": "comments\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-05T01:44:05Z", "type": "commit"}, {"oid": "aecd5cff20732e7163205bcbd07e85d3a17de571", "url": "https://github.com/envoyproxy/envoy-mobile/commit/aecd5cff20732e7163205bcbd07e85d3a17de571", "message": "why is coverage failing in CI?\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T18:16:51Z", "type": "commit"}, {"oid": "4656315c5aee5d1b27aedf0fcb64ddf68ca9409d", "url": "https://github.com/envoyproxy/envoy-mobile/commit/4656315c5aee5d1b27aedf0fcb64ddf68ca9409d", "message": "try\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T20:20:47Z", "type": "commit"}, {"oid": "928ae7bead35952362c3d86c37f7c4a0d3555d5d", "url": "https://github.com/envoyproxy/envoy-mobile/commit/928ae7bead35952362c3d86c37f7c4a0d3555d5d", "message": "Merge branch 'main' into assertion-filter\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T20:33:43Z", "type": "commit"}, {"oid": "25c7f6a92ccd93446b41dd01935ca0eaf5f9fcf4", "url": "https://github.com/envoyproxy/envoy-mobile/commit/25c7f6a92ccd93446b41dd01935ca0eaf5f9fcf4", "message": "Merge branch 'assertion-filter' of github.com:lyft/envoy-mobile into assertion-filter\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T20:34:10Z", "type": "commit"}, {"oid": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a", "url": "https://github.com/envoyproxy/envoy-mobile/commit/aa5418c59b45c8db980c0f2abeb13e45f79ddf6a", "message": "time\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T22:01:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyOTIyOA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r466729228", "bodyText": "\ud83d\ude22", "author": "goaway", "createdAt": "2020-08-06T22:57:51Z", "path": ".github/workflows/coverage.yml", "diffHunk": "@@ -13,7 +13,7 @@ jobs:\n   coverage:\n     name: coverage\n     runs-on: ubuntu-18.04\n-    timeout-minutes: 60\n+    timeout-minutes: 120", "originalCommit": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczMTYyOA==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r466731628", "bodyText": "Not needed. I just wanted to run for longer because I am actually befuddled about why the coverage run is failing :( it passes locally, and it is failing on the envoy_mobile_main_common_test which I do not touch at all in the PR", "author": "junr03", "createdAt": "2020-08-06T23:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyOTIyOA=="}], "type": "inlineReview"}, {"oid": "eb9c3de3b35da05df0f7276a4b67ddf9e9295d5d", "url": "https://github.com/envoyproxy/envoy-mobile/commit/eb9c3de3b35da05df0f7276a4b67ddf9e9295d5d", "message": "revert coverage workflow changes\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-08-06T23:32:01Z", "type": "commit"}]}