{"pr_number": 1110, "pr_title": "core: add missing coverage", "pr_createdAt": "2020-09-18T18:47:31Z", "pr_url": "https://github.com/envoyproxy/envoy-mobile/pull/1110", "timeline": [{"oid": "9c6b2d4f3ec9e5f0b43ab9551f4c78c7e21f5cfb", "url": "https://github.com/envoyproxy/envoy-mobile/commit/9c6b2d4f3ec9e5f0b43ab9551f4c78c7e21f5cfb", "message": "core: add missing coverage\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-09-18T18:46:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMTQ3MQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491131471", "bodyText": "Cool that this works", "author": "rebello95", "createdAt": "2020-09-18T18:49:11Z", "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -1324,5 +1324,127 @@ TEST_F(DispatcherTest, ResetWhenRemoteClosesBeforeLocal) {\n   ASSERT_EQ(cc.on_error_calls, 0);\n }\n \n+TEST_F(DispatcherTest, Encode100Continue) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  envoy_http_callbacks bridge_callbacks;\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode 100 continue should blow up.\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n+  EXPECT_DEATH(response_encoder_->encode100ContinueHeaders(response_headers), \"panic: not implemented\");", "originalCommit": "9c6b2d4f3ec9e5f0b43ab9551f4c78c7e21f5cfb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29466ab9fc1114496fa813d8212773f4d8779bc2", "url": "https://github.com/envoyproxy/envoy-mobile/commit/29466ab9fc1114496fa813d8212773f4d8779bc2", "message": "fmt\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-09-18T18:57:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2Nzc2Mw==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491167763", "bodyText": "?", "author": "goaway", "createdAt": "2020-09-18T20:12:07Z", "path": "test/common/network/synthetic_address_impl_test.cc", "diffHunk": "@@ -22,8 +22,10 @@ TEST(SyntheticAddressImplTest, Accessors) {\n   SyntheticAddressImpl address;\n   ASSERT_EQ(address.ip(), nullptr);\n   ASSERT_EQ(address.pipe(), nullptr);\n+  ASSERT_EQ(address.envoyInternalAddress(), nullptr);\n   ASSERT_EQ(address.sockAddr(), nullptr);\n   ASSERT_EQ(address.sockAddrLen(), 0);\n+  address.socketInterface();", "originalCommit": "29466ab9fc1114496fa813d8212773f4d8779bc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2ODYxNQ==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491168615", "bodyText": "This doesn't really feel like a useful test to me. I get that we're just trying to increase coverage, but I don't know that we actually want to be asserting or implying that this returns a specific value. If we were to change this to return 2 tomorrow, everything should still work, and the only thing that would be different is that now we'd have a broken test.", "author": "goaway", "createdAt": "2020-09-18T20:13:49Z", "path": "test/common/main_interface_test.cc", "diffHunk": "@@ -218,6 +218,75 @@ TEST(MainInterfaceTest, ResetStream) {\n   ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n }\n \n+TEST(MainInterfaceTest, UsingMainInterfaceWithoutARunningEngine) {\n+\n+  Http::TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Http::Utility::toBridgeHeaders(headers);\n+\n+  Buffer::OwnedImpl request_data = Buffer::OwnedImpl(\"request body\");\n+  envoy_data c_data = Buffer::Utility::toBridgeData(request_data);\n+\n+  Http::TestRequestTrailerMapImpl trailers;\n+  envoy_headers c_trailers = Http::Utility::toBridgeHeaders(trailers);\n+\n+  EXPECT_EQ(ENVOY_FAILURE, send_headers(0, c_headers, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_data(0, c_data, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_trailers(0, c_trailers));\n+  EXPECT_EQ(ENVOY_FAILURE, reset_stream(0));\n+\n+  // Release memory\n+  release_envoy_headers(c_headers);\n+  c_data.release(c_data.context);\n+  release_envoy_headers(c_trailers);\n+}\n+\n+TEST(MainInterfaceTest, RegisterPlatformApi) {\n+  // This config is the minimal envoy mobile config that allows for running the engine.\n+  const std::string config =\n+      \"{\\\"admin\\\":{},\\\"static_resources\\\":{\\\"listeners\\\":[{\\\"name\\\":\\\"base_api_listener\\\",\"\n+      \"\\\"address\\\":{\\\"socket_address\\\":{\\\"protocol\\\":\\\"TCP\\\",\\\"address\\\":\\\"0.0.0.0\\\",\\\"port_\"\n+      \"value\\\":10000}},\\\"api_listener\\\":{\\\"api_listener\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\\\",\\\"stat_\"\n+      \"prefix\\\":\\\"hcm\\\",\\\"route_config\\\":{\\\"name\\\":\\\"api_router\\\",\\\"virtual_hosts\\\":[{\\\"name\\\":\"\n+      \"\\\"api\\\",\\\"include_attempt_count_in_response\\\":true,\\\"domains\\\":[\\\"*\\\"],\\\"routes\\\":[{\"\n+      \"\\\"match\\\":{\\\"prefix\\\":\\\"/\"\n+      \"\\\"},\\\"route\\\":{\\\"cluster_header\\\":\\\"x-envoy-mobile-cluster\\\",\\\"retry_policy\\\":{\\\"retry_back_\"\n+      \"off\\\":{\\\"base_interval\\\":\\\"0.25s\\\",\\\"max_interval\\\":\\\"60s\\\"}}}}]}]},\\\"http_filters\\\":[{\"\n+      \"\\\"name\\\":\\\"envoy.router\\\",\\\"typed_config\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.http.router.v3.Router\\\"}}]}}}]},\\\"layered_runtime\\\":{\\\"layers\\\":[{\"\n+      \"\\\"name\\\":\\\"static_layer_0\\\",\\\"static_layer\\\":{\\\"overload\\\":{\\\"global_downstream_max_\"\n+      \"connections\\\":50000}}}]}}\";\n+  const std::string level = \"debug\";\n+  engine_test_context engine_cbs_context{};\n+  envoy_engine_callbacks engine_cbs{[](void* context) -> void {\n+                                      auto* engine_running =\n+                                          static_cast<engine_test_context*>(context);\n+                                      engine_running->on_engine_running.Notify();\n+                                    } /*on_engine_running*/,\n+                                    [](void* context) -> void {\n+                                      auto* exit = static_cast<engine_test_context*>(context);\n+                                      exit->on_exit.Notify();\n+                                    } /*on_exit*/,\n+                                    &engine_cbs_context /*context*/};\n+  run_engine(0, engine_cbs, config.c_str(), level.c_str());\n+\n+  ASSERT_TRUE(\n+      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+\n+  EXPECT_EQ(ENVOY_SUCCESS, register_platform_api(\"api\", nullptr));\n+\n+  terminate_engine(0);\n+\n+  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+}\n+\n+TEST(MainInterfaceTest, InitEngineReturns1) {\n+  // TODO(goaway): return new handle once multiple engine support is in place.\n+  // https://github.com/lyft/envoy-mobile/issues/332\n+  ASSERT_EQ(1, init_engine());\n+}", "originalCommit": "29466ab9fc1114496fa813d8212773f4d8779bc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDQwMg==", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491184402", "bodyText": "I see this as a sentinel that we have to have coverage for init_engine(). So in my mind having a test that breaks is, in and of itself, useful.", "author": "junr03", "createdAt": "2020-09-18T20:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2ODYxNQ=="}], "type": "inlineReview"}, {"oid": "d109535f73159e148ae63afb5c56819d4e47d65a", "url": "https://github.com/envoyproxy/envoy-mobile/commit/d109535f73159e148ae63afb5c56819d4e47d65a", "message": "update\n\nSigned-off-by: Jose Nino <jnino@lyft.com>", "committedDate": "2020-09-18T20:48:55Z", "type": "commit"}]}