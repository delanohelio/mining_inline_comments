{"pr_number": 645, "pr_title": "Add getEntityId() to Transaction Handler", "pr_createdAt": "2020-04-01T20:40:45Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/645", "timeline": [{"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "message": "Add getEntityId() and getProxyAccountId() to Transaction Handler\n\n- Address followups from #638 and #639\n- In RecordItemParser, one invariant that should be followed is:\n  No repo writes before txn filter is run (reads okay).\n  - getEntityId() was violating it by writing entities before filtering. Corrected it.\n- getProxyAccountId() is called only after filtering\n- Adapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\n- Added code comments to explain lot of non-obvious existing logic which was easy to\n  trip on and took decent amount of time to decipher\n- Changed entity.autoRenewAccount() logic from:\n    During entity update: Lookup/create new\n    If persisiting (after filtering): persist if new entity\n  To:\n    During entity update: create new\n    If persisting: lookup id/persist if new entity.\n  Benefits:\n  1. Essentially, entity id are not needed anywhere except when persisting,\n     so lookup can be delayed.\n  2. Earlier, EXPIRE_AFTER_30M cache was used for lookups. Its max size is 10k\n     (has to be lower since it contains full Entities objects).Now, the lookup\n    uses BIG_LRU_CACHE, max size of which is 100k (can be so big since it contains\n    EntityId objects)\n  There are tests in RecordItemParserTopicTest setting/updating autoRenewAccount\n  in various scenarios.\n- Replaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\n  Latter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-02T03:56:26Z", "type": "commit"}, {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "message": "Add getEntityId() and getProxyAccountId() to Transaction Handler\n\n- Address followups from #638 and #639\n- In RecordItemParser, one invariant that should be followed is:\n  No repo writes before txn filter is run (reads okay).\n  - getEntityId() was violating it by writing entities before filtering. Corrected it.\n- getProxyAccountId() is called only after filtering\n- Adapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\n- Added code comments to explain lot of non-obvious existing logic which was easy to\n  trip on and took decent amount of time to decipher\n- Changed entity.autoRenewAccount() logic from:\n    During entity update: Lookup/create new\n    If persisiting (after filtering): persist if new entity\n  To:\n    During entity update: create new\n    If persisting: lookup id/persist if new entity.\n  Benefits:\n  1. Essentially, entity id are not needed anywhere except when persisting,\n     so lookup can be delayed.\n  2. Earlier, EXPIRE_AFTER_30M cache was used for lookups. Its max size is 10k\n     (has to be lower since it contains full Entities objects).Now, the lookup\n    uses BIG_LRU_CACHE, max size of which is 100k (can be so big since it contains\n    EntityId objects)\n  There are tests in RecordItemParserTopicTest setting/updating autoRenewAccount\n  in various scenarios.\n- Replaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\n  Latter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-02T03:56:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2Njk4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402466988", "bodyText": "Should use type.getId() instead. Ordinal starts at 0, which is wrong. Not sure how your tests are passing.", "author": "steven-sheehy", "createdAt": "2020-04-02T16:59:08Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityId.java", "diffHunk": "@@ -20,13 +20,58 @@\n  * \u200d\n  */\n \n+import com.hederahashgraph.api.proto.java.AccountID;\n+import com.hederahashgraph.api.proto.java.ContractID;\n+import com.hederahashgraph.api.proto.java.FileID;\n+import com.hederahashgraph.api.proto.java.TopicID;\n import lombok.Value;\n \n+/**\n+ * Common encapsulation for accountID, fileID, contractID, and topicID.\n+ *\n+ * There is no valid entity in Hedera network with an id '0.0.0'. When AccountID/FileID/ContractID/TopicID are not set,\n+ * their values default to '0.0.0'. If such an unset (default) instance is used to create EntityId using one of the\n+ * of(..) functions, null is returned.\n+ */\n @Value\n public class EntityId {\n     private Long id;\n     private Long entityShard;\n     private Long entityRealm;\n     private Long entityNum;\n     private Integer entityTypeId;\n+\n+    public Entities toEntity() {\n+        Entities entity = new Entities();\n+        entity.setId(id);\n+        entity.setEntityShard(entityShard);\n+        entity.setEntityRealm(entityRealm);\n+        entity.setEntityNum(entityNum);\n+        entity.setEntityTypeId(entityTypeId);\n+        return entity;\n+    }\n+\n+    public static EntityId of(AccountID accountID) {\n+        return of(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), EntityTypeEnum.ACCOUNT);\n+    }\n+\n+    public static EntityId of(ContractID contractID) {\n+        return of(contractID.getShardNum(), contractID.getRealmNum(), contractID.getContractNum(),\n+                EntityTypeEnum.CONTRACT);\n+    }\n+\n+    public static EntityId of(FileID fileID) {\n+        return of(fileID.getShardNum(), fileID.getRealmNum(), fileID.getFileNum(), EntityTypeEnum.FILE);\n+    }\n+\n+    public static EntityId of(TopicID topicID) {\n+        return of(topicID.getShardNum(), topicID.getRealmNum(), topicID.getTopicNum(), EntityTypeEnum.TOPIC);\n+    }\n+\n+    private static EntityId of(long entityShard, long entityRealm, long entityNum, EntityTypeEnum type) {\n+        if (entityNum == 0 && entityRealm == 0 && entityShard == 0) {\n+            return null;\n+        }\n+        return new EntityId(null, entityShard, entityRealm, entityNum, type.ordinal());", "originalCommit": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjkwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402506903", "bodyText": "I don't think this will work since EntityId will have a null id. JPA won't know to lookup by shard/realm/num. Also, this won't go through cache so will be slow.", "author": "steven-sheehy", "createdAt": "2020-04-02T17:58:17Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -455,28 +411,23 @@ private void addNonFeeTransferInserts(long consensusTimestamp, long realm, long\n     /**\n      * Store ConsensusCreateTopic transaction in the database.\n      *\n-     * @param body\n-     * @param transactionRecord\n-     * @return Entity ID of the newly created topic, or 0 if no topic was created\n-     * @throws SQLException\n      * @throws IllegalArgumentException\n      */\n-    private Entities storeConsensusCreateTopic(TransactionBody body,\n-                                               TransactionRecord transactionRecord) {\n+    private void consensusCreateTopicUpdateEntity(\n+            Entities entity, TransactionBody body, TransactionRecord transactionRecord) {\n         if (!body.hasConsensusCreateTopic()) {\n             throw new IllegalArgumentException(\"transaction is not a ConsensusCreateTopic\");\n         }\n \n         if (!transactionRecord.getReceipt().hasTopicID()) {\n-            return null;\n+            return;\n         }\n \n-        Entities entity = getEntity(transactionRecord.getReceipt().getTopicID());\n         var transactionBody = body.getConsensusCreateTopic();\n \n         if (transactionBody.hasAutoRenewAccount()) {\n-            Entities autoRenewAccount = getEntity(transactionBody.getAutoRenewAccount());\n-            entity.setAutoRenewAccount(autoRenewAccount);\n+            // Entity's id will be looked up/created lazily when its needed for persisting.\n+            entity.setAutoRenewAccount(EntityId.of(transactionBody.getAutoRenewAccount()).toEntity());", "originalCommit": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyODI2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402928268", "bodyText": "Changed. Should use big cache now.\nPunting batching of lookups/writes to end of transaction to later date.", "author": "apeksharma", "createdAt": "2020-04-03T11:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNzY1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402507658", "bodyText": "EntityId.id can be null as well since it's a primitive wrapper Long.", "author": "steven-sheehy", "createdAt": "2020-04-02T17:59:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -749,76 +659,28 @@ private void insertContractResults(\n                 new ContractResult(consensusTimestamp, functionParams, gasSupplied, callResult, gasUsed));\n     }\n \n-    public Entities getEntity(AccountID accountID) {\n-        return getEntity(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public Entities getEntity(ContractID cid) {\n-        return getEntity(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public Entities getEntity(FileID fileId) {\n-        return getEntity(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public Entities getEntity(TopicID topicId) {\n-        return getEntity(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private Entities getEntity(long shardNum, long realmNum, long entityNum, String type) {\n-        return entityRepository.findByPrimaryKey(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entity = new Entities();\n-            entity.setEntityNum(entityNum);\n-            entity.setEntityRealm(realmNum);\n-            entity.setEntityShard(shardNum);\n-            entity.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entity;\n-        });\n-    }\n-\n-    public EntityId getEntityId(AccountID accountID) {\n-        return getEntityId(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public EntityId getEntityId(ContractID cid) {\n-        return getEntityId(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public EntityId getEntityId(FileID fileId) {\n-        return getEntityId(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public EntityId getEntityId(TopicID topicId) {\n-        return getEntityId(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private EntityId getEntityId(long shardNum, long realmNum, long entityNum, String type) {\n-        if (0 == entityNum) {\n+    private Entities getEntity(EntityId entityId) {\n+        if (entityId == null) {\n             return null;\n         }\n-        return entityRepository.findEntityIdByNativeIds(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entityId = new Entities();\n-            entityId.setEntityShard(shardNum);\n-            entityId.setEntityRealm(realmNum);\n-            entityId.setEntityNum(entityNum);\n-            entityId.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entityRepository.saveAndCacheEntityId(entityId);\n-        });\n+        return entityRepository.findByPrimaryKey(\n+                entityId.getEntityShard(), entityId.getEntityRealm(), entityId.getEntityNum())\n+                .orElseGet(entityId::toEntity);\n     }\n \n-    private Entities createEntity(Entities entity) {\n-        if (entity != null && entity.getId() == null) {\n-            log.debug(\"Creating entity: {}\", () -> entity.getDisplayId());\n-            var result = entityRepository.save(entity);\n-            var entityId = new EntityId(result.getId(), result.getEntityShard(), result.getEntityRealm(),\n-                    result.getEntityNum(), result.getEntityTypeId());\n-            entityRepository.cache(entityId);\n-            return result;\n-        }\n-        return entity;\n-    }\n-\n-    public enum INIT_RESULT {\n-        OK, FAIL, SKIP\n+    /**\n+     * @param entityId containing shard, realm, num, and type for which the id needs to be looked up (from cache/repo).\n+     *                 If no id is found, the the entity is inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        log.debug(\"lookupOrCreateId for {}\", entityId);\n+        if (entityId.getId() != 0) {", "originalCommit": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNjgwMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402516801", "bodyText": "This seems to be an oversight with the old code. Should we be extracting the payer account ID from the TransactionID?", "author": "steven-sheehy", "createdAt": "2020-04-02T18:15:10Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoTransferTransactionHandler.java", "diffHunk": "@@ -20,10 +20,18 @@\n  * \u200d\n  */\n \n-import lombok.AllArgsConstructor;\n import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n \n @Named\n @AllArgsConstructor\n public class CryptoTransferTransactionHandler implements TransactionHandler {\n+\n+    @Override\n+    public EntityId getEntityId(RecordItem recordItem) {\n+        return null;", "originalCommit": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyOTc0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402929740", "bodyText": "probably because payer account id is already populated in separate column for each transaction.\nDuplicating it seems unnecessary.", "author": "apeksharma", "createdAt": "2020-04-03T11:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDk1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402524955", "bodyText": "I think the id is actually always null based upon EntityId.of(), not 0. As a result, this won't work. It will always try to insert the entity thinking it's new but it may or may not exist. You need to lookup or create entity", "author": "steven-sheehy", "createdAt": "2020-04-02T18:29:15Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -335,12 +288,7 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n         tx.setChargedTxFee(txRecord.getTransactionFee());\n         tx.setConsensusNs(consensusNs);\n         if (entityId != null) {\n-            var tempEntity = new Entities();\n-            tempEntity.setId(entityId.getId());\n-            tempEntity.setEntityShard(entityId.getEntityShard());\n-            tempEntity.setEntityRealm(entityId.getEntityRealm());\n-            tempEntity.setEntityNum(entityId.getEntityNum());\n-            tx.setEntity(tempEntity);\n+            tx.setEntity(entityId.toEntity()); // entityId.id is always 0 here", "originalCommit": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyODcwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402928706", "bodyText": "Fixed. Please verify if this looks okay.", "author": "apeksharma", "createdAt": "2020-04-03T11:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDk1NQ=="}], "type": "inlineReview"}, {"oid": "c270e0d7508e4d95d46d8db5a2420dddd117fac6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c270e0d7508e4d95d46d8db5a2420dddd117fac6", "message": "fix tests\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-02T18:54:53Z", "type": "commit"}, {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3f1b804f351a291edb08b269fdecb19ef22a8a4", "message": "- Moved transaction filtering to starting of onItem().\n  Makes it easier to enforce the invariant -\n  \"No state changes (db writes) if transaction is ignored\"\n- entity.proxyAccountId: if present, looks up id using big cache.\n  Removed TransactionHandler.getProxyAccountId()\n- entity.autoRenewAccount: Changed to Long to follow same\n  pattern as proxyAccountId i.e. look up id in big cache or create\n  new one.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-03T11:15:14Z", "type": "commit"}, {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3f1b804f351a291edb08b269fdecb19ef22a8a4", "message": "- Moved transaction filtering to starting of onItem().\n  Makes it easier to enforce the invariant -\n  \"No state changes (db writes) if transaction is ignored\"\n- entity.proxyAccountId: if present, looks up id using big cache.\n  Removed TransactionHandler.getProxyAccountId()\n- entity.autoRenewAccount: Changed to Long to follow same\n  pattern as proxyAccountId i.e. look up id in big cache or create\n  new one.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-03T11:15:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyNTAzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403125037", "bodyText": "This is a breaking change to people using the configuration property. Would prefer to keep it as before unless there's a need to change now.", "author": "steven-sheehy", "createdAt": "2020-04-03T16:23:45Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/CommonParserProperties.java", "diffHunk": "@@ -78,21 +81,21 @@\n         private Collection<String> entity = new LinkedHashSet<>();\n \n         @NotNull\n-        private Collection<TransactionTypeEnum> transaction = new LinkedHashSet<>();\n+        private Collection<TransactionTypeEnum> transactionType = new LinkedHashSet<>();", "originalCommit": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyOTQ2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403229464", "bodyText": "done", "author": "apeksharma", "createdAt": "2020-04-03T18:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyNTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MTMyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403171329", "bodyText": "Calling toString() on a protobuf produces some ugly output, which is why we have helper methods in Utility. However, I think just printing transactionType, entityId and consensusTimestamp would be enough here.", "author": "steven-sheehy", "createdAt": "2020-04-03T17:26:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -129,37 +126,53 @@ private static int getTransactionType(TransactionBody body) {\n     public void onItem(RecordItem recordItem) throws ImporterException {\n         TransactionRecord txRecord = recordItem.getRecord();\n         TransactionBody body = recordItem.getTransactionBody();\n-\n+        TransactionHandler transactionHandler = transactionHandlerFactory.create(body);\n         log.trace(\"Storing transaction body: {}\", () -> Utility.printProtoMessage(body));\n-        long initialBalance = 0;\n \n+        int transactionType = getTransactionType(body);\n+        EntityId entityId = transactionHandler.getEntityId(recordItem);\n+\n+        TransactionFilterFields transactionFilterFields =\n+                new TransactionFilterFields(entityId, TransactionTypeEnum.of(transactionType));\n+        if (!transactionFilter.test(transactionFilterFields)) {\n+            log.debug(\"Ignoring recordItem {}\", txRecord);", "originalCommit": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzOTM2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403239366", "bodyText": "done", "author": "apeksharma", "createdAt": "2020-04-03T18:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MTMyOQ=="}], "type": "inlineReview"}, {"oid": "a35b507d3b68a3e4534fff28911df8ea2d9a8b21", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a35b507d3b68a3e4534fff28911df8ea2d9a8b21", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-03T18:45:57Z", "type": "commit"}]}