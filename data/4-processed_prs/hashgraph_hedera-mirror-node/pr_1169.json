{"pr_number": 1169, "pr_title": "Rosetta: Unit tests - Construction API", "pr_createdAt": "2020-10-22T07:50:57Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169", "timeline": [{"oid": "c2bfff4b233e395cbc20f7ac04a6dde7df5da47a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c2bfff4b233e395cbc20f7ac04a6dde7df5da47a", "message": "Tests: Account, Block, Mempool, Network API Services (#149)\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>\r\nSigned-off-by: Daniel Ivanov <daniel.k.ivanov95@gmail.com>\r\nSigned-off-by: Daniel <Daniel.K.Ivanov95@gmail.com>", "committedDate": "2020-10-16T13:43:22Z", "type": "commit"}, {"oid": "def3c7e8f0f892d74c0b50a2c818289b45505e3b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/def3c7e8f0f892d74c0b50a2c818289b45505e3b", "message": "Assertion of equal, unordered Error elements function\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T08:12:20Z", "type": "commit"}, {"oid": "cde549244da3a6c93c13c8a7b858707e5b478844", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cde549244da3a6c93c13c8a7b858707e5b478844", "message": "remove unnecessary assertion\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T08:13:01Z", "type": "commit"}, {"oid": "32fde97e1799c56cf9fc37dabadfc563b658f743", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/32fde97e1799c56cf9fc37dabadfc563b658f743", "message": "Refactor Equals method\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T09:19:05Z", "type": "commit"}, {"oid": "0de14c302e0a1596121e26970e708152a1e2cf21", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0de14c302e0a1596121e26970e708152a1e2cf21", "message": "efficiency refactor\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T09:24:48Z", "type": "commit"}, {"oid": "0ea66a387458bd3915345544f2300309197f64fc", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0ea66a387458bd3915345544f2300309197f64fc", "message": "remove unnecessary test\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T10:17:27Z", "type": "commit"}, {"oid": "13c49fee2a151bfb650ae0fa77084f283a66a6c2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/13c49fee2a151bfb650ae0fa77084f283a66a6c2", "message": "Error comparison method rename\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-20T13:32:55Z", "type": "commit"}, {"oid": "79d5b6580e7757a708653cfe67da18c9146a57ef", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/79d5b6580e7757a708653cfe67da18c9146a57ef", "message": "Merge pull request #155 from LimeChain/tests/data-api-unit-tests-rework\n\nPR Comments resolution", "committedDate": "2020-10-20T13:56:01Z", "type": "commit"}, {"oid": "47747872f276eb2619f4f8bfa03847117581bdfd", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/47747872f276eb2619f4f8bfa03847117581bdfd", "message": "Construction API Unit Tests (#154)\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>\r\nSigned-off-by: Daniel <Daniel.K.Ivanov95@gmail.com>\r\nSigned-off-by: Daniel Ivanov <daniel.k.ivanov95@gmail.com>", "committedDate": "2020-10-22T06:22:09Z", "type": "commit"}, {"oid": "44a4258babe05a98b0089e7be0a60e60e31cb04e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/44a4258babe05a98b0089e7be0a60e60e31cb04e", "message": "Merge remote-tracking branch 'limechain/tests/construction-api-unit-tests' into tests/construction-api-unit-tests", "committedDate": "2020-10-22T07:29:32Z", "type": "commit"}, {"oid": "48f7b588621676a2eedf335bfc5c89c2cf3ba16b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/48f7b588621676a2eedf335bfc5c89c2cf3ba16b", "message": "Merge remote-tracking branch 'hashgraph/rosetta' into tests/construction-api-unit-tests\n\n# Conflicts:\n#\thedera-mirror-rosetta/app/services/network/network_service_test.go", "committedDate": "2020-10-22T07:32:19Z", "type": "commit"}, {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/86dc63ba21f1d0722be1b0b26b53222445f34dc2", "message": "Network Service Unit Tests optimisation\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-22T07:34:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc5Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510552796", "bodyText": "unmarshableTxHash is confusing since:\n\nit should be un-unmarshable\nit's not hash, it's the hex encoded marshaled transaction bytes\n\nsomething like corruptedTxHexStr provides better clarity\nalso have to rename exampleInvalidTxHashConstructionCombineRequest as it looks like copied from the previous test case.", "author": "xin-hedera", "createdAt": "2020-10-23T01:58:54Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MzQyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510553421", "bodyText": "it shouldn't be named invalidTxHash since it's not a hash. rename exampleInvalidTxHashConstructionCombineRequest as well.", "author": "xin-hedera", "createdAt": "2020-10-23T02:01:34Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTEzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555137", "bodyText": "the arg name txHash is misleading, should be signedTx or signedTransaction", "author": "xin-hedera", "createdAt": "2020-10-23T02:09:11Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555417", "bodyText": "as in the previous comment, validSignedTxHash is misleading, should be named sth like validSignedTransaction", "author": "xin-hedera", "createdAt": "2020-10-23T02:10:26Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTc0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555741", "bodyText": "similar as above, invalidTxHash should be renamed", "author": "xin-hedera", "createdAt": "2020-10-23T02:11:41Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjU2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510556566", "bodyText": "validUnsignedTxHash should be named sth like validTxHexStr since it's the hex encoded string of the marshalled transaction bytes", "author": "xin-hedera", "createdAt": "2020-10-23T02:15:22Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NzAyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510557025", "bodyText": "validSignedTx", "author": "xin-hedera", "createdAt": "2020-10-23T02:17:31Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MTYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510561624", "bodyText": "it's not a hash", "author": "xin-hedera", "createdAt": "2020-10-23T02:37:16Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MzAzMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563032", "bodyText": "hex.DecodeString returns err, so expectedDecodedBytes is an empty slice", "author": "xin-hedera", "createdAt": "2020-10-23T02:43:37Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2Mzk5Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563996", "bodyText": "should check Payloads not just Payloads[0]. AccountIdentifier.Address", "author": "xin-hedera", "createdAt": "2020-10-23T02:47:20Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2NTY3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510565678", "bodyText": "constructionSubmitSignedTransaction", "author": "xin-hedera", "createdAt": "2020-10-23T02:54:23Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123321\", \"1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.IsType(t, &types.Error{}, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidAccount(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"23321\", \"1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"23321\", \"-1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidAccount], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionSubmitRequest := &types.ConstructionSubmitRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: invalidTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionSubmit(nil, exampleConstructionSubmitRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenUnmarshalBinaryFails(t *testing.T) {\n+\tconstructionSubmitTxHash := \"0xfc2267c53ef8a27e2ab65f0a6b5e5607ba33b9c8c8f7304d8cb4a77aee19107d\"", "originalCommit": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb16f83ec27d75aa13c2bef03fa8a92e5969758d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb16f83ec27d75aa13c2bef03fa8a92e5969758d", "message": "PR comments resolution\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-26T09:47:24Z", "type": "commit"}, {"oid": "6ec6babb5be3914b3f04699b85390beacd0635b8", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6ec6babb5be3914b3f04699b85390beacd0635b8", "message": "Merge pull request #160 from LimeChain/tests/construction-api-unit-tests-rework\n\nPR comments resolution", "committedDate": "2020-10-26T11:03:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MDQ1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r512190455", "bodyText": "it's about the implementation of ConstructionPayloads not the test case:\nshould ConstructionPayloads fail early when supplied with an empty Operations slice?", "author": "xin-hedera", "createdAt": "2020-10-26T18:45:48Z", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTx   = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTx     = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHexStr   = \"InvalidTxHexString\"\n+\tcorruptedTxHexStr = \"0x6767\"\n+\tpublicKeyBytes    = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(signedTx string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: signedTx,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTx,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = invalidTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = corruptedTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\tvalidSignedTransaction := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTx)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: validSignedTransaction},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHexStr)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTx, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTx, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(corruptedTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\tvar expectedNilBytes []byte\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedNilBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {", "originalCommit": "6ec6babb5be3914b3f04699b85390beacd0635b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "060f18aba582baf4eeb16ba616f1f9136775b1e6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/060f18aba582baf4eeb16ba616f1f9136775b1e6", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-27T08:46:12Z", "type": "commit"}, {"oid": "ec2cff11116136e77eb6672c6d45c263e63d649d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ec2cff11116136e77eb6672c6d45c263e63d649d", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-27T08:49:37Z", "type": "commit"}, {"oid": "66c210b7bd5804107d819174cca5347fb75c1110", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/66c210b7bd5804107d819174cca5347fb75c1110", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-27T08:50:50Z", "type": "commit"}, {"oid": "d725ee6898e005e934dbb3116ab1ed67821b82e7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d725ee6898e005e934dbb3116ab1ed67821b82e7", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-27T08:55:37Z", "type": "commit"}, {"oid": "d8d5c3f4bd5ef963239f18a063b1e6fa900db5e5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d8d5c3f4bd5ef963239f18a063b1e6fa900db5e5", "message": "Merge pull request #161 from LimeChain/tests/construction-api-unit-tests-rework\n\nAdditional test cases", "committedDate": "2020-10-27T09:16:03Z", "type": "commit"}, {"oid": "0f7c2fd9951145bc13465fed071aec55c06a6f51", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0f7c2fd9951145bc13465fed071aec55c06a6f51", "message": "renaming\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>", "committedDate": "2020-10-27T13:58:10Z", "type": "commit"}]}