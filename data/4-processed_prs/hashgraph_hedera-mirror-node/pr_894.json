{"pr_number": 894, "pr_title": "Store address book in DB", "pr_createdAt": "2020-07-20T07:11:01Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/894", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MDc3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457580775", "bodyText": "redundant not null for primary key", "author": "xin-hedera", "createdAt": "2020-07-20T17:38:48Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key not null,", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MjYzMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457582632", "bodyText": "fail early here by throwing an exception? since address book data is not loaded, should not continue to parse it and eventually throw an exception when checking getAddress().isEmpty().", "author": "xin-hedera", "createdAt": "2020-07-20T17:41:56Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5MTIyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457591221", "bodyText": "should guard it by checking incomingAddressBook != null?", "author": "xin-hedera", "createdAt": "2020-07-20T17:56:46Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        // if address book is complete update end time of previous address book and start time of this\n+        if (incomingAddressBook != null && incomingAddressBook.isComplete()) {\n+            // retrieve last complete address book for fileID and update endConsensusTimestamp\n+            Optional<AddressBook> addressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook.getFileId());\n+            if (addressBook.isPresent()) {\n+                addressBookRepository\n+                        .updateEndConsensusTimestamp(addressBook.get().getConsensusTimestamp(), consensusTimestamp - 1);\n+            }\n+        }\n+\n+        // store address book.\n+        // Potential to also remove incomplete address books entries in the db table\n+        addressBookRepository.save(incomingAddressBook);", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NjM3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457596373", "bodyText": "update addressBook.endConsensusTimestamp and use save() to make the update, if performance is not a concern.", "author": "xin-hedera", "createdAt": "2020-07-20T18:05:55Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        // if address book is complete update end time of previous address book and start time of this\n+        if (incomingAddressBook != null && incomingAddressBook.isComplete()) {\n+            // retrieve last complete address book for fileID and update endConsensusTimestamp\n+            Optional<AddressBook> addressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook.getFileId());\n+            if (addressBook.isPresent()) {\n+                addressBookRepository\n+                        .updateEndConsensusTimestamp(addressBook.get().getConsensusTimestamp(), consensusTimestamp - 1);", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwNTEwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459805102", "bodyText": "We're going for insert only operations where possible", "author": "Nana-EC", "createdAt": "2020-07-24T00:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NjM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwOTA2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457609064", "bodyText": "should it be entityId.getEntityNum() == 102?", "author": "xin-hedera", "createdAt": "2020-07-20T18:29:08Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NTA2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r458295067", "bodyText": "That's effectively the check. I made the default mirrorProperties.AddressBookFileIdEntityNum = 102.\nWill have to revisit this should there ever be a new address book fileID that needs to be supported", "author": "Nana-EC", "createdAt": "2020-07-21T18:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwOTA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc1OTE1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459759158", "bodyText": "Seems like there's no need for me to make this a property so I'll revert it but still do a 101 and 102 check", "author": "Nana-EC", "createdAt": "2020-07-23T22:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwOTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNTQzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457635438", "bodyText": "redundant: assign the build to itself.", "author": "xin-hedera", "createdAt": "2020-07-20T19:17:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);", "originalCommit": "d39f16caea10cf920550a8d833a4163b09d41a9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc1OTIzNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459759234", "bodyText": "Fixed", "author": "Nana-EC", "createdAt": "2020-07-23T22:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2MjI1MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r458862250", "bodyText": "I don't think this needs to be a property. 102 is a well-known system file that council members will be signing. If it changes the entire ecosystem would be at risk. Also, it's confusing since we're also watching 101 but hardcoding that.", "author": "steven-sheehy", "createdAt": "2020-07-22T15:04:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/MirrorProperties.java", "diffHunk": "@@ -56,6 +56,8 @@\n \n     private Long topicRunningHashV2AddedTimestamp;\n \n+    private Long addressBookFileIdEntityNum = 102L;", "originalCommit": "093fa2bb1e993cf2c39d912e3edeb6a64d62eb9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2MDQ2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459760468", "bodyText": "Will revert. Can have 101 and 102 as static fields within NetworkAddressBook so it's easy to reference", "author": "Nana-EC", "createdAt": "2020-07-23T22:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2MjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTc1MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459545750", "bodyText": "We should remove converter and store in db as string as that is what comes via the protobuf.", "author": "steven-sheehy", "createdAt": "2020-07-23T15:41:27Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {\n \n-    private String id;\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    private Long consensusTimestamp;\n+\n+    @Convert(converter = StringToByteArrayConverter.class)\n+    private String memo;\n \n     private String ip;\n \n     @Builder.Default\n     private int port = 50211;\n \n+    @Convert(converter = StringToByteArrayConverter.class)", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0OTY2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459549669", "bodyText": "We should store as varchar(1024) since it's a hex encoded string and is modeled as string in the protobuf", "author": "steven-sheehy", "createdAt": "2020-07-23T15:47:09Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null,\n+    is_complete                 boolean         not null default false\n+);\n+\n+create index if not exists address_book__fileId_isComplete\n+    on address_book (file_id, is_complete);\n+\n+-- add node address table\n+create table if not exists node_address\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    bytea           not null,\n+    public_key              bytea           null,", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjU2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459666560", "bodyText": "Either a) we don't really care about the type for our purposes and can use generic EntityIdConverter or b) we should extend EntityIdConverter for reuse and supply EntityTypeEnum to parent constructor.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:05:36Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/converter/FileIdConverter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.hedera.mirror.importer.converter;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import javax.persistence.AttributeConverter;\n+import org.springframework.boot.context.properties.ConfigurationPropertiesBinding;\n+import org.springframework.core.convert.converter.Converter;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Named\n+@javax.persistence.Converter\n+@ConfigurationPropertiesBinding\n+public class FileIdConverter implements AttributeConverter<EntityId, Long>, Converter<String, EntityId> {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4MzYxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461683618", "bodyText": "We do care about the type. The encoding leaves out the entity type and that will result in match failures when EntityId is read from Db and the type not updated.\nAdded a AbstractEntityIdConverter class. Since the COnverters are stated as attributes using the class the FileId and AccountId converter extend that and pass in their relative type", "author": "Nana-EC", "createdAt": "2020-07-28T15:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODQyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459668429", "bodyText": "There's no point in storing as bytea if we only ever use it as string. We should use string in both places or byte array in both places. Recommend string in both and removing converter.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:09:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {\n \n-    private String id;\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    private Long consensusTimestamp;\n+\n+    @Convert(converter = StringToByteArrayConverter.class)", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTUyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459671529", "bodyText": "From the protobuf usage to store account ID is deprecated. We should use getNodeAccountId() and if need be internally it should get from memo if it is null to be backwards compatible. This will make it clearer our intent.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:15:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -159,7 +159,7 @@ protected void downloadNextBatch() {\n \n         Set<String> nodeAccountIds = networkAddressBook.getAddresses()\n                 .stream()\n-                .map(NodeAddress::getId)\n+                .map(NodeAddress::getMemo)", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4NDM3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461684378", "bodyText": "Done. On null memo is used with AccountId as default", "author": "Nana-EC", "createdAt": "2020-07-28T15:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTc3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459671770", "bodyText": "getNodeAccountId()", "author": "steven-sheehy", "createdAt": "2020-07-23T19:15:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/NodeSignatureVerifier.java", "diffHunk": "@@ -49,7 +49,7 @@ public NodeSignatureVerifier(NetworkAddressBook networkAddressBook) {\n         nodeIDPubKeyMap = networkAddressBook\n                 .getAddresses()\n                 .stream()\n-                .collect(Collectors.toMap(NodeAddress::getId, NodeAddress::getPublicKeyAsObject));\n+                .collect(Collectors.toMap(NodeAddress::getMemo, NodeAddress::getPublicKeyAsObject));", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Mzg3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459673872", "bodyText": "We shouldn't update address book if file transaction was unsuccessful. Since we are no longer writing files and/or updating in memory byte arrays we can push this logic into insertFileData and let db transactions handle whether it gets saved or not.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:19:42Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileCreate()) {\n-                insertFileData(consensusNs, body.getFileCreate().getContents().toByteArray(),\n-                        txRecord.getReceipt().getFileID());\n+                fileID = txRecord.getReceipt().getFileID();\n+                fileBytes = body.getFileCreate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileUpdate()) {\n-                insertFileUpdate(consensusNs, body.getFileUpdate());\n+                fileID = body.getFileUpdate().getFileID();\n+                fileBytes = body.getFileUpdate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             }\n         }\n \n         entityListener.onTransaction(tx);\n         log.debug(\"Storing transaction: {}\", tx);\n \n-        if (NetworkAddressBook.isAddressBook(entityId)) {\n-            networkAddressBook.updateFrom(body);\n+        if (networkAddressBook.isAddressBook(entityId)) {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4NzcxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461687716", "bodyText": "Moved this into successful branch only.\nHowever I think the isAddressBook check is valuable outside to allow for deduplication of effort i.e. allow AddressBook to save to fileData table as it encounters a file. This needs to be done as seen and not left to the batching so we can ensure data is present in the db to concatenate when an Append transaction is seen.\nAgreed on moving into the insertFileData. Did that", "author": "Nana-EC", "createdAt": "2020-07-28T15:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Mzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Njg4NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459676885", "bodyText": "insertFileAppend and insertFileUpdate are now unused methods. Not a fan of moving the per type logic from the individual methods to this if statement. Recommend we keep the more self-contained original approach of single line calls to methods that can handle the types. Also because we later want to refactor this into the separate file handler classes.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:25:07Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY5MDQ0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461690445", "bodyText": "Reverted to the former layout with support for fileData object creation for addressBook case", "author": "Nana-EC", "createdAt": "2020-07-28T15:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Njg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3OTUyMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459679520", "bodyText": "Recommend normalized FileData object be passed to NetworkAddressBook. Can add a field to FileData to indicate create, update or append.", "author": "steven-sheehy", "createdAt": "2020-07-23T19:30:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileCreate()) {\n-                insertFileData(consensusNs, body.getFileCreate().getContents().toByteArray(),\n-                        txRecord.getReceipt().getFileID());\n+                fileID = txRecord.getReceipt().getFileID();\n+                fileBytes = body.getFileCreate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileUpdate()) {\n-                insertFileUpdate(consensusNs, body.getFileUpdate());\n+                fileID = body.getFileUpdate().getFileID();\n+                fileBytes = body.getFileUpdate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             }\n         }\n \n         entityListener.onTransaction(tx);\n         log.debug(\"Storing transaction: {}\", tx);\n \n-        if (NetworkAddressBook.isAddressBook(entityId)) {\n-            networkAddressBook.updateFrom(body);\n+        if (networkAddressBook.isAddressBook(entityId)) {\n+            networkAddressBook.updateFrom(consensusNs, fileBytes, fileID, isAppendOperation);", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2MjI5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459762293", "bodyText": "Yeah was working towards this, had just added the TransactionType to FileData. Will complete it in next commit.", "author": "Nana-EC", "createdAt": "2020-07-23T22:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3OTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMDM5Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459700392", "bodyText": "I understand it was called NodeAdress previously and the protobuf calls it a NodeAddress, but in terms of domain driven design the AddressBook is the aggregate and this class is its dependent child. Any references to this class have to come via the aggregate as this is not a standalone class without the context that the parent provides. As a result, I recommend we call it something that denotes this dependency like AddressBookEntry.", "author": "steven-sheehy", "createdAt": "2020-07-23T20:11:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMjM0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459702340", "bodyText": "Being that this is the aggregate, we should probably model this with @OneToMany and eagerly fetch a list of address book entries directly in the domain. This would reduce the need to use multiple repositories and simplify the code that uses the address book.", "author": "steven-sheehy", "createdAt": "2020-07-23T20:15:33Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class AddressBook {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY5MTQyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461691429", "bodyText": "Good suggestion. Done", "author": "Nana-EC", "createdAt": "2020-07-28T15:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMzgyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459703829", "bodyText": "This is too complex. Now that we have the address book in the database we should simply delete or modify the necessary rows there for these tests or use repository mocks.", "author": "steven-sheehy", "createdAt": "2020-07-23T20:18:26Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -206,10 +217,17 @@ void partialConsensus() throws Exception {\n     @DisplayName(\"Exactly 1/3 consensus\")\n     void oneThirdConsensus() throws Exception {\n         // Remove last node from current 4 node address book\n-        byte[] addressBook = Files.readAllBytes(mirrorProperties.getAddressBookPath());\n+        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+        Resource resource = new ClassPathResource(resourcePath, getClass());\n+        byte[] addressBook = IOUtils.toByteArray(resource.getInputStream());\n         int index = Bytes.lastIndexOf(addressBook, (byte) '\\n');\n         addressBook = Arrays.copyOfRange(addressBook, 0, index);\n-        networkAddressBook.update(addressBook);\n+        networkAddressBook.updateFrom(", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDU3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459714572", "bodyText": "I'm not sure why people keep adding repositories here. We don't need to add to the parent class unless multiple children need it, which they currently don't.", "author": "steven-sheehy", "createdAt": "2020-07-23T20:39:12Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/AbstractRepositoryTest.java", "diffHunk": "@@ -53,6 +53,10 @@\n     protected TransactionTypeRepository transactionTypeRepository;\n     @Resource\n     protected EntityTypeRepository entityTypeRepository;\n+    @Resource", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY5MTk1Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461691952", "bodyText": "Reverted and fair point", "author": "Nana-EC", "createdAt": "2020-07-28T15:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTQ3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459715478", "bodyText": "network", "author": "steven-sheehy", "createdAt": "2020-07-23T20:40:58Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNzU4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459727587", "bodyText": "As mentioned previously, recommend FileData be only input. nit: Don't like updateFrom, would prefer update(FileData filedata)", "author": "steven-sheehy", "createdAt": "2020-07-23T21:05:12Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODAwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459728007", "bodyText": "We should not have public methods for tests", "author": "steven-sheehy", "createdAt": "2020-07-23T21:06:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY5MzMxMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461693313", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-28T15:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODUyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459728525", "bodyText": "private or package protected for tests. Though this method should go away when we don't store in memory objects.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:07:04Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        if (incomingAddressBook != null) {\n+\n+            // if address book is complete update end time of previous address book and start time of this\n+            if (incomingAddressBook.isComplete()) {\n+                // retrieve last complete address book for fileID and update endConsensusTimestamp\n+                Optional<AddressBook> addressBook = addressBookRepository\n+                        .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook\n+                                .getFileId());\n+                if (addressBook.isPresent()) {\n+                    addressBookRepository\n+                            .updateEndConsensusTimestamp(addressBook.get()\n+                                    .getConsensusTimestamp(), consensusTimestamp - 1);\n+                }\n+            }\n+\n+            // store address book.\n+            // Potential to also remove incomplete address books entries in the db table\n+            addressBookRepository.save(incomingAddressBook);\n+            log.info(\"Saved new address book to db: {}\", incomingAddressBook);\n+        }\n+    }\n+\n+    private void saveNodeAddresses(long consensusTimestamp) {\n+        // update current node address for matching address file\n+        if (!incomingNodeAddresses.isEmpty()) {\n+            for (NodeAddress nodeAddress : incomingNodeAddresses) {\n+                // set consensusTimestamp\n+                nodeAddress.setConsensusTimestamp(consensusTimestamp);\n+            }\n+\n+            // store node addresses\n+            nodeAddressRepository.saveAll(incomingNodeAddresses);\n+            log.info(\"Saved {} new node address to db: {}\", incomingNodeAddresses.size());\n+\n+            // update currentAddressBook and nodeAddresses for supported addressBook and matching fileID's only\n+            if (isSupportedAddressBookEntityNum(incomingAddressBook.getFileId().getEntityNum())) {\n+                if (currentAddressBook == null || currentAddressBook.getFileId().getId() == incomingAddressBook\n+                        .getFileId().getId()) {\n+\n+                    // update current and reset incoming\n+                    log.info(\"Updating address book in use from {} to {}\", currentAddressBook, incomingAddressBook);\n+                    currentNodeAddresses = new ArrayList(incomingNodeAddresses);\n+                    currentAddressBook = incomingAddressBook.toBuilder().build();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void loadAddressBookFromDB() {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY5MzkyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461693921", "bodyText": "Made private. Method is still necessary as we should be loading from db when picking up address book info for use.", "author": "Nana-EC", "createdAt": "2020-07-28T15:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDExMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459730113", "bodyText": "You said you removed the filesystem address book but this is still present. It should be removed and mirrorProperties.getAddressBookPath() also removed", "author": "steven-sheehy", "createdAt": "2020-07-23T21:10:36Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2Mzk1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459763958", "bodyText": "I understood it as a single backup scenario of 1st start. Load file file system if not present then form classpath.\nIf fileSystem addressBook and classPath are the same then yeah makes sense to totally remove this remaining filesystem one.", "author": "Nana-EC", "createdAt": "2020-07-23T22:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MTkxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459771910", "bodyText": "Loading from filesystem or from classpath should only occur on very first start of this release (e.g. migration). And the filesystem load should only be from initialAddressBookPath not data path.", "author": "steven-sheehy", "createdAt": "2020-07-23T22:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTQ2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461721461", "bodyText": "Gotcha. Non db loading is now just on initial start if no address book is returned from db and loads from initialPath/classpath in that order", "author": "Nana-EC", "createdAt": "2020-07-28T16:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzQ2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459733464", "bodyText": "We should not store address books (current or incoming) or list of node addresses (current or incoming) in memory. Everything should be stored in the database. Besides making the code more complex to understand and maintain, it is functionally wrong since if we restart the importer between a fileupdate and a fileappend it will be lost. This was why we had the tmp file previously to ensure no loss of data during this gap.\nIf we need to cache some repository methods to make them performant then we should do so.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:17:59Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2NTM1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459765356", "bodyText": "Yeah wanted to reduce the number of db calls\nCaching is a good solution and given address book updates are rare the optimization I had in mind to manage updates across files might not be as valuable as first thought.\nNotably. the logic does cover the case of importer going down between update and append. The in memory values are set based n db reads and confirmed writes.", "author": "Nana-EC", "createdAt": "2020-07-23T22:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcwNDY4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461704687", "bodyText": "Agreed on storing every address book file in db.", "author": "Nana-EC", "createdAt": "2020-07-28T16:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDQxNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459734415", "bodyText": "I believe this entire method goes away and moves to a database migration.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:20:03Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4Njc4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459786786", "bodyText": "Yeah goes away.", "author": "Nana-EC", "createdAt": "2020-07-23T23:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTM1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459735358", "bodyText": "Instead of having two public methods where the call to the second is conditional on the first returning true, we should move isAddressBook into updateFrom. This would better encapsulate this logic.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:22:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxMDI0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461710241", "bodyText": "update is no longer calling isAddressBook", "author": "Nana-EC", "createdAt": "2020-07-28T16:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTk2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459735969", "bodyText": "Since we're now dealing with an address book domain, would recommend renaming to AddressBookServiceImpl and an AddressBookService interface created.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:23:12Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxMDg0OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461710849", "bodyText": "Applied suggestion", "author": "Nana-EC", "createdAt": "2020-07-28T16:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNzgxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459737817", "bodyText": "This does not parse the fields from the 101 file (node cert hash, etc)", "author": "steven-sheehy", "createdAt": "2020-07-23T21:27:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNzI4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459827289", "bodyText": "Missed nodeCertHash, nodeId and nodeAccountId. Updated.", "author": "Nana-EC", "createdAt": "2020-07-24T02:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Mjk2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459742964", "bodyText": "I think we can greatly simplify this class if we always pull the bytes from the file data table. We wouldn't need to have partial address books in the database or an is_complete flag and can just keep the bytes in file data until we get that last filecreate/fileupdate/fileappend that parses. It also makes it easier for readers of the address book to understand that they are only present if valid. Also allows us to be insert only and make fields as non-null like end timestamp.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:38:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4OTE3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459789178", "bodyText": "Fair point. I was going for insert only. Challenge is file_data is updated as part of batching, this is sort of like a pitstop before that logic happens so the byte[] contents won't actually be in file_data table yet.\nThat's not a problem though if I know when the first update occurred as I can query fileRepository from then till now and concatenate all the bytes including this and store the address book.", "author": "Nana-EC", "createdAt": "2020-07-23T23:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Mjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxMjQ4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461712483", "bodyText": "Updated. address_book is only updated with complete entries. file_data will be updated with all address book files regardless", "author": "Nana-EC", "createdAt": "2020-07-28T16:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Mjk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0MzgzMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459743833", "bodyText": "This method goes away if you nest List<AddressBookEntry> entries in AddressBook as suggested. Then you can cascade the persist in one call to addressBookRepository.save(incomingAddressBook).", "author": "steven-sheehy", "createdAt": "2020-07-23T21:40:48Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        if (incomingAddressBook != null) {\n+\n+            // if address book is complete update end time of previous address book and start time of this\n+            if (incomingAddressBook.isComplete()) {\n+                // retrieve last complete address book for fileID and update endConsensusTimestamp\n+                Optional<AddressBook> addressBook = addressBookRepository\n+                        .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook\n+                                .getFileId());\n+                if (addressBook.isPresent()) {\n+                    addressBookRepository\n+                            .updateEndConsensusTimestamp(addressBook.get()\n+                                    .getConsensusTimestamp(), consensusTimestamp - 1);\n+                }\n+            }\n+\n+            // store address book.\n+            // Potential to also remove incomplete address books entries in the db table\n+            addressBookRepository.save(incomingAddressBook);\n+            log.info(\"Saved new address book to db: {}\", incomingAddressBook);\n+        }\n+    }\n+\n+    private void saveNodeAddresses(long consensusTimestamp) {", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0NjAzOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459746039", "bodyText": "Not sure it makes sense to have consensus_timestamp in this table as this data comes from a blob that potentially spans transactions. It makes more sense to have a foreign key back to address_book table instead.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:45:40Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null,\n+    is_complete                 boolean         not null default false\n+);\n+\n+create index if not exists address_book__fileId_isComplete\n+    on address_book (file_id, is_complete);\n+\n+-- add node address table\n+create table if not exists node_address\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4OTQ2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459789464", "bodyText": "Good idea", "author": "Nana-EC", "createdAt": "2020-07-23T23:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0NjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3ODQ4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462678483", "bodyText": "Removed addition of constraint and defined foreign key in the table directly", "author": "Nana-EC", "createdAt": "2020-07-30T01:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0NjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Njg5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459746891", "bodyText": "Most of these methods go away with my other suggestions.", "author": "steven-sheehy", "createdAt": "2020-07-23T21:47:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(\"from AddressBook where consensusTimestamp <= ?1 and fileId = ?2 and isComplete = true order by \" +\n+            \"consensusTimestamp asc\")\n+    List<AddressBook> findCompleteAddressBooks(long consensusTimestamp, EntityId fileId);", "originalCommit": "1159393216a6b7fdc3b26617b1afd2c36c70047e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxMzM1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461713354", "bodyText": "Some, but had to add more for migrate flow", "author": "Nana-EC", "createdAt": "2020-07-28T16:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Njg5MQ=="}], "type": "inlineReview"}, {"oid": "64a2f5e761db876c55dd2e3e741317b159c01911", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/64a2f5e761db876c55dd2e3e741317b159c01911", "message": "Persist address book to db on first start and on updates\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "4f23813487e2f0c03cee840b32c19bca3e160057", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4f23813487e2f0c03cee840b32c19bca3e160057", "message": "Remove file system storage logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "19eb8a64ca8b4a1abcfc4003f4d3f31cc8b3265d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/19eb8a64ca8b4a1abcfc4003f4d3f31cc8b3265d", "message": "Fixed most tests and added more NetworkAddressBookTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "2fee26688d80f738ffb10960f17680c5a64da85f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2fee26688d80f738ffb10960f17680c5a64da85f", "message": "Fixed tests and expanded some test cases and call logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "68c5c1f63d1d9a1b52889150f4d121d6e61d02c6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/68c5c1f63d1d9a1b52889150f4d121d6e61d02c6", "message": "Merged t_record file and pg-notify fixes from master in\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "ae5efcdec2726c1a05679c5e24c4eef6bdb1108d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ae5efcdec2726c1a05679c5e24c4eef6bdb1108d", "message": "Updated file_data table and Added java migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T04:58:14Z", "type": "commit"}, {"oid": "7b95420fe5cf739063fc986287327b691268be22", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7b95420fe5cf739063fc986287327b691268be22", "message": "Persist address book to db on first start and on updates\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:07:51Z", "type": "commit"}, {"oid": "e778804b35af1afcdedbef29748d09c135ed0c79", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e778804b35af1afcdedbef29748d09c135ed0c79", "message": "Remove file system storage logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:12:33Z", "type": "commit"}, {"oid": "cb80bcb944bb9a5977f71d970f9b8b38dc2414c7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb80bcb944bb9a5977f71d970f9b8b38dc2414c7", "message": "Fixed most tests and added more NetworkAddressBookTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:14:22Z", "type": "commit"}, {"oid": "9b5a3c3c84cb5e9fb8f9a48079c72336039ae897", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9b5a3c3c84cb5e9fb8f9a48079c72336039ae897", "message": "Fixed tests and expanded some test cases and call logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:15:49Z", "type": "commit"}, {"oid": "6f41cae7f32809def692f75990496441a32cea8a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6f41cae7f32809def692f75990496441a32cea8a", "message": "Merged t_record file and pg-notify fixes from master in\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:17:35Z", "type": "commit"}, {"oid": "c120cb37f0f893ca9468c83a506daacf4f1ac56b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c120cb37f0f893ca9468c83a506daacf4f1ac56b", "message": "Passed in EntityId instead of FileID\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:18:28Z", "type": "commit"}, {"oid": "5a87120fd35dccd660884ea5dbabbb4464ada000", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5a87120fd35dccd660884ea5dbabbb4464ada000", "message": "Adopt file respository store\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:22:19Z", "type": "commit"}, {"oid": "5a87120fd35dccd660884ea5dbabbb4464ada000", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5a87120fd35dccd660884ea5dbabbb4464ada000", "message": "Adopt file respository store\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-27T05:22:19Z", "type": "forcePushed"}, {"oid": "3eaa8e9983327eaa211907d6b1de7dcdb25925c7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3eaa8e9983327eaa211907d6b1de7dcdb25925c7", "message": "Fixed merge w PgCopy and fixed java migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-28T04:14:57Z", "type": "commit"}, {"oid": "34e290be0d6764d0495925757dc6f37689b24b5e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/34e290be0d6764d0495925757dc6f37689b24b5e", "message": "Addressed feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-28T16:41:07Z", "type": "commit"}, {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "message": "Fixed java migration circular dependency issue\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-28T19:48:24Z", "type": "commit"}, {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "message": "Fixed and added tests and customized repository method names\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-29T02:17:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjE3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461892175", "bodyText": "Having an index on a field with only two potential values (101 and 102) is not useful", "author": "steven-sheehy", "createdAt": "2020-07-28T21:32:02Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId", "originalCommit": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTA5Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462679096", "bodyText": "Yeah, initially I designed it with the capability to expand on fileID's so yeah this is no longer needed.", "author": "Nana-EC", "createdAt": "2020-07-30T01:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzEzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461893135", "bodyText": "I think int would be better for when we go permissionless and doesn't add too much storage for such a small table.", "author": "steven-sheehy", "createdAt": "2020-07-28T21:34:06Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,", "originalCommit": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTMzMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462679331", "bodyText": "Fair point", "author": "Nana-EC", "createdAt": "2020-07-30T01:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzgyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461893825", "bodyText": "Are we sure 101 has a memo? Memo is deprecated and they might not populate it in the future. We should probably not force it to be not null", "author": "steven-sheehy", "createdAt": "2020-07-28T21:35:30Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,", "originalCommit": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MDQzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462680436", "bodyText": "Correct, 101 deprecate memo so yeah it shouldn't be forced to have an entry.", "author": "Nana-EC", "createdAt": "2020-07-30T01:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTI2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461895269", "bodyText": "It would be cleaner to return EntityId and clients can convert to string only if needed.", "author": "steven-sheehy", "createdAt": "2020-07-28T21:38:54Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBookEntry.java", "diffHunk": "@@ -52,4 +78,8 @@ public PublicKey getPublicKeyAsObject() {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    public String getNodeAccountId() {", "originalCommit": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4NDYxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462684617", "bodyText": "getNodeAccountId() already returns EntityId and clients are calling it as needed.\nThis method exists to manage the 2 different address books where NodeAccountId may be null and the account Id is stated in the memo. e.g. NodeSignatureVerifier constructor and Downloader.downloadSigFiles()\nIn that case it's cleaner to have that logic centralized here.\nPlease clarify if you are referring to other scenarios", "author": "Nana-EC", "createdAt": "2020-07-30T01:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MjgwMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463162801", "bodyText": "Circling back I understand the notion and agree getNodeAccountId() should return EntityId.\nWill add an extra getNodeAccountIdString() to return the desired String representation", "author": "Nana-EC", "createdAt": "2020-07-30T17:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwODAwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461908003", "bodyText": "nit: Would prefer addressBook.getEntries() instead of redundant within context addressBook.getAddressBookEntries().", "author": "steven-sheehy", "createdAt": "2020-07-28T21:55:28Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToMany;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@ToString(exclude = {\"fileData\"})\n+public class AddressBook implements Persistable<Long> {\n+    @Id\n+    private Long consensusTimestamp; // transaction consensusTimestamp\n+\n+    private Long startConsensusTimestamp; // first transaction parsed with this address book\n+\n+    private Long endConsensusTimestamp; // consensusTimestamp 1 ns prior to next address book startConsensusTimestamp\n+\n+    @Convert(converter = FileIdConverter.class)\n+    private EntityId fileId;\n+\n+    private Integer nodeCount;\n+\n+    private byte[] fileData;\n+\n+    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumn(name = \"consensusTimestamp\")\n+    private List<AddressBookEntry> addressBookEntries;", "originalCommit": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0NjQyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462446428", "bodyText": "AddressBook is the aggregate and we should return that for our API. Also we should indicate this is the current in method. Recommend AddressBook getCurrent() so that it's clear when invoking addressBookService.getCurrent().", "author": "steven-sheehy", "createdAt": "2020-07-29T16:55:50Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookService.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.Collection;\n+\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.FileData;\n+\n+public interface AddressBookService {\n+\n+    boolean isAddressBook(EntityId entityId);\n+\n+    void update(FileData fileData);\n+\n+    Collection<AddressBookEntry> getAddresses();", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODEzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462448135", "bodyText": "Should still probably check isAddressBook here even if it's also done elsewhere to ensure correctness for future users of this method.", "author": "steven-sheehy", "createdAt": "2020-07-29T16:58:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc2MTc5OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462761798", "bodyText": "Had put the check in parse() will move it up into update()", "author": "Nana-EC", "createdAt": "2020-07-30T06:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODM3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462448373", "bodyText": "I think we can print the full stacktrace since we already catch and log the common scenario of partial address book elsewhere.", "author": "steven-sheehy", "createdAt": "2020-07-29T16:59:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MTAxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462461017", "bodyText": "Again, we should not store data in memory even for caching purposes. The more places you have data the more likely they are to be out of sync. We should rely on frameworks to provide caching like @Cacheable on a repository method or the service method if it makes sense there.\nCase in point, this addressBookEntries is currently not changed on calls to update() and only populated on startup.", "author": "steven-sheehy", "createdAt": "2020-07-29T17:19:42Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMjYwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462712606", "bodyText": "This retains the logic that existed which had private volatile Collection<NodeAddress> nodeAddresses; before.\nMore importantly this is by design, addressBookEntries should not be updated on update() or during the running session of the Importer. Rather, we should only apply the update on startup.\nAddress book changes from the network are currently sent right before a network FREEZE during maintenance.\nThe address book update should only be applied after the network has been restarted.\nSince maintenance times are variable, the expectation is that mirror node should also be restarted to take any address book  changes.\nOnce the details the Connect are hashed out on the network we can then figure out the right approach to take address book changes from the mirror node within a session.", "author": "Nana-EC", "createdAt": "2020-07-30T03:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MzkwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463163903", "bodyText": "Circling back on this.\nIndeed no need to cache in memory AddressBook for now. Will update to make repository call to get latest address book from DB. If performance becomes an issue we can explore caching in a future PR as the call will be made once per record file", "author": "Nana-EC", "createdAt": "2020-07-30T17:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MTAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzgxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462463819", "bodyText": "Again, this whole method goes away. Loading from the classpath or the filesystem should be handled by the migration and done once (not once per startup). From then on the database is the source of truth.\nYour current implementation is wrong because it repeatedly reloads from classpath/filesystem on startup, completely ignoring the addressbook in the database. So clients will always get the initial address book and not the latest.", "author": "steven-sheehy", "createdAt": "2020-07-29T17:24:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMzc2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462713762", "bodyText": "The current logic does not \"repeatedly reload from classpath/filesystem on startup\". It specifically checks the DB first. It only loads from the filesystem/classpath as a back up if no valid address book is retrieved from the DB, which is expected on 1st startup. I even added tests to ensure this is the case.\nHowever, I fully agree it would be an improvement to move the filePath/classpath load to the migration and only ever pull from the DB in this class. I'll make that change", "author": "Nana-EC", "createdAt": "2020-07-30T03:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc4MDgxMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462780813", "bodyText": "Moved logic to migration. Preserved the classpath load for now as removing it creates a huge fallout in many tests since the repository won't contain a valid address book at start as most tests clear the db before and after test methods.", "author": "Nana-EC", "createdAt": "2020-07-30T06:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NDQ5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463164495", "bodyText": "Circling back. With no in memory representation indeed the init() is no longer needed on startup as migration will cover populating the db with at least the bootstrap version", "author": "Nana-EC", "createdAt": "2020-07-30T17:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTA4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462465080", "bodyText": "Might make sense to have helper methods like fileData.isAppend()", "author": "steven-sheehy", "createdAt": "2020-07-29T17:26:19Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNDIxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462714217", "bodyText": "Good idea", "author": "Nana-EC", "createdAt": "2020-07-30T03:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2MzcwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462863703", "bodyText": "Tried to go for isAppend() but kept getting Hibernate issues looking for the append column. @Transient wasn't honored so I went with a transactionTypeIsAppend().", "author": "Nana-EC", "createdAt": "2020-07-30T09:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTc4NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462465785", "bodyText": "Once you remove init(), this if statement is duplicated by similar check in update()", "author": "steven-sheehy", "createdAt": "2020-07-29T17:27:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc4NTE0OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462785148", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-30T07:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjU0OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462466548", "bodyText": "nit: Not much point to a two line method that's not reused.", "author": "steven-sheehy", "createdAt": "2020-07-29T17:28:55Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            try {\n+                bos.write(firstPartialAddressBook.getFileData());\n+                for (int i = 0; i < appendFileDataEntries.size(); i++) {\n+                    bos.write(appendFileDataEntries.get(i).getFileData());\n+                }\n+\n+                bos.write(fileData.getFileData());\n+                combinedBytes = bos.toByteArray();\n+            } catch (Exception ex) {\n+                log.error(\"Error concatenating partial address book fileData entries\", ex);\n+            }\n+        }\n+\n+        return combinedBytes;\n+    }\n+\n+    private AddressBook buildAddressBook(byte[] addressBookBytes, long consensusTimestamp, EntityId fileID) {\n+        AddressBook.AddressBookBuilder addressBookBuilder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(fileID);\n+\n+        try {\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    addressBookBuilder.nodeCount(nodeAddressBook.getNodeAddressCount());\n+                    Collection<AddressBookEntry> addressBookEntryCollection =\n+                            retrieveNodeAddressesFromAddressBook(nodeAddressBook, consensusTimestamp);\n+\n+                    addressBookBuilder.addressBookEntries((List<AddressBookEntry>) addressBookEntryCollection);\n+                }\n+            }\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            return null;\n+        }\n+\n+        return addressBookBuilder.build();\n+    }\n+\n+    private Collection<AddressBookEntry> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook,\n+                                                                              long consensusTimestamp) {\n+        ImmutableList.Builder<AddressBookEntry> builder = ImmutableList.builder();\n+\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                AddressBookEntry addressBookEntry = AddressBookEntry.builder()\n+                        .consensusTimestamp(consensusTimestamp)\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .nodeCertHash(nodeAddressProto.getNodeCertHash().toByteArray())\n+                        .nodeId(nodeAddressProto.getNodeId())\n+                        .nodeAccountId(EntityId.of(nodeAddressProto.getNodeAccountId()))\n+                        .build();\n+                builder.add(addressBookEntry);\n+            }\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    private void saveAddressBook(AddressBook addressBook) {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNDE2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462714160", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-30T03:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4Mjg1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462482858", "bodyText": "return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);", "author": "steven-sheehy", "createdAt": "2020-07-29T17:55:45Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MTc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462581757", "bodyText": "It looks like if we get a fileappend without a corresponding create or update, we still create an address book entry and it will have null bytes. This probably shouldn't happen, but we should probably handle and throw an error.", "author": "steven-sheehy", "createdAt": "2020-07-29T20:53:16Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNTQ2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462715463", "bodyText": "Good point. Engineering assured me an append will always follow a create / update but you're right it's good to check for it.", "author": "Nana-EC", "createdAt": "2020-07-30T03:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4ODI1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462588251", "bodyText": "Probably shouldn't swallow this error", "author": "steven-sheehy", "createdAt": "2020-07-29T21:05:07Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            try {\n+                bos.write(firstPartialAddressBook.getFileData());\n+                for (int i = 0; i < appendFileDataEntries.size(); i++) {\n+                    bos.write(appendFileDataEntries.get(i).getFileData());\n+                }\n+\n+                bos.write(fileData.getFileData());\n+                combinedBytes = bos.toByteArray();\n+            } catch (Exception ex) {\n+                log.error(\"Error concatenating partial address book fileData entries\", ex);", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNzI4NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462717285", "bodyText": "Will throw new InvalidDatasetException", "author": "Nana-EC", "createdAt": "2020-07-30T03:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4ODI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MDI3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462590273", "bodyText": "Can at least set initial size to first address contents size as an optimization. Can also just return initialbytes if appends.size == 0.", "author": "steven-sheehy", "createdAt": "2020-07-29T21:08:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NTQxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462795410", "bodyText": "Optimization of setting to firstAddressBook size is good and I'll apply that.\nYou wouldn't want to return initalBytes on appendFileDataEntries.size() == 0 because that would ignore the case of a single create/update and 1 append sequence.", "author": "Nana-EC", "createdAt": "2020-07-30T07:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjg0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462616840", "bodyText": "Bad practice to add custom methods just for tests.", "author": "steven-sheehy", "createdAt": "2020-07-29T22:04:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookEntryRepository.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+\n+public interface AddressBookEntryRepository extends CrudRepository<AddressBookEntry, Long> {\n+    List<AddressBookEntry> findAddressBookEntriesByConsensusTimestamp(Long consensusTimeStamp);", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NTYxMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462795611", "bodyText": "Yeah I was thinking of a special case as this is what the State Proof TEST API will likely call, but I should rely on the REST module to cover tests for that.\nRemoved", "author": "Nana-EC", "createdAt": "2020-07-30T07:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462620209", "bodyText": "Find object, then update statement doesn't make sense. Just addressBookRepository.save().", "author": "steven-sheehy", "createdAt": "2020-07-29T22:13:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {\n+\n+        log.info(\"**startConsensusTimestamp: {}\", startConsensusTimestamp);\n+        // to:do - explore whether shutdown hook is a better place for address book consensusTimestamp boundary sets\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(startConsensusTimestamp, AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID\n+                        .getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+\n+            // set StartConsensusTimestamp of addressBook as first transaction in record file if not set already\n+            if (addressBook.getStartConsensusTimestamp() == null) {\n+                addressBook.setStartConsensusTimestamp(startConsensusTimestamp);\n+                addressBookRepository\n+                        .updateStartConsensusTimestamp(addressBook.getConsensusTimestamp(), startConsensusTimestamp);", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NTkwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462795908", "bodyText": "Left over logic exploration. Meant to save() and remove custom repository calls", "author": "Nana-EC", "createdAt": "2020-07-30T07:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIzMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462620233", "bodyText": "Find object, then update statement doesn't make sense. Just addressBookRepository.save().", "author": "steven-sheehy", "createdAt": "2020-07-29T22:13:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {\n+\n+        log.info(\"**startConsensusTimestamp: {}\", startConsensusTimestamp);\n+        // to:do - explore whether shutdown hook is a better place for address book consensusTimestamp boundary sets\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(startConsensusTimestamp, AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID\n+                        .getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+\n+            // set StartConsensusTimestamp of addressBook as first transaction in record file if not set already\n+            if (addressBook.getStartConsensusTimestamp() == null) {\n+                addressBook.setStartConsensusTimestamp(startConsensusTimestamp);\n+                addressBookRepository\n+                        .updateStartConsensusTimestamp(addressBook.getConsensusTimestamp(), startConsensusTimestamp);\n+            }\n+\n+            // close off previous addressBook\n+            Optional<AddressBook> previousOptionalAddressBook = addressBookRepository\n+                    .findLatestAddressBook(addressBook\n+                            .getConsensusTimestamp(), AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID.getId());\n+            if (previousOptionalAddressBook.isPresent()) {\n+                AddressBook previousAddressbook = previousOptionalAddressBook.get();\n+\n+                // set EndConsensusTimestamp of addressBook as first transaction - 1ns in record file if not set already\n+                if (previousAddressbook.getEndConsensusTimestamp() == null) {\n+                    previousAddressbook.setEndConsensusTimestamp(startConsensusTimestamp - 1);\n+                    addressBookRepository.updateEndConsensusTimestamp(previousAddressbook", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5NjAwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462796008", "bodyText": "Left over logic exploration. Meant to save() and remove custom repository calls", "author": "Nana-EC", "createdAt": "2020-07-30T07:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462623969", "bodyText": "This causes extra queries to run for every record file even if address book wasn't updated in that file. Also, this logic is not necessary. If the intent is to only \"activate\" the address book when finished processing the record file, we can do that purely with transactions. This logic should move to AddressBookService and once an address book is successfully parsed we should set start and end time appropriately.\nI don't think the start time should be the start of the first tx in the record file as the opening and closing of that file holds no special significance in the platform. So until the platform supports updating address book without a restart, we should just set currentaddressbook.start = lastappend.timestamp and previousaddressbook.end= lastappend.timestamp - 1.\nAnd even if this logic is somehow needed, it definitely should not be in RecordFileParser but in AddressBookService.", "author": "steven-sheehy", "createdAt": "2020-07-29T22:22:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1OTMzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462759335", "bodyText": "Similar to my previous explanation the current address book should only be retired after a network restart.\nOnly when the network starts up again should transactions use the new address book.\nThe end timestamp in a sense should be inclusive of the maintenance window, not the start timestamp.\nIt would therefore be incorrect to set end and start based off of last append. Rather it should be off of the first transaction post the restart. Which is the logic in the RecordFIleParser mentioned\nThe current logic does have a gap as it relies on the orchestration of network and mirror node restarts which might not be possible.\nEspecially since we want mirror nodes to pickup the address book change without forced restart where possible, but only after the network has restarted.\nOne option would be to rely on the FREEZE transaction coming through and using that as a trigger to reload from db.", "author": "Nana-EC", "createdAt": "2020-07-30T06:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjI4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462866287", "bodyText": "Added logic to call loadAddressBook() when a FREEZE transaction is sent.\nAgain when Connect logic on network is submitted we can update the logic to set the current addressbook upon a successful update()", "author": "Nana-EC", "createdAt": "2020-07-30T09:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NTM4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463165380", "bodyText": "Circling back. The logic is complex and in flux and outside of scope.\nAs such will adopt use current methodology and we can explore usage of FREEZE or other flags in future.\nGiven the updates of address book so far picking up an address book too early won't cause issues in importer.", "author": "Nana-EC", "createdAt": "2020-07-30T17:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDYzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462624635", "bodyText": "Why native here and jpql for others? Query looks simple enough", "author": "steven-sheehy", "createdAt": "2020-07-29T22:23:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.cache.annotation.CacheConfig;\n+import org.springframework.cache.annotation.CacheEvict;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.config.CacheConfiguration;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@CacheConfig(cacheNames = \"address_book\", cacheManager = CacheConfiguration.NEVER_EXPIRE_LARGE)\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"consensus_timestamp desc limit 1\", nativeQuery = true)", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyOTMxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462729312", "bodyText": "jpql doesn't support limits, so the nativeQuery was required.\nIt was either this or utilize Pageable, have an increase code footprint.", "author": "Nana-EC", "createdAt": "2020-07-30T04:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDgwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462624807", "bodyText": "These look like leftover cacheevicts", "author": "steven-sheehy", "createdAt": "2020-07-29T22:24:20Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.cache.annotation.CacheConfig;\n+import org.springframework.cache.annotation.CacheEvict;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.config.CacheConfiguration;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@CacheConfig(cacheNames = \"address_book\", cacheManager = CacheConfiguration.NEVER_EXPIRE_LARGE)\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"consensus_timestamp desc limit 1\", nativeQuery = true)\n+    Optional<AddressBook> findLatestAddressBook(long consensusTimestamp, long encodedFileId);\n+\n+    @Query(\"from AddressBook where consensusTimestamp <= ?1 and fileId = ?2 order by \" +\n+            \"consensusTimestamp asc\")\n+    List<AddressBook> findLatestAddressBooks(long consensusTimestamp, EntityId fileId);\n+\n+    @CacheEvict(key = \"#p0\")", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyOTY4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462729689", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-30T04:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzQ4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462637480", "bodyText": "nit: It's more isolate if the constraint is declared inside the create table.", "author": "steven-sheehy", "createdAt": "2020-07-29T22:58:47Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,\n+    public_key              varchar(1024)   null,\n+    node_id                 bigint          null,\n+    node_account_id         entity_id       null,\n+    node_cert_hash          bytea           null\n+);\n+\n+create index if not exists address_book_entry__id_timestamp\n+    on address_book_entry (id, consensus_timestamp);\n+\n+-- add foreign key\n+alter table address_book_entry\n+    add constraint fk__address_book foreign key (consensus_timestamp) references address_book (consensus_timestamp);", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyOTc4NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462729785", "bodyText": "Moved it into the table creation", "author": "Nana-EC", "createdAt": "2020-07-30T04:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzc0Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462637743", "bodyText": "why would id be included? If we had the id we wouldn't need to query by consensus_timestamp", "author": "steven-sheehy", "createdAt": "2020-07-29T22:59:33Z", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,\n+    public_key              varchar(1024)   null,\n+    node_id                 bigint          null,\n+    node_account_id         entity_id       null,\n+    node_cert_hash          bytea           null\n+);\n+\n+create index if not exists address_book_entry__id_timestamp\n+    on address_book_entry (id, consensus_timestamp);", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczMDI4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462730287", "bodyText": "Should just be consensus_timestamp", "author": "Nana-EC", "createdAt": "2020-07-30T04:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0Nzk0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462647947", "bodyText": "q: Are all the casts necessary? Also, wouldn't a simple entity_id in (101, 102) suffice?", "author": "steven-sheehy", "createdAt": "2020-07-29T23:31:56Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;\n+import org.flywaydb.core.internal.jdbc.RowMapper;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.addressbook.AddressBookService;\n+import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Log4j2\n+@Named\n+public class V1_28_1__Address_Book extends BaseJavaMigration {\n+    private final AddressBookService addressBookService;\n+    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > cast(? as \" +\n+            \"nanos_timestamp) and (entity_id = cast(? as int) or entity_id = cast(? as int)) order by \" +", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczMTIyMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462731220", "bodyText": "I was hitting errors without the casts because the query was treating them as varchar. Maybe there's another way to do this.\nI was having similar issues with the in and went with this to get it working. Can revisit it.\nUnless you're suggesting hardcoding entity_id in (101, 102) which is certainly a much simpler option too", "author": "Nana-EC", "createdAt": "2020-07-30T04:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0Nzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA0MjY5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463042693", "bodyText": "Yeah, just hardcode the entity_ids. For the others, JdbcTemplate isn't guessing the correct types so you can manually specify the types using one of its overloaded methods. Specifically create a PreparedStatementSetter and pass it.", "author": "steven-sheehy", "createdAt": "2020-07-30T14:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0Nzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTIzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462649236", "bodyText": "Missing logic to load from classpath/filesystem.", "author": "steven-sheehy", "createdAt": "2020-07-29T23:36:10Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;\n+import org.flywaydb.core.internal.jdbc.RowMapper;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.addressbook.AddressBookService;\n+import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Log4j2\n+@Named\n+public class V1_28_1__Address_Book extends BaseJavaMigration {\n+    private final AddressBookService addressBookService;\n+    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > cast(? as \" +\n+            \"nanos_timestamp) and (entity_id = cast(? as int) or entity_id = cast(? as int)) order by \" +\n+            \"consensus_timestamp asc limit cast(? as int)\";\n+    private JdbcTemplate jdbcTemplate;\n+\n+    public V1_28_1__Address_Book(@Lazy AddressBookService addressBookService) {\n+        this.addressBookService = addressBookService;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        jdbcTemplate = new JdbcTemplate(context.getConnection());\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries\n+        int pageSize = 1000; // option to parameterize this", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczNTkxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462735917", "bodyText": "Yeah, moving from AddressBookServiceImpl to here", "author": "Nana-EC", "createdAt": "2020-07-30T04:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MzY2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462653660", "bodyText": "How are we mocking address book repository when Downloader only has a reference to AddressBookService? We're testing too many layers here. We should just mock the AddressBookService and remove  the filesystem manipulation and repository. This is the same thing I said before.", "author": "steven-sheehy", "createdAt": "2020-07-29T23:50:28Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -211,14 +228,23 @@ void partialConsensus() throws Exception {\n     @Test\n     @DisplayName(\"Exactly 1/3 consensus\")\n     void oneThirdConsensus() throws Exception {\n-        // Remove last node from current 4 node address book\n-        byte[] addressBook = Files.readAllBytes(mirrorProperties.getAddressBookPath());\n+        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+        Path addressBookPath = ResourceUtils.getFile(String\n+                .format(\"classpath:addressbook/%s\", hederaNetwork.name().toLowerCase())).toPath();\n+        byte[] addressBook = Files.readAllBytes(addressBookPath);\n         int index = Bytes.lastIndexOf(addressBook, (byte) '\\n');\n         addressBook = Arrays.copyOfRange(addressBook, 0, index);\n-        networkAddressBook.update(addressBook);\n+        EntityId entityId = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+        long now = Instant.now().getEpochSecond();\n+\n+        doReturn(Optional.of(addressBookFromBytes(addressBook, now, entityId)))", "originalCommit": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0NTMyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462745326", "bodyText": "Agreed, mocking just the AddressBookService is cleaner", "author": "Nana-EC", "createdAt": "2020-07-30T05:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MzY2MA=="}], "type": "inlineReview"}, {"oid": "d92fe2ca1265f71c4e3383cf2ef532166a13e1c5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d92fe2ca1265f71c4e3383cf2ef532166a13e1c5", "message": "Merged memory leak fix and version bumps\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-30T00:51:35Z", "type": "commit"}, {"oid": "fcd3ea286fbc0c6653859e1486a2b2c3c0a96e94", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fcd3ea286fbc0c6653859e1486a2b2c3c0a96e94", "message": "Addressed 1st round of final comments\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-30T06:07:20Z", "type": "commit"}, {"oid": "36a094d091407ca77c32e46e4cda52f6886b1e88", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/36a094d091407ca77c32e46e4cda52f6886b1e88", "message": "Addressed 2nd set of feedback. Also added FREEZE transaction support\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-30T09:12:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAzOTM0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463039347", "bodyText": "Use Spring JdbcTemplate not internal Flyway classes.", "author": "steven-sheehy", "createdAt": "2020-07-30T14:30:42Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;", "originalCommit": "36a094d091407ca77c32e46e4cda52f6886b1e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxNDEyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463314123", "bodyText": "Switched to Spring JdbcTemplate", "author": "Nana-EC", "createdAt": "2020-07-30T22:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAzOTM0Nw=="}], "type": "inlineReview"}, {"oid": "54a4049adcb32cbe251cc8a7a65c21e0a2c9efd5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/54a4049adcb32cbe251cc8a7a65c21e0a2c9efd5", "message": "Adopted simpler approach to address book update\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-30T19:08:58Z", "type": "commit"}, {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a1502ba448a5b3477724480eab01e70f0551bc50", "message": "Fixed up endpoint timestamp setting logic and removed consensustimestamp\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-30T22:47:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjA0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463346047", "bodyText": "Test only repository method", "author": "steven-sheehy", "createdAt": "2020-07-31T00:41:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where start_consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"start_consensus_timestamp desc limit 1\", nativeQuery = true)\n+    Optional<AddressBook> findLatestAddressBook(long consensusTimestamp, long encodedFileId);\n+\n+    @Query(\"from AddressBook where startConsensusTimestamp <= ?1 and fileId = ?2 order by startConsensusTimestamp asc\")\n+    List<AddressBook> findLatestAddressBooks(long consensusTimestamp, EntityId fileId);", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTA0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379040", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-31T02:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjI3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463346277", "bodyText": "Looks like leftover from refactoring.", "author": "steven-sheehy", "createdAt": "2020-07-31T00:42:28Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -64,6 +65,7 @@\n public class RecordFileParser implements FileParser {\n \n     private final ApplicationStatusRepository applicationStatusRepository;\n+    private final AddressBookRepository addressBookRepository;", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTA3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379077", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-31T02:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0ODgzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463348838", "bodyText": "This annotation is not applicable here.", "author": "steven-sheehy", "createdAt": "2020-07-31T00:50:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBookEntry.java", "diffHunk": "@@ -52,4 +79,18 @@ public PublicKey getPublicKeyAsObject() {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    public EntityId getNodeAccountId() {\n+        if (nodeAccountId == null) {\n+            return memo == null ? null : EntityId.of(memo, EntityTypeEnum.ACCOUNT);\n+        }\n+\n+        return nodeAccountId;\n+    }\n+\n+    @Lazy", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTEwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379107", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-31T02:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0ODgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDMxMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463350313", "bodyText": "startConsensusTimestamp is always non-null. Can remove Persistable", "author": "steven-sheehy", "createdAt": "2020-07-31T00:56:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToMany;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@ToString(exclude = {\"fileData\"})\n+public class AddressBook implements Persistable<Long> {\n+    // consensusTimestamp + 1ns of transaction containing final fileAppend operation\n+    @Id\n+    private Long startConsensusTimestamp;\n+\n+    // consensusTimestamp of transaction containing final fileAppend operation of next address book\n+    private Long endConsensusTimestamp;\n+\n+    @Convert(converter = FileIdConverter.class)\n+    private EntityId fileId;\n+\n+    private Integer nodeCount;\n+\n+    private byte[] fileData;\n+\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumn(name = \"consensusTimestamp\")\n+    private List<AddressBookEntry> entries;\n+\n+    @Override\n+    public Long getId() {\n+        return startConsensusTimestamp;\n+    }\n+\n+    @Override\n+    public boolean isNew() {\n+        return startConsensusTimestamp == null;", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTI1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379253", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-31T02:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTM4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463351380", "bodyText": "I don't think any current user of this method can handle a null returned object, so we'll get NPEs. Better to throw a meaningful exception as it's truly an invalid state if we don't have at least one address book. Thus, most of this method can be collapsed to\nreturn addressBookRepository.findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId()).orElseThrow(() -> new IllegalStateException(\"\"));", "author": "steven-sheehy", "createdAt": "2020-07-31T01:00:47Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),\n+                    addressBook.getNodeSet());\n+            return addressBook;\n+        }\n+\n+        log.warn(\"No addressBooks before {} were found.\", consensus_timestamp);", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTM5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379390", "bodyText": "Funny had as a throw when I started too. Took your simplification also.", "author": "Nana-EC", "createdAt": "2020-07-31T02:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTc2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463351763", "bodyText": "Please remove this log. It will be printed many times per second in Downloader.", "author": "steven-sheehy", "createdAt": "2020-07-31T01:02:16Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTU1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379555", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-07-31T02:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MjI5NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463352294", "bodyText": "camelCase please", "author": "steven-sheehy", "createdAt": "2020-07-31T01:04:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTYxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379612", "bodyText": "Fixed", "author": "Nana-EC", "createdAt": "2020-07-31T02:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MzgwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463353804", "bodyText": "nit: Comment could be removed if the method name was more accurately named updatePreviousAddressBook", "author": "steven-sheehy", "createdAt": "2020-07-31T01:10:28Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),\n+                    addressBook.getNodeSet());\n+            return addressBook;\n+        }\n+\n+        log.warn(\"No addressBooks before {} were found.\", consensus_timestamp);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private void parse(FileData fileData) {\n+        byte[] addressBookBytes = null;\n+        if (fileData.transactionTypeIsAppend()) {\n+            // concatenate bytes from partial address book file data in db\n+            addressBookBytes = combinePreviousFileDataContents(fileData);\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileData = fileDataRepository.save(fileData);\n+\n+        AddressBook addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            addressBook = addressBookRepository.save(addressBook);\n+            log.info(\"Saved new address book to db: {}\", addressBook);\n+\n+            // update previous addressBook", "originalCommit": "a1502ba448a5b3477724480eab01e70f0551bc50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM3OTY2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463379667", "bodyText": "Adjusted", "author": "Nana-EC", "createdAt": "2020-07-31T02:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MzgwNA=="}], "type": "inlineReview"}, {"oid": "03cff55aa63d77a2f4387b411b72d2fea645551a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/03cff55aa63d77a2f4387b411b72d2fea645551a", "message": "Addressed final feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-07-31T02:53:00Z", "type": "commit"}]}