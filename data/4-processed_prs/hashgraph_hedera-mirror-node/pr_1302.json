{"pr_number": 1302, "pr_title": "Add gRPC and REST subscriber to monitor", "pr_createdAt": "2020-11-30T17:54:13Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533039475", "bodyText": "nit: should this rather be not equal?", "author": "Nana-EC", "createdAt": "2020-12-01T02:52:35Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU0NTA3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533545071", "bodyText": "Not quite, but there is a bug here that needs to be addressed. We base64 only the timestamp but decode the entire message which includes timestamp plus non-base64 random text. Also, we create the message subtracting 8 bytes for the long, but when it's encoded to base64 it's much larger than 8 bytes so the resulting message is over the expected size.\nBoth acceptance and JMeter tests are also wrong and need to be fixed. JMeter tests incorrectly assume only the first 8 bytes are for the long but as mentioned it's a higher and variable length once base64 encoded. Acceptance tests I'm not sure how they're working at all as they assume the entire message is the timestamp despite publishing with other data in it:\n// Publish\nbyte[] byteArray = Longs.toByteArray(Instant.now().toEpochMilli());\nString message = Base64.encodeBase64String(byteArray) + \"_\" + baseMessage + \"_\" + i + 1;\n...\n// Subscribe\nInstant publishInstant = Instant.ofEpochMilli(Longs.fromByteArray(Base64.decodeBase64(mirrorConsensusTopicResponse.message)));\nI will change monitor to not base64 the Long and just convert the Long and message to byte arrays and concat them.", "author": "steven-sheehy", "createdAt": "2020-12-01T16:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MzI3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533553278", "bodyText": "Yes, I do believe a few sprints back I made a change around this logic because of some encoding confusion.\nI believe the SDK encodes the message also. So when subscribing we have to decode the whole message first.\nLet me dig in and confirm.", "author": "Nana-EC", "createdAt": "2020-12-01T16:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3Mjk4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533572988", "bodyText": "The publish and subscribe logic you pasted is correct/similar for both acceptance and performance.\nIn both cases only the first 8 bytes are read by Longs.fromByteArray() so the rest of the message doesn't really matter and the accuracy of the publish instant being retrieved isn't impacted. Are you seeing cases where this is not the case and publish times are wrong?\nThe base64 encoding was added to ensure preservation of data during transport. I believe when the byte array had negative numbers the size of the data was getting modified during transport with the sdk and resulting incorrect Instant values when converted.", "author": "Nana-EC", "createdAt": "2020-12-01T17:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3MzMxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533573310", "bodyText": "I don't think it's a bug (unless you're seeing bad times) so much as an opportunity to improve the efficiency of the logic.\nI'm okay with byte array concatenation so far as it works. The point was for the subscribe codes in all our tests to work regardless of where the transactions were published from. Service load testing/ mirror acceptance/performance tests - they should all work.\nTry a few runs after your change and check for error cases where erroneous Instants times are created on the subscribe time e.g. EPOCH/max or a time in the future.\nThat was the original bug seen that prompted the base64 encoding", "author": "Nana-EC", "createdAt": "2020-12-01T17:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxMTI4NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535311284", "bodyText": "Discussed offline. This logic has been changed from base64 to raw bytes and above is no longer applicable.", "author": "steven-sheehy", "createdAt": "2020-12-03T15:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MDI2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533070261", "bodyText": "nit: I think we should start to make it a practice of commenting on multi stage reactive flows.\nThey tend to be the places where order is important and where logic is swapped in and out.\nSo it would help for future management to be clear on the choices applied here.", "author": "Nana-EC", "createdAt": "2020-12-01T04:46:05Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/config/MonitorConfiguration.java", "diffHunk": "@@ -48,12 +48,17 @@\n     @Resource\n     private TransactionPublisher transactionPublisher;\n \n+    @Resource\n+    private Subscriber subscriber;\n+\n     @Bean\n-    IntegrationFlow publishFlow() {\n-        return IntegrationFlows\n-                .from(new ReactiveMessageSourceProducer(() -> new GenericMessage<>(transactionGenerator.next())))\n-                .channel(c -> c.executor(Executors.newFixedThreadPool(publishProperties.getConnections())))\n-                .handle(PublishRequest.class, (p, h) -> transactionPublisher.publish(p))\n-                .nullChannel();\n+    Disposable publishSubscribe() {\n+        return Flux.<PublishRequest>generate(sink -> sink.next(transactionGenerator.next()))", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU0OTY5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533549699", "bodyText": "Sure, will add some javadocs", "author": "steven-sheehy", "createdAt": "2020-12-01T16:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MDI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MTE3NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533071174", "bodyText": "This should be moved outside of the for loop and checked once right?\nSince properties doesn't change per scenario and if properties.isEnabled() is false it doesn't matter whether the scenarios are enabled.", "author": "Nana-EC", "createdAt": "2020-12-01T04:49:35Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/CompositeTransactionGenerator.java", "diffHunk": "@@ -46,22 +81,18 @@ public CompositeTransactionGenerator(PublishProperties properties) {\n                 .reduce(0.0, (x, y) -> x + y);\n \n         for (ScenarioProperties scenarioProperties : properties.getScenarios()) {\n-            if (scenarioProperties.isEnabled()) {\n+            if (properties.isEnabled() && scenarioProperties.isEnabled()) {", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MTc5Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533551796", "bodyText": "I had it like that but I later put it inside as it avoids an extra level of nesting and if statement and accomplishes the same thing. But I can move it back up if it eases your mind.", "author": "steven-sheehy", "createdAt": "2020-12-01T16:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMzcwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r532903702", "bodyText": "Is this just to avoid creating the Instant object?", "author": "ijungmann", "createdAt": "2020-11-30T21:07:07Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] timestampBytes = Arrays.copyOfRange(decoded, 0, Long.BYTES);\n+        return Longs.fromByteArray(timestampBytes);\n+    }\n+\n     public static String getEncodedTimestamp() {\n-        return Base64.getEncoder().encodeToString(Longs.toByteArray(Instant.now().toEpochMilli()));\n+        return Base64.getEncoder().encodeToString(Longs.toByteArray(System.currentTimeMillis()));", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyMTQxMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533521411", "bodyText": "Exactly. Every little bit helps when you're performance testing at 10K.", "author": "steven-sheehy", "createdAt": "2020-12-01T15:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NjY2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533476669", "bodyText": "Is there a reason to set the receipt here if it's already set in init()?", "author": "ijungmann", "createdAt": "2020-12-01T14:57:34Z", "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGeneratorTest.java", "diffHunk": "@@ -84,6 +95,76 @@ void reachedDuration() {\n                 .hasMessageContaining(\"Reached publish duration\");\n     }\n \n+    @Test\n+    void receiptDisabled() {\n+        properties.setReceipt(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void receiptEnabled() {\n+        properties.setReceipt(100);", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MjY2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533552665", "bodyText": "No, just as a form of documentation when reading the test case in isolation.", "author": "steven-sheehy", "createdAt": "2020-12-01T16:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NjY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODk4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533478989", "bodyText": "Same thing, is there a reason to set the record to the same value set in the init?", "author": "ijungmann", "createdAt": "2020-12-01T15:00:24Z", "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGeneratorTest.java", "diffHunk": "@@ -84,6 +95,76 @@ void reachedDuration() {\n                 .hasMessageContaining(\"Reached publish duration\");\n     }\n \n+    @Test\n+    void receiptDisabled() {\n+        properties.setReceipt(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void receiptEnabled() {\n+        properties.setReceipt(100);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(true);\n+        }\n+    }\n+\n+    @Test\n+    void receiptPercent() {\n+        properties.setReceipt(1);\n+        Multiset<Boolean> receipts = HashMultiset.create();\n+\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            receipts.add(generator.get().next().isReceipt());\n+        }\n+\n+        assertThat((int) (receipts.count(true) * 100.0 / SAMPLE_SIZE))\n+                .isNotNegative()\n+                .isNotZero()\n+                .isCloseTo(properties.getReceipt(), within((int) (SAMPLE_SIZE * 0.05)));\n+    }\n+\n+    @Test\n+    void recordDisabled() {\n+        properties.setRecord(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isRecord)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void recordEnabled() {\n+        properties.setRecord(100);", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mjc5Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533552792", "bodyText": "No, just as a form of documentation when reading the test case in isolation.", "author": "steven-sheehy", "createdAt": "2020-12-01T16:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODUxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533518518", "bodyText": "can catch IllegalArgumentException which is thrown if bytes has fewer than 8 elements", "author": "xin-hedera", "createdAt": "2020-12-01T15:49:39Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] timestampBytes = Arrays.copyOfRange(decoded, 0, Long.BYTES);\n+        return Longs.fromByteArray(timestampBytes);", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxNDMzOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533614339", "bodyText": "That shouldn't be possible since I check if bytes.length < Long.BYTES and return right above this.", "author": "steven-sheehy", "createdAt": "2020-12-01T18:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMDE5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533620195", "bodyText": "yes.\nI meant If we catch the exception, we don't need to check the length & copy the buffer before calling Longs.fromByteArray", "author": "xin-hedera", "createdAt": "2020-12-01T18:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDY5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533630695", "bodyText": "I'd still have to check if null as Longs.fromByteArray doesn't. But in general, it's better to use a conditional as it's an order of magnitude more performant than exception handling, especially during performance testing.", "author": "steven-sheehy", "createdAt": "2020-12-01T18:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mzk0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533553940", "bodyText": "double acquire for the first PublishRequest, is this intended?", "author": "xin-hedera", "createdAt": "2020-12-01T16:35:16Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGenerator.java", "diffHunk": "@@ -42,30 +42,44 @@ public ConfigurableTransactionGenerator(ScenarioProperties properties) {\n         this.properties = properties;\n         this.transactionSupplier = convert(properties);\n         this.rateLimiter = RateLimiter.create(properties.getTps());\n-        remaining = new AtomicLong(properties.getLimit() > 0 ? properties.getLimit() : Long.MAX_VALUE);\n+        remaining = new AtomicLong(properties.getLimit());\n         stopTime = System.nanoTime() + properties.getDuration().toNanos();\n         builder = PublishRequest.builder()\n-                .record(properties.isRecord())\n-                .receipt(properties.isReceipt())\n+                .logResponse(properties.isLogResponse())\n                 .type(properties.getType());\n-        log.info(\"Initializing scenario: {}\", properties);\n+        rateLimiter.acquire();", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxNjYzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533616636", "bodyText": "It's intended. The RateLimiter's first acquire always occurs instantaneously since it doesn't have anything to compare against. Discarding that first acquire makes the numbers more accurate but more importantly fixes the issue with setting Double.MIN_NORMAL for TPS to never generate a message like I do for inactive scenarios in CompositeTransactionGenerator.\nI'll add a comment so this is clear.", "author": "steven-sheehy", "createdAt": "2020-12-01T18:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNTAxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533625012", "bodyText": "I see.\nNot related to the conversation above, I do think we need a single global rate limiter instead of one per scenario.\nOne rate limiter per scenario can cause spikes of transactions. For example, there are two enabled scenarios of 25.0 tps (A) and 75.0 tps (B), the extreme case is for a group of 100 transactions, the distribution is the first 25 are all for A so it takes the whole second and leaves the next 75 for B generated back to back in one shot.\nA single global rate limiter will make the transactions evenly spaced time wise.", "author": "xin-hedera", "createdAt": "2020-12-01T18:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxMTg3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535311877", "bodyText": "We can consider it in the future once proven via testing", "author": "steven-sheehy", "createdAt": "2020-12-03T15:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzE0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533563141", "bodyText": "this is percent + 1 out of 100  when percent is not 0 or 100. (count % 100) < percent should work and no special handling of 0 and 100 is needed.", "author": "xin-hedera", "createdAt": "2020-12-01T16:47:34Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGenerator.java", "diffHunk": "@@ -42,30 +42,44 @@ public ConfigurableTransactionGenerator(ScenarioProperties properties) {\n         this.properties = properties;\n         this.transactionSupplier = convert(properties);\n         this.rateLimiter = RateLimiter.create(properties.getTps());\n-        remaining = new AtomicLong(properties.getLimit() > 0 ? properties.getLimit() : Long.MAX_VALUE);\n+        remaining = new AtomicLong(properties.getLimit());\n         stopTime = System.nanoTime() + properties.getDuration().toNanos();\n         builder = PublishRequest.builder()\n-                .record(properties.isRecord())\n-                .receipt(properties.isReceipt())\n+                .logResponse(properties.isLogResponse())\n                 .type(properties.getType());\n-        log.info(\"Initializing scenario: {}\", properties);\n+        rateLimiter.acquire();\n     }\n \n     @Override\n     public PublishRequest next() {\n-        if (remaining.getAndDecrement() <= 0) {\n-            throw new ScenarioException(\"Reached publish limit of \" + properties.getLimit());\n+        rateLimiter.acquire();\n+        long count = remaining.getAndDecrement();\n+\n+        if (count <= 0) {\n+            throw new ScenarioException(properties, \"Reached publish limit of \" + properties.getLimit());\n         }\n \n         if (stopTime - System.nanoTime() <= 0) {\n-            throw new ScenarioException(\"Reached publish duration of \" + properties.getDuration());\n+            throw new ScenarioException(properties, \"Reached publish duration of \" + properties.getDuration());\n         }\n \n-        rateLimiter.acquire();\n-        return builder.transactionBuilder(transactionSupplier.get()).build();\n+        return builder.receipt(shouldGenerate(properties.getReceipt(), count))\n+                .record(shouldGenerate(properties.getRecord(), count))\n+                .transactionBuilder(transactionSupplier.get())\n+                .build();\n     }\n \n     private TransactionSupplier<?> convert(ScenarioProperties p) {\n         return new ObjectMapper().convertValue(p.getProperties(), p.getType().getSupplier());\n     }\n+\n+    private boolean shouldGenerate(int percent, long count) {\n+        if (percent <= 0) {\n+            return false;\n+        } else if (percent >= 100) {\n+            return true;\n+        } else {\n+            return (count % 100) <= percent;", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2OTIwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533669206", "bodyText": "Will change", "author": "steven-sheehy", "createdAt": "2020-12-01T19:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3MjQyNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533572427", "bodyText": "subscriberProperties.getLimit() - counter.get() can be negative when subscriberProperties.getLimit() is 0 and counter is not 0\nlimit should be set 0 if getLimit() is 0; otherwise it should be set to getLimit() - counter.get()", "author": "xin-hedera", "createdAt": "2020-12-01T17:00:03Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(\"hedera.mirror.monitor.subscribe\")\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        log.info(\"Connecting to mirror node {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        this.mirrorClient = new MirrorClient(monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        Long timestamp = Utility.getDecodedTimestamp(topicResponse.message);\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;\n+        timer.record(latency, TimeUnit.MILLISECONDS);\n+        this.lastReceived = topicResponse;\n+        counter.incrementAndGet();\n+    }\n+\n+    private void onError(Throwable t) {\n+        log.error(\"Error subscribing: \", t);\n+        errors.add(getStatusCode(t).name());\n+\n+        if (shouldRetry(t)) {\n+            long delayMillis = retries.get() * subscriberProperties.getDelayMultiplier().toMillis();\n+            Duration retry = Duration.ofMillis(Math.min(delayMillis, subscriberProperties.getDelayMax().toMillis()));\n+            log.info(\"Retrying in {}s\", retry.toSeconds());\n+            Uninterruptibles.sleepUninterruptibly(retry);\n+            resubscribe();\n+        } else {\n+            close();\n+        }\n+    }\n+\n+    private boolean shouldRetry(Throwable t) {\n+        Status.Code code = getStatusCode(t);\n+\n+        if (code == INVALID_ARGUMENT || code == NOT_FOUND) {\n+            return false;\n+        }\n+\n+        return retries.incrementAndGet() < subscriberProperties.getRetries();\n+    }\n+\n+    private Status.Code getStatusCode(Throwable t) {\n+        if (t instanceof StatusRuntimeException) {\n+            return ((StatusRuntimeException) t).getStatus().getCode();\n+        }\n+        return Status.Code.UNKNOWN;\n+    }\n+\n+    @Override\n+    public void onPublish(PublishResponse response) {\n+        // Ignore for now\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        try {\n+            log.info(\"Closing mirror node connection to {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+            subscription.unsubscribe();\n+            mirrorClient.close(1, TimeUnit.SECONDS);\n+            statusThread.cancel(true);\n+        } catch (Exception e) {\n+            // Ignore\n+        }\n+    }\n+\n+    private synchronized void resubscribe() {\n+        MirrorConsensusTopicQuery mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery();\n+        mirrorConsensusTopicQuery.setTopicId(ConsensusTopicId.fromString(subscriberProperties.getTopicId()));\n+        mirrorConsensusTopicQuery.setLimit(Math.min(0, subscriberProperties.getLimit() - counter.get()));", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNjE1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533626156", "bodyText": "That's why I added the extra call to java.lang.Math. Unfortunately I put Math.min() and I meant Math.max(). Will correct.", "author": "steven-sheehy", "createdAt": "2020-12-01T18:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3MjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3ODA3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533578075", "bodyText": "endTime should stay the same when it's calculated based on duration; it should not be the current startTime + duration when retrying", "author": "xin-hedera", "createdAt": "2020-12-01T17:08:06Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(\"hedera.mirror.monitor.subscribe\")\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        log.info(\"Connecting to mirror node {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        this.mirrorClient = new MirrorClient(monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        Long timestamp = Utility.getDecodedTimestamp(topicResponse.message);\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;\n+        timer.record(latency, TimeUnit.MILLISECONDS);\n+        this.lastReceived = topicResponse;\n+        counter.incrementAndGet();\n+    }\n+\n+    private void onError(Throwable t) {\n+        log.error(\"Error subscribing: \", t);\n+        errors.add(getStatusCode(t).name());\n+\n+        if (shouldRetry(t)) {\n+            long delayMillis = retries.get() * subscriberProperties.getDelayMultiplier().toMillis();\n+            Duration retry = Duration.ofMillis(Math.min(delayMillis, subscriberProperties.getDelayMax().toMillis()));\n+            log.info(\"Retrying in {}s\", retry.toSeconds());\n+            Uninterruptibles.sleepUninterruptibly(retry);\n+            resubscribe();\n+        } else {\n+            close();\n+        }\n+    }\n+\n+    private boolean shouldRetry(Throwable t) {\n+        Status.Code code = getStatusCode(t);\n+\n+        if (code == INVALID_ARGUMENT || code == NOT_FOUND) {\n+            return false;\n+        }\n+\n+        return retries.incrementAndGet() < subscriberProperties.getRetries();\n+    }\n+\n+    private Status.Code getStatusCode(Throwable t) {\n+        if (t instanceof StatusRuntimeException) {\n+            return ((StatusRuntimeException) t).getStatus().getCode();\n+        }\n+        return Status.Code.UNKNOWN;\n+    }\n+\n+    @Override\n+    public void onPublish(PublishResponse response) {\n+        // Ignore for now\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        try {\n+            log.info(\"Closing mirror node connection to {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+            subscription.unsubscribe();\n+            mirrorClient.close(1, TimeUnit.SECONDS);\n+            statusThread.cancel(true);\n+        } catch (Exception e) {\n+            // Ignore\n+        }\n+    }\n+\n+    private synchronized void resubscribe() {\n+        MirrorConsensusTopicQuery mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery();\n+        mirrorConsensusTopicQuery.setTopicId(ConsensusTopicId.fromString(subscriberProperties.getTopicId()));\n+        mirrorConsensusTopicQuery.setLimit(Math.min(0, subscriberProperties.getLimit() - counter.get()));\n+\n+        Instant startTime = lastReceived != null ? lastReceived.consensusTimestamp.plusNanos(1) : subscriberProperties\n+                .getStartTime();\n+        startTime = Objects.requireNonNullElseGet(startTime, Instant::now);\n+        mirrorConsensusTopicQuery.setStartTime(startTime);\n+\n+        if (endTime != null) {\n+            mirrorConsensusTopicQuery.setEndTime(endTime);\n+        } else {\n+            Duration duration = subscriberProperties.getDuration();\n+            if (duration != null) {\n+                endTime = startTime.plus(duration);", "originalCommit": "fd3daf0add549d45a9f77739dbcae82d6ab515eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxNzc5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533617795", "bodyText": "Correct, which is why I store the endTime from the previous run so this code is never reached on retry.", "author": "steven-sheehy", "createdAt": "2020-12-01T18:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3ODA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxODE2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r534518166", "bodyText": "This class was removed as a result of removing the manual bean validation.  It can be added back for the message size check, just a heads up that there may be conflicts.", "author": "ijungmann", "createdAt": "2020-12-02T22:15:21Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/TransactionSupplierException.java", "diffHunk": "@@ -27,4 +27,8 @@\n     public TransactionSupplierException(TransactionSupplier transactionSupplier, List<String> requiredFields) {\n         super(String.format(MESSAGE, transactionSupplier.getClass().getSimpleName(), requiredFields));\n     }\n+\n+    public TransactionSupplierException(String message) {", "originalCommit": "00c75885a18e47f15900ddc2a054ce588d48fce9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2NTczMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r534565733", "bodyText": "Yep, removed.", "author": "steven-sheehy", "createdAt": "2020-12-03T00:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxODE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxOTc2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r534519760", "bodyText": "Thank you, I think this will really help going forward.", "author": "ijungmann", "createdAt": "2020-12-02T22:18:50Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/config/MonitorConfiguration.java", "diffHunk": "@@ -51,6 +51,14 @@\n     @Resource\n     private Subscriber subscriber;\n \n+    /**\n+     * Constructs a reactive flow for publishing and subscribing to transactions. The transaction generator will run on\n+     * a single thread and generate transactions as fast as possible. Next, a parallel Flux will concurrently publish\n+     * those transactions to the main nodes. Finally, a subscriber will receive every published transaction response and\n+     * validate whether that transaction was received by the mirror node APIs.\n+     *\n+     * @return the subscribed flux\n+     */", "originalCommit": "00c75885a18e47f15900ddc2a054ce588d48fce9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9621b376c4eb2d2d33db79c3d0d9a12767d614af", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9621b376c4eb2d2d33db79c3d0d9a12767d614af", "message": "Various publish improvements to monitor\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T22:44:44Z", "type": "commit"}, {"oid": "9bcd5eec2790a60f68d0f362a09cc0e69f692958", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9bcd5eec2790a60f68d0f362a09cc0e69f692958", "message": "Add gRPC and REST subscriber to monitor\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T22:44:45Z", "type": "commit"}, {"oid": "36aae4d6232c3def44a0dc80e622f5acd910560d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/36aae4d6232c3def44a0dc80e622f5acd910560d", "message": "Fix the build and normalize retry properties\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T22:44:45Z", "type": "commit"}, {"oid": "0470742b11e645efb03083103c0660a2ff213ce2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0470742b11e645efb03083103c0660a2ff213ce2", "message": "Address review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T22:47:37Z", "type": "commit"}, {"oid": "c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "message": "Fix code smells and add a RestSubscriberTest\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T23:20:17Z", "type": "commit"}, {"oid": "c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "message": "Fix code smells and add a RestSubscriberTest\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-02T23:20:17Z", "type": "forcePushed"}, {"oid": "01880b383ec27021a68274335aab1db00281e55f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/01880b383ec27021a68274335aab1db00281e55f", "message": "Fix test\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-03T15:03:48Z", "type": "commit"}, {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d419f11ef05f813385d17d154fa251bb45efe0e5", "message": "Fix test again\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-03T15:44:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535398416", "bodyText": "Nit: Should this be marked final if the intent is to never allow retries?", "author": "ijungmann", "createdAt": "2020-12-03T16:44:15Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/consensus/ConsensusSubmitMessageTransactionSupplier.java", "diffHunk": "@@ -21,55 +21,72 @@\n  */\n \n import com.google.common.primitives.Longs;\n+import java.nio.charset.StandardCharsets;\n import java.security.SecureRandom;\n-import java.time.Instant;\n import javax.validation.constraints.Min;\n import javax.validation.constraints.NotBlank;\n import lombok.Data;\n-import org.apache.commons.lang3.RandomStringUtils;\n+import lombok.Getter;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n \n-import com.hedera.datagenerator.common.Utility;\n import com.hedera.datagenerator.sdk.supplier.TransactionSupplier;\n+import com.hedera.hashgraph.sdk.HederaThrowable;\n import com.hedera.hashgraph.sdk.consensus.ConsensusMessageSubmitTransaction;\n import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n \n @Data\n public class ConsensusSubmitMessageTransactionSupplier implements TransactionSupplier<ConsensusMessageSubmitTransaction> {\n \n-    private static final SecureRandom RANDOM = new SecureRandom();\n-\n     @Min(1)\n     private long maxTransactionFee = 1_000_000;\n \n     private String message = StringUtils.EMPTY;\n \n-    @Min(1)\n+    @Min(8)\n     private int messageSize = 256;\n \n+    private boolean retry = false;", "originalCommit": "d419f11ef05f813385d17d154fa251bb45efe0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwMDg4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535400883", "bodyText": "If it was final I could just remove the variable and hardcode it. The intent is to make retries configurable. Later we might be able to do this generically for all transaction types in which case we can make this a publisher property.", "author": "steven-sheehy", "createdAt": "2020-12-03T16:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwNDQ4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535404488", "bodyText": "That makes sense, just in this instance it being used in a NonRetryableConsensusMessageSubmitTransaction implies it would never be configured otherwise.", "author": "ijungmann", "createdAt": "2020-12-03T16:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0MzE1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535443151", "bodyText": "Naming things is hard. Counter suggestion?", "author": "steven-sheehy", "createdAt": "2020-12-03T17:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0NjY3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535446677", "bodyText": "Hardest part of coding.  Maybe RetryConfigurableConsensusMessageSubmitTransaction?", "author": "ijungmann", "createdAt": "2020-12-03T17:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NzUyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535467524", "bodyText": "Updated", "author": "steven-sheehy", "createdAt": "2020-12-03T18:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2ODk2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535368969", "bodyText": "nit: think we should set a max on message size?", "author": "Nana-EC", "createdAt": "2020-12-03T16:07:27Z", "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/consensus/ConsensusSubmitMessageTransactionSupplier.java", "diffHunk": "@@ -21,55 +21,72 @@\n  */\n \n import com.google.common.primitives.Longs;\n+import java.nio.charset.StandardCharsets;\n import java.security.SecureRandom;\n-import java.time.Instant;\n import javax.validation.constraints.Min;\n import javax.validation.constraints.NotBlank;\n import lombok.Data;\n-import org.apache.commons.lang3.RandomStringUtils;\n+import lombok.Getter;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n \n-import com.hedera.datagenerator.common.Utility;\n import com.hedera.datagenerator.sdk.supplier.TransactionSupplier;\n+import com.hedera.hashgraph.sdk.HederaThrowable;\n import com.hedera.hashgraph.sdk.consensus.ConsensusMessageSubmitTransaction;\n import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n \n @Data\n public class ConsensusSubmitMessageTransactionSupplier implements TransactionSupplier<ConsensusMessageSubmitTransaction> {\n \n-    private static final SecureRandom RANDOM = new SecureRandom();\n-\n     @Min(1)\n     private long maxTransactionFee = 1_000_000;\n \n     private String message = StringUtils.EMPTY;\n \n-    @Min(1)\n+    @Min(8)", "originalCommit": "d419f11ef05f813385d17d154fa251bb45efe0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2ODU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535468576", "bodyText": "Sure, I can add @Max(6144) but it won't be truly accurate since 6K is the max including the signatures and other metadata.", "author": "steven-sheehy", "createdAt": "2020-12-03T18:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2ODk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535377191", "bodyText": "q: Do you think the Node Properties would be better located in a config file for easier on the fly modifications should a need arise. That way no code hotfix is needed.\nAll be it I guess should that need arise you could temporarily use the OTHER network and configure it as needed even in the case of test/main/preview net.\nFigured might make it more flexible in config file than java file.", "author": "Nana-EC", "createdAt": "2020-12-03T16:17:45Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/HederaNetwork.java", "diffHunk": "@@ -65,7 +74,8 @@\n                 new NodeProperties(\"0.0.3\", \"0.testnet.hedera.com\"),\n                 new NodeProperties(\"0.0.4\", \"1.testnet.hedera.com\"),\n                 new NodeProperties(\"0.0.5\", \"2.testnet.hedera.com\"),\n-                new NodeProperties(\"0.0.6\", \"3.testnet.hedera.com\")\n+                new NodeProperties(\"0.0.6\", \"3.testnet.hedera.com\"),", "originalCommit": "d419f11ef05f813385d17d154fa251bb45efe0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MTE2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535471166", "bodyText": "I don't see how that can be done easily. I think the OTHER should suffice for these scenarios.", "author": "steven-sheehy", "createdAt": "2020-12-03T18:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NDI4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535484283", "bodyText": "Works for me", "author": "Nana-EC", "createdAt": "2020-12-03T18:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwNzc5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535407790", "bodyText": "nit: at most loads probably negligible but might be more accurate to get system mills at start of method and use here.\nJust removing the case of added time if this process is moving slow", "author": "Nana-EC", "createdAt": "2020-12-03T16:53:54Z", "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,205 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(METRIC_NAME)\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        String endpoint = monitorProperties.getMirrorNode().getGrpc().getEndpoint();\n+        log.info(\"Connecting to mirror node {}\", endpoint);\n+        this.mirrorClient = new MirrorClient(endpoint);\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        counter.incrementAndGet();\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        this.lastReceived = topicResponse;\n+        Long timestamp = Utility.getTimestamp(topicResponse.message);\n+\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;", "originalCommit": "d419f11ef05f813385d17d154fa251bb45efe0e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MTQ0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535471445", "bodyText": "Will move", "author": "steven-sheehy", "createdAt": "2020-12-03T18:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwNzc5MA=="}], "type": "inlineReview"}, {"oid": "58a208484d2f7414d930780efbb66ff6df27e150", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/58a208484d2f7414d930780efbb66ff6df27e150", "message": "Fix 404 not retrying\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-03T18:12:25Z", "type": "commit"}, {"oid": "ac1550ec3299ce340e84aaeea23f51719848b034", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ac1550ec3299ce340e84aaeea23f51719848b034", "message": "Review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-12-03T18:20:07Z", "type": "commit"}]}