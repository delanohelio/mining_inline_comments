{"pr_number": 469, "pr_title": "implement simplified dependency resolution process", "pr_createdAt": "2020-09-24T01:07:02Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469", "timeline": [{"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "message": "implement simplified dependency resolution process", "committedDate": "2020-09-24T00:55:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494565545", "bodyText": "Does customer need to explicitly specify LOCAL in versionRequirement?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T19:38:30Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494719938", "bodyText": "No, customer doesn't need to. We use LOCAL group for local development, the target components of LOCAL group mean they are local override, so keep using local available version.", "author": "wikimonkey", "createdAt": "2020-09-25T03:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494593627", "bodyText": "If other group contains a component that's not in the deployed group, will this be also marked as target?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T20:32:43Z", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMDY4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494720683", "bodyText": "Yes, the purpose of these piece of code is to retrieve the other groups' target components. They should be resolved (including their dependencies) and running on the device at the time.", "author": "wikimonkey", "createdAt": "2020-09-25T03:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494596439", "bodyText": "componentNameToVersionConstraints doesn't have the deployment doc added yet. Why can you resolve component dependencies here? What if the versionConstraints of a component in deployment doc is conflicting with other component version requirement?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T20:38:14Z", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());\n+                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n+                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n+                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n+                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n+                });\n+            }\n+        });\n+\n+        return targetComponents;\n+    }\n+\n+    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n+            Topics groupToTargetComponentDetails, String deploymentGroupName,\n+            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n+        Set<String> otherGroupTargetComponents =\n+                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n+                        componentNameToVersionConstraints);\n+        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n+                .log(\"Found the other group target components\");\n+        // populate other groups target components dependencies\n+        // retrieve only dependency active version, update version requirement map\n+        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n+        for (String targetComponent : otherGroupTargetComponents) {\n+            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager\n+                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n+        }", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721585", "bodyText": "For the other groups, their dependencies should already be resolved and running on the device. The purpose of this iteration is to 1) build component to version requirements map because current deploying group can have common dependencies with the other groups; 2) get the other groups' resolved version because dependency resolver is supposed to return the full list of components.", "author": "wikimonkey", "createdAt": "2020-09-25T03:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494608482", "bodyText": "Is this the entire recipe content string match? Will version check be simpler?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:02:11Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721884", "bodyText": "It needs to do content comparison because private registry name occlusion feature - private is same version as public, but private needs to replace public.", "author": "wikimonkey", "createdAt": "2020-09-25T03:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODEwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188106", "bodyText": "It also has the additional benefit (implicitly) to recover mutated/corrupted recipe...", "author": "leaf94", "createdAt": "2020-09-25T19:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3Mzc3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496173772", "bodyText": "I'd prefer jsonNode object comparison. But that can be implemented later", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494616018", "bodyText": "What is the sort based on?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:17:47Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722129", "bodyText": "based upon semver ordering implemented in Semver4j library which will ensure 1.10 > 1.9 :)", "author": "wikimonkey", "createdAt": "2020-09-25T03:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjYxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722610", "bodyText": "Default sort is ascending order, so the latest version would be last. Is that what you are expecting?", "author": "MikeDombo", "createdAt": "2020-09-25T03:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTIxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494725214", "bodyText": "I want descending order. I think you override ComponentIdentifier::compareTo method, so now it's sorted in descending order.", "author": "wikimonkey", "createdAt": "2020-09-25T03:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494618308", "bodyText": "Does it mean findComponentRecipeContent() can return file name instead of file content?", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:22:44Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -98,25 +98,27 @@ void savePackageRecipe(@NonNull ComponentIdentifier pkgId, String recipeContent)\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n+\n+        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjY0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722643", "bodyText": "As mentioned above, it needs content comparison to support name occlusion feature.", "author": "wikimonkey", "createdAt": "2020-09-25T03:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA=="}], "type": "inlineReview"}, {"oid": "bd0c9f52b230148c06d2149d0375fe53571ae582", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd0c9f52b230148c06d2149d0375fe53571ae582", "message": "add unit test", "committedDate": "2020-09-25T01:31:02Z", "type": "commit"}, {"oid": "09bed162541b080bc05499a93591aacf95475996", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09bed162541b080bc05499a93591aacf95475996", "message": "delete unused import", "committedDate": "2020-09-25T01:44:41Z", "type": "commit"}, {"oid": "5094d0c393254a8459ae93a87757d270885e2488", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5094d0c393254a8459ae93a87757d270885e2488", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-25T15:17:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495185930", "bodyText": "Just to point out that this changes from the existing behavior for \"currently running version will be retained\". The new behavior for currently running version might not be retained - depend on cloud's result. I think that's what we want (so that transitive dependencies could be auto bumped for newer version within the specified version range...) Just double check on this change of behavior", "author": "leaf94", "createdAt": "2020-09-25T19:20:13Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version", "originalCommit": "5094d0c393254a8459ae93a87757d270885e2488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODY4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188681", "bodyText": "yes, that is what we want. By launch, we have the process alway trying to update to the latest versions of dependencies. Next, we will consider adding options to let customer keep the existing running version.", "author": "wikimonkey", "createdAt": "2020-09-25T19:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495187171", "bodyText": "Sorry didn't thought about when looking at the code yesterday - should we just skip calling cloud if it's a builtin service?", "author": "leaf94", "createdAt": "2020-09-25T19:23:09Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());", "originalCommit": "5094d0c393254a8459ae93a87757d270885e2488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MDE4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495190180", "bodyText": "I am thinking if it has recipes in cloud, it could be updated.", "author": "wikimonkey", "createdAt": "2020-09-25T19:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ=="}], "type": "inlineReview"}, {"oid": "c44a1f8b48e45965706ad30f98ed5868f63c0fa8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c44a1f8b48e45965706ad30f98ed5868f63c0fa8", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-25T20:47:55Z", "type": "commit"}, {"oid": "c611c9d2024eee1a537f07ef1c5d9958c8910fed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c611c9d2024eee1a537f07ef1c5d9958c8910fed", "message": "add unit test", "committedDate": "2020-09-25T23:21:45Z", "type": "commit"}, {"oid": "8dd85e3a7afc8f7a535b17668e3ed27e7ad52bff", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8dd85e3a7afc8f7a535b17668e3ed27e7ad52bff", "message": "delete unused import", "committedDate": "2020-09-25T23:21:45Z", "type": "commit"}, {"oid": "96e3c70f5006fa479020762b658d791ec37798f6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/96e3c70f5006fa479020762b658d791ec37798f6", "message": "Publish as public component, Fix error in \"startup\" based service if it errors after RUNNING (#468)\n\n* Publish as public component\r\n\r\n* If startup script fails after reporting running, it should still go to error", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "774ba32205bc9725d8e2d5529fc55df22d80cf5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/774ba32205bc9725d8e2d5529fc55df22d80cf5b", "message": "Add TelemetryAgent service (#378)\n\n* Implemented emission, aggregation and publish of metrics.\r\n* Beta 1 metrics - System metrics , kernel component state metrics\r\n* Unit tests and Integration tests", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "d711cde65cfa02549389f2b5b3d046bbb8f7b837", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d711cde65cfa02549389f2b5b3d046bbb8f7b837", "message": "wait till the publish interval to check the periodic metrics future s\u2026 (#474)\n\n* wait till the publish interval to check the periodic metrics future status\r\n\r\n* assert non null on periodic metrics future", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "0d55c42a7e40480f0faa4d24acd0fa319692f1ce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0d55c42a7e40480f0faa4d24acd0fa319692f1ce", "message": "Remove \"generic\" type from map (#475)", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "3cc5e881acca9aaa135ec4db1410649aad228525", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc5e881acca9aaa135ec4db1410649aad228525", "message": "Adding retry for Iot Jobs subscriptions (#462)\n\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "94fe3529f87db39d36c826da61ca15750de857b8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94fe3529f87db39d36c826da61ca15750de857b8", "message": "getIotClient(awsRegion, stage, credentialsProvider) API (#470)\n\n* getIotClient(awsRegion, stage, credentialsProvider) API\r\n\r\n* region and docstring\r\n\r\n* common implementation for all getIotClient APIs\r\n\r\n* throw URISyntaxException\r\n\r\n* number of retries\r\n\r\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "3e2d9d286b48d968efbca9ae56b997cdf49220b4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3e2d9d286b48d968efbca9ae56b997cdf49220b4", "message": "Making cli_ipc_info readable only for the owner (#471)\n\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "18b7904347b848464573ddb81ed911532d74a55c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18b7904347b848464573ddb81ed911532d74a55c", "message": "Merge branch 'simplified_dependency_resolution' of https://github.com/aws/aws-greengrass-kernel into simplified_dependency_resolution", "committedDate": "2020-09-25T23:21:54Z", "type": "commit"}, {"oid": "0b3b197ca716307265a78cf6a5a6d86f49e5a83a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b3b197ca716307265a78cf6a5a6d86f49e5a83a", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T15:17:47Z", "type": "commit"}, {"oid": "c2ec3f7cd119b0a46270c643d5fe921695b981c2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2ec3f7cd119b0a46270c643d5fe921695b981c2", "message": "temporarily lower integ test coverage ratio since the new DR process is not integrated into deployment flow yet", "committedDate": "2020-09-28T17:30:57Z", "type": "commit"}, {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/83e74ad405a0794ef484e90b22bcac16dbf6f45b", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T17:31:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496120170", "bodyText": "Temporarily lower integration test coverage ratio since the new DR process is not integrated into the deployment workflow yet. Once switch to the new process, the coverage will be resumed.", "author": "wikimonkey", "createdAt": "2020-09-28T17:33:33Z", "path": "pom.xml", "diffHunk": "@@ -469,12 +469,12 @@\n                                         <limit>\n                                             <counter>INSTRUCTION</counter>\n                                             <value>COVEREDRATIO</value>\n-                                            <minimum>0.59</minimum>\n+                                            <minimum>0.58</minimum>", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f45d63b4c06e425bb8b231514a3570dc4ab3073", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1f45d63b4c06e425bb8b231514a3570dc4ab3073", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T19:17:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496174516", "bodyText": "NIT: add a comment. requirementMap is a groupId->requirement map", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:13:07Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjMxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186313", "bodyText": "will add", "author": "wikimonkey", "createdAt": "2020-09-28T19:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175466", "bodyText": "How is this different from findActiveAndSatisfiedPackageMetadata?", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:14:56Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTg3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496185878", "bodyText": "this returns component identifier, no need to read recipe from file. findActiveAndSatisfiedPackageMetadata  will be cleaned out once we made the switch.", "author": "wikimonkey", "createdAt": "2020-09-28T19:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MzE2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496193164", "bodyText": "Ok. you can add @deprecated on findActiveAndSatisfiedPackageMetadata later", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175906", "bodyText": "This can be in the platform resolver class. Also add a TODO to add osVersion", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:15:48Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -90,6 +101,42 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n         return ret;\n     }\n \n+    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n+    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n+    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n+                                             Map<String, Requirement> versionRequirements)\n+            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n+\n+        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n+                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjI0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186242", "bodyText": "I would rather keep it here because ComponentPlatform is GCS coral object. Will add comment.", "author": "wikimonkey", "createdAt": "2020-09-28T19:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg=="}], "type": "inlineReview"}, {"oid": "ae8b113b0716f9685260adce73f68035b45c20dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae8b113b0716f9685260adce73f68035b45c20dd", "message": "add comments", "committedDate": "2020-09-28T19:46:01Z", "type": "commit"}]}