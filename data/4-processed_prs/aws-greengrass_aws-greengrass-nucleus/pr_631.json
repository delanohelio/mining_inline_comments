{"pr_number": 631, "pr_title": "Add error handling & retry in ArtifactDownloader", "pr_createdAt": "2020-11-06T11:25:26Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631", "timeline": [{"oid": "9edc9504f97d0ff311f317d0b903744f244d9a85", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9edc9504f97d0ff311f317d0b903744f244d9a85", "message": "Add error handling & retry in ArtifactDownloader\n\n* ArtifactDownloader can resume downloading from disconnected network or partially downloaded file.\n* ArtifactDownloader now does retry when getting artifact info.\n* S3Downloader now checks retryable() in returned AWS client errors.\n* GreengrassRepositoryDownloader handles more HTTP response codes.\n\n* Refactor to move downloading&checksum logic into parent ArtifactDownloader class.\n* Refactor to make ArtifactDownloader non-singleton. Each download will generate a downloader object.\n* Add ArtifactDownloaderFactory\n* Add tests", "committedDate": "2020-11-06T18:59:06Z", "type": "commit"}, {"oid": "9edc9504f97d0ff311f317d0b903744f244d9a85", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9edc9504f97d0ff311f317d0b903744f244d9a85", "message": "Add error handling & retry in ArtifactDownloader\n\n* ArtifactDownloader can resume downloading from disconnected network or partially downloaded file.\n* ArtifactDownloader now does retry when getting artifact info.\n* S3Downloader now checks retryable() in returned AWS client errors.\n* GreengrassRepositoryDownloader handles more HTTP response codes.\n\n* Refactor to move downloading&checksum logic into parent ArtifactDownloader class.\n* Refactor to make ArtifactDownloader non-singleton. Each download will generate a downloader object.\n* Add ArtifactDownloaderFactory\n* Add tests", "committedDate": "2020-11-06T18:59:06Z", "type": "forcePushed"}, {"oid": "2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-06T19:51:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MTg1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r518971854", "bodyText": "Moved to ArtifactDownloaderTest", "author": "ShirleyZheng92", "createdAt": "2020-11-06T19:55:50Z", "path": "src/test/java/com/aws/greengrass/componentmanager/plugins/S3DownloaderTest.java", "diffHunk": "@@ -236,39 +154,20 @@ void GIVEN_s3_artifact_uri_WHEN_error_in_getting_from_s3_THEN_fail() throws Exce\n         Path testCache = ComponentTestResourceHelper.getPathForLocalTestCache();\n         try {\n             when(s3Client.getObject(any(GetObjectRequest.class))).thenThrow(S3Exception.class);\n+            when(s3Client.headObject(any(HeadObjectRequest.class))).thenReturn(HeadObjectResponse.builder()\n+                    .contentLength((long)100).build());\n \n             Path saveToPath = testCache.resolve(TEST_COMPONENT_NAME).resolve(TEST_COMPONENT_VERSION);\n             if (Files.notExists(saveToPath)) {\n                 Files.createDirectories(saveToPath);\n             }\n-            assertThrows(PackageDownloadException.class, () -> s3Downloader.downloadToPath(\n+            S3Downloader s3Downloader = new S3Downloader(s3SdkClientFactory,\n                     new ComponentIdentifier(TEST_COMPONENT_NAME, new Semver(TEST_COMPONENT_VERSION)),\n                     ComponentArtifact.builder().artifactUri(new URI(VALID_ARTIFACT_URI))\n                             .checksum(VALID_ARTIFACT_CHECKSUM).algorithm(VALID_ALGORITHM).build(),\n-                    saveToPath));\n-        } finally {\n-            ComponentTestResourceHelper.cleanDirectory(testCache);\n-        }\n-    }\n-\n-    @Test\n-    void GIVEN_s3_artifact_exists_WHEN_check_download_required_THEN_return_false() throws Exception {", "originalCommit": "2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MTkyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r518971921", "bodyText": "Moved to ArtifactDownloaderTest", "author": "ShirleyZheng92", "createdAt": "2020-11-06T19:56:01Z", "path": "src/test/java/com/aws/greengrass/componentmanager/plugins/S3DownloaderTest.java", "diffHunk": "@@ -132,102 +134,18 @@ void GIVEN_s3_artifact_uri_WHEN_download_to_path_THEN_succeed() throws Exception\n         }\n     }\n \n-    @Test\n-    void GIVEN_s3_artifact_uri_WHEN_download_recipe_with_no_checksum_specified_THEN_use_local() throws Exception {\n-        Path testCache = ComponentTestResourceHelper.getPathForLocalTestCache();\n-        try {\n-            Path saveToPath = testCache.resolve(TEST_COMPONENT_NAME).resolve(TEST_COMPONENT_VERSION);\n-            if (Files.notExists(saveToPath)) {\n-                Files.createDirectories(saveToPath);\n-            }\n-            Files.write(saveToPath.resolve(\"artifact.txt\"), Collections.singletonList(VALID_ARTIFACT_CONTENT),\n-                    StandardCharsets.UTF_8);\n-            s3Downloader.downloadToPath(\n-                    new ComponentIdentifier(TEST_COMPONENT_NAME, new Semver(TEST_COMPONENT_VERSION)),\n-                    ComponentArtifact.builder().artifactUri(new URI(VALID_ARTIFACT_URI)).build(),\n-                    saveToPath);\n-            verify(s3Client, never()).getObject(any(GetObjectRequest.class));\n-        } finally {\n-            ComponentTestResourceHelper.cleanDirectory(testCache);\n-        }\n-    }\n-\n     @Test\n     void GIVEN_s3_artifact_uri_WHEN_bad_uri_THEN_fail() throws Exception {\n         Path testCache = ComponentTestResourceHelper.getPathForLocalTestCache();\n         try {\n             Path saveToPath = testCache.resolve(TEST_COMPONENT_NAME).resolve(TEST_COMPONENT_VERSION);\n-            assertThrows(InvalidArtifactUriException.class, () -> s3Downloader.downloadToPath(\n-                    new ComponentIdentifier(TEST_COMPONENT_NAME, new Semver(TEST_COMPONENT_VERSION)),\n-                    ComponentArtifact.builder().artifactUri(new URI(INVALID_ARTIFACT_URI)).checksum( \"somechecksum\")\n-                        .algorithm(VALID_ALGORITHM).build(),\n-                    saveToPath));\n-        } finally {\n-            ComponentTestResourceHelper.cleanDirectory(testCache);\n-        }\n-    }\n-\n-    @Test\n-    void GIVEN_s3_artifact_uri_WHEN_bad_checksum_THEN_fail() throws Exception {", "originalCommit": "2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MjA0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r518972040", "bodyText": "Moved to ArtifactDownloaderTest", "author": "ShirleyZheng92", "createdAt": "2020-11-06T19:56:13Z", "path": "src/test/java/com/aws/greengrass/componentmanager/plugins/S3DownloaderTest.java", "diffHunk": "@@ -132,102 +134,18 @@ void GIVEN_s3_artifact_uri_WHEN_download_to_path_THEN_succeed() throws Exception\n         }\n     }\n \n-    @Test\n-    void GIVEN_s3_artifact_uri_WHEN_download_recipe_with_no_checksum_specified_THEN_use_local() throws Exception {", "originalCommit": "2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3MjUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r518972519", "bodyText": "Moved to ArtifactDownloaderFactoryTest", "author": "ShirleyZheng92", "createdAt": "2020-11-06T19:57:13Z", "path": "src/test/java/com/aws/greengrass/componentmanager/ComponentManagerTest.java", "diffHunk": "@@ -210,45 +192,6 @@ void GIVEN_artifact_from_gg_repo_WHEN_download_artifact_with_unarchive_THEN_call\n         assertEquals(\"binary1\", fileCaptor.getValue().getName());\n     }\n \n-    @Test\n-    void GIVEN_artifact_from_s3_WHEN_attempt_download_THEN_invoke_s3_downloader() throws Exception {", "originalCommit": "2b04bb246d0aecb27edc94d5a5f3f118e2ede23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17730671d2b1a37bd59307d11f88628864aff00d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17730671d2b1a37bd59307d11f88628864aff00d", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-09T11:18:59Z", "type": "commit"}, {"oid": "3f09fa225102e39f5b70fa4a1128f9664a3fe416", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3f09fa225102e39f5b70fa4a1128f9664a3fe416", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-09T11:22:25Z", "type": "forcePushed"}, {"oid": "3904289d16e68c60948458468c2a2352b3338155", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3904289d16e68c60948458468c2a2352b3338155", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-09T12:16:08Z", "type": "forcePushed"}, {"oid": "8c46e8b4c5b67efcd596fe63fd1f34c6cac87a3b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8c46e8b4c5b67efcd596fe63fd1f34c6cac87a3b", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-09T21:07:50Z", "type": "forcePushed"}, {"oid": "def821ca678f850e5c90953a25cd48ab641ba3c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/def821ca678f850e5c90953a25cd48ab641ba3c3", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-09T23:22:58Z", "type": "forcePushed"}, {"oid": "ba4a6a59a3a4018c2b350464d6866b0fd8fc79a9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba4a6a59a3a4018c2b350464d6866b0fd8fc79a9", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-10T20:08:40Z", "type": "commit"}, {"oid": "ba4a6a59a3a4018c2b350464d6866b0fd8fc79a9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba4a6a59a3a4018c2b350464d6866b0fd8fc79a9", "message": "Avoid using 'while true' in getting artifact info", "committedDate": "2020-11-10T20:08:40Z", "type": "forcePushed"}, {"oid": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2b35db3ff73cc7919a1748509e55d9c6a8054780", "message": "Merge branch 'master' of https://github.com/aws/aws-greengrass-kernel into downloader_retry", "committedDate": "2020-11-10T21:01:20Z", "type": "commit"}, {"oid": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2b35db3ff73cc7919a1748509e55d9c6a8054780", "message": "Merge branch 'master' of https://github.com/aws/aws-greengrass-kernel into downloader_retry", "committedDate": "2020-11-10T21:01:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjQyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520912426", "bodyText": "sketchy...\nIf the retries should be configurable, just make it configurable.", "author": "MikeDombo", "createdAt": "2020-11-10T22:23:45Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/BaseITCase.java", "diffHunk": "@@ -31,6 +34,14 @@\n \n     protected Path tempRootDir;\n \n+    @BeforeAll\n+    static void setupAll() throws NoSuchFieldException, IllegalAccessException {\n+        // in integ test, reduce the max retry number of artifact downloading since it's expected to fail.\n+        Field artifactDownloaderRetry = ArtifactDownloader.class.getDeclaredField(\"MAX_RETRY\");\n+        artifactDownloaderRetry.setAccessible(true);\n+        artifactDownloaderRetry.setInt(null, 1);", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMDY1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520930653", "bodyText": "So far I don't want it to be configurable", "author": "ShirleyZheng92", "createdAt": "2020-11-10T23:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4ODI4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521488286", "bodyText": "Why isn't configurable? If not, why not just exposed a setter? Reflection in unit tests seems a bad practice to me.", "author": "fengwang666", "createdAt": "2020-11-11T16:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMjQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTUzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520915534", "bodyText": "Algorithm missing from artifact", "author": "MikeDombo", "createdAt": "2020-11-10T22:30:21Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing in downloading.\"));", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520915717", "bodyText": "you can't just fail us here. This breaks local deployment doesn't it?", "author": "MikeDombo", "createdAt": "2020-11-10T22:30:45Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0MTc1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520941759", "bodyText": "shouldn't reach here. because componentManager will check downloadRequired() first", "author": "ShirleyZheng92", "createdAt": "2020-11-10T23:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNzk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520917993", "bodyText": "not sure about this whole offset business. Seems that you're trying to allow for partial downloads to resume?\nIf that's the case, then you should calculate the checksum after downloading so that you can be sure that the resuming actually worked and the download wasn't corrupt.", "author": "MikeDombo", "createdAt": "2020-11-10T22:35:52Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing in downloading.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getLocalFileName());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        if (Files.exists(saveToPath)) {", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0MzM2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520943368", "bodyText": "I calculate the checksum after downloading. part of the checksum is from reading exiting file, part of the checksum is from reading the InputStream from downloading (in downloadToFile() L153).", "author": "ShirleyZheng92", "createdAt": "2020-11-10T23:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTM2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520921360", "bodyText": "you can't do this, you need to provide somewhere in the string for that object to be converted to a string.", "author": "MikeDombo", "createdAt": "2020-11-10T22:43:23Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/S3Downloader.java", "diffHunk": "@@ -24,94 +22,70 @@\n import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n import software.amazon.awssdk.services.s3.model.S3Exception;\n \n-import java.io.File;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n import java.nio.file.Path;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import javax.inject.Inject;\n \n /**\n  * Downloads component artifacts from S3 bucket URI specified in the component recipe.\n  */\n public class S3Downloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(S3Downloader.class);\n     private static final Pattern S3_PATH_REGEX = Pattern.compile(\"s3:\\\\/\\\\/([^\\\\/]+)\\\\/(.*)\");\n     protected static final String REGION_EXPECTING_STRING = \"expecting '\";\n     private final S3Client s3Client;\n     private final S3SdkClientFactory s3ClientFactory;\n+    private final S3ObjectPath s3ObjectPath;\n \n     /**\n      * Constructor.\n      *\n      * @param clientFactory S3 client factory\n      */\n-    @Inject\n-    public S3Downloader(S3SdkClientFactory clientFactory) {\n-        super();\n-        this.s3Client = clientFactory.getS3Client();\n+    protected S3Downloader(S3SdkClientFactory clientFactory, ComponentIdentifier identifier, ComponentArtifact artifact,\n+                        Path artifactDir)\n+            throws InvalidArtifactUriException {\n+        super(identifier, artifact, artifactDir);\n         this.s3ClientFactory = clientFactory;\n+        this.s3Client = clientFactory.getS3Client();\n+        this.s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), identifier);\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws InvalidArtifactUriException, PackageDownloadException {\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n-        Path filePath = saveToPath.resolve(extractFileName(s3ObjectPath.key));\n-        return !artifactExistsAndChecksum(artifact, filePath);\n+    protected String getLocalFileNameNoRetry() {\n+        String objectKey = s3ObjectPath.key;\n+        String[] pathStrings = objectKey.split(\"/\");\n+        return pathStrings[pathStrings.length - 1];\n     }\n \n-    @SuppressWarnings({\"PMD.AvoidInstanceofChecksInCatchClause\"})\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     @Override\n-    public File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException {\n-\n-        logger.atInfo().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log();\n-\n-        // Parse artifact path\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n+    protected Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws PackageDownloadException, RetryableException {\n         String bucket = s3ObjectPath.bucket;\n         String key = s3ObjectPath.key;\n-\n-        InputStream artifactObject = null;\n         try {\n-            Path filePath = saveToPath.resolve(extractFileName(key));\n-            if (artifactExistsAndChecksum(artifact, filePath)) {\n-                logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n-                        .log(\"Artifact already exists, skipping download\");\n-            } else {\n-                artifactObject = getObject(bucket, key, artifact, componentIdentifier);\n-                checkIntegrityAndSaveToStore(artifactObject, artifact, componentIdentifier, filePath);\n-            }\n-            return filePath.toFile();\n-        } catch (PackageDownloadException e) {\n-            if (e instanceof ArtifactChecksumMismatchException || !saveToPath.resolve(extractFileName(key)).toFile()\n-                    .exists()) {\n-                throw e;\n-            }\n-            logger.atInfo(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri())\n-                    .log(\"Failed to download artifact, but found it locally, using that version\", e);\n-            return saveToPath.resolve(extractFileName(key)).toFile();\n-        } finally {\n-            if (artifactObject != null) {\n-                artifactObject.close();\n+            S3Client regionClient = getRegionClientForBucket(bucket);\n+            GetObjectRequest getObjectRequest = GetObjectRequest.builder().bucket(bucket).key(key)\n+                    .range(String.format(HTTP_RANGE_HEADER_FORMAT, start, end)).build();\n+            logger.info(\"getObjectRequest\", getObjectRequest);", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0MzQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520943459", "bodyText": "Ok", "author": "ShirleyZheng92", "createdAt": "2020-11-10T23:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTc4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r520921787", "bodyText": "add GGExtension", "author": "MikeDombo", "createdAt": "2020-11-10T22:44:25Z", "path": "src/test/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloaderTest.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager.plugins;\n+\n+import com.aws.greengrass.componentmanager.exceptions.ArtifactChecksumMismatchException;\n+import com.aws.greengrass.componentmanager.exceptions.PackageDownloadException;\n+import com.aws.greengrass.componentmanager.models.ComponentArtifact;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.util.Pair;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class ArtifactDownloaderTest {", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExNzg1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521117859", "bodyText": "Why do we have to use reflection like this? Can we avoid it?", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:15:01Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/BaseITCase.java", "diffHunk": "@@ -31,6 +34,14 @@\n \n     protected Path tempRootDir;\n \n+    @BeforeAll\n+    static void setupAll() throws NoSuchFieldException, IllegalAccessException {\n+        // in integ test, reduce the max retry number of artifact downloading since it's expected to fail.\n+        Field artifactDownloaderRetry = ArtifactDownloader.class.getDeclaredField(\"MAX_RETRY\");\n+        artifactDownloaderRetry.setAccessible(true);\n+        artifactDownloaderRetry.setInt(null, 1);", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1OTMzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521159338", "bodyText": "The hardcoded 5 times exponential backoff retry in artifactDownloader is causing some integ-test timing out. So far I don't want to expose the number of retry to customer", "author": "ShirleyZheng92", "createdAt": "2020-11-11T07:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExNzg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMTc1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521121756", "bodyText": "Why not move out the exception class?", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:29:34Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -123,45 +340,16 @@ private static boolean recipeHasDigest(ComponentArtifact artifact) {\n         return !Utils.isEmpty(artifact.getAlgorithm()) && !Utils.isEmpty(artifact.getChecksum());\n     }\n \n-    /**\n-     * Download an artifact from remote.\n-     *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of the directory to put the artifact file\n-     * @return file handle of the downloaded file\n-     * @throws IOException if I/O error occurred in network/disk\n-     * @throws PackageDownloadException if error occurred in download process\n-     * @throws InvalidArtifactUriException if given artifact URI has error\n-     */\n-    public abstract File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                        Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException;\n+    protected static class RetryableException extends Exception {\n+        static final long serialVersionUID = -3387516993124229948L;", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2ODI2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521168268", "bodyText": "Currently this class is not exposed to users/upper-stream classes. Are we expecting other cloud calls will throw retryable exceptions? If so I can move it out.", "author": "ShirleyZheng92", "createdAt": "2020-11-11T07:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMzgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521123824", "bodyText": "If this shouldn't happen, just remove this piece of code?", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:37:38Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing in downloading.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getLocalFileName());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // shouldn't happen, since corrupted files are deleted every time.\n+                logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // assume the file is from last download and try to continue download from this point.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                if (offset == artifactSize) {\n+                    // shouldn't happen, since ComponentManager already had downloadRequired() check.\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // shouldn't happen, since corrupted files are deleted every time.\n+                    logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2MDUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521160519", "bodyText": "It's possible that customer mess up with the downloaded files.", "author": "ShirleyZheng92", "createdAt": "2020-11-11T07:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMzgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNDMxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521124317", "bodyText": "Nit - if we're going to log, better emphasize on the important piece of information, that there was an existing file which was partially downloaded, so something like Found existing partially downloaded file with size {}, will continue downloading or something.", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:39:30Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing in downloading.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getLocalFileName());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // shouldn't happen, since corrupted files are deleted every time.\n+                logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // assume the file is from last download and try to continue download from this point.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                if (offset == artifactSize) {\n+                    // shouldn't happen, since ComponentManager already had downloadRequired() check.\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // shouldn't happen, since corrupted files are deleted every time.\n+                    logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {\n+                    logger.atInfo().log(\"Existing partially downloaded file has size {}\", offset);", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNTgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521125802", "bodyText": "Nit - could read better as runWithRetry", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:44:32Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,277 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing in downloading.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getLocalFileName());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // shouldn't happen, since corrupted files are deleted every time.\n+                logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // assume the file is from last download and try to continue download from this point.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                if (offset == artifactSize) {\n+                    // shouldn't happen, since ComponentManager already had downloadRequired() check.\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // shouldn't happen, since corrupted files are deleted every time.\n+                    logger.atWarn().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {\n+                    logger.atInfo().log(\"Existing partially downloaded file has size {}\", offset);\n+                }\n+            }\n+        }\n+\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            downloadToFile(artifactFile, offset, artifactSize, messageDigest);\n+        } catch (IOException e) {\n+            throw new PackageDownloadException(getErrorString(\"Unable to write to open file stream\"), e);\n+        }\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n+        }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n+    }\n+\n+    private void downloadToFile(OutputStream artifactFile, long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n+        InputStream artifactInputStream = null;\n+        Runnable cleanupRunnable = null;\n+        long offset = rangeStart;\n+        int retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+        while (true) {\n+            try {\n+                Pair<InputStream, Runnable> readInput = readWithRange(offset, rangeEnd - 1);\n+                artifactInputStream = readInput.getLeft();\n+                cleanupRunnable = readInput.getRight();\n+\n+                byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                int readBytes = artifactInputStream.read(buffer);\n+                while (readBytes > -1) {\n+                    offset += readBytes;\n+                    // Compute digest as well as write to the file path\n+                    messageDigest.update(buffer, 0, readBytes);\n+                    try {\n+                        artifactFile.write(buffer, 0, readBytes);\n+                    } catch (IOException e) {\n+                        throw new PackageDownloadException(\n+                                getErrorString(\"Fail to write to file\"), e);\n+                    }\n+                    // reset retryInterval\n+                    retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+\n+                    readBytes = artifactInputStream.read(buffer);\n+                }\n+                if (offset >= rangeEnd) {\n+                    break;\n+                }\n+            } catch (IOException | RetryableException e) {\n+                logger.atWarn().setCause(e).log(\"Error in downloading artifact, wait to retry.\");\n+                // backoff sleep retry\n+                try {\n+                    Thread.sleep(retryInteraval);\n+                    if (retryInteraval < MAX_RETRY_INTERVAL_MILLI) {\n+                        retryInteraval = retryInteraval * 2;\n+                    } else {\n+                        retryInteraval = MAX_RETRY_INTERVAL_MILLI;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    logger.atInfo().log(\"Interrupted while waiting to retry download\");\n+                    return;\n+                }\n+                continue;\n+            } finally {\n+                if (artifactInputStream != null) {\n+                    try {\n+                        artifactInputStream.close();\n+                    } catch (IOException e) {\n+                        logger.atWarn().setCause(e).log(\"Unable to close artifact download stream.\");\n+                    }\n+                }\n+                if (cleanupRunnable != null) {\n+                    cleanupRunnable.run();\n+                }\n+            }\n         }\n     }\n \n+    /**\n+     * Read the partial data given range.\n+     *\n+     * @param start                                         Range start index. INCLUSIVE.\n+     * @param end                                           Range end index. INCLUSIVE.\n+     * @return {@literal Pair<InputStream, Runnable>}     Runnable is the cleanup task to run\n+     *                                                      after finishing reading from inputStream.\n+     * @throws IOException IOException                      ArtifactDownloader will retry on IOException.\n+     * @throws PackageDownloadException PackageDownloadException\n+     */\n+    protected abstract Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws RetryableException, PackageDownloadException;\n+\n     /**\n      * Checks whether it is necessary to download the artifact or the existing file suffices.\n      *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of directory where the artifact is expected to exist\n      * @return true if download is necessary\n-     * @throws PackageDownloadException if error occurred in download process\n      * @throws InvalidArtifactUriException if given artifact URI has error\n      */\n-    public abstract boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                             Path saveToPath)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+    public boolean downloadRequired() {\n+        try {\n+            String filename = getLocalFileName();\n+            return !artifactExistsAndChecksum(artifact, artifactDir.resolve(filename));\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().setCause(e).log();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Get the artifact file.\n+     *\n+     * @return artifact file that was either downloaded or had been locally present\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public File getArtifactFile() throws PackageDownloadException {\n+        return artifactDir.resolve(getLocalFileName()).toFile();\n+    }\n+\n+    /**\n+     * Get the download size of the artifact file.\n+     *\n+     * @return size of the artifact in bytes\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public final Long getDownloadSize() throws PackageDownloadException {\n+        return runRetry(\"get-download-size\", this::getDownloadSizeNoRetry, MAX_RETRY);\n+    }\n+\n+    protected abstract Long getDownloadSizeNoRetry() throws PackageDownloadException, RetryableException;\n+\n+    protected String getLocalFileName() throws PackageDownloadException {\n+        return runRetry(\"get-local-file-name\", this::getLocalFileNameNoRetry, MAX_RETRY);\n+    }\n+\n+    protected abstract String getLocalFileNameNoRetry() throws PackageDownloadException, RetryableException;\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingGenericException\", \"PMD.AvoidRethrowingException\"})\n+    private <T> T runRetry(String taskDescription, CrashableSupplier<T, Exception> taskToRetry, int maxRetry)", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNzMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521127308", "bodyText": "Nit - why is this method called localFileName since this seems to be just filename in general that you use no matter if it's cloud or local deployment?", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:49:59Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/S3Downloader.java", "diffHunk": "@@ -24,94 +22,70 @@\n import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n import software.amazon.awssdk.services.s3.model.S3Exception;\n \n-import java.io.File;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n import java.nio.file.Path;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import javax.inject.Inject;\n \n /**\n  * Downloads component artifacts from S3 bucket URI specified in the component recipe.\n  */\n public class S3Downloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(S3Downloader.class);\n     private static final Pattern S3_PATH_REGEX = Pattern.compile(\"s3:\\\\/\\\\/([^\\\\/]+)\\\\/(.*)\");\n     protected static final String REGION_EXPECTING_STRING = \"expecting '\";\n     private final S3Client s3Client;\n     private final S3SdkClientFactory s3ClientFactory;\n+    private final S3ObjectPath s3ObjectPath;\n \n     /**\n      * Constructor.\n      *\n      * @param clientFactory S3 client factory\n      */\n-    @Inject\n-    public S3Downloader(S3SdkClientFactory clientFactory) {\n-        super();\n-        this.s3Client = clientFactory.getS3Client();\n+    protected S3Downloader(S3SdkClientFactory clientFactory, ComponentIdentifier identifier, ComponentArtifact artifact,\n+                        Path artifactDir)\n+            throws InvalidArtifactUriException {\n+        super(identifier, artifact, artifactDir);\n         this.s3ClientFactory = clientFactory;\n+        this.s3Client = clientFactory.getS3Client();\n+        this.s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), identifier);\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws InvalidArtifactUriException, PackageDownloadException {\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n-        Path filePath = saveToPath.resolve(extractFileName(s3ObjectPath.key));\n-        return !artifactExistsAndChecksum(artifact, filePath);\n+    protected String getLocalFileNameNoRetry() {", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2MzIyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521163222", "bodyText": "I call it localFileName()  since it seems to me that s3 and GG Artifact has different file name that's stored in cloud and downloaded to local. If GGRepoDownloader unifies the method to get artifact file name, I can get rid of this method and re-use getArtifactFile()", "author": "ShirleyZheng92", "createdAt": "2020-11-11T07:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTE1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521129156", "bodyText": "This shouldn't be needed, Michael had a PR some time ago to avoid cloud call, it got reverted later but it's still planned I think", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:56:27Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -13,176 +13,202 @@\n import com.aws.greengrass.componentmanager.exceptions.PackageDownloadException;\n import com.aws.greengrass.componentmanager.models.ComponentArtifact;\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Pair;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n import java.net.URL;\n import java.nio.file.Path;\n import javax.inject.Inject;\n \n public class GreengrassRepositoryDownloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n     private static final String HTTP_HEADER_CONTENT_DISPOSITION = \"Content-Disposition\";\n-    private static final String ARTIFACT_DOWNLOAD_EXCEPTION_PMS_FMT =\n-            \"Failed to download artifact %s for package %s-%s\";\n-    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n-    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n \n     private final AWSEvergreen evgCmsClient;\n+    private Long artifactSize = null;\n+    private String localFileName = null;\n \n     @Inject\n-    public GreengrassRepositoryDownloader(GreengrassComponentServiceClientFactory clientFactory) {\n-        super();\n+    protected GreengrassRepositoryDownloader(GreengrassComponentServiceClientFactory clientFactory,\n+                                          ComponentIdentifier identifier, ComponentArtifact artifact,\n+                                          Path artifactDir) {\n+        super(identifier, artifact, artifactDir);\n         this.evgCmsClient = clientFactory.getCmsClient();\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws PackageDownloadException {\n-        // GG_NEEDS_REVIEW: TODO can we simplify getting filename without network request\n-        try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection httpConn = connect(url);\n-            try {\n-                int responseCode = httpConn.getResponseCode();\n+    protected String getLocalFileNameNoRetry() throws PackageDownloadException, RetryableException {\n+        if (localFileName != null) {\n+            return localFileName;\n+        }\n+        retrieveArtifactInfo();\n+        return this.localFileName;\n+    }\n \n-                if (responseCode == HttpURLConnection.HTTP_OK) {\n-                    String disposition = httpConn.getHeaderField(HTTP_HEADER_CONTENT_DISPOSITION);\n-                    String filename = extractFilename(url, disposition);\n-                    return !artifactExistsAndChecksum(artifact, saveToPath.resolve(filename));\n-                }\n-            } finally {\n-                if (httpConn != null) {\n-                    httpConn.disconnect();\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new PackageDownloadException(\"Failed to check greengrass artifact\", e);\n-        } catch (PackageDownloadException e) {\n-            if (!saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile().exists()) {\n-                throw e;\n-            }\n-            logger.atInfo(\"download-required-from-greengrass-repo\")\n-                    .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                    .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n-                    .log(\"Failed to download artifact, but found it locally, using that version\", e);\n-            return false;\n+    @Override\n+    protected Long getDownloadSizeNoRetry() throws PackageDownloadException, RetryableException {\n+        if (artifactSize != null) {\n+            return artifactSize;\n         }\n-        return true;\n+        retrieveArtifactInfo();\n+        return artifactSize;\n     }\n \n     @Override\n-    public File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws IOException, PackageDownloadException {\n-        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\")\n-                .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri().toString()).log();\n+    public Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws PackageDownloadException, RetryableException {\n+        URL url = getArtifactDownloadURL(identifier, artifact.getArtifactUri().getSchemeSpecificPart());\n \n+        HttpURLConnection httpConn = null;\n+        int responseCode;\n         try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection httpConn = connect(url);\n+            httpConn = connect(url);\n+            httpConn.setRequestProperty(HTTP_RANGE_HEADER_KEY, String.format(HTTP_RANGE_HEADER_FORMAT, start, end));\n+            responseCode = httpConn.getResponseCode();\n+        } catch (IOException e) {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+            throw new RetryableException(\"error establish connect\", e);\n+        }\n \n+        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n             try {\n-                int responseCode = httpConn.getResponseCode();\n-\n-                if (responseCode == HttpURLConnection.HTTP_OK) {\n-                    String disposition = httpConn.getHeaderField(HTTP_HEADER_CONTENT_DISPOSITION);\n-                    String filename = extractFilename(url, disposition);\n-\n-                    try (InputStream inputStream = httpConn.getInputStream()) {\n-                        if (artifactExistsAndChecksum(artifact, saveToPath.resolve(filename))) {\n-                            logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n-                                    .log(\"Artifact already exists, skipping download\");\n-                        } else {\n-                            checkIntegrityAndSaveToStore(inputStream, artifact, componentIdentifier,\n-                                    saveToPath.resolve(filename));\n-                        }\n-                    }\n-                    return saveToPath.resolve(filename).toFile();\n-                }\n-                // TODO: [P41214764]: Handle all status codes in downloading greengrass: artifacts\n-            } finally {\n-                if (httpConn != null) {\n-                    httpConn.disconnect();\n-                }\n+                return new Pair<>(httpConn.getInputStream(), httpConn::disconnect);\n+            } catch (IOException e) {\n+                throw new RetryableException(\"Unable to get HTTP inputStream\", e);\n             }\n-        } catch (PackageDownloadException e) {\n-            if (!saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile().exists()) {\n-                throw e;\n+        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n+            // 200 means http connect returns all contents.\n+            InputStream inputStream;\n+            try {\n+                inputStream = httpConn.getInputStream();\n+            } catch (IOException e) {\n+                throw new RetryableException(\"Unable to get HTTP inputStream\", e);\n             }\n-            logger.atInfo(\"download-artifact-from-greengrass-repo\")\n-                    .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                    .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n-                    .log(\"Failed to download artifact, but found it locally, using that version\", e);\n-            // GG_NEEDS_REVIEW: TODO : In the download from cloud step we rely on the content-disposition header\n-            // to get the file name and that's the accurate name, but here we're only using the scheme specific part\n-            //  of the URI when we don't find the file in cloud, we need to follow up on what is the\n-            //  right way to get file name\n-            return saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile();\n-        }\n-        return null;\n-    }\n \n-    @Override\n-    public long getDownloadSize(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws PackageDownloadException {\n-        logger.atInfo().setEventType(\"get-download-size-from-greengrass-repo\")\n-                .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri().toString()).log();\n-\n-        try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection conn = connect(url);\n-            long length = conn.getContentLengthLong();\n-            if (length == -1) {\n-                throw new PackageDownloadException(\"Failed to get download size\");\n+            // try to discard the offset number of bytes\n+            long byteSkipped;\n+            try {\n+                byteSkipped = inputStream.skip(start);\n+            } catch (IOException e) {\n+                httpConn.disconnect();\n+                throw new RetryableException(\"Unable to get partial content\", e);\n             }\n-            return length;\n-        } catch (IOException e) {\n-            throw new PackageDownloadException(\"Failed to get download size\", e);\n+            // it's possible that the number of bytes skipped is less than declared.\n+            if (byteSkipped != start) {\n+                httpConn.disconnect();\n+                throw new RetryableException(\"Unable to get partial content\");\n+            }\n+            return new Pair<>(inputStream, httpConn::disconnect);\n+        } else if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {\n+            httpConn.disconnect();\n+            throw new RetryableException(\"HTTP Error: \" + responseCode);\n+        } else {\n+            httpConn.disconnect();\n+            throw new PackageDownloadException(\"Unable to download greengrass artifact. HTTP Error: \" + responseCode);\n         }\n     }\n \n     @Override\n-    public File getArtifactFile(Path artifactDir, ComponentArtifact artifact, ComponentIdentifier componentIdentifier) {\n+    public File getArtifactFile() {\n         // GG_NEEDS_REVIEW: TODO : In the download from cloud step we rely on the content-disposition header to get the\n         //  file name and that's the accurate name, but here we're only using the scheme specific part\n         //  of the URI when we don't find the file in cloud, we need to follow up on what is the\n         //  right way to get file name\n-        return artifactDir.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile();\n+        if (localFileName != null) {\n+            return artifactDir.resolve(localFileName).toFile();\n+        }\n+        try {\n+            return artifactDir.resolve(getLocalFileNameNoRetry()).toFile();\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().log(\"Error in getting file name from HTTP response,\"\n+                    + \" getting local file name from URI scheme specific part\", e);", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2MTY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521161667", "bodyText": "This would be nice. I was confused why there are two different ways to get local file name. If that's unified to avoid cloud calls, then this @OverRide getArtifactFile() and downloadRequired() will not be needed.", "author": "ShirleyZheng92", "createdAt": "2020-11-11T07:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4NjE1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521186152", "bodyText": "Added TODO", "author": "ShirleyZheng92", "createdAt": "2020-11-11T08:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyOTMwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521129304", "bodyText": "Same as above, this needs to go away", "author": "shaguptashaikh", "createdAt": "2020-11-11T05:56:55Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -13,176 +13,202 @@\n import com.aws.greengrass.componentmanager.exceptions.PackageDownloadException;\n import com.aws.greengrass.componentmanager.models.ComponentArtifact;\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Pair;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n import java.net.URL;\n import java.nio.file.Path;\n import javax.inject.Inject;\n \n public class GreengrassRepositoryDownloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n     private static final String HTTP_HEADER_CONTENT_DISPOSITION = \"Content-Disposition\";\n-    private static final String ARTIFACT_DOWNLOAD_EXCEPTION_PMS_FMT =\n-            \"Failed to download artifact %s for package %s-%s\";\n-    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n-    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n \n     private final AWSEvergreen evgCmsClient;\n+    private Long artifactSize = null;\n+    private String localFileName = null;\n \n     @Inject\n-    public GreengrassRepositoryDownloader(GreengrassComponentServiceClientFactory clientFactory) {\n-        super();\n+    protected GreengrassRepositoryDownloader(GreengrassComponentServiceClientFactory clientFactory,\n+                                          ComponentIdentifier identifier, ComponentArtifact artifact,\n+                                          Path artifactDir) {\n+        super(identifier, artifact, artifactDir);\n         this.evgCmsClient = clientFactory.getCmsClient();\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws PackageDownloadException {\n-        // GG_NEEDS_REVIEW: TODO can we simplify getting filename without network request\n-        try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection httpConn = connect(url);\n-            try {\n-                int responseCode = httpConn.getResponseCode();\n+    protected String getLocalFileNameNoRetry() throws PackageDownloadException, RetryableException {\n+        if (localFileName != null) {\n+            return localFileName;\n+        }\n+        retrieveArtifactInfo();\n+        return this.localFileName;\n+    }\n \n-                if (responseCode == HttpURLConnection.HTTP_OK) {\n-                    String disposition = httpConn.getHeaderField(HTTP_HEADER_CONTENT_DISPOSITION);\n-                    String filename = extractFilename(url, disposition);\n-                    return !artifactExistsAndChecksum(artifact, saveToPath.resolve(filename));\n-                }\n-            } finally {\n-                if (httpConn != null) {\n-                    httpConn.disconnect();\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new PackageDownloadException(\"Failed to check greengrass artifact\", e);\n-        } catch (PackageDownloadException e) {\n-            if (!saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile().exists()) {\n-                throw e;\n-            }\n-            logger.atInfo(\"download-required-from-greengrass-repo\")\n-                    .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                    .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n-                    .log(\"Failed to download artifact, but found it locally, using that version\", e);\n-            return false;\n+    @Override\n+    protected Long getDownloadSizeNoRetry() throws PackageDownloadException, RetryableException {\n+        if (artifactSize != null) {\n+            return artifactSize;\n         }\n-        return true;\n+        retrieveArtifactInfo();\n+        return artifactSize;\n     }\n \n     @Override\n-    public File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws IOException, PackageDownloadException {\n-        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\")\n-                .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri().toString()).log();\n+    public Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws PackageDownloadException, RetryableException {\n+        URL url = getArtifactDownloadURL(identifier, artifact.getArtifactUri().getSchemeSpecificPart());\n \n+        HttpURLConnection httpConn = null;\n+        int responseCode;\n         try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection httpConn = connect(url);\n+            httpConn = connect(url);\n+            httpConn.setRequestProperty(HTTP_RANGE_HEADER_KEY, String.format(HTTP_RANGE_HEADER_FORMAT, start, end));\n+            responseCode = httpConn.getResponseCode();\n+        } catch (IOException e) {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+            throw new RetryableException(\"error establish connect\", e);\n+        }\n \n+        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n             try {\n-                int responseCode = httpConn.getResponseCode();\n-\n-                if (responseCode == HttpURLConnection.HTTP_OK) {\n-                    String disposition = httpConn.getHeaderField(HTTP_HEADER_CONTENT_DISPOSITION);\n-                    String filename = extractFilename(url, disposition);\n-\n-                    try (InputStream inputStream = httpConn.getInputStream()) {\n-                        if (artifactExistsAndChecksum(artifact, saveToPath.resolve(filename))) {\n-                            logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n-                                    .log(\"Artifact already exists, skipping download\");\n-                        } else {\n-                            checkIntegrityAndSaveToStore(inputStream, artifact, componentIdentifier,\n-                                    saveToPath.resolve(filename));\n-                        }\n-                    }\n-                    return saveToPath.resolve(filename).toFile();\n-                }\n-                // TODO: [P41214764]: Handle all status codes in downloading greengrass: artifacts\n-            } finally {\n-                if (httpConn != null) {\n-                    httpConn.disconnect();\n-                }\n+                return new Pair<>(httpConn.getInputStream(), httpConn::disconnect);\n+            } catch (IOException e) {\n+                throw new RetryableException(\"Unable to get HTTP inputStream\", e);\n             }\n-        } catch (PackageDownloadException e) {\n-            if (!saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile().exists()) {\n-                throw e;\n+        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n+            // 200 means http connect returns all contents.\n+            InputStream inputStream;\n+            try {\n+                inputStream = httpConn.getInputStream();\n+            } catch (IOException e) {\n+                throw new RetryableException(\"Unable to get HTTP inputStream\", e);\n             }\n-            logger.atInfo(\"download-artifact-from-greengrass-repo\")\n-                    .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                    .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n-                    .log(\"Failed to download artifact, but found it locally, using that version\", e);\n-            // GG_NEEDS_REVIEW: TODO : In the download from cloud step we rely on the content-disposition header\n-            // to get the file name and that's the accurate name, but here we're only using the scheme specific part\n-            //  of the URI when we don't find the file in cloud, we need to follow up on what is the\n-            //  right way to get file name\n-            return saveToPath.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile();\n-        }\n-        return null;\n-    }\n \n-    @Override\n-    public long getDownloadSize(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws PackageDownloadException {\n-        logger.atInfo().setEventType(\"get-download-size-from-greengrass-repo\")\n-                .addKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, componentIdentifier)\n-                .addKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri().toString()).log();\n-\n-        try {\n-            String preSignedUrl =\n-                    getArtifactDownloadURL(componentIdentifier, artifact.getArtifactUri().getSchemeSpecificPart());\n-            URL url = new URL(preSignedUrl);\n-            HttpURLConnection conn = connect(url);\n-            long length = conn.getContentLengthLong();\n-            if (length == -1) {\n-                throw new PackageDownloadException(\"Failed to get download size\");\n+            // try to discard the offset number of bytes\n+            long byteSkipped;\n+            try {\n+                byteSkipped = inputStream.skip(start);\n+            } catch (IOException e) {\n+                httpConn.disconnect();\n+                throw new RetryableException(\"Unable to get partial content\", e);\n             }\n-            return length;\n-        } catch (IOException e) {\n-            throw new PackageDownloadException(\"Failed to get download size\", e);\n+            // it's possible that the number of bytes skipped is less than declared.\n+            if (byteSkipped != start) {\n+                httpConn.disconnect();\n+                throw new RetryableException(\"Unable to get partial content\");\n+            }\n+            return new Pair<>(inputStream, httpConn::disconnect);\n+        } else if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {\n+            httpConn.disconnect();\n+            throw new RetryableException(\"HTTP Error: \" + responseCode);\n+        } else {\n+            httpConn.disconnect();\n+            throw new PackageDownloadException(\"Unable to download greengrass artifact. HTTP Error: \" + responseCode);\n         }\n     }\n \n     @Override\n-    public File getArtifactFile(Path artifactDir, ComponentArtifact artifact, ComponentIdentifier componentIdentifier) {\n+    public File getArtifactFile() {\n         // GG_NEEDS_REVIEW: TODO : In the download from cloud step we rely on the content-disposition header to get the\n         //  file name and that's the accurate name, but here we're only using the scheme specific part\n         //  of the URI when we don't find the file in cloud, we need to follow up on what is the\n         //  right way to get file name\n-        return artifactDir.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile();\n+        if (localFileName != null) {\n+            return artifactDir.resolve(localFileName).toFile();\n+        }\n+        try {\n+            return artifactDir.resolve(getLocalFileNameNoRetry()).toFile();\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().log(\"Error in getting file name from HTTP response,\"\n+                    + \" getting local file name from URI scheme specific part\", e);\n+            localFileName = artifact.getArtifactUri().getSchemeSpecificPart();\n+            return artifactDir.resolve(localFileName).toFile();\n+        } catch (RetryableException e) {\n+            logger.atWarn().log(\"Error in getting file name from HTTP response: {},\"\n+                    + \" getting local file name from URI scheme specific part\", e.getMessage());\n+            return artifactDir.resolve(artifact.getArtifactUri().getSchemeSpecificPart()).toFile();\n+        }\n     }\n \n-    HttpURLConnection connect(URL url) throws IOException {\n-        return (HttpURLConnection) url.openConnection();\n+    @Override\n+    public boolean downloadRequired() {\n+        try {\n+            // Override parent's behavior of checking local file from getLocalFileName()\n+            // Since in GreengrassRepositoryDownloader, getLocalFileName() requires calling cloud and may\n+            // throw exception.", "originalCommit": "2b35db3ff73cc7919a1748509e55d9c6a8054780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ed8f6b0f0f6ca9041508ff1bdfd447c406c5abe6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ed8f6b0f0f6ca9041508ff1bdfd447c406c5abe6", "message": "Address comments", "committedDate": "2020-11-11T08:02:28Z", "type": "commit"}, {"oid": "1cb4f897c6535f2b7df3eb60dc381d240b382d61", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1cb4f897c6535f2b7df3eb60dc381d240b382d61", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-11T08:14:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwNTYxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521505615", "bodyText": "What happens if the network is completely off?", "author": "fengwang666", "createdAt": "2020-11-11T17:05:01Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,281 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                // If existing file is same size as defined in artifact, check checksum.\n+                if (offset == artifactSize) {\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // Normally shouldn't happen, corrupted files are deleted every time.\n+                    logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {\n+                    logger.atInfo().log(\"Found existing partially downloaded file with size {},\"\n+                            + \"will continue downloading\", offset);\n+                }\n+            }\n+        }\n+\n+        // resume downloading from the offset, and append to existing file\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            downloadToFile(artifactFile, offset, artifactSize, messageDigest);\n+        } catch (IOException e) {\n+            throw new PackageDownloadException(getErrorString(\"Unable to write to open file stream\"), e);\n+        }\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n+        }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n+    }\n+\n+    private void downloadToFile(OutputStream artifactFile, long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n+        InputStream artifactInputStream = null;\n+        Runnable cleanupRunnable = null;\n+        long offset = rangeStart;\n+        int retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+        while (true) {\n+            try {\n+                Pair<InputStream, Runnable> readInput = readWithRange(offset, rangeEnd - 1);\n+                artifactInputStream = readInput.getLeft();\n+                cleanupRunnable = readInput.getRight();\n+\n+                byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                int readBytes = artifactInputStream.read(buffer);\n+                while (readBytes > -1) {\n+                    offset += readBytes;\n+                    // Compute digest as well as write to the file path\n+                    messageDigest.update(buffer, 0, readBytes);\n+                    try {\n+                        artifactFile.write(buffer, 0, readBytes);\n+                    } catch (IOException e) {\n+                        throw new PackageDownloadException(\n+                                getErrorString(\"Fail to write to file\"), e);\n+                    }\n+                    // reset retryInterval if download succeeded\n+                    retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+\n+                    readBytes = artifactInputStream.read(buffer);\n+                }\n+                if (offset >= rangeEnd) {\n+                    break;\n+                }\n+            } catch (IOException | RetryableException e) {\n+                logger.atWarn().setCause(e).log(\"Error in downloading artifact, wait to retry.\");\n+                // backoff sleep retry\n+                try {\n+                    Thread.sleep(retryInteraval);\n+                    if (retryInteraval < MAX_RETRY_INTERVAL_MILLI) {\n+                        retryInteraval = retryInteraval * 2;\n+                    } else {\n+                        retryInteraval = MAX_RETRY_INTERVAL_MILLI;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    logger.atInfo().log(\"Interrupted while waiting to retry download\");\n+                    return;\n+                }\n+                continue;\n+            } finally {\n+                if (artifactInputStream != null) {\n+                    try {\n+                        artifactInputStream.close();\n+                    } catch (IOException e) {\n+                        logger.atWarn().setCause(e).log(\"Unable to close artifact download stream.\");\n+                    }\n+                }\n+                if (cleanupRunnable != null) {\n+                    cleanupRunnable.run();\n+                }\n+            }\n         }\n     }\n \n+    /**\n+     * Read the partial data given range.\n+     *\n+     * @param start                                         Range start index. INCLUSIVE.\n+     * @param end                                           Range end index. INCLUSIVE.\n+     * @return {@literal Pair<InputStream, Runnable>}     Runnable is the cleanup task to run\n+     *                                                      after finishing reading from inputStream.\n+     * @throws IOException IOException                      ArtifactDownloader will retry on IOException.\n+     * @throws PackageDownloadException PackageDownloadException\n+     */\n+    protected abstract Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws RetryableException, PackageDownloadException;\n+\n     /**\n      * Checks whether it is necessary to download the artifact or the existing file suffices.\n      *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of directory where the artifact is expected to exist\n      * @return true if download is necessary\n-     * @throws PackageDownloadException if error occurred in download process\n      * @throws InvalidArtifactUriException if given artifact URI has error\n      */\n-    public abstract boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                             Path saveToPath)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+    public boolean downloadRequired() {\n+        try {\n+            String filename = getArtifactFilename();\n+            return !artifactExistsAndChecksum(artifact, artifactDir.resolve(filename));\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().setCause(e).log();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Get the artifact file.\n+     *\n+     * @return artifact file that was either downloaded or had been locally present\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public File getArtifactFile() throws PackageDownloadException {\n+        return artifactDir.resolve(getArtifactFilename()).toFile();\n+    }\n+\n+    /**\n+     * Get the download size of the artifact file.\n+     *\n+     * @return size of the artifact in bytes\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public final Long getDownloadSize() throws PackageDownloadException {\n+        return runWithRetry(\"get-download-size\", this::getDownloadSizeNoRetry, MAX_RETRY);\n+    }\n+\n+    protected abstract Long getDownloadSizeNoRetry() throws PackageDownloadException, RetryableException;\n+\n+    protected String getArtifactFilename() throws PackageDownloadException {\n+        return runWithRetry(\"get-artifact-file-name\", this::getArtifactFilenameNoRetry, MAX_RETRY);\n+    }\n+\n+    protected abstract String getArtifactFilenameNoRetry() throws PackageDownloadException, RetryableException;\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingGenericException\", \"PMD.AvoidRethrowingException\"})\n+    private <T> T runWithRetry(String taskDescription, CrashableSupplier<T, Exception> taskToRetry, int maxRetry)", "originalCommit": "1cb4f897c6535f2b7df3eb60dc381d240b382d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NjIzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521566237", "bodyText": "It will fail after max retry", "author": "ShirleyZheng92", "createdAt": "2020-11-11T18:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwNTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxMDE4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521510183", "bodyText": "Both getDownloadSizeNoRetry and getArtifactFilenameNoRetry use standard AWS SDK, which already has built-in retry logic. Why not just configure the SDK to retry?", "author": "fengwang666", "createdAt": "2020-11-11T17:12:26Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +22,281 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    private static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    private static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n+    private static int MAX_RETRY = 5;\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                // If existing file is same size as defined in artifact, check checksum.\n+                if (offset == artifactSize) {\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // Normally shouldn't happen, corrupted files are deleted every time.\n+                    logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {\n+                    logger.atInfo().log(\"Found existing partially downloaded file with size {},\"\n+                            + \"will continue downloading\", offset);\n+                }\n+            }\n+        }\n+\n+        // resume downloading from the offset, and append to existing file\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            downloadToFile(artifactFile, offset, artifactSize, messageDigest);\n+        } catch (IOException e) {\n+            throw new PackageDownloadException(getErrorString(\"Unable to write to open file stream\"), e);\n+        }\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n+        }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n+    }\n+\n+    private void downloadToFile(OutputStream artifactFile, long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n+        InputStream artifactInputStream = null;\n+        Runnable cleanupRunnable = null;\n+        long offset = rangeStart;\n+        int retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+        while (true) {\n+            try {\n+                Pair<InputStream, Runnable> readInput = readWithRange(offset, rangeEnd - 1);\n+                artifactInputStream = readInput.getLeft();\n+                cleanupRunnable = readInput.getRight();\n+\n+                byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                int readBytes = artifactInputStream.read(buffer);\n+                while (readBytes > -1) {\n+                    offset += readBytes;\n+                    // Compute digest as well as write to the file path\n+                    messageDigest.update(buffer, 0, readBytes);\n+                    try {\n+                        artifactFile.write(buffer, 0, readBytes);\n+                    } catch (IOException e) {\n+                        throw new PackageDownloadException(\n+                                getErrorString(\"Fail to write to file\"), e);\n+                    }\n+                    // reset retryInterval if download succeeded\n+                    retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+\n+                    readBytes = artifactInputStream.read(buffer);\n+                }\n+                if (offset >= rangeEnd) {\n+                    break;\n+                }\n+            } catch (IOException | RetryableException e) {\n+                logger.atWarn().setCause(e).log(\"Error in downloading artifact, wait to retry.\");\n+                // backoff sleep retry\n+                try {\n+                    Thread.sleep(retryInteraval);\n+                    if (retryInteraval < MAX_RETRY_INTERVAL_MILLI) {\n+                        retryInteraval = retryInteraval * 2;\n+                    } else {\n+                        retryInteraval = MAX_RETRY_INTERVAL_MILLI;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    logger.atInfo().log(\"Interrupted while waiting to retry download\");\n+                    return;\n+                }\n+                continue;\n+            } finally {\n+                if (artifactInputStream != null) {\n+                    try {\n+                        artifactInputStream.close();\n+                    } catch (IOException e) {\n+                        logger.atWarn().setCause(e).log(\"Unable to close artifact download stream.\");\n+                    }\n+                }\n+                if (cleanupRunnable != null) {\n+                    cleanupRunnable.run();\n+                }\n+            }\n         }\n     }\n \n+    /**\n+     * Read the partial data given range.\n+     *\n+     * @param start                                         Range start index. INCLUSIVE.\n+     * @param end                                           Range end index. INCLUSIVE.\n+     * @return {@literal Pair<InputStream, Runnable>}     Runnable is the cleanup task to run\n+     *                                                      after finishing reading from inputStream.\n+     * @throws IOException IOException                      ArtifactDownloader will retry on IOException.\n+     * @throws PackageDownloadException PackageDownloadException\n+     */\n+    protected abstract Pair<InputStream, Runnable> readWithRange(long start, long end)\n+            throws RetryableException, PackageDownloadException;\n+\n     /**\n      * Checks whether it is necessary to download the artifact or the existing file suffices.\n      *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of directory where the artifact is expected to exist\n      * @return true if download is necessary\n-     * @throws PackageDownloadException if error occurred in download process\n      * @throws InvalidArtifactUriException if given artifact URI has error\n      */\n-    public abstract boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                             Path saveToPath)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+    public boolean downloadRequired() {\n+        try {\n+            String filename = getArtifactFilename();\n+            return !artifactExistsAndChecksum(artifact, artifactDir.resolve(filename));\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().setCause(e).log();\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Get the artifact file.\n+     *\n+     * @return artifact file that was either downloaded or had been locally present\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public File getArtifactFile() throws PackageDownloadException {\n+        return artifactDir.resolve(getArtifactFilename()).toFile();\n+    }\n+\n+    /**\n+     * Get the download size of the artifact file.\n+     *\n+     * @return size of the artifact in bytes\n+     * @throws InvalidArtifactUriException if provided info results in invalid URI\n+     * @throws PackageDownloadException if error encountered\n+     */\n+    public final Long getDownloadSize() throws PackageDownloadException {\n+        return runWithRetry(\"get-download-size\", this::getDownloadSizeNoRetry, MAX_RETRY);", "originalCommit": "1cb4f897c6535f2b7df3eb60dc381d240b382d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NjQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521566439", "bodyText": "I don't like the idea of building retry logic on top of our own business logic methods. It produces nested retries, which can cause retry storm that is unfriendly to our AWS cloud services. It also makes the code difficult to read. Instead, retry should be as close to the client as possible. If we're using AWS client, we can just configure the retry logic, if we're using raw HTTP client, then let's add a retry layer on the raw HTTP client.\n\nI'll update the implementation", "author": "ShirleyZheng92", "createdAt": "2020-11-11T18:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxMDE4Mw=="}], "type": "inlineReview"}, {"oid": "2955ab8f0037442c19f1919cde5b9b2a95c69ba5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2955ab8f0037442c19f1919cde5b9b2a95c69ba5", "message": "Merge remote-tracking branch 'origin/master' into downloader_retry", "committedDate": "2020-11-11T21:16:05Z", "type": "commit"}, {"oid": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aed6624b4016350bd51474463c58c9ae6f0dc24c", "message": "Address comments. Move retry logic to client side", "committedDate": "2020-11-11T22:12:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2MzM5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521863392", "bodyText": "log the expected file size and actual file size.", "author": "fengwang666", "createdAt": "2020-11-12T06:18:58Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,238 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");", "originalCommit": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2MzY1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521863651", "bodyText": "Refactor this to its own method", "author": "fengwang666", "createdAt": "2020-11-12T06:19:44Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,238 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }", "originalCommit": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2OTI0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521869248", "bodyText": "hmmm....resetting offset and messageDigest makes this code fragile and hard to read. The flow of the code can be organized better as well. The whole block from line82 to line125 can be refactored like this:\noffset = Files.size(saveToPath);\nmessageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\nif (offset > artifactSize) {\n    deleteFile();\n    downloadToFile(artifactFile, 0, artifactSize, messageDigest);\n} else {\n    // calculate the digest from the existing file\n    updateExistingDigest(offset, messageDigest);\n   // downloadToFile should handle the case when offset equals to the file size (just return)\n   downloadToFile(artifactFile, offset, artifactSize, messageDigest);\n}\n\nIsn't this much simpler?", "author": "fengwang666", "createdAt": "2020-11-12T06:36:57Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,238 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                // If existing file is same size as defined in artifact, check checksum.\n+                if (offset == artifactSize) {\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // Normally shouldn't happen, corrupted files are deleted every time.\n+                    logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();", "originalCommit": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2OTcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521869704", "bodyText": "This is duplicate logic to line 130. may as well just have one place to delete corrupted/unmatch files.", "author": "fengwang666", "createdAt": "2020-11-12T06:38:29Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,238 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                // If existing file is same size as defined in artifact, check checksum.\n+                if (offset == artifactSize) {\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // Normally shouldn't happen, corrupted files are deleted every time.\n+                    logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);", "originalCommit": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2OTk2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r521869962", "bodyText": "Have you considered to refactor this to a utility class? Then it's also easier to write unit tests.", "author": "fengwang666", "createdAt": "2020-11-12T06:39:02Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,238 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            offset = Files.size(saveToPath);\n+            if (offset > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                Files.deleteIfExists(saveToPath);\n+                offset = 0;\n+            } else {\n+                // Updating checksum digest with the bytes in existing file.\n+                try (InputStream existingArtifact = Files.newInputStream(saveToPath)) {\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = existingArtifact.read(buffer);\n+                    while (readBytes > -1) {\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        readBytes = existingArtifact.read(buffer);\n+                    }\n+                }\n+\n+                // If existing file is same size as defined in artifact, check checksum.\n+                if (offset == artifactSize) {\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (digest.equals(artifact.getChecksum())) {\n+                        logger.atDebug().log(\"Artifacts already downloaded\");\n+                        return saveToPath.toFile();\n+                    }\n+\n+                    // Normally shouldn't happen, corrupted files are deleted every time.\n+                    logger.atError().log(\"existing file corrupted. Removing and retry download.\");\n+                    Files.deleteIfExists(saveToPath);\n+                    offset = 0;\n+                    messageDigest.reset();\n+                } else {\n+                    logger.atInfo().log(\"Found existing partially downloaded file with size {},\"\n+                            + \"will continue downloading\", offset);\n+                }\n+            }\n+        }\n+\n+        // resume downloading from the offset, and append to existing file\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            downloadToFile(artifactFile, offset, artifactSize, messageDigest);\n+        } catch (IOException e) {\n+            throw new PackageDownloadException(getErrorString(\"Unable to write to open file stream\"), e);\n+        }\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n+        }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n+    }\n+\n+    private void downloadToFile(OutputStream artifactFile, long rangeStart, long rangeEnd, MessageDigest messageDigest)", "originalCommit": "aed6624b4016350bd51474463c58c9ae6f0dc24c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDEwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522330100", "bodyText": "I don't think so. It's kind of hard since readWithRange() is an abstract method to be implemented by subclasses.", "author": "ShirleyZheng92", "createdAt": "2020-11-12T18:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2OTk2Mg=="}], "type": "inlineReview"}, {"oid": "644ec530794d957b2cfb74e7c46053b15ca911cd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/644ec530794d957b2cfb74e7c46053b15ca911cd", "message": "Address comments", "committedDate": "2020-11-12T20:35:26Z", "type": "commit"}, {"oid": "c35bbffa4b7e1cca2764d2bcdfbe61bba3d24776", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c35bbffa4b7e1cca2764d2bcdfbe61bba3d24776", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-12T20:38:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5Nzg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522497865", "bodyText": "hmmmm...throwing this exception up here is questionable. What do we expect the customers to respond to this? Is this considered a user error that customers need to take action? Since our cloud service generates the digest from the artifact, most likely the exception is due to file corruption that happens on the device. I think we should retry on this.", "author": "fengwang666", "createdAt": "2020-11-12T23:22:17Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,214 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset = Files.size(saveToPath);\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        downloadToFile(saveToPath, offset, artifactSize, messageDigest);\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n         }", "originalCommit": "c35bbffa4b7e1cca2764d2bcdfbe61bba3d24776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYzNTA2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522635064", "bodyText": "Updated", "author": "ShirleyZheng92", "createdAt": "2020-11-13T04:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5Nzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwMjUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522502539", "bodyText": "Why is there an infinite loop here? Isn' there retry in the readWithRange already? Even if we want to handle the network disconnect case, shouldn't that be within readWithRange as readWithRange is the method that does the download.", "author": "fengwang666", "createdAt": "2020-11-12T23:30:01Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,214 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset = Files.size(saveToPath);\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        downloadToFile(saveToPath, offset, artifactSize, messageDigest);\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n         }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n     }\n \n+    private void downloadToFile(Path saveToPath, long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n+        if (rangeStart >= rangeEnd) {\n+            return;\n+        }\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            InputStream artifactInputStream = null;\n+            Runnable cleanupRunnable = null;\n+            long offset = rangeStart;\n+            int retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+            while (true) {", "originalCommit": "c35bbffa4b7e1cca2764d2bcdfbe61bba3d24776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjQ3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522506474", "bodyText": "I don't like this method return an InputStream. It breaks the logic of download to two parts. Now you need to handle retry on both places. Can we just merge them into one method and have a separate implementation for each downloader? Then we can see what are the common code that can be extracted out.", "author": "fengwang666", "createdAt": "2020-11-12T23:37:04Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -20,62 +21,214 @@\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n \n public abstract class ArtifactDownloader {\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n-            while (readBytes > -1) {\n-                // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n-                artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n-            }\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n \n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws InvalidArtifactUriException if given artifact URI has error\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n                 throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n         } catch (NoSuchAlgorithmException e) {\n             throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        Path saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        long offset = 0;\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset = Files.size(saveToPath);\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        downloadToFile(saveToPath, offset, artifactSize, messageDigest);\n+\n+        String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+        if (!digest.equals(artifact.getChecksum())) {\n+            // Handle failure in integrity check, delete bad file then throw\n+            Files.deleteIfExists(saveToPath);\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Integrity check for downloaded artifact failed\"));\n         }\n+        logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+        return saveToPath.toFile();\n     }\n \n+    private void downloadToFile(Path saveToPath, long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n+        if (rangeStart >= rangeEnd) {\n+            return;\n+        }\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n+            InputStream artifactInputStream = null;\n+            Runnable cleanupRunnable = null;\n+            long offset = rangeStart;\n+            int retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+            while (true) {\n+                try {\n+                    Pair<InputStream, Runnable> readInput = readWithRange(offset, rangeEnd - 1);\n+                    artifactInputStream = readInput.getLeft();\n+                    cleanupRunnable = readInput.getRight();\n+\n+                    byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n+                    int readBytes = artifactInputStream.read(buffer);\n+                    while (readBytes > -1) {\n+                        offset += readBytes;\n+                        // Compute digest as well as write to the file path\n+                        messageDigest.update(buffer, 0, readBytes);\n+                        try {\n+                            artifactFile.write(buffer, 0, readBytes);\n+                        } catch (IOException e) {\n+                            throw new PackageDownloadException(\n+                                    getErrorString(\"Fail to write to file\"), e);\n+                        }\n+                        // reset retryInterval if download succeeded\n+                        retryInteraval = INIT_RETRY_INTERVAL_MILLI;\n+\n+                        readBytes = artifactInputStream.read(buffer);\n+                    }\n+                    if (offset >= rangeEnd) {\n+                        break;\n+                    }\n+                } catch (IOException e) {\n+                    logger.atWarn().setCause(e).log(\"Error in downloading artifact, wait to retry.\");\n+                    // backoff sleep retry\n+                    try {\n+                        Thread.sleep(retryInteraval);\n+                        if (retryInteraval < MAX_RETRY_INTERVAL_MILLI) {\n+                            retryInteraval = retryInteraval * 2;\n+                        } else {\n+                            retryInteraval = MAX_RETRY_INTERVAL_MILLI;\n+                        }\n+                    } catch (InterruptedException ie) {\n+                        logger.atInfo().log(\"Interrupted while waiting to retry download\");\n+                        return;\n+                    }\n+                    continue;\n+                } finally {\n+                    if (artifactInputStream != null) {\n+                        try {\n+                            artifactInputStream.close();\n+                        } catch (IOException e) {\n+                            logger.atWarn().setCause(e).log(\"Unable to close artifact download stream.\");\n+                        }\n+                    }\n+                    if (cleanupRunnable != null) {\n+                        cleanupRunnable.run();\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new PackageDownloadException(getErrorString(\"Unable to write to open file stream\"), e);\n+        }\n+    }\n+\n+    /**\n+     * Read the partial data given range.\n+     *\n+     * @param start                                         Range start index. INCLUSIVE.\n+     * @param end                                           Range end index. INCLUSIVE.\n+     * @return {@literal Pair<InputStream, Runnable>}     Runnable is the cleanup task to run\n+     *                                                      after finishing reading from inputStream.\n+     * @throws IOException IOException                      ArtifactDownloader will retry on IOException.\n+     * @throws PackageDownloadException PackageDownloadException\n+     */\n+    protected abstract Pair<InputStream, Runnable> readWithRange(long start, long end)", "originalCommit": "c35bbffa4b7e1cca2764d2bcdfbe61bba3d24776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYzNTE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r522635196", "bodyText": "Updated", "author": "ShirleyZheng92", "createdAt": "2020-11-13T04:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjQ3NA=="}], "type": "inlineReview"}, {"oid": "05b3cb0abae14881a02fba2371099baeb0c7b96f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/05b3cb0abae14881a02fba2371099baeb0c7b96f", "message": "Refactor and address comments", "committedDate": "2020-11-13T04:32:48Z", "type": "commit"}, {"oid": "104f44d334d444c71da8c33dcd0699d4e00ce7ec", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/104f44d334d444c71da8c33dcd0699d4e00ce7ec", "message": "Merge branch 'master' of https://github.com/aws/aws-greengrass-kernel into downloader_retry", "committedDate": "2020-11-13T05:52:37Z", "type": "commit"}, {"oid": "b0114ae9fc48dddacae0da41574753a634d50df0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0114ae9fc48dddacae0da41574753a634d50df0", "message": "fix tests", "committedDate": "2020-11-13T06:42:48Z", "type": "commit"}, {"oid": "5821c6e711526900255fdd9283e11cd8fc1b2111", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5821c6e711526900255fdd9283e11cd8fc1b2111", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-13T07:28:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzMTY5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523131697", "bodyText": "this isn't threadsafe if we download in parallel at all, the kvs would be mismatched", "author": "MikeDombo", "createdAt": "2020-11-13T18:05:09Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzMjQ1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523132450", "bodyText": "Removing and retrying download", "author": "MikeDombo", "createdAt": "2020-11-13T18:06:36Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws ArtifactChecksumMismatchException if given artifact checksum algorithm isn't supported.\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n+                throw new ArtifactChecksumMismatchException(\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n+            }\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        final AtomicLong offset = new AtomicLong(0);\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzMzYwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523133602", "bodyText": "add context (a message) to this error log", "author": "MikeDombo", "createdAt": "2020-11-13T18:09:00Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws ArtifactChecksumMismatchException if given artifact checksum algorithm isn't supported.\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n+                throw new ArtifactChecksumMismatchException(\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n+            }\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        final AtomicLong offset = new AtomicLong(0);\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset.set(Files.size(saveToPath));\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        return runWithRetry(\"download-artifact\", 3,\n+                Collections.singletonList(ArtifactChecksumMismatchException.class),\n+                () -> {\n+                    while (offset.get() < artifactSize) {\n+                        long downloadedBytes = download(offset.get(), artifactSize - 1, messageDigest);\n+                        offset.addAndGet(downloadedBytes);\n+                    }\n+\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (!digest.equals(artifact.getChecksum())) {\n+                        // Handle failure in integrity check, delete bad file then throw\n+                        Files.deleteIfExists(saveToPath);\n+                        offset.set(0);\n+                        messageDigest.reset();\n+                        throw new ArtifactChecksumMismatchException(\"Integrity check for downloaded artifact failed. \"\n+                                + \"Probably due to file corruption.\");\n+                    }\n+                    logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+                    return saveToPath.toFile();\n+                });\n+    }\n+\n+    /**\n+     * Internal helper method to download from input stream.\n+     * If IOException is thrown during the process, the method will return actual number of bytes downloaded.\n+     * Supposed to be invoked in `protected abstract long download(long rangeStart, long rangeEnd)`\n+     * @param inputStream inputStream to download from.\n+     * @param messageDigest messageDigest to update.\n+     * @return number of bytes downloaded.\n+     */\n+    protected long download(InputStream inputStream, MessageDigest messageDigest) {\n+        long totalReadBytes = 0;\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                    StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n             byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n+            int readBytes = inputStream.read(buffer);\n             while (readBytes > -1) {\n                 // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n                 artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n+                messageDigest.update(buffer, 0, readBytes);\n+                totalReadBytes += readBytes;\n+                readBytes = inputStream.read(buffer);\n             }\n-\n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n-                throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+            return totalReadBytes;\n+        } catch (IOException e) {\n+            return totalReadBytes;\n+        } finally {\n+            try {\n+                inputStream.close();\n+            } catch (IOException e) {\n+                logger.atWarn().setCause(e).log(\"Fail to close input stream.\");\n             }\n-            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new ArtifactChecksumMismatchException(\n-                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                            componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                            \"Algorithm requested for artifact checksum is not supported\"), e);\n         }\n     }\n \n+    /**\n+     * Internal method invoked in downloadToFile().\n+     *\n+     * @param rangeStart    Range start index. INCLUSIVE.\n+     * @param rangeEnd      Range end index. INCLUSIVE.\n+     * @param messageDigest messageDigest to update.\n+     * @return  number of bytes downloaded.\n+     * @throws PackageDownloadException PackageDownloadException\n+     */\n+    protected abstract long download(long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException;\n+\n     /**\n      * Checks whether it is necessary to download the artifact or the existing file suffices.\n      *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of directory where the artifact is expected to exist\n      * @return true if download is necessary\n-     * @throws PackageDownloadException if error occurred in download process\n      * @throws InvalidArtifactUriException if given artifact URI has error\n      */\n-    public abstract boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                             Path saveToPath)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+    public boolean downloadRequired() {\n+        try {\n+            String filename = getArtifactFilename();\n+            return !artifactExistsAndChecksum(artifact, artifactDir.resolve(filename));\n+        } catch (PackageDownloadException e) {\n+            logger.atWarn().setCause(e).log();", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MTkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523141938", "bodyText": "download shouldn't be closing the input stream, since it is closed here, right?", "author": "MikeDombo", "createdAt": "2020-11-13T18:21:22Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/S3Downloader.java", "diffHunk": "@@ -24,94 +21,71 @@\n import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n import software.amazon.awssdk.services.s3.model.S3Exception;\n \n-import java.io.File;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import javax.inject.Inject;\n \n /**\n  * Downloads component artifacts from S3 bucket URI specified in the component recipe.\n  */\n public class S3Downloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(S3Downloader.class);\n     private static final Pattern S3_PATH_REGEX = Pattern.compile(\"s3:\\\\/\\\\/([^\\\\/]+)\\\\/(.*)\");\n     protected static final String REGION_EXPECTING_STRING = \"expecting '\";\n     private final S3Client s3Client;\n     private final S3SdkClientFactory s3ClientFactory;\n+    private final S3ObjectPath s3ObjectPath;\n \n     /**\n      * Constructor.\n      *\n      * @param clientFactory S3 client factory\n      */\n-    @Inject\n-    public S3Downloader(S3SdkClientFactory clientFactory) {\n-        super();\n-        this.s3Client = clientFactory.getS3Client();\n+    protected S3Downloader(S3SdkClientFactory clientFactory, ComponentIdentifier identifier, ComponentArtifact artifact,\n+                        Path artifactDir)\n+            throws InvalidArtifactUriException {\n+        super(identifier, artifact, artifactDir);\n         this.s3ClientFactory = clientFactory;\n+        this.s3Client = clientFactory.getS3Client();\n+        this.s3ObjectPath = getS3PathForURI(artifact.getArtifactUri());\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws InvalidArtifactUriException, PackageDownloadException {\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n-        Path filePath = saveToPath.resolve(extractFileName(s3ObjectPath.key));\n-        return !artifactExistsAndChecksum(artifact, filePath);\n+    protected String getArtifactFilename() {\n+        String objectKey = s3ObjectPath.key;\n+        String[] pathStrings = objectKey.split(\"/\");\n+        return pathStrings[pathStrings.length - 1];\n     }\n \n-    @SuppressWarnings({\"PMD.AvoidInstanceofChecksInCatchClause\"})\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     @Override\n-    public File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException {\n-\n-        logger.atInfo().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log();\n-\n-        // Parse artifact path\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n+    protected long download(long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n         String bucket = s3ObjectPath.bucket;\n         String key = s3ObjectPath.key;\n \n-        InputStream artifactObject = null;\n-        try {\n-            Path filePath = saveToPath.resolve(extractFileName(key));\n-            if (artifactExistsAndChecksum(artifact, filePath)) {\n-                logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n-                        .log(\"Artifact already exists, skipping download\");\n-            } else {\n-                artifactObject = getObject(bucket, key, artifact, componentIdentifier);\n-                checkIntegrityAndSaveToStore(artifactObject, artifact, componentIdentifier, filePath);\n-            }\n-            return filePath.toFile();\n-        } catch (PackageDownloadException e) {\n-            if (e instanceof ArtifactChecksumMismatchException || !saveToPath.resolve(extractFileName(key)).toFile()\n-                    .exists()) {\n-                throw e;\n+        S3Client regionClient = getRegionClientForBucket(bucket);\n+        GetObjectRequest getObjectRequest = GetObjectRequest.builder().bucket(bucket).key(key)\n+                .range(String.format(HTTP_RANGE_HEADER_FORMAT, rangeStart, rangeEnd)).build();\n+        logger.debug(\"Getting s3 object request: {}\", getObjectRequest.toString());\n+\n+        return runWithRetry(\"download-S3-artifact\", MAX_RETRY,() -> {\n+            try (InputStream inputStream = regionClient.getObject(getObjectRequest)) {\n+                return download(inputStream, messageDigest);", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MjA4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523142085", "bodyText": "don't call toString", "author": "MikeDombo", "createdAt": "2020-11-13T18:21:42Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/S3Downloader.java", "diffHunk": "@@ -24,94 +21,71 @@\n import software.amazon.awssdk.services.s3.model.HeadObjectResponse;\n import software.amazon.awssdk.services.s3.model.S3Exception;\n \n-import java.io.File;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import javax.inject.Inject;\n \n /**\n  * Downloads component artifacts from S3 bucket URI specified in the component recipe.\n  */\n public class S3Downloader extends ArtifactDownloader {\n-    private static final Logger logger = LogManager.getLogger(S3Downloader.class);\n     private static final Pattern S3_PATH_REGEX = Pattern.compile(\"s3:\\\\/\\\\/([^\\\\/]+)\\\\/(.*)\");\n     protected static final String REGION_EXPECTING_STRING = \"expecting '\";\n     private final S3Client s3Client;\n     private final S3SdkClientFactory s3ClientFactory;\n+    private final S3ObjectPath s3ObjectPath;\n \n     /**\n      * Constructor.\n      *\n      * @param clientFactory S3 client factory\n      */\n-    @Inject\n-    public S3Downloader(S3SdkClientFactory clientFactory) {\n-        super();\n-        this.s3Client = clientFactory.getS3Client();\n+    protected S3Downloader(S3SdkClientFactory clientFactory, ComponentIdentifier identifier, ComponentArtifact artifact,\n+                        Path artifactDir)\n+            throws InvalidArtifactUriException {\n+        super(identifier, artifact, artifactDir);\n         this.s3ClientFactory = clientFactory;\n+        this.s3Client = clientFactory.getS3Client();\n+        this.s3ObjectPath = getS3PathForURI(artifact.getArtifactUri());\n     }\n \n     @Override\n-    public boolean downloadRequired(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                    Path saveToPath) throws InvalidArtifactUriException, PackageDownloadException {\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n-        Path filePath = saveToPath.resolve(extractFileName(s3ObjectPath.key));\n-        return !artifactExistsAndChecksum(artifact, filePath);\n+    protected String getArtifactFilename() {\n+        String objectKey = s3ObjectPath.key;\n+        String[] pathStrings = objectKey.split(\"/\");\n+        return pathStrings[pathStrings.length - 1];\n     }\n \n-    @SuppressWarnings({\"PMD.AvoidInstanceofChecksInCatchClause\"})\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     @Override\n-    public File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact, Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException {\n-\n-        logger.atInfo().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", componentIdentifier)\n-                .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log();\n-\n-        // Parse artifact path\n-        S3ObjectPath s3ObjectPath = getS3PathForURI(artifact.getArtifactUri(), componentIdentifier);\n+    protected long download(long rangeStart, long rangeEnd, MessageDigest messageDigest)\n+            throws PackageDownloadException {\n         String bucket = s3ObjectPath.bucket;\n         String key = s3ObjectPath.key;\n \n-        InputStream artifactObject = null;\n-        try {\n-            Path filePath = saveToPath.resolve(extractFileName(key));\n-            if (artifactExistsAndChecksum(artifact, filePath)) {\n-                logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n-                        .log(\"Artifact already exists, skipping download\");\n-            } else {\n-                artifactObject = getObject(bucket, key, artifact, componentIdentifier);\n-                checkIntegrityAndSaveToStore(artifactObject, artifact, componentIdentifier, filePath);\n-            }\n-            return filePath.toFile();\n-        } catch (PackageDownloadException e) {\n-            if (e instanceof ArtifactChecksumMismatchException || !saveToPath.resolve(extractFileName(key)).toFile()\n-                    .exists()) {\n-                throw e;\n+        S3Client regionClient = getRegionClientForBucket(bucket);\n+        GetObjectRequest getObjectRequest = GetObjectRequest.builder().bucket(bucket).key(key)\n+                .range(String.format(HTTP_RANGE_HEADER_FORMAT, rangeStart, rangeEnd)).build();\n+        logger.debug(\"Getting s3 object request: {}\", getObjectRequest.toString());", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NDUzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523144536", "bodyText": "use logger.createChild otherwise you are adding these defaults to the logger for ArtifactDownload because loggers created with the same name (the class name) aren't unique, they are the same logger.", "author": "MikeDombo", "createdAt": "2020-11-13T18:26:36Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE1Njg1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523156851", "bodyText": "nit: don't use magic number. Extract 3 to a constant.", "author": "fengwang666", "createdAt": "2020-11-13T18:47:53Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws ArtifactChecksumMismatchException if given artifact checksum algorithm isn't supported.\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n+                throw new ArtifactChecksumMismatchException(\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n+            }\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        final AtomicLong offset = new AtomicLong(0);\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset.set(Files.size(saveToPath));\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        return runWithRetry(\"download-artifact\", 3,", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE2MTkwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523161907", "bodyText": "why not also declare inputstream in the try with block?", "author": "fengwang666", "createdAt": "2020-11-13T18:57:31Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws ArtifactChecksumMismatchException if given artifact checksum algorithm isn't supported.\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n+                throw new ArtifactChecksumMismatchException(\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n+            }\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        final AtomicLong offset = new AtomicLong(0);\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset.set(Files.size(saveToPath));\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        return runWithRetry(\"download-artifact\", 3,\n+                Collections.singletonList(ArtifactChecksumMismatchException.class),\n+                () -> {\n+                    while (offset.get() < artifactSize) {\n+                        long downloadedBytes = download(offset.get(), artifactSize - 1, messageDigest);\n+                        offset.addAndGet(downloadedBytes);\n+                    }\n+\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (!digest.equals(artifact.getChecksum())) {\n+                        // Handle failure in integrity check, delete bad file then throw\n+                        Files.deleteIfExists(saveToPath);\n+                        offset.set(0);\n+                        messageDigest.reset();\n+                        throw new ArtifactChecksumMismatchException(\"Integrity check for downloaded artifact failed. \"\n+                                + \"Probably due to file corruption.\");\n+                    }\n+                    logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+                    return saveToPath.toFile();\n+                });\n+    }\n+\n+    /**\n+     * Internal helper method to download from input stream.\n+     * If IOException is thrown during the process, the method will return actual number of bytes downloaded.\n+     * Supposed to be invoked in `protected abstract long download(long rangeStart, long rangeEnd)`\n+     * @param inputStream inputStream to download from.\n+     * @param messageDigest messageDigest to update.\n+     * @return number of bytes downloaded.\n+     */\n+    protected long download(InputStream inputStream, MessageDigest messageDigest) {\n+        long totalReadBytes = 0;\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                    StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n             byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n+            int readBytes = inputStream.read(buffer);\n             while (readBytes > -1) {\n                 // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n                 artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n+                messageDigest.update(buffer, 0, readBytes);\n+                totalReadBytes += readBytes;\n+                readBytes = inputStream.read(buffer);\n             }\n-\n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n-                throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+            return totalReadBytes;\n+        } catch (IOException e) {\n+            return totalReadBytes;\n+        } finally {\n+            try {\n+                inputStream.close();", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE2MjIxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523162218", "bodyText": "Why is this exception swallowed?", "author": "fengwang666", "createdAt": "2020-11-13T18:58:09Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -12,70 +12,203 @@\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.CrashableSupplier;\n import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public abstract class ArtifactDownloader {\n+    @SuppressFBWarnings({\"MS_SHOULD_BE_FINAL\"})\n+    protected static int MAX_RETRY = 5;\n+\n+    protected static final int MAX_RETRY_INTERVAL_MILLI = 30_000;\n+    protected static final int INIT_RETRY_INTERVAL_MILLI = 1000;\n     private static final int DOWNLOAD_BUFFER_SIZE = 1024;\n-    private static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n     static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n-            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+            \"Failed to download artifact %s for component %s-%s, reason: \";\n+    public static final String ARTIFACT_URI_LOG_KEY = \"artifactUri\";\n+    public static final String COMPONENT_IDENTIFIER_LOG_KEY = \"componentIdentifier\";\n+    protected static final String HTTP_RANGE_HEADER_FORMAT = \"bytes=%d-%d\";\n+    protected static final String HTTP_RANGE_HEADER_KEY = \"Range\";\n \n-    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n-                                             ComponentIdentifier componentIdentifier, Path saveToPath)\n-            throws PackageDownloadException, IOException {\n-        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n-            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+    protected final ComponentIdentifier identifier;\n+    protected final ComponentArtifact artifact;\n+    protected final Path artifactDir;\n+\n+    private Path saveToPath;\n+\n+    protected ArtifactDownloader(ComponentIdentifier identifier, ComponentArtifact artifact,\n+                              Path artifactDir) {\n+        this.identifier = identifier;\n+        this.artifact = artifact;\n+        this.artifactDir = artifactDir;\n+        this.logger.addDefaultKeyValue(ARTIFACT_URI_LOG_KEY, artifact.getArtifactUri())\n+                .addDefaultKeyValue(COMPONENT_IDENTIFIER_LOG_KEY, identifier.getName());\n+    }\n+\n+    /**\n+     * Download an artifact from remote.\n+     *\n+     * @return file handle of the downloaded file\n+     * @throws IOException if I/O error occurred in network/disk\n+     * @throws PackageDownloadException if error occurred in download process\n+     * @throws ArtifactChecksumMismatchException if given artifact checksum algorithm isn't supported.\n+     */\n+    public final File downloadToPath() throws PackageDownloadException, IOException {\n+        MessageDigest messageDigest;\n+        try {\n+            if (artifact.getAlgorithm() == null) {\n+                throw new ArtifactChecksumMismatchException(\n+                        getErrorString(\"Algorithm missing from artifact.\"));\n+            }\n+            messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    getErrorString(\"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+\n+        saveToPath = artifactDir.resolve(getArtifactFilename());\n+        long artifactSize = getDownloadSize();\n+        final AtomicLong offset = new AtomicLong(0);\n+\n+        // If there are partially downloaded artifact existing on device\n+        if (Files.exists(saveToPath)) {\n+            if (Files.size(saveToPath) > artifactSize) {\n+                // Existing file is corrupted, it's larger than defined in artifact.\n+                // Normally shouldn't happen, corrupted files are deleted every time.\n+                logger.atError().log(\"existing file corrupted. Expected size: {}, Actual size: {}.\"\n+                        + \" Removing and retry download.\", artifactSize, Files.size(saveToPath));\n+                Files.deleteIfExists(saveToPath);\n+            } else {\n+                offset.set(Files.size(saveToPath));\n+                updateDigestFromFile(saveToPath, messageDigest);\n+            }\n+        }\n+\n+        return runWithRetry(\"download-artifact\", 3,\n+                Collections.singletonList(ArtifactChecksumMismatchException.class),\n+                () -> {\n+                    while (offset.get() < artifactSize) {\n+                        long downloadedBytes = download(offset.get(), artifactSize - 1, messageDigest);\n+                        offset.addAndGet(downloadedBytes);\n+                    }\n+\n+                    String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+                    if (!digest.equals(artifact.getChecksum())) {\n+                        // Handle failure in integrity check, delete bad file then throw\n+                        Files.deleteIfExists(saveToPath);\n+                        offset.set(0);\n+                        messageDigest.reset();\n+                        throw new ArtifactChecksumMismatchException(\"Integrity check for downloaded artifact failed. \"\n+                                + \"Probably due to file corruption.\");\n+                    }\n+                    logger.atDebug().setEventType(\"download-artifact\").log(\"Passed integrity check\");\n+                    return saveToPath.toFile();\n+                });\n+    }\n+\n+    /**\n+     * Internal helper method to download from input stream.\n+     * If IOException is thrown during the process, the method will return actual number of bytes downloaded.\n+     * Supposed to be invoked in `protected abstract long download(long rangeStart, long rangeEnd)`\n+     * @param inputStream inputStream to download from.\n+     * @param messageDigest messageDigest to update.\n+     * @return number of bytes downloaded.\n+     */\n+    protected long download(InputStream inputStream, MessageDigest messageDigest) {\n+        long totalReadBytes = 0;\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath,\n+                    StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE)) {\n             byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = artifactObject.read(buffer);\n+            int readBytes = inputStream.read(buffer);\n             while (readBytes > -1) {\n                 // Compute digest as well as write to the file path\n-                messageDigest.update(buffer, 0, readBytes);\n                 artifactFile.write(buffer, 0, readBytes);\n-                readBytes = artifactObject.read(buffer);\n+                messageDigest.update(buffer, 0, readBytes);\n+                totalReadBytes += readBytes;\n+                readBytes = inputStream.read(buffer);\n             }\n-\n-            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n-            if (!digest.equals(artifact.getChecksum())) {\n-                // Handle failure in integrity check, delete bad file then throw\n-                Files.deleteIfExists(saveToPath);\n-                throw new ArtifactChecksumMismatchException(\n-                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n-                                componentIdentifier.getName(), componentIdentifier.getVersion().toString(),\n-                                \"Integrity check for downloaded artifact failed\"));\n+            return totalReadBytes;\n+        } catch (IOException e) {\n+            return totalReadBytes;", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMTQxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523201419", "bodyText": "At this point, part of the input stream is read and written to file. Throwing exception will cause this info lost about 'how much of file is written' . I'll add log on it", "author": "ShirleyZheng92", "createdAt": "2020-11-13T20:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE2MjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE3MDg0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523170845", "bodyText": "return null is usually a bad idea. For example, inside the GreengrassRepositoryDownloader.download method where runWithRetry is called, the expected return type is long. Unboxing a null Long to long will throw NPE. It's not going to be pretty.\nThink about when InterruptedException will be threw and how it should be handled, not just locally but across the whole running program.", "author": "fengwang666", "createdAt": "2020-11-13T19:15:51Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -102,66 +235,86 @@ static boolean artifactExistsAndChecksum(ComponentArtifact artifact, Path filePa\n         }\n \n         // If the file already exists and has the right content, skip download\n-        try (InputStream existingArtifact = Files.newInputStream(filePath)) {\n+        try {\n             MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = existingArtifact.read(buffer);\n-            while (readBytes > -1) {\n-                messageDigest.update(buffer, 0, readBytes);\n-                readBytes = existingArtifact.read(buffer);\n-            }\n+            updateDigestFromFile(filePath, messageDigest);\n             String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n             return digest.equals(artifact.getChecksum());\n-\n         } catch (IOException | NoSuchAlgorithmException e) {\n-            // If error in checking the existing content, attempt fresh download\n             return false;\n         }\n     }\n \n-    private static boolean recipeHasDigest(ComponentArtifact artifact) {\n-        return !Utils.isEmpty(artifact.getAlgorithm()) && !Utils.isEmpty(artifact.getChecksum());\n+    protected <T> T runWithRetry(String taskDescription, int maxRetry,\n+                                 CrashableSupplier<T, Exception> taskToRetry) throws PackageDownloadException {\n+        return runWithRetry(taskDescription, maxRetry, Collections.singletonList(IOException.class), taskToRetry);\n     }\n \n-    /**\n-     * Download an artifact from remote.\n-     *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of the directory to put the artifact file\n-     * @return file handle of the downloaded file\n-     * @throws IOException if I/O error occurred in network/disk\n-     * @throws PackageDownloadException if error occurred in download process\n-     * @throws InvalidArtifactUriException if given artifact URI has error\n-     */\n-    public abstract File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                        Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException;\n+    @SuppressWarnings({\"PMD.AvoidCatchingGenericException\",\n+            \"PMD.AvoidRethrowingException\", \"PMD.AvoidInstanceofChecksInCatchClause\"})\n+    protected <T> T runWithRetry(String taskDescription, int maxRetry, List<Class> retryableExceptions,\n+                                 CrashableSupplier<T, Exception> taskToRetry)\n+            throws PackageDownloadException {\n+        int retryInterval = INIT_RETRY_INTERVAL_MILLI;\n+        int retry = 0;\n+        Exception lastRetryableException = null;\n+        while (retry < maxRetry) {\n+            retry++;\n+            try {\n+                return taskToRetry.apply();\n+            } catch (Exception e) {\n+                logger.atWarn().kv(\"exception\", e.getMessage()).log(\"Retry \" + taskDescription);\n+                if (retry >= maxRetry) {\n+                    break;\n+                }\n+                boolean retryable = false;\n+                for (Class retryableException : retryableExceptions) {\n+                    if (retryableException.isInstance(e)) {\n+                        lastRetryableException = e;\n+                        logger.atWarn().kv(\"exception\", e.getMessage()).log(\"Retry \" + taskDescription);\n+                        retryable = true;\n+                    }\n+                }\n \n-    /**\n-     * Get the download size of an artifact file.\n-     *\n-     * @param componentIdentifier package info\n-     * @param artifact artifact info\n-     * @param artifactDir path of directory where the artifact is expected to exist\n-     * @return size of the artifact in bytes\n-     * @throws InvalidArtifactUriException if provided info results in invalid URI\n-     * @throws PackageDownloadException if error encountered\n-     */\n-    public abstract long getDownloadSize(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                         Path artifactDir)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+                if (!retryable) {\n+                    if (e instanceof PackageDownloadException) {\n+                        throw (PackageDownloadException) e;\n+                    }\n+                    throw new PackageDownloadException(\"Unexpected error in \" + taskDescription, e);\n+                }\n \n-    /**\n-     * Get the artifact file.\n-     *\n-     * @param saveToPath          path of directory where the artifact is expected to exist\n-     * @param artifact            artifact info\n-     * @param componentIdentifier component info\n-     * @return artifact file that was either downloaded or had been locally present\n-     * @throws InvalidArtifactUriException if provided info results in invalid URI\n-     */\n-    public abstract File getArtifactFile(Path saveToPath, ComponentArtifact artifact,\n-                                         ComponentIdentifier componentIdentifier) throws InvalidArtifactUriException;\n+                try {\n+                    Thread.sleep(retryInterval);\n+                    if (retryInterval < MAX_RETRY_INTERVAL_MILLI) {\n+                        retryInterval = retryInterval * 2;\n+                    } else {\n+                        retryInterval = MAX_RETRY_INTERVAL_MILLI;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    logger.atInfo().log(\"Interrupted while waiting to retry \" + taskDescription);\n+                    return null;", "originalCommit": "5821c6e711526900255fdd9283e11cd8fc1b2111", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de557fe79a3644e8f307f84350b14195a50cc074", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/de557fe79a3644e8f307f84350b14195a50cc074", "message": "Address comments", "committedDate": "2020-11-13T20:50:53Z", "type": "commit"}, {"oid": "de557fe79a3644e8f307f84350b14195a50cc074", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/de557fe79a3644e8f307f84350b14195a50cc074", "message": "Address comments", "committedDate": "2020-11-13T20:50:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzODgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523238802", "bodyText": "This is still not ideal. InterruptedException is an expected behavior. It happens when the whole program is to be shut down. Wrapping it inside an PackageDownloadException which is an error case doesn't seem right. For this method, it can just stop and populate the InterruptedException up and let its caller (or caller's caller) handle it. The caller who manages the lifecycle of the current running thread is the right place to handle Interrupted exception.", "author": "fengwang666", "createdAt": "2020-11-13T21:21:39Z", "path": "src/main/java/com/aws/greengrass/componentmanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -102,66 +236,88 @@ static boolean artifactExistsAndChecksum(ComponentArtifact artifact, Path filePa\n         }\n \n         // If the file already exists and has the right content, skip download\n-        try (InputStream existingArtifact = Files.newInputStream(filePath)) {\n+        try {\n             MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n-            byte[] buffer = new byte[DOWNLOAD_BUFFER_SIZE];\n-            int readBytes = existingArtifact.read(buffer);\n-            while (readBytes > -1) {\n-                messageDigest.update(buffer, 0, readBytes);\n-                readBytes = existingArtifact.read(buffer);\n-            }\n+            updateDigestFromFile(filePath, messageDigest);\n             String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n             return digest.equals(artifact.getChecksum());\n-\n         } catch (IOException | NoSuchAlgorithmException e) {\n-            // If error in checking the existing content, attempt fresh download\n             return false;\n         }\n     }\n \n-    private static boolean recipeHasDigest(ComponentArtifact artifact) {\n-        return !Utils.isEmpty(artifact.getAlgorithm()) && !Utils.isEmpty(artifact.getChecksum());\n+    protected <T> T runWithRetry(String taskDescription, int maxRetry,\n+                                 CrashableSupplier<T, Exception> taskToRetry)\n+            throws PackageDownloadException {\n+        return runWithRetry(taskDescription, maxRetry, Collections.singletonList(IOException.class), taskToRetry);\n     }\n \n-    /**\n-     * Download an artifact from remote.\n-     *\n-     * @param componentIdentifier component that has the artifact\n-     * @param artifact an artifact object\n-     * @param saveToPath path of the directory to put the artifact file\n-     * @return file handle of the downloaded file\n-     * @throws IOException if I/O error occurred in network/disk\n-     * @throws PackageDownloadException if error occurred in download process\n-     * @throws InvalidArtifactUriException if given artifact URI has error\n-     */\n-    public abstract File downloadToPath(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                        Path saveToPath)\n-            throws IOException, PackageDownloadException, InvalidArtifactUriException;\n+    @SuppressWarnings({\"PMD.AvoidCatchingGenericException\", \"PMD.AvoidRethrowingException\",\n+            \"PMD.AvoidInstanceofChecksInCatchClause\", \"PMD.PreserveStackTrace\"})\n+    protected <T> T runWithRetry(String taskDescription, int maxRetry, List<Class> retryableExceptions,\n+                                 CrashableSupplier<T, Exception> taskToRetry)\n+            throws PackageDownloadException {\n+        int retryInterval = INIT_RETRY_INTERVAL_MILLI;\n+        int retry = 0;\n+        Exception lastRetryableException = null;\n+        while (retry < maxRetry) {\n+            retry++;\n+            try {\n+                return taskToRetry.apply();\n+            } catch (Exception e) {\n+                logger.atWarn().kv(\"exception\", e.getMessage()).log(\"Retry \" + taskDescription);\n+                if (retry >= maxRetry) {\n+                    break;\n+                }\n+                boolean retryable = false;\n+                for (Class retryableException : retryableExceptions) {\n+                    if (retryableException.isInstance(e)) {\n+                        lastRetryableException = e;\n+                        logger.atWarn().kv(\"exception\", e.getMessage()).log(\"Retry \" + taskDescription);\n+                        retryable = true;\n+                    }\n+                }\n \n-    /**\n-     * Get the download size of an artifact file.\n-     *\n-     * @param componentIdentifier package info\n-     * @param artifact artifact info\n-     * @param artifactDir path of directory where the artifact is expected to exist\n-     * @return size of the artifact in bytes\n-     * @throws InvalidArtifactUriException if provided info results in invalid URI\n-     * @throws PackageDownloadException if error encountered\n-     */\n-    public abstract long getDownloadSize(ComponentIdentifier componentIdentifier, ComponentArtifact artifact,\n-                                         Path artifactDir)\n-            throws InvalidArtifactUriException, PackageDownloadException;\n+                if (!retryable) {\n+                    if (e instanceof PackageDownloadException) {\n+                        throw (PackageDownloadException) e;\n+                    }\n+                    throw new PackageDownloadException(\"Unexpected error in \" + taskDescription, e);\n+                }\n \n-    /**\n-     * Get the artifact file.\n-     *\n-     * @param saveToPath          path of directory where the artifact is expected to exist\n-     * @param artifact            artifact info\n-     * @param componentIdentifier component info\n-     * @return artifact file that was either downloaded or had been locally present\n-     * @throws InvalidArtifactUriException if provided info results in invalid URI\n-     */\n-    public abstract File getArtifactFile(Path saveToPath, ComponentArtifact artifact,\n-                                         ComponentIdentifier componentIdentifier) throws InvalidArtifactUriException;\n+                try {\n+                    Thread.sleep(retryInterval);\n+                    if (retryInterval < MAX_RETRY_INTERVAL_MILLI) {\n+                        retryInterval = retryInterval * 2;\n+                    } else {\n+                        retryInterval = MAX_RETRY_INTERVAL_MILLI;\n+                    }\n+                } catch (InterruptedException ie) {\n+                    String errMsg = \"Interrupted while waiting to retry \" + taskDescription;\n+                    logger.atInfo().setCause(ie).log(errMsg);\n+                    throw new PackageDownloadException(getErrorString(errMsg));", "originalCommit": "de557fe79a3644e8f307f84350b14195a50cc074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM0OTgzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523349832", "bodyText": "Why is the InterruptedException still wrapped?", "author": "fengwang666", "createdAt": "2020-11-14T02:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzODgwMg=="}], "type": "inlineReview"}, {"oid": "67c0016d01b2883313408d9955d5375a108931a0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67c0016d01b2883313408d9955d5375a108931a0", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-13T21:44:13Z", "type": "commit"}, {"oid": "1743b82c8135bc2c16625fc76775dbf256d7344e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1743b82c8135bc2c16625fc76775dbf256d7344e", "message": "populate interruptedException", "committedDate": "2020-11-13T22:19:08Z", "type": "forcePushed"}, {"oid": "8ff2742df88a8f2ec14ea5c516cf4826bef1f286", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ff2742df88a8f2ec14ea5c516cf4826bef1f286", "message": "populate interruptedException", "committedDate": "2020-11-13T23:01:57Z", "type": "commit"}, {"oid": "8ff2742df88a8f2ec14ea5c516cf4826bef1f286", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ff2742df88a8f2ec14ea5c516cf4826bef1f286", "message": "populate interruptedException", "committedDate": "2020-11-13T23:01:57Z", "type": "forcePushed"}, {"oid": "245913bcb641ea2cd9098930e759953b72a6155d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/245913bcb641ea2cd9098930e759953b72a6155d", "message": "Merge branch 'master' into downloader_retry", "committedDate": "2020-11-13T23:03:35Z", "type": "commit"}, {"oid": "84c17901bf5ba03be1546a9573d888a9376ea6e7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/84c17901bf5ba03be1546a9573d888a9376ea6e7", "message": "Fix logger multi-thread", "committedDate": "2020-11-14T02:06:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM0NTE0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/631#discussion_r523345146", "bodyText": "Can you please also add a log here?", "author": "fengwang666", "createdAt": "2020-11-14T02:14:27Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -285,14 +279,21 @@ private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIden\n                 if (Thread.currentThread().isInterrupted()) {", "originalCommit": "84c17901bf5ba03be1546a9573d888a9376ea6e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d39bb60940127b4a2bfc57d733c4cb5303c55287", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d39bb60940127b4a2bfc57d733c4cb5303c55287", "message": "Fix logger multi-thread. Throw InterruptException in retry.", "committedDate": "2020-11-14T02:39:09Z", "type": "commit"}, {"oid": "d39bb60940127b4a2bfc57d733c4cb5303c55287", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d39bb60940127b4a2bfc57d733c4cb5303c55287", "message": "Fix logger multi-thread. Throw InterruptException in retry.", "committedDate": "2020-11-14T02:39:09Z", "type": "forcePushed"}, {"oid": "441c4b54451774705951a8aa3a6e64486a12663f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/441c4b54451774705951a8aa3a6e64486a12663f", "message": "Merge remote-tracking branch 'origin/master' into downloader_retry", "committedDate": "2020-11-14T07:28:52Z", "type": "commit"}, {"oid": "19875b9ed3e3869e213cd23836e69648b667ccfe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/19875b9ed3e3869e213cd23836e69648b667ccfe", "message": "Minor log update", "committedDate": "2020-11-14T07:30:18Z", "type": "commit"}, {"oid": "19875b9ed3e3869e213cd23836e69648b667ccfe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/19875b9ed3e3869e213cd23836e69648b667ccfe", "message": "Minor log update", "committedDate": "2020-11-14T07:30:18Z", "type": "forcePushed"}]}