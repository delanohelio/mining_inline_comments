{"pr_number": 362, "pr_title": "Kernel detects and resumes persisted deployment on launch", "pr_createdAt": "2020-08-11T01:55:53Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczMTcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468731717", "bodyText": "Add the service update exception details in the result as well?", "author": "ShirleyZheng92", "createdAt": "2020-08-11T17:03:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -25,32 +29,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n+                try {\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK,", "originalCommit": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMzg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468823865", "bodyText": "Tried to add original SUE as suppressed but it won't get reported in deployment result, so replace the result with SUE and only log IOE here", "author": "hui-yang", "createdAt": "2020-08-11T19:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczMTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNDA5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468734090", "bodyText": "RollbackCompletes() delete the old  \"broken\" directory. I guess we want to keep the last broken dir", "author": "ShirleyZheng92", "createdAt": "2020-08-11T17:08:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -25,32 +29,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n+                try {\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK,\n+                            ioException);\n+                }\n                 return null;\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, null);\n+                try {\n+                    kernelAlts.rollbackCompletes();", "originalCommit": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MDE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468760170", "bodyText": "If broken dir exists, it indicates stage rollback. If we want to keep the last broken, we can add back the previous-X pointers in the launch dir", "author": "hui-yang", "createdAt": "2020-08-11T17:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0NzI2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468947261", "bodyText": "If rollback fails and we call rollbackComplete() , then the broken dir is the failed deployment dir, and current dir is the deployment before that (which was once successful). I'm ok with this for now. We can discuss offline", "author": "ShirleyZheng92", "createdAt": "2020-08-12T01:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTg1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468745854", "bodyText": "I'm wondering if we should swallow the exception here. Maybe it's better to handle in the rollback failure", "author": "ShirleyZheng92", "createdAt": "2020-08-11T17:28:10Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -5,121 +5,99 @@\n \n package com.aws.iot.evergreen.deployment.activator;\n \n-import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelAlternatives;\n import com.aws.iot.evergreen.kernel.KernelLifecycle;\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n import javax.inject.Inject;\n \n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.KERNEL_ROLLBACK;\n \n /**\n  * Activation and rollback of Kernel update deployments.\n  */\n public class KernelUpdateActivator extends DeploymentActivator {\n     private final BootstrapManager bootstrapManager;\n+    private final KernelAlternatives kernelAlternatives;\n \n     @Inject\n     protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n         super(kernel);\n         this.bootstrapManager = bootstrapManager;\n+        this.kernelAlternatives = kernel.getContext().get(KernelAlternatives.class);\n     }\n \n     @Override\n-    public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+    public void activate(Map<Object, Object> newConfig, Deployment deployment,\n                          CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n-        String deploymentId = deploymentDocument.getDeploymentId();\n-        if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n+        if (!takeConfigSnapshot(totallyCompleteFuture)) {\n             return;\n         }\n \n+        DeploymentDocument deploymentDocument = deployment.getDeploymentDocumentObj();\n         // Wait for all services to close\n-        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(30);\n         kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        Path bootstrapTaskFilePath;\n         try {\n-            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n-            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n-                    deploymentId.replace(':', '.').replace('/', '+')));\n-            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+            bootstrapTaskFilePath = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+            deploymentDirectoryManager.takeConfigSnapshot(deploymentDirectoryManager.getTargetConfigFilePath());\n+            bootstrapManager.persistBootstrapTaskList(bootstrapTaskFilePath);\n+\n+            kernelAlternatives.prepareBootstrap(deploymentDocument.getDeploymentId());\n         } catch (IOException e) {\n-            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            rollback(deployment, e);\n             return;\n         }\n-        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n-        bootstrapManager.persistBootstrapTaskList();\n-        // TODO: KernelAlts prepare bootstrap\n \n         try {\n-            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(bootstrapTaskFilePath);\n             if (!bootstrapManager.hasNext()) {\n-                // TODO: flip symlinks, new to current\n                 logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n             }\n             // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n             // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n-            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")\n+            logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n                     + \" requested to complete bootstrap task\");\n-            // TODO: Kernel shutdown supports exit code\n-            // System.exit(exitCode == 101 ? 101 : 100);\n \n-        } catch (ServiceUpdateException e) {\n-            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            kernel.shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+        } catch (ServiceUpdateException | IOException e) {\n+            rollback(deployment, e);\n             return;\n         }\n     }\n \n-    void rollback(DeploymentDocument deploymentDocument, CompletableFuture<DeploymentResult> totallyCompleteFuture,\n-                  Throwable failureCause) {\n-        String deploymentId = deploymentDocument.getDeploymentId();\n-        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+    void rollback(Deployment deployment, Throwable failureCause) {\n+        logger.atInfo(MERGE_CONFIG_EVENT_KEY, failureCause)\n+                .kv(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId())\n                 .log(\"Rolling back failed deployment\");\n+        deployment.setStageDetails(failureCause.getMessage());\n+        deployment.setDeploymentStage(KERNEL_ROLLBACK);\n \n-        // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n-        long mergeTime = rollbackConfig(deploymentId, totallyCompleteFuture, failureCause);\n-        if (mergeTime == -1) {\n-            return;\n+        try {\n+            deploymentDirectoryManager.writeDeploymentMetadata(deployment);\n+        } catch (IOException ioException) {\n+            logger.atError().setCause(ioException).log(\"Failed to persist deployment details\");\n         }\n-\n-        kernel.getContext().get(ExecutorService.class).execute(() -> {\n-            // TODO: Add timeout\n-            try {\n-                kernel.getContext().get(KernelLifecycle.class).startupAllServices();\n-\n-                Collection<EvergreenService> servicesToTrackForRollback = kernel.orderedDependencies();\n-\n-                waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                        .log(\"All services rolled back\");\n-\n-                ConfigSnapshotUtils.cleanUpSnapshot(\n-                        ConfigSnapshotUtils.getSnapshotFilePath(kernel, deploymentId), logger);\n-\n-                totallyCompleteFuture.complete(new DeploymentResult(\n-                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-            } catch (InterruptedException | ServiceUpdateException e) {\n-                // Rollback execution failed\n-                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                        .log(\"Failed to rollback deployment\");\n-                // TODO : Run user provided script to reach user defined safe state and\n-                //  set deployment status based on the success of the script run\n-                totallyCompleteFuture.complete(new DeploymentResult(\n-                        DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-            }\n-        });\n+        try {\n+            kernelAlternatives.prepareRollback();\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).log(\"Failed to set up rollback directory\");", "originalCommit": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MDY4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468760684", "bodyText": "Makes sense. I'll think over it.", "author": "hui-yang", "createdAt": "2020-08-11T17:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyNDE2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468824169", "bodyText": "We don't have a way to handle it actually. I can maybe return unable-to-rollback directory here.\nEDIT: let's discuss offline", "author": "hui-yang", "createdAt": "2020-08-11T19:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0ODEwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468748109", "bodyText": "maybe Use Jackson?", "author": "ShirleyZheng92", "createdAt": "2020-08-11T17:31:52Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/bootstrap/BootstrapTaskStatus.java", "diffHunk": "@@ -9,11 +9,17 @@\n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.Serializable;\n \n @Data\n @EqualsAndHashCode\n @AllArgsConstructor(access = AccessLevel.PACKAGE)\n-public class BootstrapTaskStatus {\n+@NoArgsConstructor(access = AccessLevel.PACKAGE)\n+public class BootstrapTaskStatus implements Serializable {", "originalCommit": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MDk2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468760963", "bodyText": "Right. Will undo this change.", "author": "hui-yang", "createdAt": "2020-08-11T17:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0ODEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0OTE1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468749151", "bodyText": "NIT: I feel it a little weird to pass bootstrapManager and deploymentDirManager as parameter here. These can be private fields of KernelAlts and set from either context or KernelCommandline", "author": "ShirleyZheng92", "createdAt": "2020-08-11T17:33:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);", "originalCommit": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MTg0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468761848", "bodyText": "Yeah I did that initially. But those two fields are only used once here in this method.", "author": "hui-yang", "createdAt": "2020-08-11T17:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0OTE1MQ=="}], "type": "inlineReview"}, {"oid": "3dd5a2d8291773ec1d911c2366c8cf932ef79163", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3dd5a2d8291773ec1d911c2366c8cf932ef79163", "message": "Kernel detects and resumes persisted deployment on launch", "committedDate": "2020-08-11T19:49:38Z", "type": "commit"}, {"oid": "3bdda28da660228c499c587729f82fae382ee876", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3bdda28da660228c499c587729f82fae382ee876", "message": "Address comments and fix integration tests", "committedDate": "2020-08-11T19:49:39Z", "type": "commit"}, {"oid": "7c0172257ac29862d2251a125b7a41f4e59a0055", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7c0172257ac29862d2251a125b7a41f4e59a0055", "message": "Merge remote-tracking branch 'origin/master' into ku05update", "committedDate": "2020-08-11T19:57:16Z", "type": "commit"}, {"oid": "7c0172257ac29862d2251a125b7a41f4e59a0055", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7c0172257ac29862d2251a125b7a41f4e59a0055", "message": "Merge remote-tracking branch 'origin/master' into ku05update", "committedDate": "2020-08-11T19:57:16Z", "type": "forcePushed"}, {"oid": "90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "message": "Fix build and cleanup", "committedDate": "2020-08-11T21:05:16Z", "type": "forcePushed"}, {"oid": "cbf69c8606e993c584943b036cca4a3373612279", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbf69c8606e993c584943b036cca4a3373612279", "message": "Fix build and cleanup", "committedDate": "2020-08-11T22:43:38Z", "type": "commit"}, {"oid": "3cc51cd285397a46501c172ceeaf10732814ac1d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc51cd285397a46501c172ceeaf10732814ac1d", "message": "Merge remote-tracking branch 'origin/master' into ku05update", "committedDate": "2020-08-11T22:45:26Z", "type": "commit"}, {"oid": "3cc51cd285397a46501c172ceeaf10732814ac1d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc51cd285397a46501c172ceeaf10732814ac1d", "message": "Merge remote-tracking branch 'origin/master' into ku05update", "committedDate": "2020-08-11T22:45:26Z", "type": "forcePushed"}, {"oid": "66194487c9e07ade221a98936c32540d4e8598f4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/66194487c9e07ade221a98936c32540d4e8598f4", "message": "fix build", "committedDate": "2020-08-11T23:08:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyODM5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468928394", "bodyText": "make this default value in logger?", "author": "ShirleyZheng92", "createdAt": "2020-08-11T23:55:45Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DefaultDeploymentTask.java", "diffHunk": "@@ -49,9 +51,10 @@ public DeploymentResult call()\n             throws NonRetryableDeploymentTaskFailureException, RetryableDeploymentTaskFailureException {\n         Future<Void> preparePackagesFuture = null;\n         Future<DeploymentResult> deploymentMergeFuture = null;\n+        DeploymentDocument deploymentDocument = deployment.getDeploymentDocumentObj();\n         try {\n             logger.atInfo().setEventType(DEPLOYMENT_TASK_EVENT_TYPE)\n-                    .addKeyValue(DEPLOYMENT_ID_LOGGING_KEY, deploymentDocument.getDeploymentId())\n+                    .addKeyValue(DEPLOYMENT_ID_LOG_KEY, deploymentDocument.getDeploymentId())", "originalCommit": "66194487c9e07ade221a98936c32540d4e8598f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzOTYwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468939609", "bodyText": "curious why use this?", "author": "ShirleyZheng92", "createdAt": "2020-08-12T00:36:09Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -29,44 +30,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());", "originalCommit": "66194487c9e07ade221a98936c32540d4e8598f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3NDk4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r469374985", "bodyText": "No specific reason actually. I just need a timestamp before this kernel start", "author": "hui-yang", "createdAt": "2020-08-12T16:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzOTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0NTc5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468945799", "bodyText": "throw the exception instead?", "author": "ShirleyZheng92", "createdAt": "2020-08-12T00:59:44Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -29,44 +30,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n-                try {\n-                    kernel.getContext().get(KernelAlternatives.class).activationSucceeds();\n-                } catch (IOException e) {\n-                    logger.atError().setCause(e).log(\"Fail to complete activation succeeds\");\n-                }\n-\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n                 try {\n-                    kernel.getContext().get(KernelAlternatives.class).prepareRollback();\n-                } catch (IOException ioE) {\n-                    logger.atError().setCause(ioE).log(\"fail to flip symlink on roll back\");\n-                    // TODO: error handle\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    logger.atError().log(\"Failed to set up Kernel rollback directory\", ioException);\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, e);\n                 }\n                 return null;\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, null);\n+                try {\n+                    kernelAlts.rollbackCompletes();\n+                } catch (IOException ioException) {\n+                    logger.atError().log(\"Failed to reset Kernel launch directory\", ioException);\n+                }\n+                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, e);\n             }\n             return null;\n         }\n     }\n+\n+    private void saveDeploymentStatusDetails(String message) {\n+        deployment.setStageDetails(message);\n+        try {\n+            kernel.getContext().get(DeploymentDirectoryManager.class).writeDeploymentMetadata(deployment);\n+        } catch (IOException ioException) {", "originalCommit": "66194487c9e07ade221a98936c32540d4e8598f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "message": "Address comments", "committedDate": "2020-08-13T00:10:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYyNDU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r469624596", "bodyText": "NIT: this line can be moved to call() so that you don't need to break the @AllArgsConstructor :P", "author": "ShirleyZheng92", "createdAt": "2020-08-13T00:29:34Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DefaultDeploymentTask.java", "diffHunk": "@@ -45,6 +43,30 @@\n \n     private static final String DEPLOYMENT_TASK_EVENT_TYPE = \"deployment-task-execution\";\n \n+    /**\n+     * Constructor for DefaultDeploymentTask.\n+     *\n+     * @param dependencyResolver DependencyResolver instance\n+     * @param packageManager PackageManager instance\n+     * @param kernelConfigResolver KernelConfigResolver instance\n+     * @param deploymentConfigMerger DeploymentConfigMerger instance\n+     * @param logger Logger instance\n+     * @param deployment Deployment instance\n+     * @param deploymentServiceConfig Deployment service configuration Topics\n+     */\n+    public DefaultDeploymentTask(DependencyResolver dependencyResolver, PackageManager packageManager,\n+                                 KernelConfigResolver kernelConfigResolver,\n+                                 DeploymentConfigMerger deploymentConfigMerger, Logger logger, Deployment deployment,\n+                                 Topics deploymentServiceConfig) {\n+        this.dependencyResolver = dependencyResolver;\n+        this.packageManager = packageManager;\n+        this.kernelConfigResolver = kernelConfigResolver;\n+        this.deploymentConfigMerger = deploymentConfigMerger;\n+        this.logger = logger.dfltKv(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5NzcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470097706", "bodyText": "True. I can change it back.", "author": "hui-yang", "createdAt": "2020-08-13T17:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYyNDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYzNjYzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r469636639", "bodyText": "This can be tricky because tempRootDir and e2eTestPkgStoreDir might be the same directory. It was causing problem before when prepare local deployment store and copy file recursively from one folder to another (I see you removed that copy file logic). I'll still prefer e2eTestPkgStoreDir = tempRootDir.resolve(\"eteTestPkgStore\");", "author": "ShirleyZheng92", "createdAt": "2020-08-13T01:08:22Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/BaseE2ETestCase.java", "diffHunk": "@@ -140,8 +140,9 @@\n             new DeviceProvisioningHelper(GAMMA_REGION.toString(), System.out);\n \n     @TempDir\n-    protected static Path tempRootDir;\n+    protected Path tempRootDir;\n \n+    @TempDir\n     protected static Path e2eTestPkgStoreDir;", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5OTQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470099446", "bodyText": "The problem is tempRootDir was shared by all e2e tests. I'm not sure if that's ok. and e2eTestPkgStoreDir needs to be static based on our upload logic", "author": "hui-yang", "createdAt": "2020-08-13T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYzNjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxNzgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470217827", "bodyText": "Is 100 coming from our design terminology?", "author": "abanthiy", "createdAt": "2020-08-13T20:08:05Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0NTA2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470245066", "bodyText": "Yes. The reserved ones are 100 and 101", "author": "hui-yang", "createdAt": "2020-08-13T20:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxNzgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3ODAyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470278021", "bodyText": "Anyone new reading the code will not understand. May either remove it or explain.", "author": "abanthiy", "createdAt": "2020-08-13T22:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxNzgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxOTUyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470219520", "bodyText": "Do we need shutdown in case when bootstrap did not happen correctly? The directories have been adjusted I believe as part of kernelAlts.prepareRollback(). Can't we push the deployment with rollback stage in the queue at this point?", "author": "abanthiy", "createdAt": "2020-08-13T20:11:02Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n+                    logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n+                            + \" requested to complete bootstrap task\");\n+\n+                    shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+                } catch (ServiceUpdateException | IOException e) {\n+                    logger.atInfo().log(\"Deployment bootstrap failed\", e);\n+                    try {\n+                        kernelAlts.prepareRollback();\n+                        Deployment deployment = deploymentDirectoryManager.readDeploymentMetadata();\n+                        deployment.setStageDetails(e.getMessage());\n+                        deploymentDirectoryManager.writeDeploymentMetadata(deployment);\n+                    } catch (IOException ioException) {\n+                        logger.atError().setCause(ioException).log(\n+                                \"Something went wrong while preparing for rollback\");\n+                    }\n+                    shutdown(30, 2);", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0OTYzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470249631", "bodyText": "Correct, we reverted the launch dir changes with kernelAlts.prepareRollback. but this kernel is launched from the broken new launch dir, so we have to restart from old launch dir again.", "author": "hui-yang", "createdAt": "2020-08-13T21:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxOTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223308", "bodyText": "Does bootstrap tasks follow dependency order? If not can we restart only once after all tasks have finished?", "author": "abanthiy", "createdAt": "2020-08-13T20:18:10Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0Njk1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470246958", "bodyText": "Yes. it's ordered by dependency.\nIt can be an option, but we won't get details of which bootstrap leads to failure", "author": "hui-yang", "createdAt": "2020-08-13T21:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjcwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470282707", "bodyText": "ok. If its dependency ordered then current implementation is probably better approach.", "author": "abanthiy", "createdAt": "2020-08-13T22:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223946", "bodyText": "Name seems to indicate that it will execute all the tasks and then return but it executes one by one and returns after executing one. Probably rename it to indicate this behavior, that would also make the if check in next line more intuitive.", "author": "abanthiy", "createdAt": "2020-08-13T20:19:28Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0NjE0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470246144", "bodyText": "If not restart/reboot request, it does move on to the next bootstrap task. And it returns right away for restart/reboot", "author": "hui-yang", "createdAt": "2020-08-13T21:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjIxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470282214", "bodyText": "ya thats right. Ok I think the naming is fine then", "author": "abanthiy", "createdAt": "2020-08-13T22:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223991", "bodyText": "Where is the IOException coming from and does that need to be handled separately?", "author": "abanthiy", "createdAt": "2020-08-13T20:19:33Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n+                    logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n+                            + \" requested to complete bootstrap task\");\n+\n+                    shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+                } catch (ServiceUpdateException | IOException e) {", "originalCommit": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0ODI2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470248264", "bodyText": "IOException can happen when saving bootstrap status to file. I cannot think of a better way to recover from IOException", "author": "hui-yang", "createdAt": "2020-08-13T21:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk5MQ=="}], "type": "inlineReview"}]}