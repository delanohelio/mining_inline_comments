{"pr_number": 168, "pr_title": "Refactor: Split EvergreenService and Lifecycle", "pr_createdAt": "2020-04-08T22:06:05Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168", "timeline": [{"oid": "2a2b3a185e02b48eeeeec837291ac0de9f64689f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2a2b3a185e02b48eeeeec837291ac0de9f64689f", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-08T22:15:23Z", "type": "forcePushed"}, {"oid": "1816d832067d7e49c44920b75ed0dcae11d14d1c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1816d832067d7e49c44920b75ed0dcae11d14d1c", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-08T22:49:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjQ2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405876460", "bodyText": "do we always continue in INSTALLED?", "author": "ShirleyZheng92", "createdAt": "2020-04-08T23:43:13Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")\n+public class Lifecycle {\n+    public static final String SERVICE_INVALID_STATE_ERROR = \"service-invalid-state-error\";\n+    private final EvergreenService evergreenService;\n+    private final Topic stateTopic;\n+    private final Logger logger;\n+    private Future backingTask = CompletableFuture.completedFuture(null);\n+    private String backingTaskName;\n+    private State prevState;\n+    @Getter\n+    private Future<?> lifecycleFuture;\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+    private final Object stateEventLock = new Object();\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <RUNNING>\n+    // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n+    private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n+    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n+            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n+    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+    /**\n+     * Constructor for lifecycle.\n+     *\n+     * @param evergreenService service that this is the lifecycle for\n+     * @param state            service's state topic\n+     */\n+    public Lifecycle(EvergreenService evergreenService, Topic state) {\n+        this.evergreenService = evergreenService;\n+        this.prevState = State.NEW;\n+        this.stateTopic = state;\n+        this.logger = evergreenService.getLogger();\n+    }\n+\n+    private void updateStateAndBroadcast(State newState) {\n+        final State currentState = evergreenService.getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        logger.atInfo().setEventType(\"service-set-state\").kv(EvergreenService.CURRENT_STATE_METRIC_NAME, currentState)\n+                .kv(\"newState\", newState).log();\n+\n+        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+        // across different services.\n+        synchronized (State.class) {\n+            prevState = currentState;\n+            stateTopic.withValue(newState);\n+            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+        }\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are RUNNING, FINISHED, ERRORED.\n+     *\n+     * @param newState reported state from the service which should eventually be set as the service's\n+     *                 actual state\n+     */\n+    synchronized void reportState(State newState) {\n+        logger.atInfo().setEventType(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError().setEventType(SERVICE_INVALID_STATE_ERROR).kv(\"newState\", newState)\n+                    .log(\"Invalid report state\");\n+        }\n+        // TODO: Add more validations\n+\n+        if (evergreenService.getState().equals(State.INSTALLED) && newState.equals(State.FINISHED)) {\n+            // if a service doesn't have any run logic, request stop on service to clean up DesiredStateList\n+            requestStop();\n+        }\n+\n+        enqueueStateEvent(newState);\n+    }\n+\n+    private Optional<State> getReportState() {\n+        Object top = stateEventQueue.poll();\n+        if (top instanceof State) {\n+            return Optional.of((State) top);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Returns true if the service has reached its desired state.\n+     *\n+     * @return\n+     */\n+    public boolean reachedDesiredState() {\n+        synchronized (desiredStateList) {\n+            return desiredStateList.isEmpty()\n+                    // when reachedDesiredState() is called in global state listener,\n+                    // service lifecycle thread hasn't drained the desiredStateList yet.\n+                    // Therefore adding this check.\n+                    || desiredStateList.stream().allMatch(s -> s == evergreenService.getState());\n+        }\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first.equals(activeState)) {\n+                desiredStateList.remove(first);\n+                // ignore remove() return value as it's possible that desiredStateList update\n+            }\n+            return Optional.ofNullable(first);\n+        }\n+    }\n+\n+    void setDesiredState(State... state) {\n+        // Set desiredStateList and override existing desiredStateList.\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private void enqueueStateEvent(Object event) {\n+        synchronized (stateEventLock) {\n+            if (event instanceof State) {\n+                // override existing reportState\n+                stateEventQueue.clear();\n+                stateEventQueue.offer(event);\n+            } else {\n+                stateEventQueue.offer(event);\n+\n+                // Ignore returned value of offer().\n+                // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+                // trigger to process state transition.\n+            }\n+        }\n+    }\n+\n+    void startStateTransition() throws InterruptedException {\n+        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+            Optional<State> desiredState;\n+            State current = evergreenService.getState();\n+            logger.atInfo().setEventType(\"service-state-transition-start\")\n+                    .kv(EvergreenService.CURRENT_STATE_METRIC_NAME, current).log();\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState.isPresent() && desiredState.get().equals(current)) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+            switch (current) {\n+                case BROKEN:\n+                    return;\n+                case NEW:\n+                    if (handleCurrentStateNew(desiredState)) {\n+                        break;\n+                    }\n+                    continue;\n+                case INSTALLED:\n+                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n+                        break;\n+                    }\n+                    continue;", "originalCommit": "1816d832067d7e49c44920b75ed0dcae11d14d1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwMDU5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405900594", "bodyText": "No, fixed.", "author": "MikeDombo", "createdAt": "2020-04-09T01:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzA4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405877081", "bodyText": "NIT: i believe you reverted Feng's change", "author": "ShirleyZheng92", "createdAt": "2020-04-08T23:45:13Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -793,11 +373,8 @@ private boolean dependersExited(List<EvergreenService> dependers) {\n \n     private boolean dependencyReady() {\n         List<EvergreenService> ret =\n-                dependencies.entrySet()\n-                        .stream()\n-                        .filter(e -> !dependencyReady(e.getKey(), e.getValue().startWhen))\n-                        .map(Map.Entry::getKey)\n-                        .collect(Collectors.toList());\n+                dependencies.entrySet().stream().filter(e -> !dependencyReady(e.getKey(), e.getValue().startWhen))\n+                        .map(Map.Entry::getKey).collect(Collectors.toList());", "originalCommit": "1816d832067d7e49c44920b75ed0dcae11d14d1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzQzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405877438", "bodyText": "I feel LifecycletTopic can be a field in lifecycle class", "author": "ShirleyZheng92", "createdAt": "2020-04-08T23:46:35Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -970,21 +531,12 @@ public boolean satisfiedBy(Set<EvergreenService> ready) {\n         return ready.containsAll(dependencies.keySet());\n     }\n \n-    public enum RunStatus {\n-        OK, NothingDone, Errored\n-    }\n-\n-    public interface GlobalStateChangeListener {\n-        void globalServiceStateChanged(EvergreenService l, State oldState, State newState);\n+    protected Topics getLifecycleTopic() {\n+        return config.findInteriorChild(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n     }", "originalCommit": "1816d832067d7e49c44920b75ed0dcae11d14d1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f4a6393042932e7c999e3bfb78bdd5eaa85a77e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6f4a6393042932e7c999e3bfb78bdd5eaa85a77e", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-09T01:07:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxNzQ3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405917470", "bodyText": "This seems unused in this class now, could just move it to Lifecycle class and make it a private constant there", "author": "shaguptashaikh", "createdAt": "2020-04-09T02:14:00Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -57,43 +46,25 @@\n     public static final String TIMEOUT_NAMESPACE_TOPIC = \"timeout\";\n     public static final Integer DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC = 120;\n     public static final Integer DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC = 120;\n-    private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n-    private static final String INVALID_STATE_ERROR_EVENT = \"service-invalid-state-error\";\n+    static final String CURRENT_STATE_METRIC_NAME = \"currentState\";", "originalCommit": "6f4a6393042932e7c999e3bfb78bdd5eaa85a77e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxODk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405918966", "bodyText": "Nit- I would pass in the logger to the constructor of Lifecycle or make it default, that way it is accessible only where you intend it to be, a public getter method exposes it to everyone, and doing that for the logger instance is a bit odd", "author": "shaguptashaikh", "createdAt": "2020-04-09T02:19:56Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -57,43 +46,25 @@\n     public static final String TIMEOUT_NAMESPACE_TOPIC = \"timeout\";\n     public static final Integer DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC = 120;\n     public static final Integer DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC = 120;\n-    private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n-    private static final String INVALID_STATE_ERROR_EVENT = \"service-invalid-state-error\";\n+    static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n \n     protected final Topics config;\n     public Context context;\n \n-    private final Object dependencyReadyLock = new Object();\n-    private final Object dependersExitedLock = new Object();\n     private final Topic state;\n+    private final Lifecycle lifecycle;\n+    private final Object dependersExitedLock = new Object();\n     private Throwable error;\n-    private Future backingTask = CompletableFuture.completedFuture(null);\n-    private String backingTaskName;\n     private Periodicity periodicityInformation;\n-    private State prevState = State.NEW;\n-    private Future<?> lifecycleFuture;\n-    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-    // A state event can be a state transition event, or a desired state updated notification.\n-    // TODO: make class of StateEvent instead of generic object.\n-    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n-    private final Object stateEventLock = new Object();\n-\n-    // DesiredStateList is used to set desired path of state transition.\n-    // Eg. Start a service will need DesiredStateList to be <RUNNING>\n-    // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n-    private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n-\n-    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n-            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n+    private final Object dependencyReadyLock = new Object();\n \n     // dependencies that are explicitly declared by customer in config store.\n     private final Topic externalDependenciesTopic;\n     // Services that this service depends on.\n     // Includes both explicit declared dependencies and implicit ones added through 'autoStart' and @Inject annotation.\n     protected final ConcurrentHashMap<EvergreenService, DependencyInfo> dependencies = new ConcurrentHashMap<>();\n-\n     // Service logger instance\n+    @Getter", "originalCommit": "6f4a6393042932e7c999e3bfb78bdd5eaa85a77e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5dd1dc30befd4dd962643f27d9e9d85e80eb1ab9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5dd1dc30befd4dd962643f27d9e9d85e80eb1ab9", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-09T18:33:32Z", "type": "forcePushed"}, {"oid": "b5f8fc2bc4bd29e573dfe8e40ade029e1bf3a0dc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b5f8fc2bc4bd29e573dfe8e40ade029e1bf3a0dc", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-09T20:28:20Z", "type": "forcePushed"}, {"oid": "62ff57b548c3db99882bded24494c348260c19a7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62ff57b548c3db99882bded24494c348260c19a7", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-09T22:47:45Z", "type": "commit"}, {"oid": "62ff57b548c3db99882bded24494c348260c19a7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62ff57b548c3db99882bded24494c348260c19a7", "message": "Refactor: Split EvergreenService and Lifecycle", "committedDate": "2020-04-09T22:47:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzUzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406523532", "bodyText": "Seems this reverted Feng's change?", "author": "ShirleyZheng92", "createdAt": "2020-04-09T23:04:05Z", "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -115,16 +115,8 @@ public void fire(WhatHappened what) {\n                 .addKeyValue(\"reason\", what.name()).log();\n         if (watchers != null) {\n             for (Watcher s : watchers) {\n-                try {", "originalCommit": "62ff57b548c3db99882bded24494c348260c19a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzgyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406523829", "bodyText": "His was a bad merge, so mine fixes his.", "author": "MikeDombo", "createdAt": "2020-04-09T23:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDk3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406524974", "bodyText": "Curious, does this have to be on method level?", "author": "ShirleyZheng92", "createdAt": "2020-04-09T23:09:29Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")", "originalCommit": "62ff57b548c3db99882bded24494c348260c19a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyOTU5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406529596", "bodyText": "It applied to all methods that synchronized on the desired state list, so I just added this at the class level instead of all those individual places.", "author": "MikeDombo", "createdAt": "2020-04-09T23:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDk3NA=="}], "type": "inlineReview"}]}