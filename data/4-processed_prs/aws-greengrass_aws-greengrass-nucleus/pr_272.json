{"pr_number": 272, "pr_title": "Add readme for config schema", "pr_createdAt": "2020-06-05T19:33:58Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4ODY2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436188664", "bodyText": "What's the difference of load and apply diff?", "author": "hui-yang", "createdAt": "2020-06-05T22:16:07Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU4OTQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r437589452", "bodyText": "I'll change 'apply diff' to config merge.", "author": "ShirleyZheng92", "createdAt": "2020-06-09T17:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4ODY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4ODc3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436188773", "bodyText": "typo: starts", "author": "hui-yang", "createdAt": "2020-06-05T22:16:26Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4OTMyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436189325", "bodyText": "What's separate doc? I think it's ok if we don't explain all design choices here.", "author": "hui-yang", "createdAt": "2020-06-05T22:18:23Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4OTk4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436189980", "bodyText": "typo: Root.\nnit: can we avoid using component here? \ud83d\ude04", "author": "hui-yang", "createdAt": "2020-06-05T22:20:55Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MDI3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436190272", "bodyText": "typo: include\nDo we support pluggable EG components now?", "author": "hui-yang", "createdAt": "2020-06-05T22:22:01Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.\n+\n+## Service Config Components\n+\n+### Lifecycle\n+\n+\u2018Services\u2019 field contains all services config. Services including custom services and pluggable evergreen components.  ", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU4OTk3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r437589977", "bodyText": "I'll remove the unimplemented feature from this md now", "author": "ShirleyZheng92", "createdAt": "2020-06-09T17:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MDI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTI2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436191260", "bodyText": "nit: I think these four settings can be consolidated to one model description, or explicitly discuss each lifecycle key with or without an example, but I'll trust your decision.", "author": "hui-yang", "createdAt": "2020-06-05T22:25:46Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.\n+\n+## Service Config Components\n+\n+### Lifecycle\n+\n+\u2018Services\u2019 field contains all services config. Services including custom services and pluggable evergreen components.  \n+\n+```\n+services: \n+<serviceName>:\n+  lifecycle:\n+    install:\n+      skipif: onpath <executable>|exists <file>\n+      script:\n+      timeout: # default to be infinity. Number of seconds to timeout.\n+      environment (currently setenv): # optional\n+      \n+    startup: # mutually exclusive from 'run'\n+      script: # eg: brew services start influxdb\n+      timeout: # Optional\n+      environment:  # optional\n+        <key>: overrideValue\n+        \n+    run: # mutually exclusive from 'startup'\n+      script:\n+      environment:\n+      timeout: # Optional\n+      periodicity: #Perodically run the command\n+      \n+    shutdown: # can co-exist with both startup/run\n+      script:\n+      environment: #optional\n+      timeout: # Optional", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTc1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436191758", "bodyText": "For my info, does install/startup/run/shutdown support retryPolicy?", "author": "hui-yang", "createdAt": "2020-06-05T22:27:36Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.\n+\n+## Service Config Components\n+\n+### Lifecycle\n+\n+\u2018Services\u2019 field contains all services config. Services including custom services and pluggable evergreen components.  \n+\n+```\n+services: \n+<serviceName>:\n+  lifecycle:\n+    install:\n+      skipif: onpath <executable>|exists <file>\n+      script:\n+      timeout: # default to be infinity. Number of seconds to timeout.\n+      environment (currently setenv): # optional\n+      \n+    startup: # mutually exclusive from 'run'\n+      script: # eg: brew services start influxdb\n+      timeout: # Optional\n+      environment:  # optional\n+        <key>: overrideValue\n+        \n+    run: # mutually exclusive from 'startup'\n+      script:\n+      environment:\n+      timeout: # Optional\n+      periodicity: #Perodically run the command\n+      \n+    shutdown: # can co-exist with both startup/run\n+      script:\n+      environment: #optional\n+      timeout: # Optional\n+    \n+    environment: # apply to all commands\n+      <key>: defaultValue\n+    \n+    healthcheck: # do health check when service is in Running\n+      script: # non-zero exit trigger error\n+      checkPeriod: # optional, default to be 0\n+      environment: #override\n+      \n+    recover:\n+      script: # will be run every time service enters error.\n+      environment: #override\n+      # referring to https://docs.docker.com/v17.12/compose/compose-file/#restart_policy\n+      retryPolicy:\n+        delay: # default to be 0. Time to wait between retry.\n+        maxAttempts: # default to be infinite. After N times of error, service enter Broken state.\n+        window: # How long to wait before deciding if a restart has succeeded", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MTYyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r437591620", "bodyText": "Nope. Install failure directly goes to error and state machine handles retry.", "author": "ShirleyZheng92", "createdAt": "2020-06-09T17:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MjE3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436192175", "bodyText": "Add an extra new line before this, if that's your intended format. Same for 2 other places.", "author": "hui-yang", "createdAt": "2020-06-05T22:29:14Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5Njk3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436196976", "bodyText": "I would rephrase the section a little with the same information. One option:\nServices can define custom configurations in the \u2018custom\u2019 field. Custom configurations are passed to services through IPC. Service can listen on config changes via IPC and apply the new configuration without being forced to restart by Kernel. Details of how configuration change push/listening can be supported is documented in Configuration IPC Application and Dynamically reload config without restarting Evergreen service\n\nNote: Currently custom configuration only support one level key-value. Detailed discussion is at Custom config supporting complex data structure", "author": "hui-yang", "createdAt": "2020-06-05T22:48:03Z", "path": "README_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.\n+\n+## Service Config Components\n+\n+### Lifecycle\n+\n+\u2018Services\u2019 field contains all services config. Services including custom services and pluggable evergreen components.  \n+\n+```\n+services: \n+<serviceName>:\n+  lifecycle:\n+    install:\n+      skipif: onpath <executable>|exists <file>\n+      script:\n+      timeout: # default to be infinity. Number of seconds to timeout.\n+      environment (currently setenv): # optional\n+      \n+    startup: # mutually exclusive from 'run'\n+      script: # eg: brew services start influxdb\n+      timeout: # Optional\n+      environment:  # optional\n+        <key>: overrideValue\n+        \n+    run: # mutually exclusive from 'startup'\n+      script:\n+      environment:\n+      timeout: # Optional\n+      periodicity: #Perodically run the command\n+      \n+    shutdown: # can co-exist with both startup/run\n+      script:\n+      environment: #optional\n+      timeout: # Optional\n+    \n+    environment: # apply to all commands\n+      <key>: defaultValue\n+    \n+    healthcheck: # do health check when service is in Running\n+      script: # non-zero exit trigger error\n+      checkPeriod: # optional, default to be 0\n+      environment: #override\n+      \n+    recover:\n+      script: # will be run every time service enters error.\n+      environment: #override\n+      # referring to https://docs.docker.com/v17.12/compose/compose-file/#restart_policy\n+      retryPolicy:\n+        delay: # default to be 0. Time to wait between retry.\n+        maxAttempts: # default to be infinite. After N times of error, service enter Broken state.\n+        window: # How long to wait before deciding if a restart has succeeded\n+        \n+    checkIfSafeToUpdate:\n+       recheckPeriod: 5\n+       script:\n+\n+    updatesCompleted:\n+       script:\n+```\n+\n+### Dependency\n+\n+Detailed documentation is at [Evergreen Service Hot-pluggable Dependencies](https://quip-amazon.com/y29dAC02fUBu)\n+\n+```\n+myCustomService:\n+  dependencies:\n+    - <serviceName>:dependencyType\n+```\n+\n+**DependencyType**\n+DependencyType is either **SOFT or HARD**\n+\n+### Logging\n+\n+Detailed design doc at: [[Design] Evergreen Logging Service](https://quip-amazon.com/QbwaANkaR95C)\n+\n+### Custom configuration\n+", "originalCommit": "018ae0696045988aaa127e514279ce97c217831a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3acc2eb707c1bf0fe7dbd539eda9e29620f118a8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3acc2eb707c1bf0fe7dbd539eda9e29620f118a8", "message": "Add readme for config schema", "committedDate": "2020-06-08T18:58:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTI2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436989265", "bodyText": "services also have version.", "author": "MikeDombo", "createdAt": "2020-06-08T20:43:44Z", "path": "README_CONFIG_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service", "originalCommit": "3acc2eb707c1bf0fe7dbd539eda9e29620f118a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU3ODEwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r437578108", "bodyText": "Sure. I just realized we haven't discussed kernel config schema versioning. Need to bring this up too", "author": "ShirleyZheng92", "createdAt": "2020-06-09T16:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTM5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436989394", "bodyText": "capitalize root", "author": "MikeDombo", "createdAt": "2020-06-08T20:43:58Z", "path": "README_CONFIG_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.", "originalCommit": "3acc2eb707c1bf0fe7dbd539eda9e29620f118a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r436989629", "bodyText": "environment isn't a key, unless you want us to change it.", "author": "MikeDombo", "createdAt": "2020-06-08T20:44:26Z", "path": "README_CONFIG_SCHEMA.md", "diffHunk": "@@ -0,0 +1,152 @@\n+# Evergreen Kernel Configuration Schema\n+Detailed doc in https://quip-amazon.com/35xMAtuSgvha\n+\n+## Resolve config workflow\n+\n+**Config load**\n+Raw yaml file \u2192 Resolve platform & Platform Validation (eg: return error on unrecognized platform) \u2192 Resolve Config & Validation \u2192 take effect\n+\n+**Config Applying diff**\n+Load raw yaml file of the new config \u2192 Resolve platform & Platform Validation \u2192 Resolve Config & validation\n+\n+Once the config is resolved and loaded in memory, it doesn\u2019t have any platform branches.\n+\n+## Config Schema - Overview\n+\n+Config file defines how kernel start each service.\n+A config file in kernel memory after resolving platform looks like below:\n+\n+```\n+version:\n+  <version> # Discussed in separate doc of schema versioning\n+services:\n+  <service1>: #Service name uniquely identifies a service\n+    dependencies: # declare dependency, \n+      - <serviceName>:[SOFT/HARD]\n+        \n+    lifecycle: # lifecycle commands.\n+    \n+    logging: # logging config.\n+      \n+    custom: # custom config. \n+    \n+  <service2>:\n+    lifecycle:\n+    logging:\n+    \n+system:\n+  <kernel system config> \n+```\n+\n+### Config Validation\n+\n+root keys have to be recognized keys. Each component has its own validation logic.\n+\n+## Service Config Components\n+\n+### Lifecycle\n+\n+\u2018Services\u2019 field contains all services config. Services including custom services and pluggable evergreen components.  \n+\n+```\n+services: \n+<serviceName>:\n+  lifecycle:\n+    install:\n+      skipif: onpath <executable>|exists <file>\n+      script:\n+      timeout: # default to be infinity. Number of seconds to timeout.\n+      environment (currently setenv): # optional\n+      \n+    startup: # mutually exclusive from 'run'\n+      script: # eg: brew services start influxdb\n+      timeout: # Optional\n+      environment:  # optional\n+        <key>: overrideValue\n+        \n+    run: # mutually exclusive from 'startup'\n+      script:\n+      environment:\n+      timeout: # Optional\n+      periodicity: #Perodically run the command\n+      \n+    shutdown: # can co-exist with both startup/run\n+      script:\n+      environment: #optional\n+      timeout: # Optional\n+    \n+    environment: # apply to all commands", "originalCommit": "3acc2eb707c1bf0fe7dbd539eda9e29620f118a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU3ODQxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/272#discussion_r437578415", "bodyText": "I'll keep the current setenv", "author": "ShirleyZheng92", "createdAt": "2020-06-09T16:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTYyOQ=="}], "type": "inlineReview"}, {"oid": "ea8f8ddffe42b1588ca7c3c40a16c17c13c930cc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea8f8ddffe42b1588ca7c3c40a16c17c13c930cc", "message": "Add readme for config schema", "committedDate": "2020-06-09T17:10:40Z", "type": "forcePushed"}, {"oid": "780416f3916bf663fdbc744eb772557f1ae51896", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/780416f3916bf663fdbc744eb772557f1ae51896", "message": "Add readme for config schema", "committedDate": "2020-06-09T17:28:04Z", "type": "commit"}, {"oid": "780416f3916bf663fdbc744eb772557f1ae51896", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/780416f3916bf663fdbc744eb772557f1ae51896", "message": "Add readme for config schema", "committedDate": "2020-06-09T17:28:04Z", "type": "forcePushed"}]}