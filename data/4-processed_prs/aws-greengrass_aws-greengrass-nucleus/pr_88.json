{"pr_number": 88, "pr_title": "Deployment service integration", "pr_createdAt": "2020-02-28T08:44:59Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88", "timeline": [{"oid": "51719c65345e0ede474ddff6a583c956b6e85ed8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/51719c65345e0ede474ddff6a583c956b6e85ed8", "message": "Deployment service initial implementation", "committedDate": "2020-02-28T06:13:31Z", "type": "commit"}, {"oid": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "message": "Integrating with Package manger and resolve configuration APIs", "committedDate": "2020-02-28T08:21:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5OTIwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385799200", "bodyText": "Go ahead and make all of these final unless you do write to them more than once.", "author": "MikeDombo", "createdAt": "2020-02-28T16:39:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -3,39 +3,40 @@\n \n package com.aws.iot.evergreen.deployment;\n \n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.PackageDownloadingState;\n+import com.aws.iot.evergreen.deployment.state.ParseAndValidateState;\n import com.aws.iot.evergreen.deployment.state.State;\n import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.PackageManager;\n-import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.Getter;\n import lombok.Setter;\n \n import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n /**\n  * Deployment as a process that controls state transition and passes context among\n  * deployment states.\n  */\n-public class DeploymentProcess {\n+public class DeploymentProcess implements Callable<Boolean> {\n \n     // TODO : This object should control all states and transitions\n     // and not let itself be modified by other states\n-    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n \n     private static final long DEPLOYMENT_STATE_CHANGE_WAIT_TIME_SECONDS = 2;\n \n-    @Getter\n-    private final State downloadedState;\n-\n-    @Getter\n-    private final State updatingKernelState;\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+    private ObjectMapper objectMapper;\n+    private Kernel kernel;\n+    private PackageManager packageManager;", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5OTY2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385799665", "bodyText": "[typo]\nvalidating", "author": "MikeDombo", "createdAt": "2020-02-28T16:40:00Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -44,54 +45,86 @@\n     @Getter\n     private final DeploymentPacket deploymentPacket;\n \n-    @Getter\n-    @Setter\n-    private Set<Package> packagesToDeploy;\n-\n-    @Getter\n-    @Setter\n-    private Set<String> removedTopLevelPackageNames;\n-\n     @Getter\n     @Setter\n     private Map<Object, Object> resolvedKernelConfig;\n \n     /**\n      * Constructor to initialize deployment process.\n      *\n-     * @param packet parsed deployment document\n-     * @param kernel running kernel instance\n+     * @param deploymentPacket parsed deployment document\n      */\n-    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n-        this.downloadedState = new DownloadedState(this, kernel);\n-        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n-\n-        // TODO : Change this to appropriate initial state when the initial state is implemented\n-        this.currentState = this.downloadedState;\n-        this.deploymentPacket = packet;\n+    public DeploymentProcess(DeploymentPacket deploymentPacket, ObjectMapper objectMapper, Kernel kernel,\n+                             PackageManager packageManager) {\n+        this.objectMapper = objectMapper;\n+        this.currentState = new ParseAndValidateState(deploymentPacket, objectMapper);\n+        this.kernel = kernel;\n+        this.packageManager = packageManager;\n+        deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.VALIDATE_AND_PARSE);\n+        this.deploymentPacket = deploymentPacket;\n     }\n \n     /**\n      * Execute deployment.\n+     *\n+     * @return\n      */\n-    public void execute() {\n+    public Boolean execute() throws DeploymentFailureException {\n         // TODO : Letting this state machine be modified by individual states is not very maintainable\n         // When the state machine is redesigned, have this class manage passing context to states and\n         // control state transitions\n-        while (!currentState.isFinalState()) {\n-            if (currentState.canProceed()) {\n-                currentState.proceed();\n-            } else {\n-                try {\n-                    int duration = 2;\n-                    TimeUnit.SECONDS.sleep(2);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    break;\n+        try {\n+            while (!currentState.isFinalState()) {\n+                if (currentState.canProceed()) {\n+                    currentState.proceed();\n+                    switch (deploymentPacket.getProcessStatus()) {\n+                        //TODO: Rename these states\n+                        case VALIDATE_AND_PARSE: {\n+                            logger.info(\"Finished validatin and parsing. Going to downloading\");", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMDU0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385800540", "bodyText": "I don't think this log will work really since you haven't provided a placeholder ({}). But you should probably add it as a k-v pair instead, like logger.atInfo().addKeyValue(\"deploymentPacket\", deploymentPacket).log(\"Package downloaded...\")", "author": "MikeDombo", "createdAt": "2020-02-28T16:41:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -44,54 +45,86 @@\n     @Getter\n     private final DeploymentPacket deploymentPacket;\n \n-    @Getter\n-    @Setter\n-    private Set<Package> packagesToDeploy;\n-\n-    @Getter\n-    @Setter\n-    private Set<String> removedTopLevelPackageNames;\n-\n     @Getter\n     @Setter\n     private Map<Object, Object> resolvedKernelConfig;\n \n     /**\n      * Constructor to initialize deployment process.\n      *\n-     * @param packet parsed deployment document\n-     * @param kernel running kernel instance\n+     * @param deploymentPacket parsed deployment document\n      */\n-    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n-        this.downloadedState = new DownloadedState(this, kernel);\n-        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n-\n-        // TODO : Change this to appropriate initial state when the initial state is implemented\n-        this.currentState = this.downloadedState;\n-        this.deploymentPacket = packet;\n+    public DeploymentProcess(DeploymentPacket deploymentPacket, ObjectMapper objectMapper, Kernel kernel,\n+                             PackageManager packageManager) {\n+        this.objectMapper = objectMapper;\n+        this.currentState = new ParseAndValidateState(deploymentPacket, objectMapper);\n+        this.kernel = kernel;\n+        this.packageManager = packageManager;\n+        deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.VALIDATE_AND_PARSE);\n+        this.deploymentPacket = deploymentPacket;\n     }\n \n     /**\n      * Execute deployment.\n+     *\n+     * @return\n      */\n-    public void execute() {\n+    public Boolean execute() throws DeploymentFailureException {\n         // TODO : Letting this state machine be modified by individual states is not very maintainable\n         // When the state machine is redesigned, have this class manage passing context to states and\n         // control state transitions\n-        while (!currentState.isFinalState()) {\n-            if (currentState.canProceed()) {\n-                currentState.proceed();\n-            } else {\n-                try {\n-                    int duration = 2;\n-                    TimeUnit.SECONDS.sleep(2);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    break;\n+        try {\n+            while (!currentState.isFinalState()) {\n+                if (currentState.canProceed()) {\n+                    currentState.proceed();\n+                    switch (deploymentPacket.getProcessStatus()) {\n+                        //TODO: Rename these states\n+                        case VALIDATE_AND_PARSE: {\n+                            logger.info(\"Finished validatin and parsing. Going to downloading\");\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.PACKAGE_DOWNLOADING);\n+                            currentState = new PackageDownloadingState(deploymentPacket, objectMapper, packageManager);\n+                            break;\n+                        }\n+                        case PACKAGE_DOWNLOADING: {\n+                            logger.info(\"Package downloaded. Next step is to create config for kernel\",", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMTcyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385801725", "bodyText": "For our logging, when you have put a k-v pair then don't use a message that sounds like it wants a placeholder. I think the better way to do this would be logger.atInfo().setEventType(\"deployment-state-machine-end\").addKeyValue(...).log()", "author": "MikeDombo", "createdAt": "2020-02-28T16:43:27Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -44,54 +45,86 @@\n     @Getter\n     private final DeploymentPacket deploymentPacket;\n \n-    @Getter\n-    @Setter\n-    private Set<Package> packagesToDeploy;\n-\n-    @Getter\n-    @Setter\n-    private Set<String> removedTopLevelPackageNames;\n-\n     @Getter\n     @Setter\n     private Map<Object, Object> resolvedKernelConfig;\n \n     /**\n      * Constructor to initialize deployment process.\n      *\n-     * @param packet parsed deployment document\n-     * @param kernel running kernel instance\n+     * @param deploymentPacket parsed deployment document\n      */\n-    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n-        this.downloadedState = new DownloadedState(this, kernel);\n-        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n-\n-        // TODO : Change this to appropriate initial state when the initial state is implemented\n-        this.currentState = this.downloadedState;\n-        this.deploymentPacket = packet;\n+    public DeploymentProcess(DeploymentPacket deploymentPacket, ObjectMapper objectMapper, Kernel kernel,\n+                             PackageManager packageManager) {\n+        this.objectMapper = objectMapper;\n+        this.currentState = new ParseAndValidateState(deploymentPacket, objectMapper);\n+        this.kernel = kernel;\n+        this.packageManager = packageManager;\n+        deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.VALIDATE_AND_PARSE);\n+        this.deploymentPacket = deploymentPacket;\n     }\n \n     /**\n      * Execute deployment.\n+     *\n+     * @return\n      */\n-    public void execute() {\n+    public Boolean execute() throws DeploymentFailureException {\n         // TODO : Letting this state machine be modified by individual states is not very maintainable\n         // When the state machine is redesigned, have this class manage passing context to states and\n         // control state transitions\n-        while (!currentState.isFinalState()) {\n-            if (currentState.canProceed()) {\n-                currentState.proceed();\n-            } else {\n-                try {\n-                    int duration = 2;\n-                    TimeUnit.SECONDS.sleep(2);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    break;\n+        try {\n+            while (!currentState.isFinalState()) {\n+                if (currentState.canProceed()) {\n+                    currentState.proceed();\n+                    switch (deploymentPacket.getProcessStatus()) {\n+                        //TODO: Rename these states\n+                        case VALIDATE_AND_PARSE: {\n+                            logger.info(\"Finished validatin and parsing. Going to downloading\");\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.PACKAGE_DOWNLOADING);\n+                            currentState = new PackageDownloadingState(deploymentPacket, objectMapper, packageManager);\n+                            break;\n+                        }\n+                        case PACKAGE_DOWNLOADING: {\n+                            logger.info(\"Package downloaded. Next step is to create config for kernel\",\n+                                    deploymentPacket.toString());\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.PACKAGE_DOWNLOADED);\n+                            currentState = new DownloadedState(deploymentPacket, objectMapper, kernel);\n+                            break;\n+                        }\n+                        case PACKAGE_DOWNLOADED: { //TODO: Consider renaming this to Create config\n+                            logger.info(\"Created config for kernel. Next is to update the kernel\",\n+                                    deploymentPacket.toString());\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.UPDATING_KERNEL);\n+                            currentState = new UpdatingKernelState(deploymentPacket, objectMapper, kernel);\n+                            break;\n+                        }\n+                        case UPDATING_KERNEL: {\n+                            logger.info(\"Updated kernel\",\n+                                    deploymentPacket.toString());\n+                            break;\n+                        }\n+                        default: {\n+                            logger.error(\"Unexpected status for deployment process with deployment Id {}\",\n+                                    deploymentPacket.getDeploymentId());\n+                            return Boolean.FALSE;\n+                        }\n+                    }\n+                } else {\n+                    try {\n+                        TimeUnit.SECONDS.sleep(DEPLOYMENT_STATE_CHANGE_WAIT_TIME_SECONDS);\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        break;\n+                    }\n                 }\n             }\n+            logger.atInfo().addKeyValue(\"final_state\", currentState.getClass().getSimpleName()).log(\"final state is\");", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMTg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385801873", "bodyText": "Log exception, or at least rethrow so the caller can handle it?", "author": "MikeDombo", "createdAt": "2020-02-28T16:43:41Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -44,54 +45,86 @@\n     @Getter\n     private final DeploymentPacket deploymentPacket;\n \n-    @Getter\n-    @Setter\n-    private Set<Package> packagesToDeploy;\n-\n-    @Getter\n-    @Setter\n-    private Set<String> removedTopLevelPackageNames;\n-\n     @Getter\n     @Setter\n     private Map<Object, Object> resolvedKernelConfig;\n \n     /**\n      * Constructor to initialize deployment process.\n      *\n-     * @param packet parsed deployment document\n-     * @param kernel running kernel instance\n+     * @param deploymentPacket parsed deployment document\n      */\n-    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n-        this.downloadedState = new DownloadedState(this, kernel);\n-        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n-\n-        // TODO : Change this to appropriate initial state when the initial state is implemented\n-        this.currentState = this.downloadedState;\n-        this.deploymentPacket = packet;\n+    public DeploymentProcess(DeploymentPacket deploymentPacket, ObjectMapper objectMapper, Kernel kernel,\n+                             PackageManager packageManager) {\n+        this.objectMapper = objectMapper;\n+        this.currentState = new ParseAndValidateState(deploymentPacket, objectMapper);\n+        this.kernel = kernel;\n+        this.packageManager = packageManager;\n+        deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.VALIDATE_AND_PARSE);\n+        this.deploymentPacket = deploymentPacket;\n     }\n \n     /**\n      * Execute deployment.\n+     *\n+     * @return\n      */\n-    public void execute() {\n+    public Boolean execute() throws DeploymentFailureException {\n         // TODO : Letting this state machine be modified by individual states is not very maintainable\n         // When the state machine is redesigned, have this class manage passing context to states and\n         // control state transitions\n-        while (!currentState.isFinalState()) {\n-            if (currentState.canProceed()) {\n-                currentState.proceed();\n-            } else {\n-                try {\n-                    int duration = 2;\n-                    TimeUnit.SECONDS.sleep(2);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    break;\n+        try {\n+            while (!currentState.isFinalState()) {\n+                if (currentState.canProceed()) {\n+                    currentState.proceed();\n+                    switch (deploymentPacket.getProcessStatus()) {\n+                        //TODO: Rename these states\n+                        case VALIDATE_AND_PARSE: {\n+                            logger.info(\"Finished validatin and parsing. Going to downloading\");\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.PACKAGE_DOWNLOADING);\n+                            currentState = new PackageDownloadingState(deploymentPacket, objectMapper, packageManager);\n+                            break;\n+                        }\n+                        case PACKAGE_DOWNLOADING: {\n+                            logger.info(\"Package downloaded. Next step is to create config for kernel\",\n+                                    deploymentPacket.toString());\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.PACKAGE_DOWNLOADED);\n+                            currentState = new DownloadedState(deploymentPacket, objectMapper, kernel);\n+                            break;\n+                        }\n+                        case PACKAGE_DOWNLOADED: { //TODO: Consider renaming this to Create config\n+                            logger.info(\"Created config for kernel. Next is to update the kernel\",\n+                                    deploymentPacket.toString());\n+                            deploymentPacket.setProcessStatus(DeploymentPacket.ProcessStatus.UPDATING_KERNEL);\n+                            currentState = new UpdatingKernelState(deploymentPacket, objectMapper, kernel);\n+                            break;\n+                        }\n+                        case UPDATING_KERNEL: {\n+                            logger.info(\"Updated kernel\",\n+                                    deploymentPacket.toString());\n+                            break;\n+                        }\n+                        default: {\n+                            logger.error(\"Unexpected status for deployment process with deployment Id {}\",\n+                                    deploymentPacket.getDeploymentId());\n+                            return Boolean.FALSE;\n+                        }\n+                    }\n+                } else {\n+                    try {\n+                        TimeUnit.SECONDS.sleep(DEPLOYMENT_STATE_CHANGE_WAIT_TIME_SECONDS);\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        break;\n+                    }\n                 }\n             }\n+            logger.atInfo().addKeyValue(\"final_state\", currentState.getClass().getSimpleName()).log(\"final state is\");\n+            return Boolean.TRUE;\n+        } catch (DeploymentFailureException e) {\n+            //TODO: Update deployment packet with status details", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjU0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385966544", "bodyText": "Done", "author": "abanthiy", "createdAt": "2020-02-28T23:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMjM2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385802361", "bodyText": "final?", "author": "MikeDombo", "createdAt": "2020-02-28T16:44:33Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMjk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385802988", "bodyText": "Convert this to a lambda. Also, make all these final when they can be.", "author": "MikeDombo", "createdAt": "2020-02-28T16:45:39Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzQzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385803436", "bodyText": "remove the trailing space from your log message.", "author": "MikeDombo", "createdAt": "2020-02-28T16:46:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {\n+        @Override\n+        public void accept(AWSIotMessage awsIotMessage) {\n+            /*\n+             * This message is received when either of these things happen\n+             * 1. Last job completed (successful/failed)\n+             * 2. A new job was queued\n+             * 3. A job was cancelled\n+             * This message receives the list of Queued and InProgress jobs at the time of this message\n+             */\n+            logger.info(\"Received mqtt notify message\");\n+            logger.info(\"Payload: \" + awsIotMessage.getStringPayload());\n+\n+            AwsIotJobsMqttMessage jobsMqttMessage;\n+            try {\n+                jobsMqttMessage = objectMapper.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n+            } catch (JsonProcessingException ex) {\n+                logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n                 return;\n             }\n-            logger.atInfo().setEventType(\"got-deployment-job-doc\").addKeyValue(\"jobDocument\", jobDocument).log();\n-            logger.info(\"Job status is {}\", jobExecutionData.status);\n-            if (jobExecutionData.status == JobStatus.QUEUED) {\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.IN_PROGRESS, null);\n-                logger.debug(\"Updated the status of JobsId {} to in progress\", jobId);\n-                //TODO: Trigger deployment process\n+\n+            try {\n+                //TODO: Check that if there is a current job runnign by the device then thats\n+                // coming in the inProgress list. If its not there then it will be an indication that\n+                // it was cancelled.\n+                if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n+                    iotJobsHelper.getNextPendingJob();\n+                }\n+            } catch (ExecutionException | InterruptedException ex) {\n+                //TODO: DA should continue listening for other messages if error in one message\n+                logger.error(\"Caught exception while handling Mqtt message \", ex);", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzY5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385803699", "bodyText": "Use {} or use a k-v pair.", "author": "MikeDombo", "createdAt": "2020-02-28T16:46:50Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {\n+        @Override\n+        public void accept(AWSIotMessage awsIotMessage) {\n+            /*\n+             * This message is received when either of these things happen\n+             * 1. Last job completed (successful/failed)\n+             * 2. A new job was queued\n+             * 3. A job was cancelled\n+             * This message receives the list of Queued and InProgress jobs at the time of this message\n+             */\n+            logger.info(\"Received mqtt notify message\");\n+            logger.info(\"Payload: \" + awsIotMessage.getStringPayload());", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzk0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385803949", "bodyText": "Same here, make this a lambda and final if possible.", "author": "MikeDombo", "createdAt": "2020-02-28T16:47:18Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {\n+        @Override\n+        public void accept(AWSIotMessage awsIotMessage) {\n+            /*\n+             * This message is received when either of these things happen\n+             * 1. Last job completed (successful/failed)\n+             * 2. A new job was queued\n+             * 3. A job was cancelled\n+             * This message receives the list of Queued and InProgress jobs at the time of this message\n+             */\n+            logger.info(\"Received mqtt notify message\");\n+            logger.info(\"Payload: \" + awsIotMessage.getStringPayload());\n+\n+            AwsIotJobsMqttMessage jobsMqttMessage;\n+            try {\n+                jobsMqttMessage = objectMapper.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n+            } catch (JsonProcessingException ex) {\n+                logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n                 return;\n             }\n-            logger.atInfo().setEventType(\"got-deployment-job-doc\").addKeyValue(\"jobDocument\", jobDocument).log();\n-            logger.info(\"Job status is {}\", jobExecutionData.status);\n-            if (jobExecutionData.status == JobStatus.QUEUED) {\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.IN_PROGRESS, null);\n-                logger.debug(\"Updated the status of JobsId {} to in progress\", jobId);\n-                //TODO: Trigger deployment process\n+\n+            try {\n+                //TODO: Check that if there is a current job runnign by the device then thats\n+                // coming in the inProgress list. If its not there then it will be an indication that\n+                // it was cancelled.\n+                if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n+                    iotJobsHelper.getNextPendingJob();\n+                }\n+            } catch (ExecutionException | InterruptedException ex) {\n+                //TODO: DA should continue listening for other messages if error in one message\n+                logger.error(\"Caught exception while handling Mqtt message \", ex);\n+                errored = true;\n+                reportState(State.ERRORED);\n             }\n-            //TODO:Check that if job Id is in progress and take appropriate action.\n-            // We expect only one JobId to be in progress at a time\n-\n-            iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, null);\n-            logger.debug(\"Updated the status of JobId {} to in completed\", jobId);\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: If error in one job then DA should continue listening for other jobs\n-            logger.error(\"Caught exception while doing a deployment\", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n         }\n     };\n \n+    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer =", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDQzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385804430", "bodyText": "For our structured logs we'll probably want the jobId as a k-v pair too, can you add that to all the logs which are processing a job? That way we can easily trace logs back to their jobs.", "author": "MikeDombo", "createdAt": "2020-02-28T16:48:15Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {\n+        @Override\n+        public void accept(AWSIotMessage awsIotMessage) {\n+            /*\n+             * This message is received when either of these things happen\n+             * 1. Last job completed (successful/failed)\n+             * 2. A new job was queued\n+             * 3. A job was cancelled\n+             * This message receives the list of Queued and InProgress jobs at the time of this message\n+             */\n+            logger.info(\"Received mqtt notify message\");\n+            logger.info(\"Payload: \" + awsIotMessage.getStringPayload());\n+\n+            AwsIotJobsMqttMessage jobsMqttMessage;\n+            try {\n+                jobsMqttMessage = objectMapper.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n+            } catch (JsonProcessingException ex) {\n+                logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n                 return;\n             }\n-            logger.atInfo().setEventType(\"got-deployment-job-doc\").addKeyValue(\"jobDocument\", jobDocument).log();\n-            logger.info(\"Job status is {}\", jobExecutionData.status);\n-            if (jobExecutionData.status == JobStatus.QUEUED) {\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.IN_PROGRESS, null);\n-                logger.debug(\"Updated the status of JobsId {} to in progress\", jobId);\n-                //TODO: Trigger deployment process\n+\n+            try {\n+                //TODO: Check that if there is a current job runnign by the device then thats\n+                // coming in the inProgress list. If its not there then it will be an indication that\n+                // it was cancelled.\n+                if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n+                    iotJobsHelper.getNextPendingJob();\n+                }\n+            } catch (ExecutionException | InterruptedException ex) {\n+                //TODO: DA should continue listening for other messages if error in one message\n+                logger.error(\"Caught exception while handling Mqtt message \", ex);\n+                errored = true;\n+                reportState(State.ERRORED);\n             }\n-            //TODO:Check that if job Id is in progress and take appropriate action.\n-            // We expect only one JobId to be in progress at a time\n-\n-            iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, null);\n-            logger.debug(\"Updated the status of JobId {} to in completed\", jobId);\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: If error in one job then DA should continue listening for other jobs\n-            logger.error(\"Caught exception while doing a deployment\", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n         }\n     };\n \n+    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer =\n+            new Consumer<DescribeJobExecutionResponse>() {\n+                @Override\n+                public void accept(DescribeJobExecutionResponse response) {\n+                    try {\n+                        if (response.execution == null) {\n+                            return;\n+                        }\n+\n+                        JobExecutionData jobExecutionData = response.execution;\n+                        currentJobId = jobExecutionData.jobId;\n+                        logger.atInfo().log(\"Received job description for job id : {} and status {}\", currentJobId,", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNTIzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385805237", "bodyText": "This is duplicated from L157.", "author": "MikeDombo", "createdAt": "2020-02-28T16:49:42Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -35,98 +41,134 @@\n                     .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n     private static final long DEPLOYMENT_POLLING_FREQUENCY = Duration.ofSeconds(30).toMillis();\n     private static final String NOTIFY_TOPIC = \"$aws/things/{thingName}/jobs/notify\";\n+    private static ObjectMapper objectMapper;\n \n     @Inject\n     private IotJobsHelper iotJobsHelper;\n+    private MqttHelper mqttHelper;\n     private AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n     private boolean errored;\n-\n-    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = awsIotMessage -> {\n-        logger.info(\"Received mqtt notify message\");\n-        logger.info(\"Payload: {}\", awsIotMessage.getStringPayload());\n-        AwsIotJobsMqttMessage jobsMqttMessage;\n-        try {\n-            jobsMqttMessage = OBJECT_MAPPER.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n-        } catch (JsonProcessingException ex) {\n-            logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n-            return;\n-        }\n-\n-        try {\n-            if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n-                iotJobsHelper.getNextPendingJob();\n-            }\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: DA should continue listening for other messages if error in one message\n-            logger.error(\"Caught exception while handling Mqtt message \", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n-        }\n-    };\n-\n-    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer = response -> {\n-        if (response.execution == null) {\n-            return;\n-        }\n-        logger.info(\"Describe Job: {} version: {}\", response.execution.jobId, response.execution.versionNumber);\n-        JobExecutionData jobExecutionData = response.execution;\n-        String jobId = jobExecutionData.jobId;\n-        Map<String, Object> jobDocument = jobExecutionData.jobDocument;\n-        HashMap<String, String> statusDetails = new HashMap<>();\n-        try {\n-            if (jobDocument == null) {\n-                statusDetails.put(\"JobDocument\", \"Empty\");\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, statusDetails);\n+    //Thread safe?\n+    private ExecutorService executorService = context.get(ExecutorService.class);\n+    private Future<Boolean> currentProcessStatus = null;\n+    private String currentJobId;\n+    private DeploymentPacket currentDeploymentPacket;\n+\n+\n+    private Consumer<AWSIotMessage> awsIotNotifyMessageHandler = new Consumer<AWSIotMessage>() {\n+        @Override\n+        public void accept(AWSIotMessage awsIotMessage) {\n+            /*\n+             * This message is received when either of these things happen\n+             * 1. Last job completed (successful/failed)\n+             * 2. A new job was queued\n+             * 3. A job was cancelled\n+             * This message receives the list of Queued and InProgress jobs at the time of this message\n+             */\n+            logger.info(\"Received mqtt notify message\");\n+            logger.info(\"Payload: \" + awsIotMessage.getStringPayload());\n+\n+            AwsIotJobsMqttMessage jobsMqttMessage;\n+            try {\n+                jobsMqttMessage = objectMapper.readValue(awsIotMessage.getStringPayload(), AwsIotJobsMqttMessage.class);\n+            } catch (JsonProcessingException ex) {\n+                logger.error(\"Incorrectly formatted message received from AWS Iot\", ex);\n                 return;\n             }\n-            logger.atInfo().setEventType(\"got-deployment-job-doc\").addKeyValue(\"jobDocument\", jobDocument).log();\n-            logger.info(\"Job status is {}\", jobExecutionData.status);\n-            if (jobExecutionData.status == JobStatus.QUEUED) {\n-                iotJobsHelper.updateJobStatus(jobId, JobStatus.IN_PROGRESS, null);\n-                logger.debug(\"Updated the status of JobsId {} to in progress\", jobId);\n-                //TODO: Trigger deployment process\n+\n+            try {\n+                //TODO: Check that if there is a current job runnign by the device then thats\n+                // coming in the inProgress list. If its not there then it will be an indication that\n+                // it was cancelled.\n+                if (!jobsMqttMessage.getJobs().getQueued().isEmpty()) {\n+                    iotJobsHelper.getNextPendingJob();\n+                }\n+            } catch (ExecutionException | InterruptedException ex) {\n+                //TODO: DA should continue listening for other messages if error in one message\n+                logger.error(\"Caught exception while handling Mqtt message \", ex);\n+                errored = true;\n+                reportState(State.ERRORED);\n             }\n-            //TODO:Check that if job Id is in progress and take appropriate action.\n-            // We expect only one JobId to be in progress at a time\n-\n-            iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, null);\n-            logger.debug(\"Updated the status of JobId {} to in completed\", jobId);\n-        } catch (ExecutionException | InterruptedException ex) {\n-            //TODO: If error in one job then DA should continue listening for other jobs\n-            logger.error(\"Caught exception while doing a deployment\", ex);\n-            errored = true;\n-            reportState(State.ERRORED);\n         }\n     };\n \n+    private Consumer<DescribeJobExecutionResponse> describeJobExecutionResponseConsumer =\n+            new Consumer<DescribeJobExecutionResponse>() {\n+                @Override\n+                public void accept(DescribeJobExecutionResponse response) {\n+                    try {\n+                        if (response.execution == null) {\n+                            return;\n+                        }\n+\n+                        JobExecutionData jobExecutionData = response.execution;\n+                        currentJobId = jobExecutionData.jobId;\n+                        logger.atInfo().log(\"Received job description for job id : {} and status {}\", currentJobId,\n+                                jobExecutionData.status);\n+                        if (jobExecutionData.status == JobStatus.IN_PROGRESS) {\n+                            //TODO: Check the currently runnign process,\n+                            // if it is same as this jobId then do nothing. If not then there is something wrong\n+                            return;\n+                        } else if (jobExecutionData.status == JobStatus.QUEUED) {\n+                            //There should be no job runnign at this point of time\n+                            iotJobsHelper.updateJobStatus(currentJobId, JobStatus.IN_PROGRESS, null);\n+\n+                            logger.info(\"Updated the status of JobsId {} to {}\", currentJobId, JobStatus.IN_PROGRESS);\n+                            currentDeploymentPacket =\n+                                    DeploymentPacket.builder().jobDocument(response.execution.jobDocument)\n+                                            .proposedPackagesFromDeployment(new HashSet<>())\n+                                            .packagesToDeploy(new HashSet<>())\n+                                            .removedTopLevelPackageNames(new HashSet<>())\n+                                            .build();\n+                            //Starting the job processing in another thread\n+                            currentProcessStatus = executorService\n+                                    .submit(new DeploymentProcess(currentDeploymentPacket, objectMapper,\n+                                            context.get(Kernel.class), context.get(PackageManager.class)));\n+                            logger.atInfo().log(\"Submitted the job with jobId {}\", jobExecutionData.jobId);\n+                        }\n+\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.error(\"Caught exception in callback to handle describe job response {}\", e);\n+                        //TODO:Exception handling in callbacks\n+                    }\n+                }\n+            };\n+\n+    private void updateJobAsSucceded(String jobId, DeploymentPacket currentDeploymentPacket)\n+            throws ExecutionException, InterruptedException {\n+        //TODO: Fill in status details from the deployment packet\n+        iotJobsHelper.updateJobStatus(jobId, JobStatus.SUCCEEDED, null);\n+    }\n+\n+    private void updateJobAsFailed(String jobId, DeploymentPacket deploymentPacket)\n+            throws ExecutionException, InterruptedException {\n+        //TODO: Fill in status details from the deployment packet\n+        iotJobsHelper.updateJobStatus(jobId, JobStatus.FAILED, null);\n+    }\n+\n     public DeploymentService(Topics topics) {\n         super(topics);\n     }\n \n+\n     @Override\n     public void startup() {\n         // Reset shutdown signal since we're trying to startup here\n         this.receivedShutdown.set(false);\n \n         logger.info(\"Starting up the Deployment Service\");\n+        receivedShutdown.set(false);", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNTkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385805917", "bodyText": "Pick 1, we shouldn't log multiple times for the same error.", "author": "MikeDombo", "createdAt": "2020-02-28T16:50:59Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -148,28 +190,60 @@ public void startup() {\n         logger.info(\"Running deployment service\");\n         while (!receivedShutdown.get() && !errored) {\n             try {\n+                if (currentProcessStatus != null) {\n+                    logger.info(\"Getting the status of the current process\");\n+                    Boolean deploymentStatus = currentProcessStatus.get();\n+                    if (deploymentStatus) {\n+                        updateJobAsSucceded(currentJobId, currentDeploymentPacket);\n+                    } else {\n+                        updateJobAsFailed(currentJobId, currentDeploymentPacket);\n+                    }\n+                    currentProcessStatus = null;\n+                    currentDeploymentPacket = null;\n+                }\n                 Thread.sleep(DEPLOYMENT_POLLING_FREQUENCY);\n             } catch (InterruptedException ex) {\n                 logger.atError().setCause(ex).log(\"Exception encountered while sleeping in DA\");\n                 errored = true;\n                 reportState(State.ERRORED);\n+            } catch (ExecutionException e) {\n+                logger.error(\"Caught exception while getting the status of the Job jobId {}, error : {}\", currentJobId,\n+                        e);\n+                logger.atError().setCause(e).log(\"Caught exception while getting the status of the\");", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNjM2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385806362", "bodyText": "Let's not have these paths be relative to $HOME. Can we just define the paths in the config as absolute?", "author": "MikeDombo", "createdAt": "2020-02-28T16:51:47Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -148,28 +190,60 @@ public void startup() {\n         logger.info(\"Running deployment service\");\n         while (!receivedShutdown.get() && !errored) {\n             try {\n+                if (currentProcessStatus != null) {\n+                    logger.info(\"Getting the status of the current process\");\n+                    Boolean deploymentStatus = currentProcessStatus.get();\n+                    if (deploymentStatus) {\n+                        updateJobAsSucceded(currentJobId, currentDeploymentPacket);\n+                    } else {\n+                        updateJobAsFailed(currentJobId, currentDeploymentPacket);\n+                    }\n+                    currentProcessStatus = null;\n+                    currentDeploymentPacket = null;\n+                }\n                 Thread.sleep(DEPLOYMENT_POLLING_FREQUENCY);\n             } catch (InterruptedException ex) {\n                 logger.atError().setCause(ex).log(\"Exception encountered while sleeping in DA\");\n                 errored = true;\n                 reportState(State.ERRORED);\n+            } catch (ExecutionException e) {\n+                logger.error(\"Caught exception while getting the status of the Job jobId {}, error : {}\", currentJobId,\n+                        e);\n+                logger.atError().setCause(e).log(\"Caught exception while getting the status of the\");\n+                //Do not stop the thread as it should go on to process other incoming messages\n             }\n         }\n     }\n \n+\n     @Override\n     public void shutdown() {\n         receivedShutdown.set(true);\n         iotJobsHelper.closeConnection();\n     }\n \n+    private void initialize(String thingName) throws AWSIotException {\n+        String envHome = System.getenv(\"HOME\");", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0Mzk1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385843955", "bodyText": "For things that we expect on the device, it has to relative to something. Right now no tests use this. But when we do then every host may have different directory structure. When provisioning of device gets more figured out, then we will be able to set this to a better value. Is your concern using HOME directly over here and would rather use something that kernel offers?", "author": "abanthiy", "createdAt": "2020-02-28T18:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0OTc1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385849750", "bodyText": "That would help, yes. But it does not need to be relative if it is just an absolute path. But yeah, making it relative to the kernel's home directory (not user home) would be better. You can use deTilde in Kernel to make absolute paths from relative ones like ~config/keys/....", "author": "MikeDombo", "createdAt": "2020-02-28T18:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNjk4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385806984", "bodyText": "You can just do this at the field level.\nprivate static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().configure(DeserializationFeature......)", "author": "MikeDombo", "createdAt": "2020-02-28T16:53:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -148,28 +190,60 @@ public void startup() {\n         logger.info(\"Running deployment service\");\n         while (!receivedShutdown.get() && !errored) {\n             try {\n+                if (currentProcessStatus != null) {\n+                    logger.info(\"Getting the status of the current process\");\n+                    Boolean deploymentStatus = currentProcessStatus.get();\n+                    if (deploymentStatus) {\n+                        updateJobAsSucceded(currentJobId, currentDeploymentPacket);\n+                    } else {\n+                        updateJobAsFailed(currentJobId, currentDeploymentPacket);\n+                    }\n+                    currentProcessStatus = null;\n+                    currentDeploymentPacket = null;\n+                }\n                 Thread.sleep(DEPLOYMENT_POLLING_FREQUENCY);\n             } catch (InterruptedException ex) {\n                 logger.atError().setCause(ex).log(\"Exception encountered while sleeping in DA\");\n                 errored = true;\n                 reportState(State.ERRORED);\n+            } catch (ExecutionException e) {\n+                logger.error(\"Caught exception while getting the status of the Job jobId {}, error : {}\", currentJobId,\n+                        e);\n+                logger.atError().setCause(e).log(\"Caught exception while getting the status of the\");\n+                //Do not stop the thread as it should go on to process other incoming messages\n             }\n         }\n     }\n \n+\n     @Override\n     public void shutdown() {\n         receivedShutdown.set(true);\n         iotJobsHelper.closeConnection();\n     }\n \n+    private void initialize(String thingName) throws AWSIotException {\n+        String envHome = System.getenv(\"HOME\");\n+        String privateKeyPath = envHome + getStringParameterFromConfig(\"privateKeyPath\");\n+        String certificateFilePath = envHome + getStringParameterFromConfig(\"certificateFilePath\");\n+        String rootCAPath = envHome + getStringParameterFromConfig(\"rootCaPath\");\n+        String clientEndpoint = getStringParameterFromConfig(\"mqttClientEndpoint\");\n+\n+        mqttHelper = new MqttHelper(clientEndpoint, UUID.randomUUID().toString(), certificateFilePath, privateKeyPath);\n+        iotJobsHelper = new IotJobsHelper(thingName, clientEndpoint, certificateFilePath, privateKeyPath, rootCAPath,\n+                UUID.randomUUID().toString());\n+\n+        objectMapper = new ObjectMapper();\n+        objectMapper.configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false);\n+        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzkxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385807911", "bodyText": "Why are these classes \"Configurations\"? Perhaps just DeploymentDocument and DeploymentPackage (or even PackageFromDeployment)?", "author": "MikeDombo", "createdAt": "2020-02-28T16:54:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentConfiguration.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.List;\n+\n+/**\n+ * Class to model the deployment configuration coming from cloud, local, or any other sources\n+ * that can trigger a deployment.\n+ */\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Getter\n+public class DeploymentConfiguration {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NDY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385844685", "bodyText": "This everything that will come in the Job document. The term we have been using in our discussions is DeploymentConfiguration. I have tried to keep with that terminology. Is this confusing?", "author": "abanthiy", "createdAt": "2020-02-28T18:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDU3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385850571", "bodyText": "Yeah, I get it, but it seems with a name like Configuration that this would be used to configure the deployment, and not be the actual deployment.", "author": "MikeDombo", "createdAt": "2020-02-28T18:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzU0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385913548", "bodyText": "Probably DeploymentDocument is better. Configuration is a bit overloaded.", "author": "fengwang666", "createdAt": "2020-02-28T20:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODQwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385808406", "bodyText": "Can we pull this out of this class? It seems like we may want to use this type in more places, especially if we're getting rid of some of the package classes.", "author": "MikeDombo", "createdAt": "2020-02-28T16:55:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import lombok.Getter;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to represent a single package along with its dependencies\n+ * that comes in the deployment configuration.\n+ */\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Getter\n+public class DeploymentPackageConfiguration {\n+\n+    @JsonProperty(\"Name\")\n+    String packageName;\n+\n+    @JsonProperty(\"ResolvedVersion\")\n+    String resolvedVersion;\n+\n+    @JsonProperty(\"VersionConstraint\")\n+    String versionConstraint;\n+\n+    @JsonProperty(\"Parameters\")\n+    Set<PackageParameter> parameters;\n+\n+    @JsonProperty(\"Dependencies\")\n+    List<NameVersionPair> listOfDependentPackages;\n+\n+    @JsonSerialize\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    public static class NameVersionPair {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NTIxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385845219", "bodyText": "Yes we will refactor the modeling in next sprint. I would do it then one final time, than iterate on this right now", "author": "abanthiy", "createdAt": "2020-02-28T18:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzk5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385913997", "bodyText": "Yeah. This should be the \"primary key\" referring each package.", "author": "fengwang666", "createdAt": "2020-02-28T20:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODczNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385808734", "bodyText": "We already have a parameter class somewhere. Can you use that one instead of making a new one?", "author": "MikeDombo", "createdAt": "2020-02-28T16:56:28Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/Parameter.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+@Getter\n+@AllArgsConstructor\n+public class Parameter {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NTg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385845857", "bodyText": "I must have checked this in by mistake. I use the one defined in packagemanager", "author": "abanthiy", "createdAt": "2020-02-28T18:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwOTE2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385809160", "bodyText": "Make this abstract?", "author": "MikeDombo", "createdAt": "2020-02-28T16:57:08Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/BaseState.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class BaseState implements State {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwOTcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385809704", "bodyText": "Remove this error log. (keep the one above though, that's fine)", "author": "MikeDombo", "createdAt": "2020-02-28T16:58:12Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/PackageDownloadingState.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class representing the package downloading state.\n+ * Dependency resolution and download of package recipes, artifacts will happen.\n+ */\n+public class PackageDownloadingState extends BaseState {\n+\n+    private static Logger logger = LogManager.getLogger(PackageDownloadingState.class);\n+\n+    private PackageManager packageManager;\n+\n+    /**\n+     * Constructor for PackageDownloadingState.\n+     * @param deploymentPacket Deployment packet containing deployment configuration\n+     * @param objectMapper Object mapper\n+     * @param packageManager Package manager {@link PackageManager}\n+     */\n+    public PackageDownloadingState(DeploymentPacket deploymentPacket,\n+                                   ObjectMapper objectMapper, PackageManager packageManager) {\n+        this.deploymentPacket = deploymentPacket;\n+        this.objectMapper = objectMapper;\n+        this.packageManager = packageManager;\n+    }\n+\n+\n+    @Override\n+    public boolean canProceed() {\n+        //TODO: Evaluate download conditions\n+        return true;\n+    }\n+\n+    @Override\n+    public void proceed() throws DeploymentFailureException {\n+        logger.info(\"Downloading the packages\");\n+        logger.atInfo().log(\"PackageMetadata received: {}\",\n+                deploymentPacket.getProposedPackagesFromDeployment());\n+        //call package manager withe proposed packages\n+        try {\n+            Set<Package> packages =\n+                    packageManager.resolvePackages(deploymentPacket.getProposedPackagesFromDeployment()).get();\n+            deploymentPacket.setPackagesToDeploy(packages);\n+            //TODO: Clean up the proposed packages from deployment packet, if not needed after this point\n+        } catch (InterruptedException | ExecutionException e) {\n+            logger.error(\"Caught exception while downloading packages\", e);\n+            logger.error(e.getMessage());", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDk0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385810945", "bodyText": "GIVEN.", "author": "MikeDombo", "createdAt": "2020-02-28T17:00:28Z", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadataTest.java", "diffHunk": "@@ -11,10 +11,11 @@\n class PackageMetadataTest {\n \n     @Test\n-    void GIVEN_package_metadata_WHEN_equality_is_called_THEN_decide_if_they_are_equal() {\n+    void Given_package_metadata_WHEN_equality_is_called_THEN_decide_if_they_are_equal() {", "originalCommit": "78e43ab0a0519f4830ad0340c8ceffc3c40e792f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/714fc29396af12c61cfe33131d57ca83c1c9d41c", "message": "Fixup comments", "committedDate": "2020-02-28T17:43:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1NjcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385856706", "bodyText": "As discussed yesterday, I made changes to package model to never have null values, so that we don't keep making null checks everywhere we use them, so this can be removed, would be another branch to cover in testing otherwise", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:36:41Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -90,9 +92,11 @@ private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n             String value = (String) lifecycle.get(lifecycleKey);\n \n             // Handle package parameters\n-            for (final PackageParameter parameter : packageParameters) {\n-                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n-                        parameter.getValue());\n+            if (packageParameters != null) {", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1NzQ0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385857440", "bodyText": "Update javadoc to reflect all parameters", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:38:18Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -44,54 +45,87 @@\n     @Getter\n     private final DeploymentPacket deploymentPacket;\n \n-    @Getter\n-    @Setter\n-    private Set<Package> packagesToDeploy;\n-\n-    @Getter\n-    @Setter\n-    private Set<String> removedTopLevelPackageNames;\n-\n     @Getter\n     @Setter\n     private Map<Object, Object> resolvedKernelConfig;\n \n     /**\n      * Constructor to initialize deployment process.\n      *\n-     * @param packet parsed deployment document\n-     * @param kernel running kernel instance\n+     * @param deploymentPacket parsed deployment document", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2MTQzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385861437", "bodyText": "Might want to name this resolvedPackagesToDeploy now to make it less confusing how it's different from proposedPackagesFromDeployment", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:47:02Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -3,15 +3,35 @@\n \n package com.aws.iot.evergreen.deployment.model;\n \n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n import lombok.Builder;\n import lombok.Getter;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n \n @Getter\n+@Setter\n @Builder\n+@ToString\n public class DeploymentPacket {\n-\n+    private HashMap<String, Object> jobDocument;\n     private String deploymentId;\n-\n     private long deploymentCreationTimestamp;\n+    private Set<Package> packagesToDeploy;", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2MzA1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385863052", "bodyText": "This is only used in one state, it can be moved to that state, doesn't need to be in base class. You have to instantiate states with this when you don't even need it", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:50:46Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/BaseState.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public abstract class BaseState implements State {\n+\n+    @Getter\n+    @Setter\n+    protected DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    protected ObjectMapper objectMapper;", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MzcwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385873705", "bodyText": "This should be coming from the calling class. So no new object is instantiated. We will revisit state machine in next sprint. Can rethink about it.", "author": "abanthiy", "createdAt": "2020-02-28T19:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2MzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2MzM1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385863359", "bodyText": "Could have a constructor in base class and call super class constructor here", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:51:21Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -5,25 +5,39 @@\n \n import com.aws.iot.evergreen.deployment.ConfigResolver;\n import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.RequiredArgsConstructor;\n \n import java.util.Map;\n+import javax.inject.Inject;\n \n /**\n  * Deployment state after package dependencies have been resolved and packages have been downloaded.\n  * Generates config to be merged when appropriate.\n  */\n @RequiredArgsConstructor\n-public class DownloadedState implements State {\n+public class DownloadedState extends BaseState {\n \n     private static final Logger logger = LogManager.getLogger(DownloadedState.class);\n \n-    private final DeploymentProcess deploymentProcess;\n+    private Kernel kernel;\n \n-    private final Kernel kernel;\n+    /**\n+     * Constructor for Downloaded state.\n+     * @param deploymentPacket Deployment packet containing deployment configuration details\n+     * @param objectMapper Object mapper\n+     * @param kernel Evergreen kernel {@link Kernel}\n+     */\n+    public DownloadedState(DeploymentPacket deploymentPacket, ObjectMapper objectMapper, Kernel kernel) {\n+        this.deploymentPacket = deploymentPacket;", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3NDM1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385874359", "bodyText": "Will punt this to refactor of state machine", "author": "abanthiy", "createdAt": "2020-02-28T19:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2MzM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg2NTcxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385865718", "bodyText": "Why is this not final anymore?", "author": "shaguptashaikh", "createdAt": "2020-02-28T18:56:07Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/state/UpdatingKernelState.java", "diffHunk": "@@ -4,45 +4,58 @@\n package com.aws.iot.evergreen.deployment.state;\n \n import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.deployment.exceptions.DeploymentFailureException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import lombok.RequiredArgsConstructor;\n \n import java.io.IOException;\n import java.util.Map;\n+import javax.inject.Inject;\n \n /**\n  * Deployment state for updating kernel config.\n  * Checks for update conditions, performs updates and handles result.\n  */\n @RequiredArgsConstructor\n-public class UpdatingKernelState implements State {\n+public class UpdatingKernelState extends BaseState {\n \n     private static final Logger logger = LogManager.getLogger(UpdatingKernelState.class);\n \n     private static final String ROLLBACK_SNAPSHOT_PATH_FORMAT = \"rollback_snapshot_%s.tlog\";\n \n-    private final DeploymentProcess deploymentProcess;\n-\n-    private final Kernel kernel;\n+    private Kernel kernel;", "originalCommit": "714fc29396af12c61cfe33131d57ca83c1c9d41c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a23790479d23960d13cceb70c09c616872ee9bfc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a23790479d23960d13cceb70c09c616872ee9bfc", "message": "Addressing review comments", "committedDate": "2020-02-28T19:34:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzI1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385913253", "bodyText": "What's groupName?", "author": "fengwang666", "createdAt": "2020-02-28T20:43:38Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentConfiguration.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.List;\n+\n+/**\n+ * Class to model the deployment configuration coming from cloud, local, or any other sources\n+ * that can trigger a deployment.\n+ */\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Getter\n+public class DeploymentConfiguration {\n+\n+    @JsonProperty(\"DeploymentId\")\n+    String deploymentId;\n+\n+    @JsonProperty(\"ListOfPackagesToDeploy\")\n+    List<String> listOfPackagesToDeploy;\n+\n+    @JsonProperty(\"Packages\")\n+    List<DeploymentPackageConfiguration> deploymentPackageConfigurationList;\n+\n+    @JsonProperty(\"GroupName\")\n+    String groupName;", "originalCommit": "bb751e4a7904c68b421d9b3519a824ee896b6529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNzUyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385927529", "bodyText": "This corresponds to the Iot Thing Group which the device belongs to. I imagine we would need the group name in the document to indicate the group for which this deployment came.", "author": "abanthiy", "createdAt": "2020-02-28T21:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzMyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385913328", "bodyText": "Is this deployment creation timestamp on the cloud?", "author": "fengwang666", "createdAt": "2020-02-28T20:43:52Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentConfiguration.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.List;\n+\n+/**\n+ * Class to model the deployment configuration coming from cloud, local, or any other sources\n+ * that can trigger a deployment.\n+ */\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@Getter\n+public class DeploymentConfiguration {\n+\n+    @JsonProperty(\"DeploymentId\")\n+    String deploymentId;\n+\n+    @JsonProperty(\"ListOfPackagesToDeploy\")\n+    List<String> listOfPackagesToDeploy;\n+\n+    @JsonProperty(\"Packages\")\n+    List<DeploymentPackageConfiguration> deploymentPackageConfigurationList;\n+\n+    @JsonProperty(\"GroupName\")\n+    String groupName;\n+\n+    @JsonProperty(\"Timestamp\")\n+    Long timestamp;", "originalCommit": "bb751e4a7904c68b421d9b3519a824ee896b6529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNzY2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385927666", "bodyText": "Yes", "author": "abanthiy", "createdAt": "2020-02-28T21:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNDIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385914211", "bodyText": "What is DeploymentPacket?", "author": "fengwang666", "createdAt": "2020-02-28T20:46:12Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -3,15 +3,35 @@\n \n package com.aws.iot.evergreen.deployment.model;\n \n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n import lombok.Builder;\n import lombok.Getter;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n \n @Getter\n+@Setter\n @Builder\n+@ToString\n public class DeploymentPacket {", "originalCommit": "bb751e4a7904c68b421d9b3519a824ee896b6529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNDY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/88#discussion_r385934695", "bodyText": "I changed this to DeploymentContext. This is the context object for a deployment which will capture the status of deployment and artifacts required by different states", "author": "abanthiy", "createdAt": "2020-02-28T21:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNDIxMQ=="}], "type": "inlineReview"}, {"oid": "6bc2608c78df49614a64564348dafa63ae5a54c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6bc2608c78df49614a64564348dafa63ae5a54c3", "message": "Using single logger across multiple classes that do a single deployment", "committedDate": "2020-02-28T21:10:16Z", "type": "commit"}, {"oid": "6bc2608c78df49614a64564348dafa63ae5a54c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6bc2608c78df49614a64564348dafa63ae5a54c3", "message": "Using single logger across multiple classes that do a single deployment", "committedDate": "2020-02-28T21:10:16Z", "type": "forcePushed"}, {"oid": "e3c9444b441dde41c91cec4c5574f8bf07a112ca", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e3c9444b441dde41c91cec4c5574f8bf07a112ca", "message": "Refactoring the model classes naming and structure", "committedDate": "2020-02-28T21:52:46Z", "type": "commit"}, {"oid": "284295321a6908e5603b27bb4bf85cd60d4078f2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/284295321a6908e5603b27bb4bf85cd60d4078f2", "message": "Updating the path of the certificats wrt to kernel config path", "committedDate": "2020-03-02T19:27:54Z", "type": "commit"}]}