{"pr_number": 309, "pr_title": "Deployment Service can start a Kernel update", "pr_createdAt": "2020-07-15T03:03:54Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309", "timeline": [{"oid": "0313d617ed771756c31e24e4b22a9d4107ed5f6b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0313d617ed771756c31e24e4b22a9d4107ed5f6b", "message": "Deployment Service can start a Kernel update", "committedDate": "2020-07-15T22:19:08Z", "type": "forcePushed"}, {"oid": "6ae1e301bc064f286308e5570a70fc47801de8eb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6ae1e301bc064f286308e5570a70fc47801de8eb", "message": "Deployment Service can start a Kernel update", "committedDate": "2020-07-16T01:43:45Z", "type": "forcePushed"}, {"oid": "6dd3424d36bc7258246b99ab7074a12e60242d50", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6dd3424d36bc7258246b99ab7074a12e60242d50", "message": "Deployment Service can start a Kernel update", "committedDate": "2020-07-20T22:14:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyODExOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r457728118", "bodyText": "I'm little confused on this class's responsibility...\nIf I understand it correctly maybe we could have\ninterface DeploymentActivator which is implemented by class DefaultDeploymentActivator vs class KernelUpdateActivator, with a DeploymentActivatorFactory?\nAnd is it possible to make the managers and Activation here singleton? Most of the logic is reusable and stateless and we could refactor out the stateful things with Data Transfer Objects.", "author": "leaf94", "createdAt": "2020-07-20T22:30:52Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigActivation.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.ConfigurationReader;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger.AggregateServicesChangeManager;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelLifecycle;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+\n+public abstract class DeploymentConfigActivation {\n+    protected final Kernel kernel;\n+    protected static final Logger logger = LogManager.getLogger(DeploymentConfigActivation.class);\n+    protected final DeploymentDocument deploymentDocument;\n+    protected final Map<Object, Object> newConfig;\n+\n+    protected DeploymentConfigActivation(Kernel kernel, DeploymentDocument deploymentDocument,\n+                                         Map<Object, Object> newConfig) {\n+        this.kernel = kernel;\n+        this.deploymentDocument = deploymentDocument;\n+        this.newConfig = newConfig;\n+    }\n+\n+    static DeploymentConfigActivation getActivationManager(Kernel kernel, DeploymentDocument deploymentDocument,\n+                                                           Map<Object, Object> newConfig) {\n+        BootstrapManager bootstrapManager = new BootstrapManager(kernel, newConfig);\n+        if (bootstrapManager.isBootstrapRequired()) {\n+            logger.atInfo().log(\"Continue with component bootstrap tasks\");\n+            return new KernelUpdateActivation(kernel, deploymentDocument, newConfig, bootstrapManager);\n+        }\n+        logger.atInfo().log(\"Continue with component config activation\");\n+        return new DefaultActivation(kernel, deploymentDocument, newConfig);\n+    }\n+\n+    abstract void activate(CompletableFuture<DeploymentResult> totallyCompleteFuture);\n+", "originalCommit": "6dd3424d36bc7258246b99ab7074a12e60242d50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczOTEzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r457739137", "bodyText": "Will update.", "author": "hui-yang", "createdAt": "2020-07-20T23:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyODExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MjAxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459042016", "bodyText": "Throw exception at cycled dependency?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T19:47:59Z", "path": "src/main/java/com/aws/iot/evergreen/util/DependencyOrder.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public class DependencyOrder<T> {\n+    @FunctionalInterface\n+    public interface DependencyGetter<E> {\n+        Set<E> getDependencies(E elem);\n+    }\n+\n+    /**\n+     * Resolve the inter-dependency order within a given set of elements.\n+     *\n+     * @param pendingDependencies a set of inter-dependent elements\n+     * @param dependencyGetter function to get all dependency elements of the given element\n+     * @return\n+     */\n+    @SuppressWarnings(\"PMD.LooseCoupling\")\n+    public LinkedHashSet<T> computeOrderedDependencies(Set<T> pendingDependencies,\n+                                                       DependencyGetter<T> dependencyGetter) {\n+        final LinkedHashSet<T> dependencyFound = new LinkedHashSet<>();\n+        while (!pendingDependencies.isEmpty()) {\n+            int sz = pendingDependencies.size();\n+            pendingDependencies.removeIf(pendingService -> {\n+                if (dependencyFound.containsAll(dependencyGetter.getDependencies(pendingService))) {\n+                    dependencyFound.add(pendingService);\n+                    return true;\n+                }\n+                return false;\n+            });\n+            if (sz == pendingDependencies.size()) {\n+                // didn't find anything to remove, there must be a cycle\n+                break;", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5ODYyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459098623", "bodyText": "Maybe just log?\nI don't want to break our current behavior.", "author": "hui-yang", "createdAt": "2020-07-22T21:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzI0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459123240", "bodyText": "I don't think we support cycle dependencies so throwing error here shouldn't break our current test. We can have a TODO here for now.", "author": "ShirleyZheng92", "createdAt": "2020-07-22T22:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0MjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2NDA3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459064076", "bodyText": "Do you perform another bootstrap call on existing services when rolling back?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T20:29:52Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.activator;\n+\n+import com.aws.iot.evergreen.deployment.BootstrapManager;\n+import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelLifecycle;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+\n+/**\n+ * Activation and rollback of Kernel update deployments.\n+ */\n+public class KernelUpdateActivator extends DeploymentActivator {\n+    private final BootstrapManager bootstrapManager;\n+\n+    @Inject\n+    protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n+        super(kernel);\n+        this.bootstrapManager = bootstrapManager;\n+    }\n+\n+    @Override\n+    public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n+        String deploymentId = deploymentDocument.getDeploymentId();\n+        if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n+            return;\n+        }\n+\n+        // Wait for all services to close\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        try {\n+            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n+            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n+                    deploymentId.replace(':', '.').replace('/', '+')));\n+            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+        } catch (IOException e) {\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            return;\n+        }\n+        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n+        bootstrapManager.persistBootstrapTaskList();\n+        // TODO: KernelAlts prepare bootstrap\n+\n+        try {\n+            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+            if (!bootstrapManager.hasNext()) {\n+                // TODO: flip symlinks, new to current\n+                logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+            }\n+            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")\n+                    + \" requested to complete bootstrap task\");\n+            // TODO: Kernel shutdown supports exit code\n+            // System.exit(exitCode == 101 ? 101 : 100);\n+        } catch (ServiceUpdateException e) {\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            return;\n+        }\n+    }\n+\n+    void rollback(DeploymentDocument deploymentDocument, CompletableFuture<DeploymentResult> totallyCompleteFuture,\n+                  Throwable failureCause) {\n+        String deploymentId = deploymentDocument.getDeploymentId();\n+        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                .log(\"Rolling back failed deployment\");\n+\n+        // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+        long mergeTime = rollbackConfig(deploymentId, totallyCompleteFuture, failureCause);\n+        if (mergeTime == -1) {\n+            return;\n+        }\n+\n+        kernel.getContext().get(ExecutorService.class).execute(() -> {\n+            // TODO: Add timeout\n+            try {\n+                kernel.getContext().get(KernelLifecycle.class).startupAllServices();", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5OTc5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459099792", "bodyText": "No. That can be tricky, so in the design we decided that each bootstrap script is responsible to do best-effort rollback/cleanup on failure", "author": "hui-yang", "createdAt": "2020-07-22T21:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2NDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA2NzEzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459067135", "bodyText": "NIT: info level. It's not invalid input", "author": "ShirleyZheng92", "createdAt": "2020-07-22T20:35:41Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MDM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459070379", "bodyText": "rename to oldServiceBootstrap", "author": "ShirleyZheng92", "createdAt": "2020-07-22T20:41:40Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,\n+                                                Map<String, Object> componentConfig) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> serviceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!serviceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MTA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459071062", "bodyText": "make const. Are these customer facing return code?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T20:42:56Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,\n+                                                Map<String, Object> componentConfig) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> serviceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!serviceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC);\n+        return serviceBootstrap == null\n+                || !serviceBootstrap.toPOJO().equals(serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC));\n+    }\n+\n+    public void persistBootstrapTaskList() {\n+        // TODO: write bootstrapTaskStatusList to writer\n+        // TODO: add file validation\n+    }\n+\n+    public void loadBootstrapTaskList() {\n+        // TODO: read bootstrapTaskStatusList\n+        // TODO: validate file\n+    }\n+\n+    /**\n+     * Execute the given bootstrap task.\n+     *\n+     * @param next BootstrapTaskStatus object\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     */\n+    public int executeOneBootstrapTask(BootstrapTaskStatus next) {\n+        Objects.requireNonNull(next);\n+        // TODO: support bootstrap step in Evergreen Services.\n+        // Load service BootstrapTaskStatus.componentName and call bootstrap here.\n+\n+        return 0;\n+    }\n+\n+    /**\n+     * Execute all bootstrap steps one by one, until kernel restart or device reboot is requested to complete any one\n+     * of the bootstrap steps.\n+     *\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     * @throws ServiceUpdateException if a bootstrap step fails\n+     */\n+    public int executeAllBootstrapTasksSequentially() throws ServiceUpdateException {\n+        int exitCode;\n+        while (hasNext()) {\n+            BootstrapTaskStatus next = next();\n+            logger.atInfo().kv(\"componentName\", next.componentName).log(\"Execute component bootstrap step\");\n+            exitCode = executeOneBootstrapTask(next);\n+            switch (exitCode) {\n+                case 0:\n+                case 100:\n+                case 101:", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwMjU5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459102592", "bodyText": "Yes. Will do", "author": "hui-yang", "createdAt": "2020-07-22T21:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MzA2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459073060", "bodyText": "if exitcode is 0 then this log line isn't correct", "author": "ShirleyZheng92", "createdAt": "2020-07-22T20:46:43Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.activator;\n+\n+import com.aws.iot.evergreen.deployment.BootstrapManager;\n+import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelLifecycle;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+\n+/**\n+ * Activation and rollback of Kernel update deployments.\n+ */\n+public class KernelUpdateActivator extends DeploymentActivator {\n+    private final BootstrapManager bootstrapManager;\n+\n+    @Inject\n+    protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n+        super(kernel);\n+        this.bootstrapManager = bootstrapManager;\n+    }\n+\n+    @Override\n+    public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n+        String deploymentId = deploymentDocument.getDeploymentId();\n+        if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n+            return;\n+        }\n+\n+        // Wait for all services to close\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        try {\n+            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n+            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n+                    deploymentId.replace(':', '.').replace('/', '+')));\n+            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+        } catch (IOException e) {\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            return;\n+        }\n+        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n+        bootstrapManager.persistBootstrapTaskList();\n+        // TODO: KernelAlts prepare bootstrap\n+\n+        try {\n+            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+            if (!bootstrapManager.hasNext()) {\n+                // TODO: flip symlinks, new to current\n+                logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+            }\n+            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNTA3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459105075", "bodyText": "executeAllBootstrapTasksSequentially will continue to run the next bootstrap task if the current one returns 0. So here we have 3 cases, 0 (all tasks done) => restart, 100 (may not finish all tasks) => restart, 101 (may not finish all tasks) => reboot.\nWill try to add some comments in line for clarifications.", "author": "hui-yang", "createdAt": "2020-07-22T21:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA3MzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MDI1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459080257", "bodyText": "hasNext() and Next() need to be synchronized", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:00:35Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,\n+                                                Map<String, Object> componentConfig) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> serviceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!serviceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC);\n+        return serviceBootstrap == null\n+                || !serviceBootstrap.toPOJO().equals(serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC));\n+    }\n+\n+    public void persistBootstrapTaskList() {\n+        // TODO: write bootstrapTaskStatusList to writer\n+        // TODO: add file validation\n+    }\n+\n+    public void loadBootstrapTaskList() {\n+        // TODO: read bootstrapTaskStatusList\n+        // TODO: validate file\n+    }\n+\n+    /**\n+     * Execute the given bootstrap task.\n+     *\n+     * @param next BootstrapTaskStatus object\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     */\n+    public int executeOneBootstrapTask(BootstrapTaskStatus next) {\n+        Objects.requireNonNull(next);\n+        // TODO: support bootstrap step in Evergreen Services.\n+        // Load service BootstrapTaskStatus.componentName and call bootstrap here.\n+\n+        return 0;\n+    }\n+\n+    /**\n+     * Execute all bootstrap steps one by one, until kernel restart or device reboot is requested to complete any one\n+     * of the bootstrap steps.\n+     *\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     * @throws ServiceUpdateException if a bootstrap step fails\n+     */\n+    public int executeAllBootstrapTasksSequentially() throws ServiceUpdateException {\n+        int exitCode;\n+        while (hasNext()) {\n+            BootstrapTaskStatus next = next();\n+            logger.atInfo().kv(\"componentName\", next.componentName).log(\"Execute component bootstrap step\");\n+            exitCode = executeOneBootstrapTask(next);\n+            switch (exitCode) {\n+                case 0:\n+                case 100:\n+                case 101:\n+                    persistBootstrapTaskList();\n+                    break;\n+                default:\n+                    throw new ServiceUpdateException(\"Fail to execute bootstrap step for \" + next.componentName);\n+            }\n+            if (exitCode != 0) {\n+                return exitCode;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNjI5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459106296", "bodyText": "this class is not thread-safe. I can add that clarification", "author": "hui-yang", "createdAt": "2020-07-22T21:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MDI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4Mjk4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459082986", "bodyText": "Why not let the exception throw? It's better to fail fast on invalid input", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:06:03Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,\n+                                                Map<String, Object> componentConfig) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwODM3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459108372", "bodyText": "Right. I'll update the error handling here.", "author": "hui-yang", "createdAt": "2020-07-22T22:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4Mjk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4MzQzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459083437", "bodyText": "I'd prefer renaming to getDependenciesWithinSubset", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:06:54Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4NDg5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459084897", "bodyText": "Curious , why not using Queue , but having a cursor and a list instead?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:09:35Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atError().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        // Figure out the dependency order within the subset of components which require changes\n+        final LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getRelevantDependencies(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name)));\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getRelevantDependencies(String componentName, Set<String> subset,\n+                                                Map<String, Object> componentConfig) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> serviceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!serviceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC);\n+        return serviceBootstrap == null\n+                || !serviceBootstrap.toPOJO().equals(serviceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC));\n+    }\n+\n+    public void persistBootstrapTaskList() {\n+        // TODO: write bootstrapTaskStatusList to writer\n+        // TODO: add file validation\n+    }\n+\n+    public void loadBootstrapTaskList() {\n+        // TODO: read bootstrapTaskStatusList\n+        // TODO: validate file\n+    }\n+\n+    /**\n+     * Execute the given bootstrap task.\n+     *\n+     * @param next BootstrapTaskStatus object\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     */\n+    public int executeOneBootstrapTask(BootstrapTaskStatus next) {\n+        Objects.requireNonNull(next);\n+        // TODO: support bootstrap step in Evergreen Services.\n+        // Load service BootstrapTaskStatus.componentName and call bootstrap here.\n+\n+        return 0;\n+    }\n+\n+    /**\n+     * Execute all bootstrap steps one by one, until kernel restart or device reboot is requested to complete any one\n+     * of the bootstrap steps.\n+     *\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     * @throws ServiceUpdateException if a bootstrap step fails\n+     */\n+    public int executeAllBootstrapTasksSequentially() throws ServiceUpdateException {\n+        int exitCode;\n+        while (hasNext()) {\n+            BootstrapTaskStatus next = next();\n+            logger.atInfo().kv(\"componentName\", next.componentName).log(\"Execute component bootstrap step\");\n+            exitCode = executeOneBootstrapTask(next);\n+            switch (exitCode) {\n+                case 0:\n+                case 100:\n+                case 101:\n+                    persistBootstrapTaskList();\n+                    break;\n+                default:\n+                    throw new ServiceUpdateException(\"Fail to execute bootstrap step for \" + next.componentName);\n+            }\n+            if (exitCode != 0) {\n+                return exitCode;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        while (cursor < bootstrapTaskStatusList.size()) {", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMDc0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459110743", "bodyText": "That can also be a option.\nI intended to have a list like below and keep syncing the list to disk. Implementing iterator is to wrap the logic of finding the next pending task after kernel restarts.\nBefore execution:\ntask1,pending,\ntask2,pending,\n\nAfter task1:\ntask1,done,100\ntask2,pending,\n\nAfter task2:\ntask1,done,100\ntask2,done,5", "author": "hui-yang", "createdAt": "2020-07-22T22:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4NDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4ODA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459088074", "bodyText": "PersistBootstrapTaskList before shutdown?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:15:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.activator;\n+\n+import com.aws.iot.evergreen.deployment.BootstrapManager;\n+import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelLifecycle;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+\n+/**\n+ * Activation and rollback of Kernel update deployments.\n+ */\n+public class KernelUpdateActivator extends DeploymentActivator {\n+    private final BootstrapManager bootstrapManager;\n+\n+    @Inject\n+    protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n+        super(kernel);\n+        this.bootstrapManager = bootstrapManager;\n+    }\n+\n+    @Override\n+    public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n+        String deploymentId = deploymentDocument.getDeploymentId();\n+        if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n+            return;\n+        }\n+\n+        // Wait for all services to close\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        try {\n+            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n+            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n+                    deploymentId.replace(':', '.').replace('/', '+')));\n+            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+        } catch (IOException e) {\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            return;\n+        }\n+        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n+        bootstrapManager.persistBootstrapTaskList();\n+        // TODO: KernelAlts prepare bootstrap\n+\n+        try {\n+            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+            if (!bootstrapManager.hasNext()) {\n+                // TODO: flip symlinks, new to current\n+                logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+            }\n+            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")\n+                    + \" requested to complete bootstrap task\");\n+            // TODO: Kernel shutdown supports exit code\n+            // System.exit(exitCode == 101 ? 101 : 100);", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNTQ1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459105457", "bodyText": "Since executeAllBootstrapTasksSequentially can run multiple tasks, I plan to add PersistBootstrapTaskList after each task, so we don't need to call persist here again.", "author": "hui-yang", "createdAt": "2020-07-22T21:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4ODA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4OTM0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459089348", "bodyText": "NIT: It's nice if we add test for this class.", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:18:24Z", "path": "src/main/java/com/aws/iot/evergreen/util/DependencyOrder.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public class DependencyOrder<T> {\n+    @FunctionalInterface\n+    public interface DependencyGetter<E> {\n+        Set<E> getDependencies(E elem);\n+    }\n+\n+    /**\n+     * Resolve the inter-dependency order within a given set of elements.\n+     *\n+     * @param pendingDependencies a set of inter-dependent elements\n+     * @param dependencyGetter function to get all dependency elements of the given element\n+     * @return\n+     */\n+    @SuppressWarnings(\"PMD.LooseCoupling\")\n+    public LinkedHashSet<T> computeOrderedDependencies(Set<T> pendingDependencies,", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTMzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459111339", "bodyText": "We actually have unit test coverage because this is extracted from Kernel class. I can refactor the relevant tests", "author": "hui-yang", "createdAt": "2020-07-22T22:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA4OTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MTU0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459091542", "bodyText": "NIT: You can mock DeploymentActivatorFactory.class\nwhen(mockDeploymentActivatorFactory).getDeploymentActivator(anyMap()).thenReturn(mockActivator());\nand verify mockActivator.activate() is invoked once", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:22:52Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -281,6 +288,13 @@ public void GIVEN_deployment_WHEN_task_not_cancelled_THEN_update_is_continued()\n         UpdateSystemSafelyService updateSystemSafelyService = mock(UpdateSystemSafelyService.class);\n         when(context.get(UpdateSystemSafelyService.class)).thenReturn(updateSystemSafelyService);\n \n+        DeploymentActivatorFactory deploymentActivatorFactory = new DeploymentActivatorFactory(kernel);\n+        when(context.get(DeploymentActivatorFactory.class)).thenReturn(deploymentActivatorFactory);\n+        BootstrapManager bootstrapManager = mock(BootstrapManager.class);\n+        when(bootstrapManager.isBootstrapRequired(any())).thenReturn(false);", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMjQ2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459112467", "bodyText": "Yes I can refactor the test. I didn't do that earlier because this test actually verifies some behavior in DefaultActivator before the refactor.", "author": "hui-yang", "createdAt": "2020-07-22T22:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDY4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459124688", "bodyText": "+1", "author": "leaf94", "createdAt": "2020-07-22T22:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2MDY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459760694", "bodyText": "I decide not to refactor this test now. Will try to add more unit tests for activators later.", "author": "hui-yang", "createdAt": "2020-07-23T22:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MzEwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459093107", "bodyText": "Do you need to reset cursor? Also why this class need to implement iterator?", "author": "ShirleyZheng92", "createdAt": "2020-07-22T21:26:03Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.BootstrapManager.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class BootstrapManager implements Iterator<BootstrapManager.BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     */\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();", "originalCommit": "b17af7af556ea892cb28d64dfcc7bf69fefdb0c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMjgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459112820", "bodyText": "good point. will do. 2. explained in the reply above", "author": "hui-yang", "createdAt": "2020-07-22T22:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5MzEwNw=="}], "type": "inlineReview"}, {"oid": "eeca905cfbdc77e180849843066e3c09be105fde", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eeca905cfbdc77e180849843066e3c09be105fde", "message": "Deployment Service can start a Kernel update", "committedDate": "2020-07-23T20:27:13Z", "type": "commit"}, {"oid": "ec423410229c256280cec52139dda32d039979ea", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec423410229c256280cec52139dda32d039979ea", "message": "Address comments to refactor DeploymentActivator", "committedDate": "2020-07-23T20:27:13Z", "type": "commit"}, {"oid": "7469f7023120d64164d8ee54053444e6c1673f8e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7469f7023120d64164d8ee54053444e6c1673f8e", "message": "Temporarily lower the coverage limit for integ tests on Windows", "committedDate": "2020-07-23T20:27:13Z", "type": "commit"}, {"oid": "20a72fe9d0c309493db3160f91d08c99373ac959", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/20a72fe9d0c309493db3160f91d08c99373ac959", "message": "Address comments", "committedDate": "2020-07-23T22:23:53Z", "type": "commit"}, {"oid": "1e843537b79ab158ce9b58e77e9908965dd4735a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1e843537b79ab158ce9b58e77e9908965dd4735a", "message": "Merge remote-tracking branch 'origin/master' into ku00", "committedDate": "2020-07-23T22:30:19Z", "type": "commit"}, {"oid": "1e843537b79ab158ce9b58e77e9908965dd4735a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1e843537b79ab158ce9b58e77e9908965dd4735a", "message": "Merge remote-tracking branch 'origin/master' into ku00", "committedDate": "2020-07-23T22:30:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5ODQ1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459798455", "bodyText": "Protected?", "author": "ShirleyZheng92", "createdAt": "2020-07-24T00:25:58Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/bootstrap/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.bootstrap;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.NO_OP;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Generates a list of bootstrap tasks from deployments, manages the execution and persists status.\n+ */\n+@NotThreadSafe\n+public class BootstrapManager implements Iterator<BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     * @throws ServiceUpdateException if parsing bootstrap tasks from new configuration fails\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) throws ServiceUpdateException {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+        cursor = 0;\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atInfo().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        List<String> errors = new ArrayList<>();\n+        // Figure out the dependency order within the subset of components which require changes\n+        LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getDependenciesWithinSubset(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name), errors));\n+        if (!errors.isEmpty()) {\n+            throw new ServiceUpdateException(errors.toString());\n+        }\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getDependenciesWithinSubset(String componentName, Set<String> subset,\n+                                                    Map<String, Object> componentConfig, List<String> errors) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+                errors.add(e.getMessage());\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> newServiceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!newServiceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || newServiceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceOldBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC);\n+        return serviceOldBootstrap == null\n+                || !serviceOldBootstrap.toPOJO().equals(newServiceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC));\n+    }\n+\n+    public void persistBootstrapTaskList() {\n+        // TODO: write bootstrapTaskStatusList to writer\n+        // TODO: add file validation\n+    }\n+\n+    public void loadBootstrapTaskList() {\n+        // TODO: read bootstrapTaskStatusList\n+        // TODO: validate file\n+    }\n+\n+    /**\n+     * Execute the given bootstrap task.\n+     *\n+     * @param next BootstrapTaskStatus object\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     */\n+    public int executeOneBootstrapTask(BootstrapTaskStatus next) {", "originalCommit": "1e843537b79ab158ce9b58e77e9908965dd4735a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5ODYwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459798604", "bodyText": "Add exit code in the error message", "author": "ShirleyZheng92", "createdAt": "2020-07-24T00:26:48Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/bootstrap/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.bootstrap;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.NO_OP;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Generates a list of bootstrap tasks from deployments, manages the execution and persists status.\n+ */\n+@NotThreadSafe\n+public class BootstrapManager implements Iterator<BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     * @throws ServiceUpdateException if parsing bootstrap tasks from new configuration fails\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) throws ServiceUpdateException {\n+        if (hasNext()) {\n+            return true;\n+        }\n+        bootstrapTaskStatusList.clear();\n+        cursor = 0;\n+\n+        if (newConfig == null || !newConfig.containsKey(SERVICES_NAMESPACE_TOPIC)) {\n+            logger.atInfo().log(\n+                    \"No bootstrap tasks found: Deployment configuration is missing or has no service changes\");\n+            return false;\n+        }\n+        // Compare newConfig with kernel and find out all that changed\n+        Set<String> componentsRequiresBootstrapTask = new HashSet<>();\n+        Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n+        serviceConfig.forEach((name, config) -> {\n+            if (serviceBootstrapRequired(name, (Map<String, Object>) config)) {\n+                componentsRequiresBootstrapTask.add(name);\n+            }\n+        });\n+        if (componentsRequiresBootstrapTask.isEmpty()) {\n+            return false;\n+        }\n+        List<String> errors = new ArrayList<>();\n+        // Figure out the dependency order within the subset of components which require changes\n+        LinkedHashSet<String> dependencyFound =\n+                new DependencyOrder<String>().computeOrderedDependencies(componentsRequiresBootstrapTask,\n+                        name -> getDependenciesWithinSubset(name, componentsRequiresBootstrapTask,\n+                                (Map<String, Object>) serviceConfig.get(name), errors));\n+        if (!errors.isEmpty()) {\n+            throw new ServiceUpdateException(errors.toString());\n+        }\n+        logger.atInfo().kv(\"list\", dependencyFound).log(\"Found a list of bootstrap tasks in dependency order\");\n+        dependencyFound.forEach(name -> bootstrapTaskStatusList.add(new BootstrapTaskStatus(name)));\n+\n+        return !bootstrapTaskStatusList.isEmpty();\n+    }\n+\n+    /**\n+     * Find out dependencies of the given component within a subset of components.\n+     *\n+     * @param componentName name of the component\n+     * @param subset a subset of components\n+     * @param componentConfig config of the component\n+     * @return\n+     */\n+    private Set<String> getDependenciesWithinSubset(String componentName, Set<String> subset,\n+                                                    Map<String, Object> componentConfig, List<String> errors) {\n+        Set<String> relevantDependencies = new HashSet<>();\n+        if (!componentConfig.containsKey(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC)) {\n+            return relevantDependencies;\n+        }\n+        Iterable<String> dependencyList = (Iterable<String>) componentConfig.get(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC);\n+        for (String dependency : dependencyList) {\n+            try {\n+                String depName = EvergreenService.parseSingleDependency(dependency).getLeft();\n+                if (subset.contains(depName)) {\n+                    relevantDependencies.add(depName);\n+                }\n+            } catch (InputValidationException e) {\n+                logger.atError().kv(\"componentName\", componentName).setCause(e).log(\n+                        \"Ignore component with invalid dependency setting\");\n+                errors.add(e.getMessage());\n+            }\n+        }\n+        return relevantDependencies;\n+    }\n+\n+    /**\n+     * Check if Kernel needs to run bootstrap task of the given component.\n+     *\n+     * @param componentName the name of the component\n+     * @return true if component has a bootstrap step under one of the following conditions:\n+     *      1. component is newly added, 2. component version changes, 3. component bootstrap step changes.\n+     *      false otherwise\n+     */\n+    boolean serviceBootstrapRequired(String componentName, Map<String, Object> newServiceConfig) {\n+        if (!newServiceConfig.containsKey(SERVICE_LIFECYCLE_NAMESPACE_TOPIC)) {\n+            return false;\n+        }\n+        Map<String, Object> newServiceLifecycle =\n+                (Map<String, Object>) newServiceConfig.get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+        if (!newServiceLifecycle.containsKey(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC)\n+                || newServiceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC) == null) {\n+            return false;\n+        }\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            return true;\n+        }\n+        if (!service.getConfig().find(VERSION_CONFIG_KEY).getOnce()\n+                .equals(newServiceConfig.get(VERSION_CONFIG_KEY))) {\n+            return true;\n+        }\n+        // TODO: Support bootstrap node to be Topics\n+        Topic serviceOldBootstrap = service.getConfig().find(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC);\n+        return serviceOldBootstrap == null\n+                || !serviceOldBootstrap.toPOJO().equals(newServiceLifecycle.get(LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC));\n+    }\n+\n+    public void persistBootstrapTaskList() {\n+        // TODO: write bootstrapTaskStatusList to writer\n+        // TODO: add file validation\n+    }\n+\n+    public void loadBootstrapTaskList() {\n+        // TODO: read bootstrapTaskStatusList\n+        // TODO: validate file\n+    }\n+\n+    /**\n+     * Execute the given bootstrap task.\n+     *\n+     * @param next BootstrapTaskStatus object\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     */\n+    public int executeOneBootstrapTask(BootstrapTaskStatus next) {\n+        Objects.requireNonNull(next);\n+        // TODO: support bootstrap step in Evergreen Services.\n+        // Load service BootstrapTaskStatus.componentName and call bootstrap here.\n+\n+        return 0;\n+    }\n+\n+    /**\n+     * Execute all bootstrap steps one by one, until kernel restart or device reboot is requested to complete any one\n+     * of the bootstrap steps.\n+     *\n+     * @return 100 if kernel restart is needed, 101 if device reboot is needed, 0 if no-op.\n+     * @throws ServiceUpdateException if a bootstrap step fails\n+     */\n+    public int executeAllBootstrapTasksSequentially() throws ServiceUpdateException {\n+        int exitCode;\n+        while (hasNext()) {\n+            BootstrapTaskStatus next = next();\n+            logger.atInfo().kv(\"componentName\", next.getComponentName()).log(\"Execute component bootstrap step\");\n+            exitCode = executeOneBootstrapTask(next);\n+\n+            switch (exitCode) {\n+                case NO_OP:\n+                case REQUEST_RESTART:\n+                case REQUEST_REBOOT:\n+                    persistBootstrapTaskList();\n+                    break;\n+                default:\n+                    throw new ServiceUpdateException(\"Fail to execute bootstrap step for \" + next.getComponentName());", "originalCommit": "1e843537b79ab158ce9b58e77e9908965dd4735a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMzY4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r459803689", "bodyText": "I'd prefer splitting this into two functions: isBootstrapRequired() and loadBootstrapFromConfig(newConfig) .\nisBootstrapRequired() will be useful when multiple restarts are required during one deployment , and loadBootstrapFromConfig() is used once every deployment.", "author": "ShirleyZheng92", "createdAt": "2020-07-24T00:49:16Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/bootstrap/BootstrapManager.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment.bootstrap;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DependencyOrder;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.NO_OP;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapTaskStatus.ExecutionStatus.DONE;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.Lifecycle.LIFECYCLE_BOOTSTRAP_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Generates a list of bootstrap tasks from deployments, manages the execution and persists status.\n+ */\n+@NotThreadSafe\n+public class BootstrapManager implements Iterator<BootstrapTaskStatus>  {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+    @Setter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PACKAGE)\n+    private List<BootstrapTaskStatus> bootstrapTaskStatusList = new ArrayList<>();\n+    private final Kernel kernel;\n+    private int cursor;\n+\n+    /**\n+     * Constructor for BootstrapManager to process bootstrap tasks from deployments.\n+     *\n+     * @param kernel Kernel instance\n+     */\n+    @Inject\n+    public BootstrapManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.cursor = 0;\n+    }\n+\n+    /**\n+     * Check if any bootstrap tasks are pending. Meanwhile resolve a list of bootstrap tasks if not done already.\n+     *\n+     * @param newConfig new configuration from deployment\n+     * @return true if there are bootstrap tasks, false otherwise\n+     * @throws ServiceUpdateException if parsing bootstrap tasks from new configuration fails\n+     */\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")\n+    public boolean isBootstrapRequired(Map<Object, Object> newConfig) throws ServiceUpdateException {", "originalCommit": "1e843537b79ab158ce9b58e77e9908965dd4735a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2OTUxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/309#discussion_r460169514", "bodyText": "Actuallly isBootstrapRequired is only intended to be used in a new deployment, not after restart. Maybe the implementation is confusing. I'll clean it up.", "author": "hui-yang", "createdAt": "2020-07-24T16:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMzY4OQ=="}], "type": "inlineReview"}, {"oid": "5b321e87b6b7c1ef9f0b250f542f3d8b68a62f79", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b321e87b6b7c1ef9f0b250f542f3d8b68a62f79", "message": "Address comments", "committedDate": "2020-07-24T16:51:16Z", "type": "commit"}, {"oid": "e0cfc91da32f94f8d7d9e3d926e7000e0424044f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e0cfc91da32f94f8d7d9e3d926e7000e0424044f", "message": "Merge branch 'master' into ku00", "committedDate": "2020-07-24T19:22:33Z", "type": "commit"}]}