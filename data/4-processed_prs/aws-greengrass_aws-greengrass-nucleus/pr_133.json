{"pr_number": 133, "pr_title": "Fix kernel blocking when merging same config twice", "pr_createdAt": "2020-03-24T20:58:08Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4Nzc3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397487773", "bodyText": "this needs a comment for why it is a global lock", "author": "MikeDombo", "createdAt": "2020-03-24T22:00:16Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -123,7 +124,7 @@ private void updateStateAndBroadcast(State newState) {\n         logger.atInfo().setEventType(\"service-set-state\").addKeyValue(\"currentState\", currentState)\n                 .addKeyValue(\"newState\", newState).log();\n \n-        synchronized (this.state) {\n+        synchronized (State.class) {", "originalCommit": "2c21f4b35a24bc38617002a25bf106d51765ccab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488041", "bodyText": "nit\n.equals.", "author": "MikeDombo", "createdAt": "2020-03-24T22:00:53Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {", "originalCommit": "2c21f4b35a24bc38617002a25bf106d51765ccab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488531", "bodyText": "We need a way to cancel this: ex if the future that we return is cancelled by the user, this should also be cancelled.", "author": "MikeDombo", "createdAt": "2020-03-24T22:01:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(Executor.class).execute(() -> {", "originalCommit": "2c21f4b35a24bc38617002a25bf106d51765ccab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwNTI5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397505293", "bodyText": "So far all this large blob() is in UpdateSystemSafelyService.addUpdateAction() . In which UpdateSystemSafelyService queue actions and run them on runOnPublishQueueAndWait(). There isn't a way to cancel the queued actions in UpdateSystemSafelyService now.", "author": "ShirleyZheng92", "createdAt": "2020-03-24T22:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMTcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397521708", "bodyText": "We don't need to cancel it though, we can cancel our own code inside by checking that the future is not canceled before continuing.", "author": "MikeDombo", "createdAt": "2020-03-24T23:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ=="}], "type": "inlineReview"}, {"oid": "11c3853be4ae2cd430f41730641f7ef236cb45a0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11c3853be4ae2cd430f41730641f7ef236cb45a0", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test", "committedDate": "2020-03-25T00:09:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjIzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592239", "bodyText": "formatting looks off, can you auto-format the whole file please?", "author": "MikeDombo", "createdAt": "2020-03-25T03:37:43Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {", "originalCommit": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjcyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592720", "bodyText": "Not too sure what the behavior is of completing a cancelled future. In the case that it is cancelled, the loop exits and we'll fall through to here and complete it which would normally mean that the merge is done, but that's not the case here.", "author": "MikeDombo", "createdAt": "2020-03-25T03:39:32Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+                            removeServices(removedServices);\n+", "originalCommit": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTMxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397599315", "bodyText": "Updated. However totallyCompleteFuture can be cancelled at any point. We might need to revisit the behavior of cancelling a config merge.", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjcyMA=="}], "type": "inlineReview"}, {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d428e6c49462a68e9aba4dbc931361f884c55ce0", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test", "committedDate": "2020-03-25T04:00:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzQ2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603463", "bodyText": "Since mergeMap is asynchronous, does it mean when line613 is executed the mergeMap might not be done yet? Is that not an issue? Do we need to make mergeMap blocking?", "author": "fengwang666", "createdAt": "2020-03-25T04:28:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608018", "bodyText": "the setValue() in mergeMap is blocking. the running listeners on topics isn't . L613 will be able to locate new evergreen service.", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603841", "bodyText": "Why do we need to run context.runOnPublishQueueAndWait() instead of on the current thread? is it because of mergeMap? Let's try to make this code more readable.", "author": "fengwang666", "createdAt": "2020-03-25T04:30:05Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODM3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608377", "bodyText": "Yes. the topic listeners triggered by mergeMap might not finished at this point. We want the check of reachedDesiredState() happens after topic listeners updates desiredState in every service", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1Mjg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398252857", "bodyText": "Right now maybe add more comments on explain why we need to run on the publish queue. Let's also try to think how we can improve this in the long run.", "author": "fengwang666", "createdAt": "2020-03-26T00:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDY4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604688", "bodyText": "I would log a warn instead.", "author": "fengwang666", "createdAt": "2020-03-25T04:34:08Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODQxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608414", "bodyText": "Sure", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDg0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604847", "bodyText": "This log line should be after removeServices()", "author": "fengwang666", "createdAt": "2020-03-25T04:35:06Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjA1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397606054", "bodyText": "Do we need to clean up or revert anything before exiting here? Probably also treat different exception differently. Don't need to address in this PR but I would leave a TODO comment in the code so we don't forget.", "author": "fengwang666", "createdAt": "2020-03-25T04:40:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzI4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607281", "bodyText": "I understand this part of code is copy and paste from previous commit, but I think we shouldn't block on get() forever. I don't understand close() return a future instead of a synchronous call. It's not like we can cancel a close.", "author": "fengwang666", "createdAt": "2020-03-25T04:46:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODY1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608654", "bodyText": "The reason we make it asynchronous is we don't want to block on each service's close. If services don't have dependency on each other, they can be closed in parallel", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607579", "bodyText": "Not sure only logging is sufficient. Not able to remove the topic seems like an error we need to populate up and handle seriously (e.g. rollback).", "author": "fengwang666", "createdAt": "2020-03-25T04:48:25Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "originalCommit": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608806", "bodyText": "I haven't look into the code of when this case can happen. Can add a TODO here.", "author": "ShirleyZheng92", "createdAt": "2020-03-25T04:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MTk1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398171957", "bodyText": "I don't think it is possible for it to fail, but let me know if you find that it can.", "author": "MikeDombo", "createdAt": "2020-03-25T21:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1NDAzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398254035", "bodyText": "Then let's remove the try..catch. It doesn't provide any value to wrap all the code in try...catch lol.", "author": "fengwang666", "createdAt": "2020-03-26T00:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}], "type": "inlineReview"}, {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test", "committedDate": "2020-03-25T17:43:08Z", "type": "commit"}, {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test", "committedDate": "2020-03-25T17:43:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MjE5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398172191", "bodyText": "Use the public static constant for \"services\"", "author": "MikeDombo", "createdAt": "2020-03-25T21:11:43Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,95 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                // wait until topic listeners finished processing mergeMap changes.\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atWarn(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            removeServices(removedServices);\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                .log(\"All services updated\");\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            //TODO: handle different throwables. Revert changes if applicable.\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();", "originalCommit": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb779a746e2b287cf81e73004215266f9683b71b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb779a746e2b287cf81e73004215266f9683b71b", "message": "Address comments", "committedDate": "2020-03-26T01:38:39Z", "type": "commit"}, {"oid": "fb779a746e2b287cf81e73004215266f9683b71b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb779a746e2b287cf81e73004215266f9683b71b", "message": "Address comments", "committedDate": "2020-03-26T01:38:39Z", "type": "forcePushed"}, {"oid": "9a4de9002202c34d01fb012d3a1fdd743b808208", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9a4de9002202c34d01fb012d3a1fdd743b808208", "message": "Merge branch 'master' into fixConfigMergeTwice", "committedDate": "2020-03-26T12:38:58Z", "type": "commit"}]}