{"pr_number": 245, "pr_title": "Refactored deployment service/added support for local deployment", "pr_createdAt": "2020-05-15T21:17:22Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1MzUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426053519", "bodyText": "Not sure I'd remove this. It will throw runtime exceptions if it can't inject or find the class, etc.", "author": "MikeDombo", "createdAt": "2020-05-15T21:23:00Z", "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -110,7 +110,7 @@ public boolean remove(Object tag) {\n         return parts.computeIfAbsent(tag, c -> new Value(clazz, null));\n     }\n \n-    public <T> T newInstance(Class<T> cl) throws Throwable {\n+    public <T> T newInstance(Class<T> cl) {", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1NDM2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426054365", "bodyText": "probably drop this down to debug.", "author": "MikeDombo", "createdAt": "2020-05-15T21:25:27Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.Setter;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENT_SERVICE_TOPICS;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentType;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+\n+public class DeploymentStatusKeeper {\n+\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE = \"JobType\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n+    private static Logger logger = LogManager.getLogger(DeploymentStatusKeeper.class);\n+\n+    @Inject\n+    @Setter\n+    private Configuration config;\n+\n+    private Topics processedDeployments;\n+\n+    private Map<DeploymentType, Function<Map<String, Object>, Boolean>> deploymentStatusConsumer\n+            = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Register call backs for receiving deployment status updates for a particular deployment type .\n+     * @param type determines which deployment type the call back consumes\n+     * @param consumer deployment status details\n+     * @return true if call back is registered.\n+     */\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n+            Boolean> consumer) {\n+        return deploymentStatusConsumer.putIfAbsent(type, consumer) == null;\n+    }\n+\n+    /**\n+     * Persist deployment status in kernel config.\n+     * @param jobId id for the deployment.\n+     * @param deploymentType type of deployment.\n+     * @param status status of deployment.\n+     * @param statusDetails other details of deployment status.\n+     */\n+    public void persistAndUpdateDeploymentStatus(String jobId, DeploymentType deploymentType,\n+                                                 JobStatus status, Map<String, String> statusDetails) {\n+        // no need to persist status for local deployment\n+        if (deploymentType.equals(DeploymentType.LOCAL)) {\n+            return;\n+        }\n+\n+        Topics processedDeployments = getProcessedDeployments();\n+        //While this method is being run, another thread could be running the updateStatusOfPersistedDeployments\n+        // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n+        synchronized (processedDeployments) {\n+            logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1ODk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426958966", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-05-19T00:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA1NDM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjUzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426062538", "bodyText": "What if there's no consumer? NPE.", "author": "MikeDombo", "createdAt": "2020-05-15T21:50:31Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.Setter;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENT_SERVICE_TOPICS;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentType;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+\n+public class DeploymentStatusKeeper {\n+\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE = \"JobType\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n+    private static Logger logger = LogManager.getLogger(DeploymentStatusKeeper.class);\n+\n+    @Inject\n+    @Setter\n+    private Configuration config;\n+\n+    private Topics processedDeployments;\n+\n+    private Map<DeploymentType, Function<Map<String, Object>, Boolean>> deploymentStatusConsumer\n+            = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Register call backs for receiving deployment status updates for a particular deployment type .\n+     * @param type determines which deployment type the call back consumes\n+     * @param consumer deployment status details\n+     * @return true if call back is registered.\n+     */\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n+            Boolean> consumer) {\n+        return deploymentStatusConsumer.putIfAbsent(type, consumer) == null;\n+    }\n+\n+    /**\n+     * Persist deployment status in kernel config.\n+     * @param jobId id for the deployment.\n+     * @param deploymentType type of deployment.\n+     * @param status status of deployment.\n+     * @param statusDetails other details of deployment status.\n+     */\n+    public void persistAndUpdateDeploymentStatus(String jobId, DeploymentType deploymentType,\n+                                                 JobStatus status, Map<String, String> statusDetails) {\n+        // no need to persist status for local deployment\n+        if (deploymentType.equals(DeploymentType.LOCAL)) {\n+            return;\n+        }\n+\n+        Topics processedDeployments = getProcessedDeployments();\n+        //While this method is being run, another thread could be running the updateStatusOfPersistedDeployments\n+        // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n+        synchronized (processedDeployments) {\n+            logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = new HashMap<>();\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            //Each status update is uniquely stored\n+            Topic thisJob = processedDeployments.createLeafChild(String.valueOf(System.currentTimeMillis()));\n+            thisJob.withValue(deploymentDetails);\n+\n+            if (deploymentStatusConsumer.get(deploymentType).apply(deploymentDetails)) {", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1ODMxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426958313", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-05-19T00:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426063062", "bodyText": "just remove the parentheses.", "author": "MikeDombo", "createdAt": "2020-05-15T21:52:17Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -152,12 +173,35 @@\n             return;\n         }\n         Deployment deployment =\n-                new Deployment(documentString, Deployment.DeploymentType.IOT_JOBS, jobExecutionData.jobId);\n+                new Deployment(documentString, DeploymentType.IOT_JOBS, jobExecutionData.jobId);\n         if (!deploymentsQueue.contains(deployment) && deploymentsQueue.offer(deployment)) {\n             logger.atInfo().kv(JOB_ID_LOG_KEY_NAME, jobExecutionData.jobId).log(\"Added the job to the queue\");\n         }\n     };\n \n+    @Setter\n+    private MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            //TODO: what about error code 0\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.UselessParentheses\")", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjY3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427452676", "bodyText": "removed warning and parentheses", "author": "fahadmohammed01", "createdAt": "2020-05-19T16:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzQwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426063403", "bodyText": "this is uncontrolled, ie. it happens at a random time during JVM shutdown. Does this need to be more controlled, like after all services have shutdown?", "author": "MikeDombo", "createdAt": "2020-05-15T21:53:24Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -186,6 +230,58 @@ public IotJobsHelper(LinkedBlockingQueue<Deployment> deploymentsQueue,\n         this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n     }\n \n+    @Override\n+    @SuppressFBWarnings\n+    public void postInject() {\n+        executorService.submit(() -> {\n+            try {\n+                connectToAWSIot();\n+            } catch (InterruptedException e) {\n+               //TODO: re-evaluate the retry strategy,\n+               // re-connection attempts are made only for ConnectionUnavailableException\n+               logger.error(\"Failed to connect to IoT cloud\");\n+            }\n+        });\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTU0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426961546", "bodyText": "All closeConnection() does is close the mqtt connection and have no clean up tasks related to Iot Jobs. Since mqtt connection will be handles by mqtt proxy going forward, I think this can be over looked for now. Added a TODO.", "author": "fahadmohammed01", "createdAt": "2020-05-19T00:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzY5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426063693", "bodyText": "postinject can be called many times. make sure that these actions only ever run once.", "author": "MikeDombo", "createdAt": "2020-05-15T21:54:22Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -186,6 +230,58 @@ public IotJobsHelper(LinkedBlockingQueue<Deployment> deploymentsQueue,\n         this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n     }\n \n+    @Override\n+    @SuppressFBWarnings\n+    public void postInject() {", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5Mjk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427092996", "bodyText": "Updated to use an atomic boolean to make sure its only run once. This is temporary, when mqtt proxy is implemented all actions that should be run only once can be moved out from postInject.", "author": "fahadmohammed01", "createdAt": "2020-05-19T07:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MzY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NDE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426064197", "bodyText": "you're injecting this, but where is it created concretely?", "author": "MikeDombo", "createdAt": "2020-05-15T21:55:54Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -87,11 +101,18 @@\n     @Inject\n     private IotJobsClientFactory iotJobsClientFactory;\n \n+    @Inject\n+    private ExecutorService executorService;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n     @Setter\n+    @Inject\n+    @Named(\"deploymentsQueue\")", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1ODkwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426958902", "bodyText": "Created by dependency injection", "author": "fahadmohammed01", "createdAt": "2020-05-19T00:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NDE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMTA1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426101058", "bodyText": "This logic needs to change. In case when deployment type is not same, it should continue executing the current job. Also in that case, we need to peek() instead of poll(). It should look something like:\nDeployment deployment = deploymentQueue.peek();\n...\nif (!currentDeploymentType.equals(deployment.getDeploymentType()) ||\n    (deployment.getId().equals(currentDeploymentId) && deployment.getDeploymentType().equals(currentDeploymentType))) {\ncontinue;\n} else {\n...//cancel\n}\ndeploymentsQueue.remove(deployment);\ncreateNewDeployment(deployment);", "author": "abanthiy", "createdAt": "2020-05-16T00:59:07Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -178,64 +152,31 @@ public void startup() throws InterruptedException {\n             // the waiting on currentProcessStatus in its own thread. I currently choose to not do this.\n             Deployment deployment = deploymentsQueue.poll();\n             if (deployment != null) {\n-                if (currentJobId != null) {\n-                    if (deployment.getId().equals(currentJobId)) {\n+                if (currentDeploymentId != null) {\n+                    if (deployment.getId().equals(currentDeploymentId)", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MjIyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426942222", "bodyText": "Updated likewise", "author": "fahadmohammed01", "createdAt": "2020-05-18T23:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMTQ3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426101470", "bodyText": "JobStatus.IN_PROGRESS should be replaced by custom enum which will then be mapped to JobStatus.IN_PROGRESS in the deploymentStatusKeeper when deployment type is IOT_JOBS. For other types it must map to other expected statuses. Same applies to FAILED and SUCCEED status updates", "author": "abanthiy", "createdAt": "2020-05-16T01:02:48Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -305,125 +250,22 @@ private void createNewDeployment(Deployment deployment) {\n                     .log(\"Invalid document for deployment\");\n             HashMap<String, String> statusDetails = new HashMap<>();\n             statusDetails.put(\"error\", e.getMessage());\n-            storeDeploymentStatusInConfig(deployment.getId(), JobStatus.FAILED, statusDetails);\n+            deploymentStatusKeeper.persistAndUpdateDeploymentStatus(deployment.getId(), deployment.getDeploymentType(),\n+                    JobStatus.FAILED, statusDetails);\n             return;\n         }\n         currentDeploymentTask =\n                 new DeploymentTask(dependencyResolver, packageManager, kernelConfigResolver, deploymentConfigMerger,\n                         logger, deploymentDocument);\n-        storeDeploymentStatusInConfig(deployment.getId(), JobStatus.IN_PROGRESS, new HashMap<>());\n-        updateStatusOfPersistedDeployments();\n+        deploymentStatusKeeper.persistAndUpdateDeploymentStatus(deployment.getId(), deployment.getDeploymentType(),\n+                JobStatus.IN_PROGRESS, new HashMap<>());", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5Mzg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427093842", "bodyText": "Agreed, but it would be better to make this change when there is another deployment method that required status updates sent via another channel.", "author": "fahadmohammed01", "createdAt": "2020-05-19T07:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzU4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426103580", "bodyText": "If the connectToAWSIot get a device configuration exception because device was not configured to communicate with Iot cloud then this step should not happen. We can argue that it does not hurt, but it is not clean.", "author": "abanthiy", "createdAt": "2020-05-16T01:24:45Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -186,6 +230,58 @@ public IotJobsHelper(LinkedBlockingQueue<Deployment> deploymentsQueue,\n         this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n     }\n \n+    @Override\n+    @SuppressFBWarnings\n+    public void postInject() {\n+        executorService.submit(() -> {\n+            try {\n+                connectToAWSIot();\n+            } catch (InterruptedException e) {\n+               //TODO: re-evaluate the retry strategy,\n+               // re-connection attempts are made only for ConnectionUnavailableException\n+               logger.error(\"Failed to connect to IoT cloud\");\n+            }\n+        });\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                closeConnection();\n+            } catch (ExecutionException | InterruptedException e) {\n+                logger.atError().log(\"Error while closing IoT client\", e);\n+            }\n+        }));\n+\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.IOT_JOBS,", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0MzI4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426943288", "bodyText": "In that case the device should not receive any deployments of type IOT_JOB. In that case this call back will not be invoked.", "author": "fahadmohammed01", "createdAt": "2020-05-18T23:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODQ0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427518441", "bodyText": "I know but why even register when it cannot be invoked?", "author": "abanthiy", "createdAt": "2020-05-19T18:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzcyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426103720", "bodyText": "How does this thread continue to live? If the thread dies then the subscription/communication with Iot cloud will also die right? Have you tested this E2E?", "author": "abanthiy", "createdAt": "2020-05-16T01:26:05Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -186,6 +230,58 @@ public IotJobsHelper(LinkedBlockingQueue<Deployment> deploymentsQueue,\n         this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n     }\n \n+    @Override\n+    @SuppressFBWarnings\n+    public void postInject() {\n+        executorService.submit(() -> {\n+            try {\n+                connectToAWSIot();", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1OTk4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426959987", "bodyText": "The connectToAWSIot will not run once the mqtt connection is established.  Once a connection is established, onConnectionResumed call back is used to re-subscribe to topics used by iot jobs. Yes we do not attempt to create a new mqtt connection after one has been established, i think this behavior is ok for now as the reconnect will be handled by mqtt proxy in the future.", "author": "fahadmohammed01", "createdAt": "2020-05-19T00:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzk5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426103998", "bodyText": "How does this gets initialized?", "author": "abanthiy", "createdAt": "2020-05-16T01:29:29Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -80,48 +63,33 @@\n     private KernelConfigResolver kernelConfigResolver;\n     @Inject\n     private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n     @Inject\n-    private IotJobsHelper iotJobsHelper;\n+    private Context context;\n \n     @Getter\n     private Future<DeploymentResult> currentProcessStatus = null;\n \n     // This is very likely not thread safe. If the Deployment Service is split into multiple threads in a re-design\n     // as mentioned in some other comments, this will need an update as well\n-    private String currentJobId = null;\n+    private String currentDeploymentId = null;\n+    private Deployment.DeploymentType currentDeploymentType = null;\n+\n     private final AtomicInteger currentJobAttemptCount = new AtomicInteger(0);\n     private DeploymentTask currentDeploymentTask = null;\n \n     @Getter\n     private final AtomicBoolean receivedShutdown = new AtomicBoolean(false);\n-    // If a device is unable to connect to AWS Iot upon starting due to network availability this flag will be set\n-    // which will indicate the device to retry connecting to AWS Iot cloud after polling frequency\n-    private final AtomicBoolean retryConnectingToAWSIot = new AtomicBoolean(false);\n+\n     @Setter\n     private long pollingFrequency = DEPLOYMENT_POLLING_FREQUENCY;\n-    private LinkedBlockingQueue<Deployment> deploymentsQueue = new LinkedBlockingQueue<>();\n-\n-    final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n-        @Override\n-        public void onConnectionInterrupted(int errorCode) {\n-            //TODO: what about error code 0\n-            if (errorCode != 0) {\n-                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n-                //TODO: Detect this using secondary mechanisms like checking if internet is availalble\n-                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n-            }\n-        }\n \n-        @Override\n-        @SuppressWarnings(\"PMD.UselessParentheses\")\n-        public void onConnectionResumed(boolean sessionPresent) {\n-            logger.atInfo().kv(\"sessionPresent\", (sessionPresent ? \"true\" : \"false\")).log(\"Connection resumed\");\n-            runInSeparateThread(() -> {\n-                subscribeToIotJobTopics();\n-                updateStatusOfPersistedDeployments();\n-            });\n-        }\n-    };\n+    @Inject\n+    @Named(\"deploymentsQueue\")\n+    private LinkedBlockingQueue<Deployment> deploymentsQueue;", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0NDE4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426944184", "bodyText": "Initialized by dependency injection.", "author": "fahadmohammed01", "createdAt": "2020-05-18T23:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwNDA4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426104080", "bodyText": "Where are they used?", "author": "abanthiy", "createdAt": "2020-05-16T01:30:09Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -9,6 +9,8 @@\n import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.IotJobsHelper;\n+import com.aws.iot.evergreen.deployment.LocalDeploymentListener;", "originalCommit": "ae7253927e9c386b0c89f4f325138e06e7b2c424", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0NDA5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r426944091", "bodyText": "Thats strange, I don't have this now. It should have been removed before I pushed. It got added when I tested something, it is removed now", "author": "fahadmohammed01", "createdAt": "2020-05-18T23:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwNDA4MA=="}], "type": "inlineReview"}, {"oid": "ea56d25c66765b5eccbf2867d4408717f502ab5a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea56d25c66765b5eccbf2867d4408717f502ab5a", "message": "initial changes to support local deployment", "committedDate": "2020-05-18T23:57:03Z", "type": "commit"}, {"oid": "3956cfea642c25f5ce93113afa9ee9234ccdd715", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3956cfea642c25f5ce93113afa9ee9234ccdd715", "message": "refactored deployment service to reduce the coupling with iotjobshelper", "committedDate": "2020-05-18T23:57:03Z", "type": "commit"}, {"oid": "bdbef8e4f22f15e78f3cc925c15806030914cea5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bdbef8e4f22f15e78f3cc925c15806030914cea5", "message": "added/updaed unit tests\n\n(cherry picked from commit 3b31b5a00a2d3d47193f178f5af18884fe0cb9eb)", "committedDate": "2020-05-18T23:57:03Z", "type": "commit"}, {"oid": "33263353e1d9d576b3c775da20c7122b80f6b95c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33263353e1d9d576b3c775da20c7122b80f6b95c", "message": "addressed pr comments", "committedDate": "2020-05-19T00:07:42Z", "type": "commit"}, {"oid": "33263353e1d9d576b3c775da20c7122b80f6b95c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33263353e1d9d576b3c775da20c7122b80f6b95c", "message": "addressed pr comments", "committedDate": "2020-05-19T00:07:42Z", "type": "forcePushed"}, {"oid": "2148bc6b40c3083a9592516a6d96ca873f519ffc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2148bc6b40c3083a9592516a6d96ca873f519ffc", "message": "addressed pr comments", "committedDate": "2020-05-19T00:12:41Z", "type": "commit"}, {"oid": "b26308becd4a516206c12594803882374177d530", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b26308becd4a516206c12594803882374177d530", "message": "fixed formatting", "committedDate": "2020-05-19T00:32:40Z", "type": "commit"}, {"oid": "4608963602318dc28f6d5535d74ea14d1383f02b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4608963602318dc28f6d5535d74ea14d1383f02b", "message": "added tests/ addressed pr comments", "committedDate": "2020-05-19T07:26:37Z", "type": "commit"}, {"oid": "74bc1faa8d68a8d8a8971a4c5d762ba380c1b19f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/74bc1faa8d68a8d8a8971a4c5d762ba380c1b19f", "message": "addressed pr comments", "committedDate": "2020-05-19T07:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjAxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427446014", "bodyText": "after all to close the kernel.", "author": "MikeDombo", "createdAt": "2020-05-19T16:42:49Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/LocalDeploymentListenerTest.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.LocalDeploymentListener;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.FileUtils;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class LocalDeploymentListenerTest {\n+\n+    private static Kernel kernel;\n+    private static LocalDeploymentListener localDeploymentListener;\n+\n+    @BeforeAll\n+    static void setupKernel() throws IOException {\n+        kernel = new Kernel();", "originalCommit": "74bc1faa8d68a8d8a8971a4c5d762ba380c1b19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MzUzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427463535", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-05-19T17:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODMyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427448321", "bodyText": "Use string interpolation and add a space after type.", "author": "MikeDombo", "createdAt": "2020-05-19T16:46:23Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.Setter;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENT_SERVICE_TOPICS;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentType;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+\n+public class DeploymentStatusKeeper {\n+\n+    public static final String PROCESSED_DEPLOYMENTS_TOPICS = \"ProcessedDeployments\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID = \"JobId\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS = \"JobStatus\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE = \"JobType\";\n+    public static final String PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS = \"StatusDetails\";\n+    private static final String JOB_ID_LOG_KEY_NAME = \"JobId\";\n+    private static Logger logger = LogManager.getLogger(DeploymentStatusKeeper.class);\n+\n+    @Inject\n+    @Setter\n+    private Configuration config;\n+\n+    private Topics processedDeployments;\n+\n+    private final Map<DeploymentType, Function<Map<String, Object>, Boolean>> deploymentStatusConsumer\n+            = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Register call backs for receiving deployment status updates for a particular deployment type .\n+     * @param type determines which deployment type the call back consumes\n+     * @param consumer deployment status details\n+     * @return true if call back is registered.\n+     */\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n+            Boolean> consumer) {\n+        return deploymentStatusConsumer.putIfAbsent(type, consumer) == null;\n+    }\n+\n+    /**\n+     * Persist deployment status in kernel config.\n+     * @param jobId id for the deployment.\n+     * @param deploymentType type of deployment.\n+     * @param status status of deployment.\n+     * @param statusDetails other details of deployment status.\n+     */\n+    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n+                                                  JobStatus status, Map<String, String> statusDetails) {\n+        // no need to persist status for local deployment\n+        if (deploymentType.equals(DeploymentType.LOCAL)) {\n+            return;\n+        }\n+\n+        Topics processedDeployments = getProcessedDeployments();\n+        //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n+        // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n+        synchronized (processedDeployments) {\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = new HashMap<>();\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n+            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            //Each status update is uniquely stored\n+            Topic thisJob = processedDeployments.createLeafChild(String.valueOf(System.currentTimeMillis()));\n+            thisJob.withValue(deploymentDetails);\n+\n+            if (getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n+                processedDeployments.remove(thisJob);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Invokes the call-backs with persisted deployment status updates for deployments with specified type.\n+     * This is called by IotJobsHelper/MqttJobsHelper when connection is re-established to update cloud of all\n+     * all deployments the device performed when offline\n+     * @param type deployment type\n+     */\n+    public void publishPersistedStatusUpdates(DeploymentType type) {\n+        Topics processedDeployments = getProcessedDeployments();\n+        //TODO: better sync approach.\n+        synchronized (processedDeployments) {\n+            ArrayList<Topic> deployments = new ArrayList<>();\n+            processedDeployments.forEach(topic -> {\n+\n+                Map<String, Object> deploymentDetails = (HashMap) ((Topic) topic).getOnce();\n+                DeploymentType deploymentType = (DeploymentType)\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n+                if (deploymentType.equals(type)) {\n+                    deployments.add((Topic) topic);\n+                }\n+            });\n+            // Topics are stored as ConcurrentHashMaps which do not guarantee ordering of elements\n+            // We want the statuses to be updated in the cloud in the order in which they were processed on the device.\n+            // This will be accurate representation of what happened on the device, especially when deployment service\n+            // processes multiple deployments in the order in which they come. Additionally, a customer workflow can\n+            // depend on this order. If Group2 gets successfully updated before Group1 then customer workflow may\n+            // error out.\n+            List<Topic> sortedByTimestamp = deployments.stream().sorted((o1, o2) -> {\n+                if (Long.valueOf(o1.getModtime()) > Long.valueOf(o2.getModtime())) {\n+                    return 1;\n+                }\n+                return -1;\n+            }).collect(Collectors.toList());\n+\n+            Iterator iterator = sortedByTimestamp.iterator();\n+            while (iterator.hasNext()) {\n+                Topic topic = (Topic) iterator.next();\n+                Map<String, Object> deploymentDetails = (HashMap) topic.getOnce();\n+                DeploymentType deploymentType = (DeploymentType)\n+                        deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n+\n+                if (getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n+                    processedDeployments.remove(topic);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n+        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n+            logger.atDebug().log(\"Consumer not found, Dropping status update for type\" + deploymentType);", "originalCommit": "74bc1faa8d68a8d8a8971a4c5d762ba380c1b19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MzgyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427463829", "bodyText": "updated logging", "author": "fahadmohammed01", "createdAt": "2020-05-19T17:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTUyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427449520", "bodyText": "you need to close any context that you make in the after.", "author": "MikeDombo", "createdAt": "2020-05-19T16:48:12Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeperTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentType.IOT_JOBS;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentType.LOCAL;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DeploymentStatusKeeperTest {\n+\n+    private static final Function<Map<String, Object>, Boolean> DUMMY_CONSUMER = (details) -> false;\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+    private Topics processedDeployments;\n+\n+    @BeforeEach\n+    public void setup() {\n+        Configuration config = new Configuration(new Context());", "originalCommit": "74bc1faa8d68a8d8a8971a4c5d762ba380c1b19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MzY3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427463671", "bodyText": "closed conext", "author": "fahadmohammed01", "createdAt": "2020-05-19T17:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTUyMA=="}], "type": "inlineReview"}, {"oid": "b21718bd6bd944ab460d22d23395ef78ec4a7f95", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b21718bd6bd944ab460d22d23395ef78ec4a7f95", "message": "addressed pmd violation", "committedDate": "2020-05-19T16:52:27Z", "type": "commit"}, {"oid": "77ef39e1f61c56d5a55449ced343ac5df9385953", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77ef39e1f61c56d5a55449ced343ac5df9385953", "message": "addressed pr comments", "committedDate": "2020-05-19T17:10:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2NzM2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427467364", "bodyText": "missing spaces in logs.", "author": "MikeDombo", "createdAt": "2020-05-19T17:16:41Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -177,13 +213,77 @@ public IotJobsHelper(LinkedBlockingQueue<Deployment> deploymentsQueue,\n                   AWSIotMqttConnectionFactory awsIotMqttConnectionFactory,\n                   IotJobsClientFactory iotJobsClientFactory,\n                   LinkedBlockingQueue<Deployment> deploymentsQueue,\n-                  MqttClientConnectionEvents callbacks) throws DeviceConfigurationException {\n+                  DeploymentStatusKeeper deploymentStatusKeeper,\n+                  ExecutorService executorService) throws DeviceConfigurationException {\n         this.deviceConfigurationHelper = deviceConfigurationHelper;\n         this.awsIotMqttConnectionFactory = awsIotMqttConnectionFactory;\n         this.iotJobsClientFactory = iotJobsClientFactory;\n         this.deploymentsQueue = deploymentsQueue;\n-        this.callbacks = callbacks;\n         this.thingName = deviceConfigurationHelper.getDeviceConfiguration().getThingName();\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    @SuppressFBWarnings\n+    public void postInject() {\n+\n+        //TODO: once connectToAWSIot and closeConnection is removed from post inject\n+        // this check should be removed\n+        if (postInjectInProgress.get()) {\n+            return;\n+        }\n+        postInjectInProgress.set(true);\n+\n+        //TODO: remove establishing mqtt connection logic when when MQTT proxy is implemented.\n+        executorService.submit(() -> {\n+            try {\n+                connectToAWSIot();\n+            } catch (InterruptedException e) {\n+               //TODO: re-evaluate the retry strategy,\n+               // re-connection attempts are made only for ConnectionUnavailableException\n+               logger.error(\"Failed to connect to IoT cloud\");\n+            }\n+        });\n+\n+        //TODO: remove closing mqtt connection logic from iot jobs handler when MQTT proxy is implemented.\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            try {\n+                closeConnection();\n+            } catch (ExecutionException | InterruptedException e) {\n+                logger.atError().log(\"Error while closing IoT client\", e);\n+            }\n+        }));\n+\n+        deploymentStatusKeeper.registerDeploymentStatusConsumer(DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged);\n+    }\n+\n+    private void connectToAWSIot() throws InterruptedException {\n+        // If a device is unable to connect to AWS Iot upon starting due to network availability,\n+        // the device will retry connecting to AWS Iot cloud. Retry frequency used is the same as frequency\n+        // used by deployment service to poll for new deployments.\n+        boolean shouldRetry = true;\n+        while (shouldRetry && !receivedShutdown.get()) {\n+            shouldRetry = false;\n+            try {\n+                //TODO: Separate out making MQTT connection and IotJobs helper when MQTT proxy is used.\n+                connect();\n+            } catch (DeviceConfigurationException e) {\n+                //Since there is no device configuration, device should still be able to perform local deploymentsQueue\n+                logger.atWarn().setCause(e).log(\"Device not configured to communicate with AWS Iot Cloud\"\n+                        + \"Device will now operate in offline mode\");", "originalCommit": "77ef39e1f61c56d5a55449ced343ac5df9385953", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NTkxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427485918", "bodyText": "updated", "author": "fahadmohammed01", "createdAt": "2020-05-19T17:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2NzM2NA=="}], "type": "inlineReview"}, {"oid": "7f17c3a59ba70d7296f099c1d7fa22274776989b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7f17c3a59ba70d7296f099c1d7fa22274776989b", "message": "added space to logs", "committedDate": "2020-05-19T17:45:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMDY0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427620642", "bodyText": "You need to reset the currentDeploymentType to null as well. The if conditions in the main DeploymentService loop depends on these checks. If this was not caught in tests , then we need to make sure we have tests that catch these things.\nI am trying to think if we can have one object representing the current deployment. Whether that will be overkill or simplification.", "author": "abanthiy", "createdAt": "2020-05-19T21:49:38Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -275,8 +225,7 @@ private void finishCurrentDeployment() throws InterruptedException {\n         // Setting this to null to indicate there is not current deployment being processed\n         // Did not use optionals over null due to performance\n         currentProcessStatus = null;\n-        currentJobId = null;\n-        updateStatusOfPersistedDeployments();\n+        currentDeploymentId = null;", "originalCommit": "7f17c3a59ba70d7296f099c1d7fa22274776989b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0NDg4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427644880", "bodyText": "set currentDeploymentType = null. This needs a bit more refactoring to avoid the multiple assignments that needs to happen at create deployment / finish deployment / cancel deployment.", "author": "fahadmohammed01", "createdAt": "2020-05-19T22:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMTk0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427621941", "bodyText": "Reset the currentDeploymentType to null.", "author": "abanthiy", "createdAt": "2020-05-19T21:52:28Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -286,14 +235,16 @@ private void cancelCurrentDeployment() {\n         if (currentProcessStatus != null) {\n             currentProcessStatus.cancel(true);\n             currentProcessStatus = null;\n-            currentJobId = null;\n+            currentDeploymentId = null;", "originalCommit": "7f17c3a59ba70d7296f099c1d7fa22274776989b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0NDg4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427644885", "bodyText": "done", "author": "fahadmohammed01", "createdAt": "2020-05-19T22:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNTQxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427625415", "bodyText": "Remove?", "author": "abanthiy", "createdAt": "2020-05-19T22:00:22Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -67,33 +52,27 @@\n public class DeploymentServiceTest extends EGServiceTestUtil {\n \n     private static final String TEST_JOB_ID_1 = \"TEST_JOB_1\";\n-    private static final String TEST_JOB_ID_2 = \"TEST_JOB_2\";\n-    private static final String CONNECTION_ERROR = \"Connection error\";\n+    //private static final String TEST_JOB_ID_2 = \"TEST_JOB_2\";\n+    //private static final String CONNECTION_ERROR = \"Connection error\";", "originalCommit": "7f17c3a59ba70d7296f099c1d7fa22274776989b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0NDkwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/245#discussion_r427644904", "bodyText": "removed", "author": "fahadmohammed01", "createdAt": "2020-05-19T22:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNTQxNQ=="}], "type": "inlineReview"}, {"oid": "78956dee521c5668cfa597d34b69828e166fcc5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/78956dee521c5668cfa597d34b69828e166fcc5b", "message": "addressed pr comments", "committedDate": "2020-05-19T22:52:38Z", "type": "commit"}, {"oid": "a9c17d949ef1af3bea9a2cd51637fda194b83a08", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9c17d949ef1af3bea9a2cd51637fda194b83a08", "message": "Merge branch 'master' into local_deployment", "committedDate": "2020-05-19T22:57:28Z", "type": "commit"}]}