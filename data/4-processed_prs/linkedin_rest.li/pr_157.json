{"pr_number": 157, "pr_title": "Update Data Schema Doc to add PDL content.", "pr_createdAt": "2020-01-04T01:20:48Z", "pr_url": "https://github.com/linkedin/rest.li/pull/157", "timeline": [{"oid": "f6fb44d39c2dd0c5a404fd502086d449ca148358", "url": "https://github.com/linkedin/rest.li/commit/f6fb44d39c2dd0c5a404fd502086d449ca148358", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-04T00:49:08Z", "type": "commit"}, {"oid": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "url": "https://github.com/linkedin/rest.li/commit/82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-04T01:08:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMDgyNA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363500824", "bodyText": "This is not correct. doc is not specific to enums. Also for enum symbol docs, we just use java comment syntax /**...*/", "author": "karthikbalasub", "createdAt": "2020-01-06T21:52:49Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMTcwMQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363501701", "bodyText": "PDL doesn't have type as attribute anymore, we just allow the actual type (enum, record or typeref) to be used at the top level.", "author": "karthikbalasub", "createdAt": "2020-01-06T21:55:10Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ0ODc2NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364448765", "bodyText": "removed this one, please check the new revision", "author": "nickibi", "createdAt": "2020-01-08T21:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMTg3OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363501878", "bodyText": "same here, there is no name attribute, name is now part of the type definition.", "author": "karthikbalasub", "createdAt": "2020-01-06T21:55:39Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ0ODYzOA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364448638", "bodyText": "removed this one, please check the new revision", "author": "nickibi", "createdAt": "2020-01-08T21:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMjM4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363502384", "bodyText": "doc is no longer an atribute, we just use javadoc style comments for doc.", "author": "karthikbalasub", "createdAt": "2020-01-06T21:56:53Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwMTUzNg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364401536", "bodyText": "Removed this part.", "author": "nickibi", "createdAt": "2020-01-08T19:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMjc3OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363502778", "bodyText": "I think we can delete this section as each sub-section has specific examples.", "author": "karthikbalasub", "createdAt": "2020-01-06T21:57:56Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5NjYyOA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363896628", "bodyText": "Deleted.", "author": "nickibi", "createdAt": "2020-01-07T18:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUwMjc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mzg0Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363563847", "bodyText": "Import should be a separate section outside records.", "author": "karthikbalasub", "createdAt": "2020-01-07T02:01:41Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5ODUwMQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363898501", "bodyText": "Moved it to a separate section.", "author": "nickibi", "createdAt": "2020-01-07T18:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mzg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mzk0Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363563946", "bodyText": "Same for this as this applies to all types, not just records", "author": "karthikbalasub", "createdAt": "2020-01-07T02:02:15Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTQ4MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363571481", "bodyText": "+1, explain how this works for all types, enum symbols, and record fields (also union members maybe?)", "author": "evanw555", "createdAt": "2020-01-07T02:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyMTMwOA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364021308", "bodyText": "Moved this part to a separate section.", "author": "nickibi", "createdAt": "2020-01-08T00:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Mzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDA2Mg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363564062", "bodyText": "Comment is wrong, f1 and b1 are switched", "author": "karthikbalasub", "createdAt": "2020-01-07T02:02:58Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkwMzE2Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363903166", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-01-07T19:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDgwNQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363564805", "bodyText": "include an example with multiple includes", "author": "karthikbalasub", "createdAt": "2020-01-07T02:06:58Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2MTU2Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364361567", "bodyText": "Added the example", "author": "nickibi", "createdAt": "2020-01-08T17:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDg4OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363564888", "bodyText": "Update text: include fields from one or more other records.", "author": "karthikbalasub", "createdAt": "2020-01-07T02:07:28Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODM3OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363968379", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-01-07T21:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTgyNQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363565825", "bodyText": "Include example for specifying default values", "author": "karthikbalasub", "createdAt": "2020-01-07T02:12:28Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MjM2NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363572365", "bodyText": "+1, especially for bytes (e.g. \"\\u0007\") because I was confused about this for a little while myself.", "author": "evanw555", "createdAt": "2020-01-07T02:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4NjQxOA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363986418", "bodyText": "Added an example for specifying default values.", "author": "nickibi", "createdAt": "2020-01-07T22:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTg2OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363565868", "bodyText": "Include examples with defaults", "author": "karthikbalasub", "createdAt": "2020-01-07T02:12:42Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAxMDg2Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364010867", "bodyText": "Added an example for defaults.", "author": "nickibi", "createdAt": "2020-01-08T00:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTk0OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363565948", "bodyText": "Same here, example for defaults", "author": "karthikbalasub", "createdAt": "2020-01-07T02:13:11Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk5MzcwNg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363993706", "bodyText": "Added an example for defaults.", "author": "nickibi", "createdAt": "2020-01-07T23:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTk5MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363565990", "bodyText": "defaults", "author": "karthikbalasub", "createdAt": "2020-01-07T02:13:23Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk5Mzg3Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363993876", "bodyText": "Added an example for defaults.", "author": "nickibi", "createdAt": "2020-01-07T23:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjA3MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363566071", "bodyText": "This can be removed, not really adding value", "author": "karthikbalasub", "createdAt": "2020-01-07T02:13:48Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk5NTg3MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363995871", "bodyText": "removed", "author": "nickibi", "createdAt": "2020-01-07T23:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjI4OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363566288", "bodyText": "Include a section for inlined records, with examples including how to specify default value.", "author": "karthikbalasub", "createdAt": "2020-01-07T02:15:03Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5NjQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363896483", "bodyText": "Added inline record section and examples.", "author": "nickibi", "createdAt": "2020-01-07T18:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjcwMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363566703", "bodyText": "Like we discussed, we need to keep the details here to be specific to the syntax. Just use a simple sentence to explain what a typeref is and remove the other details.", "author": "karthikbalasub", "createdAt": "2020-01-07T02:17:25Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enums can also be referenced in other schemas by inlining their type definition. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, @deprecation and properties can be added directly to enum symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg4MTI1OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363881258", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-07T18:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Njk2NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363566965", "bodyText": "This is not referencing, this is actually inline defining of the enum.", "author": "karthikbalasub", "createdAt": "2020-01-07T02:18:44Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enums can also be referenced in other schemas by inlining their type definition. ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1MDI1NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364450255", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-08T21:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2Njk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NzA0NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363567044", "bodyText": "Include an example with default", "author": "karthikbalasub", "createdAt": "2020-01-07T02:19:09Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAxMDk3Mg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364010972", "bodyText": "Added an example for defaults.", "author": "nickibi", "createdAt": "2020-01-08T00:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NzA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NzE5MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363567191", "bodyText": "Suggest picking a different name for the field to avoid confusion", "author": "karthikbalasub", "createdAt": "2020-01-07T02:19:57Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg4MDgxMA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363880810", "bodyText": "Updated the name.", "author": "nickibi", "createdAt": "2020-01-07T18:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU2NzE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MDE2Mg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363570162", "bodyText": "Same as Karthik's comments. This section doesn't make sense because PDL schemas don't have \"attributes\" as JSON keys. These things are defined using specific constructs in the syntax.", "author": "evanw555", "createdAt": "2020-01-07T02:36:33Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAwODI5NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364008294", "bodyText": "Shall we just remove this section?", "author": "nickibi", "createdAt": "2020-01-07T23:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MDY2NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363570665", "bodyText": "These are both incorrect; imports are not required at all. Imports are only used for convenience to avoid writing whole FQNs.", "author": "evanw555", "createdAt": "2020-01-07T02:39:22Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTMzNA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363571334", "bodyText": "You should probably just replace this with an explanation of what imports are (i.e. optional statements which allow you to avoid writing whole FQNs, similar to in Java). You should also include below the three rules which dictate the kinds of imports that result in parser errors.", "author": "evanw555", "createdAt": "2020-01-07T02:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTAzMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363571032", "bodyText": "This is misleading and also confusing. The alphabetical rule you're describing is only used by the encoder. Anyone writing PDL can import a type even if it's alphabetically after another type with the same simple name. I'd suggest just removing this point since it doesn't apply to how the parser interprets PDL.", "author": "evanw555", "createdAt": "2020-01-07T02:41:38Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ0ODk5Mg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364448992", "bodyText": "removed", "author": "nickibi", "createdAt": "2020-01-08T21:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTU5NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363571595", "bodyText": "You should also explain that includes can be done after the definition as well (include-before vs include-after)", "author": "evanw555", "createdAt": "2020-01-07T02:45:14Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAxMDYwMA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364010600", "bodyText": "Discussed offline, will not include this part.", "author": "nickibi", "createdAt": "2020-01-08T00:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363571799", "bodyText": "Include example showing that properties without explicit values (e.g. @prop) can be used, and explain that this results in a value of true.", "author": "evanw555", "createdAt": "2020-01-07T02:46:17Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAxMDcwMA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364010700", "bodyText": "Added the example.", "author": "nickibi", "createdAt": "2020-01-08T00:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MjA4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363572084", "bodyText": "I'd suggest using a more clear example. This example is confusing because there are only two segments in the path, and the value also happens to represent a path as well. Something like @a.b.c = 10 is good, because then the expanded @a = {\"b\": {\"c\": 10}} is exaggerated.", "author": "evanw555", "createdAt": "2020-01-07T02:48:07Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyMDQ1OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364020459", "bodyText": "Fixed the example.", "author": "nickibi", "createdAt": "2020-01-08T00:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MjY4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363572684", "bodyText": "typo: \"separate\". Same as below. Also reword this sentence because it's a little unclear.", "author": "evanw555", "createdAt": "2020-01-07T02:51:38Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5NjYwMQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364396601", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-08T19:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Mjg2Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363572866", "bodyText": "nit: don't put a space between the word and the parenthesis. This applies to all other instances in this doc.", "author": "evanw555", "createdAt": "2020-01-07T02:52:43Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MzU4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363963584", "bodyText": "\"a space between the word and the parenthesis\". Can you please point to the right place or you wanted to say something else?", "author": "nickibi", "createdAt": "2020-01-07T21:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Mjg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzE2MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363573160", "bodyText": "This sentence doesn't really make sense. Maybe say \"Pegasus Arrays are defined as a collection of a particular \"items\" type\"?", "author": "evanw555", "createdAt": "2020-01-07T02:54:29Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1MTg2Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363951866", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-01-07T21:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzM5MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363573391", "bodyText": "nit: don't use the at-sign, just say deprecation.", "author": "evanw555", "createdAt": "2020-01-07T02:55:57Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enums can also be referenced in other schemas by inlining their type definition. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, @deprecation and properties can be added directly to enum symbols. ", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1MTk5OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363951998", "bodyText": "updated", "author": "nickibi", "createdAt": "2020-01-07T21:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzUwOQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363573509", "bodyText": "reword: \"Aliased unions are defined as:\"", "author": "evanw555", "createdAt": "2020-01-07T02:56:41Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDY3Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363960676", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-07T21:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3MzUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Mzc4MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363573780", "bodyText": "I notice you've left the little \u3002character in some places in place of a period. Please replace with a period in all places.", "author": "evanw555", "createdAt": "2020-01-07T02:58:12Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enums can also be referenced in other schemas by inlining their type definition. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, @deprecation and properties can be added directly to enum symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like\n+a typedef in C. It does not declare a new type but declares an alias to\n+an existing type.\n+\n+  - Typerefs are useful for differentiating different uses of the same\n+    type. For example, we can use to a typeref to differentiate a string\n+    field that holds an URN (uniform resource name) from an arbitrary\n+    string value or a long field that holds an epoch time in\n+    milliseconds from a generic long value.\n+  - A typeref allows additional meta-data to be associated with\n+    primitive and unnamed types. This meta-data can be used to provide\n+    documentation or support custom properties.\n+  - A typeref provides a way to refer to common unnamed types such as\n+    arrays, maps, and unions. Without typerefs, users may have to wrap\n+    these unnamed types with a record in order to address them.\n+    Alternatively, users may cut-and-paste common type declarations,\n+    resulting in unnecessary duplication and potentially causing\n+    inconsistencies if future changes are not propagated correctly to\n+    all copies.\n+\n+\n+### Provide a name for a union, map, or array. So that it can be referenced by name\u3002\n+\n+It is very useful, because unions, maps and arrays cannot be named directly like records and enums.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+typeref AnswerTypes = union[MultipleChoice, TextEntry]\n+\n+```\n+\n+Typerefs can be referred to from any other type using the name\u3002", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1MjUzOQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363952539", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-07T21:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3Mzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3NDI1Mw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363574253", "bodyText": "These headers seem odd because there's no context. It's as if they're supposed to be in a list of \"reasons to use typerefs\". You could either make a section that's explicit about this, or you can just reword the headers to something like Typerefs can be used to name anonymous types, Typerefs can provide additional clarity when using primitive types, and Typerefs can be used to specify custom types and coercers (though this last one should probably be moved to another Java-specific page, perhaps you can do that later).", "author": "evanw555", "createdAt": "2020-01-07T03:01:02Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,828 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Typerefs](#typerefs)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+The named schema declarations support the following attributes: \n+\n+  - `type` provides the type of the named schema\n+    (required).\n+  - `name` provides the name of the named schema\n+    (required).\n+  - `namespace` qualifies the namespace for the named\n+    schema.\n+  - `package` qualifies the language binding\n+    namespace for the named schema (optional). If this is not specified,\n+    language  bindingclass for the named schema will use `namespace` as\n+    its default namespace.\n+  - `doc` provides documentation to the user of this\n+    named schema (optional).\n+  - `import` qualifies the name of object which is used in the schema.(optional).\n+\n+The named schemas with type \u201cenum\u201d also supports a `doc`\n+attribute to provide documentation for each enum symbol.\n+\n+**Note:** Due to the addition of doclint in JDK8, anything under the\n+`doc`  attribute must be W3C HTML 4.01 compliant. This is\n+because the contents of this string will appear as Javadocs in the\n+generated Java \u2018data template\u2019 classes later. Please take this into\n+consideration when writing your documentation.\n+\n+The following are a few example schemas and their file names.\n+\n+\n+com/linkedin/pegasus/generator/examples/Foo.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, \n+    /**\n+     * A foo record\n+     */\n+    record Foo {\n+      intField: int\n+      longField: long\n+      floatField: float\n+      doubleField: double\n+      bytesField: bytes\n+      stringField: string\n+      intArrayField: array[int]\n+      stringMapField: map[string, string]\n+      unionField: union[int, string, Foo, array[string], map[string, long]]\n+    }, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/FooWithNamespaceOverride.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+package com.linkedin.pegasus.generator.examples.`record`\n+\n+/**\n+ * A foo record\n+ */\n+record FooWithNamespaceOverride {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  bytesField: bytes\n+  stringField: string\n+  fruitsField: Fruits\n+  intArrayField: array[int]\n+  stringMapField: map[string, string]\n+  unionField: union[int, string, Fruits, array[string], map[string, long]]\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/Fruits.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  /**\n+   * A red, yellow or green fruit.\n+   */\n+  APPLE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  BANANA\n+\n+  /**\n+   * An orange fruit.\n+   */\n+  ORANGE\n+\n+  /**\n+   * A yellow fruit.\n+   */\n+  PINEAPPLE\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/MD5.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * MD5\n+ */\n+fixed MD5 16\n+```\n+\n+com/linkedin/pegasus/generator/examples/StringList.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A list of strings\n+ */\n+record StringList {\n+  element: string\n+  next: optional \n+\n+    /**\n+     * A list of strings\n+     */\n+    record StringList {\n+      element: string\n+      next: optional StringList\n+    }\n+}\n+```\n+\n+com/linkedin/pegasus/generator/examples/InlinedExample.pdl\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Example on how you can declare an enum and a record inside another record\n+ */\n+record InlinedExample {\n+\n+  /**\n+   * This is how we inline enum declaration without creating a new pdl file\n+   */\n+  @symbolDocs.FOO = \"It's a foo!\"\n+  @symbolDocs.NONE = \"It's a baz!\"\n+  @symbolDocs.HASH = \"It's a bar!\"\n+  myEnumField: enum EnumDeclarationInTheSameFile {\n+    FOO\n+    BAR\n+    BAZ\n+  }\n+\n+  /**\n+   * A regular string\n+   */\n+  stringField: string\n+\n+  /**\n+   * A regular int\n+   */\n+  intField: int\n+\n+  /**\n+   * In this example we will declare a record and an enum inside a union\n+   */\n+  UnionFieldWithInlineRecordAndEnum: optional union[record myRecord {\n+\n+    /**\n+     * random int field\n+     */\n+    foo1: int\n+\n+    /**\n+     * random int field\n+     */\n+    foo2: int\n+  }, \n+    /**\n+     * Random enum\n+     */\n+    enum anotherEnum {\n+\n+      /**\n+       * description about FOOFOO\n+       */\n+      FOOFOO\n+\n+      /**\n+       * description about BARBAR\n+       */\n+      BARBAR\n+    }]\n+}\n+```\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive type, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example : \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+\n+### Import\n+\n+1. If the type is outside the root namespace of the document, you need to add it as an import.\n+\n+2. If the type is declared outside the document, you need to add it as an import.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- When multiple referenced types with the same unqualified name may be imported, \n+the type with the alphabetically first namespace is chosen. \n+(e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\") \n+\n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+\n+\n+### Deprecation\n+Types and fields can be deprecated by adding @deprecated annotation.\n+\n+For example :\n+\n+```\n+@deprecated = \"Use record X instead.\"\n+record Example {\n+  @deprecated = \"Use field x instead.\"\n+  field: string\n+}\n+```\n+\n+### Including fields\n+\n+Record can include fields from other record.\n+\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields f1 from itself and b1 from Bar\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.\n+\n+For example : \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example : \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+```\n+\n+#### Property keys can expressed as paths:\n+\n+For example : \n+```\n+@java.class = \"org.joda.DateTime\"\n+@java.coercerClass = \"org.example.DateTimeCoercer\"\n+```\n+\n+The dot seperate keys format is equivalent to JSON value format.\n+\n+The above dot seperate keys example is equivalent to the following JSON value example :\n+```\n+@java = {\n+  \"class\": \"org.joda.DateTime\",\n+  \"coercerClass\": \"org.example.DateTimeCoercer\"\n+}\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example : \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+## Array Type\n+\n+Pegesus Arrays are defined within a items type.\n+\n+For Example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Record Arrays :\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example : \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+Custom Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.customtypes.CustomInt\n+\n+record WithCustomTypesMap {\n+  ints: map[string, CustomInt]\n+}\n+```\n+\n+Complex Types Map :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum map or array type.\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  `union`: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions would be defines as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example :\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enums can also be referenced in other schemas by inlining their type definition. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, @deprecation and properties can be added directly to enum symbols. \n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example :\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like\n+a typedef in C. It does not declare a new type but declares an alias to\n+an existing type.\n+\n+  - Typerefs are useful for differentiating different uses of the same\n+    type. For example, we can use to a typeref to differentiate a string\n+    field that holds an URN (uniform resource name) from an arbitrary\n+    string value or a long field that holds an epoch time in\n+    milliseconds from a generic long value.\n+  - A typeref allows additional meta-data to be associated with\n+    primitive and unnamed types. This meta-data can be used to provide\n+    documentation or support custom properties.\n+  - A typeref provides a way to refer to common unnamed types such as\n+    arrays, maps, and unions. Without typerefs, users may have to wrap\n+    these unnamed types with a record in order to address them.\n+    Alternatively, users may cut-and-paste common type declarations,\n+    resulting in unnecessary duplication and potentially causing\n+    inconsistencies if future changes are not propagated correctly to\n+    all copies.\n+\n+\n+### Provide a name for a union, map, or array. So that it can be referenced by name\u3002", "originalCommit": "82a73b73d1e48aef68cf4d59ab52ba082f38f2e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1NDIzMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r363954233", "bodyText": "updated the headers", "author": "nickibi", "createdAt": "2020-01-07T21:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU3NDI1Mw=="}], "type": "inlineReview"}, {"oid": "39493d1217f39ab7379a6af4c9405315ffa1befa", "url": "https://github.com/linkedin/rest.li/commit/39493d1217f39ab7379a6af4c9405315ffa1befa", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-08T21:39:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODQ4OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364488488", "bodyText": "maps, arrays or other records", "author": "karthikbalasub", "createdAt": "2020-01-08T23:07:33Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5ODY1OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364498658", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-08T23:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODc0Mg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364488742", "bodyText": "remove this as optional is introduced in the next step", "author": "karthikbalasub", "createdAt": "2020-01-08T23:08:22Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5ODcyNg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364498726", "bodyText": "removed", "author": "nickibi", "createdAt": "2020-01-08T23:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODg0OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364488849", "bodyText": "Add a doc to explain this field is optional.", "author": "karthikbalasub", "createdAt": "2020-01-08T23:08:44Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5ODk2MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364498960", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-08T23:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4ODg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4OTI3Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364489276", "bodyText": "An optional", "author": "karthikbalasub", "createdAt": "2020-01-08T23:10:13Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5OTAyMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364499022", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-08T23:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ4OTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MDI4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364490284", "bodyText": "What I meant was the default value for the field that defines the inline record.\neg,\nrecord WithInlineRecord {\ninline: record InlineRecord {\nvalue: int\n} = {\"value\": 1}\ninlineOptional: optional record InlineOptionalRecord {\nvalue: string\n} = {\"value\": \"default-value\"}\n}", "author": "karthikbalasub", "createdAt": "2020-01-08T23:13:33Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Inline record can also contains default values.", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwMTU3Mw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364501573", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-08T23:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MDI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MzMyOQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364493329", "bodyText": "arbitrary data", "author": "karthikbalasub", "createdAt": "2020-01-08T23:23:43Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps and arrays.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field2: optional int\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+A optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Inline record can also contains default values.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * A inline record\n+    */\n+   inlinedRecord: record Boo {\n+      message: string = \"Hello\"\n+   }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary datas and added to records, fields and enums.", "originalCommit": "39493d1217f39ab7379a6af4c9405315ffa1befa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5ODI4Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364498286", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-08T23:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MzMyOQ=="}], "type": "inlineReview"}, {"oid": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "url": "https://github.com/linkedin/rest.li/commit/f25fee15c63e8abeae12c10eafedca1b47adc26a", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-09T00:25:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NTU5Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364895597", "bodyText": "nit: update some examples to include more than one value in the default", "author": "karthikbalasub", "createdAt": "2020-01-09T18:32:43Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {", "originalCommit": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxMjQzOA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364912438", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-01-09T19:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NjA5OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364896098", "bodyText": "Fruits here is enum, not a record, I think you can change the text to say \"Record or Enum arrays:\"", "author": "karthikbalasub", "createdAt": "2020-01-09T18:33:54Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1]\n+  longs: array[long] = [3000000000]\n+  floats: array[float] = [3.3]\n+  doubles: array[double] = [4.4E38]\n+  booleans: array[boolean] = [true]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]", "originalCommit": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxMjUwMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364912503", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-01-09T19:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NjA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NjQyNQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364896425", "bodyText": "Same here, include an example with multiple map entries", "author": "karthikbalasub", "createdAt": "2020-01-09T18:34:40Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1]\n+  longs: array[long] = [3000000000]\n+  floats: array[float] = [3.3]\n+  doubles: array[double] = [4.4E38]\n+  booleans: array[boolean] = [true]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordArrayDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {", "originalCommit": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxNDk1OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364914959", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-09T19:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NjQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzM4Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364897387", "bodyText": "Suggested rewording:\nA union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.", "author": "karthikbalasub", "createdAt": "2020-01-09T18:36:46Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1]\n+  longs: array[long] = [3000000000]\n+  floats: array[float] = [3.3]\n+  doubles: array[double] = [4.4E38]\n+  booleans: array[boolean] = [true]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordArrayDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int\": 1 }\n+  longs: map[string, long] = { \"long\": 3000000000 }\n+  floats: map[string, float] = { \"float\": 3.3 }\n+  doubles: map[string, double] = { \"double\": 4.4E38 }\n+  booleans: map[string, boolean] = { \"boolean\": true }\n+  strings: map[string, string] = { \"string\": \"hello\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum, map or array type.", "originalCommit": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkxNTAwNA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364915004", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-09T19:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5Nzc3MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364897770", "bodyText": "Include a default value in the example", "author": "karthikbalasub", "createdAt": "2020-01-09T18:37:46Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,819 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1]\n+  longs: array[long] = [3000000000]\n+  floats: array[float] = [3.3]\n+  doubles: array[double] = [4.4E38]\n+  booleans: array[boolean] = [true]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordArray {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordArrayDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int\": 1 }\n+  longs: map[string, long] = { \"long\": 3000000000 }\n+  floats: map[string, float] = { \"float\": 3.3 }\n+  doubles: map[string, double] = { \"double\": 4.4E38 }\n+  booleans: map[string, boolean] = { \"boolean\": true }\n+  strings: map[string, string] = { \"string\": \"hello\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Each member may be any pegasus type except union type. \n+Each member can be primitive, record, enum, map or array type.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}", "originalCommit": "f25fee15c63e8abeae12c10eafedca1b47adc26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3MDk5OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r364970998", "bodyText": "Added an example with default value", "author": "nickibi", "createdAt": "2020-01-09T21:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5Nzc3MA=="}], "type": "inlineReview"}, {"oid": "85af80bc1fe0c3a6ff5ec07e42aaf84e39017817", "url": "https://github.com/linkedin/rest.li/commit/85af80bc1fe0c3a6ff5ec07e42aaf84e39017817", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-09T21:40:56Z", "type": "commit"}, {"oid": "4241a14b75fb8f1c9d76054c6358b67c9c15f80a", "url": "https://github.com/linkedin/rest.li/commit/4241a14b75fb8f1c9d76054c6358b67c9c15f80a", "message": "Update Data Schema doc to add PDL content", "committedDate": "2020-01-09T22:04:05Z", "type": "commit"}, {"oid": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "url": "https://github.com/linkedin/rest.li/commit/b296b37030d1444ab9afd5686a84f78a2fb5b01c", "message": "Update the union with default value example", "committedDate": "2020-01-09T22:29:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMjI5MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365012291", "bodyText": "I wouldn't necessarily say PDL is less verbose. I would say it's more concise.", "author": "evanw555", "createdAt": "2020-01-09T23:37:26Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNjMzMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365036332", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T01:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMjI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMzIxMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365013212", "bodyText": "nit: \"Inline Records\"", "author": "evanw555", "createdAt": "2020-01-09T23:40:54Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNzA1Mw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365037053", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-10T01:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMzIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxNDUzOQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365014539", "bodyText": "Explain that the default value for a field is represented as the JSON value for the field's type. This relates to the inlined record default section below.", "author": "evanw555", "createdAt": "2020-01-09T23:46:34Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2MTU3OA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365061578", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T03:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxNDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDQwMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365030402", "bodyText": "Reword: The default value of inlined records can be expressed using its serialized JSON representation.", "author": "evanw555", "createdAt": "2020-01-10T00:53:55Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNzI1Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365037257", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-01-10T01:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDY3OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365030679", "bodyText": "I'd suggest renaming the field to something other than value, the reason being that someone who sees this may think that \"value\" is a special keyword. Maybe just make it someField or something.", "author": "evanw555", "createdAt": "2020-01-10T00:55:05Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzODAxNQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365038015", "bodyText": "Updated the field name.", "author": "nickibi", "createdAt": "2020-01-10T01:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDcxMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365030713", "bodyText": "typo: also", "author": "evanw555", "createdAt": "2020-01-10T00:55:13Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA0MTUxMA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365041510", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-10T01:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMTg2MA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365031860", "bodyText": "As I mentioned offline, make this its own top-level section to describe the mechanics of properties. Then also add blurbs about adding properties to individual sections (e.g. enum symbols, record fields, aliased union members, etc.)", "author": "evanw555", "createdAt": "2020-01-10T01:00:21Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA1Mjc2MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365052761", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-10T02:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjA4Mw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365032083", "bodyText": "Remove y on \"implicity\" and \"explicity\"", "author": "evanw555", "createdAt": "2020-01-10T01:01:03Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA1Mjg3NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365052874", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-10T02:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjUxOQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365032519", "bodyText": "I can see that you copied many of these examples from the unit tests. The namespaces are a little lengthy. Wherever the namespace doesn't matter, make it something simple like com.example.models", "author": "evanw555", "createdAt": "2020-01-10T01:02:59Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc3NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365064775", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-01-10T04:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjY1MQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365032651", "bodyText": "Also explain that escaping property keys can be used to escape reserved keywords such as \"namespace\" or \"record\"", "author": "evanw555", "createdAt": "2020-01-10T01:03:37Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzODI2NQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365038265", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T01:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMjY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMzEyMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365033123", "bodyText": "Reword: Maps are defined with a key type and a value type. The value type can be any valid PDL type, but currently only string is supported for the key type.", "author": "evanw555", "createdAt": "2020-01-10T01:05:49Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzODQyMQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365038421", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T01:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMzEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMzc5Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365033797", "bodyText": "Show that aliased union members can have doc strings and custom properties. Clarify that this is not supported for non-aliased union members.\nExplain that either ALL union members must be aliased, or NONE at all. Having a \"heterogeneously aliased union\" is not allowed (the only exception is that the \"null\" member may be non-aliased, but you can leave this out because it seems like we plan on removing support for this).", "author": "evanw555", "createdAt": "2020-01-10T01:09:06Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record MultipleChoice {\n+  answer: string\n+}\n+```\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record TextEntry {\n+  text: string\n+}\n+```\n+\n+Union with default value:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry] = {\"com.linkedin.pegasus.generator.examples.MultipleChoice\" : {\"answer\" : \"A\"}}\n+}\n+```\n+### Union with aliases", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc1NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365064754", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T04:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzMzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNDAxMQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365034011", "bodyText": "Also explain that this feature is useful for cases where a union contains multiple different typerefs with the same underlying type. This use case is not supported with a non-aliased union.", "author": "evanw555", "createdAt": "2020-01-10T01:10:15Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record MultipleChoice {\n+  answer: string\n+}\n+```\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record TextEntry {\n+  text: string\n+}\n+```\n+\n+Union with default value:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry] = {\"com.linkedin.pegasus.generator.examples.MultipleChoice\" : {\"answer\" : \"A\"}}\n+}\n+```\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA0MDY5Ng==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365040696", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-01-10T01:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNDQwMA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365034400", "bodyText": "In general in the documentation, escape code-like text such as \"@deprecated\" with the backtick so that it shows up like @deprecated", "author": "evanw555", "createdAt": "2020-01-10T01:12:14Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,843 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl__schema_definition)\n+-   [Creating a Schema](#creating_a_schema)\n+-   [Record Type](#record_type)\n+-   [Primitive Types](#primitive_type)\n+-   [Array Type](#array_type)\n+-   [Map Type](#map_type)\n+-   [Union Type](#union_type)\n+-   [Enum Type](#enum_type)\n+-   [Fixed Type](#fixed_type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace\\)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and less verbose than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record_type), [Primitive types](#record_type), [Enums](#enum_type), [Arrays](#array_type), [Maps](#map_type), [Unions](#union_type), [Fixed](#fixed_type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Record\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    value: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    value: string\n+  }\n+}\n+```\n+\n+Default value can be set up for a field that defines the inline records.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      value: int\n+    } = { \"value\" : 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      value: string\n+    } = { \"value\" : \"default-value\" }\n+}\n+```\n+\n+Inline records can aslo be union members.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Properties\n+Properties can be used to present arbitrary data and added to records, fields and enums.\n+\n+For example: \n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+#### Property values can be any valid JSON type:\n+\n+For example: \n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+#### Property values can also be empty: \n+\n+If you don't indicate an explicity property value, it will resuilt in an implicity value of `true`.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}\n+```\n+#### Property keys can be expressed as JSON:\n+\n+For example: \n+```\n+@a = {\n+  \"b\": {\n+    \"c\": {\n+      \"d\": {\n+        \"e\": {\n+          \"f\": false\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+#### Property keys can be expressed as paths:\n+\n+The JSON style property key is complicated to write and read, so we provide a shorthand - the dot separate format to express the property keys.\n+\n+The following example is equivalent to the previous JSON example:\n+\n+```\n+@a.b.c.d.e.f = false\n+```\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks : ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string.\n+For example: \n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are : int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.records\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Pegasus maps are defined with a values type and an optional key type.\n+\n+For example: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+**Note**: \n+The key must always be \"string\".\n+\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.unions\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record MultipleChoice {\n+  answer: string\n+}\n+```\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record TextEntry {\n+  text: string\n+}\n+```\n+\n+Union with default value:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry] = {\"com.linkedin.pegasus.generator.examples.MultipleChoice\" : {\"answer\" : \"A\"}}\n+}\n+```\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members.\n+\n+Aliased unions are defined as :\n+```\n+union [alias: type, ...]\n+```\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+\n+Union with aliases with default value:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record QuestionDefault {\n+ answerFormat: union[   \n+   shortAnswer: string,\n+   longAnswer: string,\n+   multipleChoice: MultipleChoice\n+ ] = { \"shortAnswer\": \"short answer.\" }\n+}\n+```\n+\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enum can also be inline defined.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, deprecation and properties can be added directly to enum symbols. \n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Fixed Type\n+\n+Fixed type is used to define schema with fixed size of bytes. \n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+fixed MD5 16\n+```\n+In the above example, `16` is the defined size of bytes for MD5 schema.\n+\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like\n+a typedef in C. It does not declare a new type but declares an alias to\n+an existing type.\n+\n+### Typerefs can be used to name anonymous types.\n+\n+It is very useful, because unions, maps and arrays cannot be named directly like records and enums.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+typeref AnswerTypes = union[MultipleChoice, TextEntry]\n+\n+```\n+\n+Typerefs can be referred to from any other type using the name.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Question {\n+  answerFormat: AnswerTypes\n+}\n+```\n+      \n+\n+### Typerefs can provide additional clarity when using primitive types.\n+\n+For example:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+typeref UnixTimestamp = long\n+```\n+\n+### Typerefs can be used to specify custom types and coercers\n+For example, Joda time has a convenient DateTime class. If we wish to use this class in Java to represent date times, all we need to do is define a pegasus custom type that binds to it:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@java.class = \"org.joda.time.DateTime\"\n+@java.coercerClass = \"com.linkedin.example.DateTimeCoercer\"\n+typeref DateTime = string\n+```\n+The coercer is responsible for converting the pegasus \u201creferenced\u201d type, in this case \"string\" to the Joda DateTime class:\n+\n+Once a custom type is defined, it can be used in any type. \n+\n+For example, to use the DateTime custom type in a record:\n+\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Fortune {\n+  createdAt: DateTime\n+} \n+```\n+\n+## Namespace\n+\n+Namespace is used to qualify the namespace for the named schema.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+record Foo {}\n+```\n+\n+## Import\n+\n+Imports are optional statements which allow you to avoid wirting the full qualified names, similar to in Java.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+- Using imports in the following ways will lead to PDL parser errors. You should avoid to do so.\n+1. Importing types declared inside the document.\n+2. Importing types within the root namespace of the document.\n+3. Declaring types that conflict with existing imports.\n+\n+## Deprecation\n+\n+All types, enum symbols and record fields can be deprecated by adding @deprecated annotation.", "originalCommit": "b296b37030d1444ab9afd5686a84f78a2fb5b01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzOTkwNw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365039907", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T01:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNDQwMA=="}], "type": "inlineReview"}, {"oid": "9ff79e2096716be9cf8023eb30af10991f90f085", "url": "https://github.com/linkedin/rest.li/commit/9ff79e2096716be9cf8023eb30af10991f90f085", "message": "Update the union with default value example", "committedDate": "2020-01-10T04:13:47Z", "type": "commit"}, {"oid": "fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "url": "https://github.com/linkedin/rest.li/commit/fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "message": "Address review comments", "committedDate": "2020-01-10T04:16:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MjczMg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365462732", "bodyText": "Needlessly complicated. Code snippet can just say @prop", "author": "evanw555", "createdAt": "2020-01-10T22:55:40Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,876 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Enum Type](#enum-type)\n+-   [Fixed Type](#fixed-type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and more concise than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record-type), [Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type), [Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values. The default value for a field is represented as the JSON value for the field's type.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Records\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    someField: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    someField: string\n+  }\n+}\n+```\n+\n+The default value of inlined records can be expressed using its serialized JSON representation.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      someField: int\n+    } = { \"someField\": 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      someField: string\n+    } = { \"someField\": \"default-value\" }\n+}\n+```\n+\n+Inline records can also be union members.\n+\n+For example:\n+```\n+namespace ccom.example.models\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.example.models\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks: ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.example.models\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string. Escaping property keys can also be used to escape reserved keywords such as \"namespace\" or \"record\".\n+\n+For example: \n+\n+```\n+namespace com.example.models\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are: int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.example.models\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.example.models\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Maps are defined with a key type and a value type. The value type can be any valid PDL type, but currently only `string` is supported for the key type.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record MultipleChoice {\n+  answer: string\n+}\n+```\n+\n+```\n+namespace com.example.models\n+\n+record TextEntry {\n+  text: string\n+}\n+```\n+\n+Union with default value:\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry] = {\"com.linkedin.pegasus.generator.examples.MultipleChoice\": {\"answer\": \"A\"}}\n+}\n+```\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members. Union with aliases is useful for cases where a union contains multiple different typerefs with the same underlying type. This use case is not supported with a non-aliased union.\n+\n+Aliased unions are defined as:\n+```\n+union [alias: type, ...]\n+```\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   /**\n+     * Doc for shortAnswer.\n+     */\n+   shortAnswer: string,\n+   @customProperty = \"property for longAnswer.\"\n+   longAnswer: string\n+ ]\n+}\n+```\n+**Aliased union members can have doc strings and custom properties. This is not supported for non-aliased union members.**\n+\n+\n+Union with aliases with default value:\n+```\n+namespace com.example.models\n+\n+record QuestionDefault {\n+ answerFormat: union[ \n+   shortAnswer: string,\n+   longAnswer: string,\n+   multipleChoice: MultipleChoice\n+ ] = { \"shortAnswer\": \"short answer.\" }\n+}\n+```\n+\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+**Note:**\n+Either ALL union members must be aliased, or NONE at all.\n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enum can also be inline defined.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, deprecation and properties can be added directly to enum symbols. \n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Fixed Type\n+\n+Fixed type is used to define schema with fixed size of bytes. \n+\n+For example:\n+```\n+namespace com.example.models\n+\n+fixed MD5 16\n+```\n+In the above example, `16` is the defined size of bytes for MD5 schema.\n+\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like\n+a typedef in C. It does not declare a new type but declares an alias to\n+an existing type.\n+\n+### Typerefs can be used to name anonymous types.\n+\n+It is very useful, because unions, maps and arrays cannot be named directly like records and enums.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+typeref AnswerTypes = union[MultipleChoice, TextEntry]\n+\n+```\n+\n+Typerefs can be referred to from any other type using the name.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: AnswerTypes\n+}\n+```\n+      \n+\n+### Typerefs can provide additional clarity when using primitive types.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+typeref UnixTimestamp = long\n+```\n+\n+### Typerefs can be used to specify custom types and coercers\n+For example, Joda time has a convenient DateTime class. If we wish to use this class in Java to represent date times, all we need to do is define a pegasus custom type that binds to it:\n+\n+```\n+namespace com.example.models\n+\n+@java.class = \"org.joda.time.DateTime\"\n+@java.coercerClass = \"com.linkedin.example.DateTimeCoercer\"\n+typeref DateTime = string\n+```\n+The coercer is responsible for converting the pegasus \u201creferenced\u201d type, in this case \"string\" to the Joda DateTime class:\n+\n+Once a custom type is defined, it can be used in any type. \n+\n+For example, to use the DateTime custom type in a record:\n+\n+```\n+namespace com.example.models\n+\n+record Fortune {\n+  createdAt: DateTime\n+} \n+```\n+\n+## Namespace\n+\n+Namespace is used to qualify the namespace for the named schema.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record Foo {}\n+```\n+\n+## Import\n+\n+Imports are optional statements which allow you to avoid wirting the full qualified names, similar to in Java.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+- Using imports in the following ways will lead to PDL parser errors. You should avoid to do so.\n+1. Importing types declared inside the document.\n+2. Importing types within the root namespace of the document.\n+3. Declaring types that conflict with existing imports.\n+\n+## Properties\n+Properties can be used to present arbitrary data and added to records, record fields, enums, enum symbols, aliased union members.\n+\n+Add properties to record and record field:\n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+\n+Add properties to enum and enum symbols:\n+```\n+@prop = \"value\"\n+enum Fruits {\n+  @color = \"red\"\n+  APPLE\n+\n+  @color = \"orange\"\n+  ORANGE\n+\n+  @color = \"yellow\"\n+  BANANA\n+}\n+```\n+\n+Add properties to aliased union members:\n+```\n+record Question {\n+ answerFormat: union[\n+   @prop\n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+\n+### Property values can be any valid JSON type:\n+\n+For example:\n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+### Property values can also be empty:\n+\n+If you don't indicate an explicit property value, it will resuilt in an implicit value of `true`.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.examples\n+\n+@prop\n+record Foo {\n+  f1: string\n+}", "originalCommit": "fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2Njk2Nw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365466967", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T23:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MjczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MjgxNg==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365462816", "bodyText": "typo: result", "author": "evanw555", "createdAt": "2020-01-10T22:55:52Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,876 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Enum Type](#enum-type)\n+-   [Fixed Type](#fixed-type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and more concise than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record-type), [Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type), [Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values. The default value for a field is represented as the JSON value for the field's type.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   field2: string = \"message\"\n+}\n+```\n+\n+An optional field may have default value.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithOptionalPrimitiveDefault {\n+  intWithDefault: optional int = 1\n+}\n+```\n+\n+### Inline Records\n+\n+A record can contain inline records.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record WithInlineRecord {\n+  inline: record InlineRecord {\n+    someField: int\n+  }\n+  inlineOptional: optional record InlineOptionalRecord {\n+    someField: string\n+  }\n+}\n+```\n+\n+The default value of inlined records can be expressed using its serialized JSON representation.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithInlineRecord {\n+\n+    inline: record InlineRecord {\n+      someField: int\n+    } = { \"someField\": 1 }\n+\n+    inlineOptional: optional record InlineOptionalRecord {\n+      someField: string\n+    } = { \"someField\": \"default-value\" }\n+}\n+```\n+\n+Inline records can also be union members.\n+\n+For example:\n+```\n+namespace ccom.example.models\n+\n+record UnionWithInlineRecord {\n+  value = union[\n+\n+    record InlineRecord {\n+      value: optional int\n+    },\n+\n+    record InlineRecord2 {}\n+  ]\n+}\n+```\n+\n+### Doc Strings\n+\n+Types and fields may be documented using \u201cdoc strings\u201d.\n+\n+For example: \n+```\n+/**\n+ * Doc strings may be added to types. This doc should describe the purposes\n+ * of the Example type.\n+ */\n+record Example {\n+  /**\n+   * Doc strings may also be added to fields.\n+   */\n+   field1: string\n+\n+   /** Doc strings can be single line.*/\n+   field2: int\n+}\n+```\n+\n+**Note:**\n+If you use Java comment style for doc string, e.g \"// Doc String\", those doc strings will not be stored in in-memory schema.\n+\n+### Including fields\n+\n+Record can include fields from one or more other records..\n+\n+For example: \n+\n+```\n+namespace com.example.models\n+\n+/**\n+ * Bar includes fields of Foo, Bar will have fields b1 from itself and f1 from Foo\n+ */\n+record Bar includes Foo {\n+  b1: string\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record Foo {\n+  f1: string\n+}\n+```\n+\n+Multiple includes example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * Bar includes fields of Foo and Simple, Bar will have fields b1 from itself, f1 from Foo and s1 from Simple\n+ */\n+record Bar includes Foo, Simple {\n+  b1: string\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record Simple {\n+  s1: string\n+}\n+```\n+\n+In pegasus, field inclusion does not imply inheritance, it is merely a convenience to reduce duplication when writing schemas.\n+\n+\n+### Escaping\n+There are some keywords which are reserved in Pegasus. If you have to use them to define any names, you need to put them in backticks: ` `.\n+\n+#### Keyword Escaping\n+\n+```\n+namespace com.example.models\n+\n+record PdlKeywordEscaping {\n+  `namespace`: string\n+  `record`: string\n+  `null`: string\n+  `enum`: string\n+  recordName: record `record` { }\n+}\n+```\n+\n+#### Namespace/Package escaping\n+\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.escaping.`record`\n+package com.linkedin.pegasus.generator.test.idl.escaping.override.`typeref`\n+\n+/**\n+ * Ensures that the namespace and package are properly escaped at the root as well as in scoped named-type declarations.\n+ */\n+record NamespacePackageEscaping {\n+  x: {\n+    namespace com.x.y.z.`enum`\n+    package com.a.b.c.`fixed`\n+\n+    record Foo {}\n+  }\n+}\n+```\n+\n+#### Property key escaping \n+\n+If you want Pegasus to treat property key name with dots as one string key, please use backticks to escape such string. Escaping property keys can also be used to escape reserved keywords such as \"namespace\" or \"record\".\n+\n+For example: \n+\n+```\n+namespace com.example.models\n+\n+record PropertyKeyEscaping {\n+  @`namespace` = \"foo.bar\"\n+  @`test.path` = 1\n+  @validate.`com.linkedin.CustomValidator` = \"foo\"\n+  aField: string\n+}\n+```\n+\n+\n+## Primitive Types\n+\n+The Pegasus primitive types are: int, long, float, double, boolean, string and bytes.\n+\n+For Example:\n+```\n+namespace com.example.models\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```\n+namespace com.example.models\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a collection of a particular \"items\" type.\n+\n+For Example: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+\n+record WithRecordAndEnumArrays {\n+  empties: array[Empty]\n+  fruits: array[Fruits]\n+}\n+```\n+\n+Record or Enum arrays with default values: \n+```\n+namespace com.linkedin.pegasus.generator.test.idl.arrays\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record WithRecordAndEnumDefaults {\n+  empties: array[Simple] = [{ \"message\": \"defaults!\" }]\n+  fruits: array[Fruits] = [\"APPLE\", \"ORANGE\"]\n+}\n+```\n+\n+\n+## Map Type\n+\n+Maps are defined with a key type and a value type. The value type can be any valid PDL type, but currently only `string` is supported for the key type.\n+\n+For example: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values: \n+```\n+namespace com.example.models\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Complex Types Map:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.maps\n+\n+import com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+import com.linkedin.pegasus.generator.test.idl.records.Empty\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+import com.linkedin.pegasus.generator.test.idl.`fixed`.Fixed8\n+\n+record WithComplexTypesMap {\n+  empties: map[string, Empty]\n+  fruits: map[string, Fruits]\n+  arrays: map[string, array[Simple]]\n+  maps: map[string, map[string, Simple]]\n+  unions: map[\n+    string,\n+    typeref WithComplexTypesMapUnion = union[int, string, Simple]\n+  ]\n+  `fixed`: map[string, Fixed8]\n+}\n+```\n+\n+## Union Type\n+\n+A union type may be defined with any number of member types. Member type can be primitive, record, enum, map or array. Unions are not allowed as members inside an union.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record WithPrimitivesUnion {\n+  value: union[int, long, float, double, boolean, string, bytes]\n+}\n+```\n+\n+The member type names also serve as the \u201cmember keys\u201d (also called as \u201cunion tags\u201d), and identify which union member type data holds.\n+To define a field of a record containing a union of two other records, we would define:\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry]\n+}\n+```\n+```\n+namespace com.example.models\n+\n+record MultipleChoice {\n+  answer: string\n+}\n+```\n+\n+```\n+namespace com.example.models\n+\n+record TextEntry {\n+  text: string\n+}\n+```\n+\n+Union with default value:\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: union[MultipleChoice, TextEntry] = {\"com.linkedin.pegasus.generator.examples.MultipleChoice\": {\"answer\": \"A\"}}\n+}\n+```\n+### Union with aliases\n+Union members can optionally be given an alias. Aliases can be used to create unions with members of the same type or to give better naming for union members. Union with aliases is useful for cases where a union contains multiple different typerefs with the same underlying type. This use case is not supported with a non-aliased union.\n+\n+Aliased unions are defined as:\n+```\n+union [alias: type, ...]\n+```\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record Question {\n+ answerFormat: union[   \n+   multipleChoice: MultipleChoice,\n+   /**\n+     * Doc for shortAnswer.\n+     */\n+   shortAnswer: string,\n+   @customProperty = \"property for longAnswer.\"\n+   longAnswer: string\n+ ]\n+}\n+```\n+**Aliased union members can have doc strings and custom properties. This is not supported for non-aliased union members.**\n+\n+\n+Union with aliases with default value:\n+```\n+namespace com.example.models\n+\n+record QuestionDefault {\n+ answerFormat: union[ \n+   shortAnswer: string,\n+   longAnswer: string,\n+   multipleChoice: MultipleChoice\n+ ] = { \"shortAnswer\": \"short answer.\" }\n+}\n+```\n+\n+In the above example, the union answerFormat has three members, with two string type members differentiated using the aliases (shortAnswer and longAnswer). When aliases are used, the alias becomes the \"member key\" for the union members and will be used in the wire format. \n+\n+**Note:**\n+Either ALL union members must be aliased, or NONE at all.\n+\n+## Enum Type\n+\n+Enums types may contain any number of symbols. \n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+enum Fruits {\n+  APPLE\n+  BANANA\n+  ORANGE\n+  PINEAPPLE\n+}\n+```\n+\n+Enums can be referenced in other schemas by name.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: Fruits\n+}\n+```\n+\n+Enum can also be inline defined.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE }\n+} \n+```\n+\n+### Enum documentation, deprecation and properties\n+Doc comments, deprecation and properties can be added directly to enum symbols. \n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+/**\n+ * A fruit\n+ */\n+enum Fruits {\n+\n+  @color = \"red\"\n+  APPLE\n+\n+  /**\n+   * A yummy fruit.\n+   */\n+  @color = \"yellow\"\n+  BANANA\n+\n+  @deprecated\n+  @color = \"orange\"\n+  ORANGE\n+}\n+```\n+\n+### Enum defaults\n+To specify defaults, specify the enum value as string.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: enum Fruits { APPLE, BANANA, ORANGE } = \"APPLE\"\n+} \n+```\n+\n+\n+The default value can also be defined as following exmaple:\n+\n+```\n+namespace com.example.models\n+\n+record FruitBasket {\n+  fruit: Fruits = \"APPLE\"\n+} \n+```\n+\n+## Fixed Type\n+\n+Fixed type is used to define schema with fixed size of bytes. \n+\n+For example:\n+```\n+namespace com.example.models\n+\n+fixed MD5 16\n+```\n+In the above example, `16` is the defined size of bytes for MD5 schema.\n+\n+\n+## Typerefs\n+Pegasus supports a new schema type known as a typeref. A typeref is like\n+a typedef in C. It does not declare a new type but declares an alias to\n+an existing type.\n+\n+### Typerefs can be used to name anonymous types.\n+\n+It is very useful, because unions, maps and arrays cannot be named directly like records and enums.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+typeref AnswerTypes = union[MultipleChoice, TextEntry]\n+\n+```\n+\n+Typerefs can be referred to from any other type using the name.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+record Question {\n+  answerFormat: AnswerTypes\n+}\n+```\n+      \n+\n+### Typerefs can provide additional clarity when using primitive types.\n+\n+For example:\n+\n+```\n+namespace com.example.models\n+\n+typeref UnixTimestamp = long\n+```\n+\n+### Typerefs can be used to specify custom types and coercers\n+For example, Joda time has a convenient DateTime class. If we wish to use this class in Java to represent date times, all we need to do is define a pegasus custom type that binds to it:\n+\n+```\n+namespace com.example.models\n+\n+@java.class = \"org.joda.time.DateTime\"\n+@java.coercerClass = \"com.linkedin.example.DateTimeCoercer\"\n+typeref DateTime = string\n+```\n+The coercer is responsible for converting the pegasus \u201creferenced\u201d type, in this case \"string\" to the Joda DateTime class:\n+\n+Once a custom type is defined, it can be used in any type. \n+\n+For example, to use the DateTime custom type in a record:\n+\n+```\n+namespace com.example.models\n+\n+record Fortune {\n+  createdAt: DateTime\n+} \n+```\n+\n+## Namespace\n+\n+Namespace is used to qualify the namespace for the named schema.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+record Foo {}\n+```\n+\n+## Import\n+\n+Imports are optional statements which allow you to avoid wirting the full qualified names, similar to in Java.\n+\n+For example:\n+```\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+import com.linkedin.pegasus.generator.test.idl.records.Simple\n+\n+record Example {\n+  /**\n+   * Requires an import since this type is outside the root namespace and is not declared in this file.\n+   */\n+  externalOutsideNS: Simple\n+}\n+```\n+\n+**Note:** \n+- Any type that is not imported and is not within the namespace from which it's referenced must be referenced by\n+fully qualified name.\n+- Using imports in the following ways will lead to PDL parser errors. You should avoid to do so.\n+1. Importing types declared inside the document.\n+2. Importing types within the root namespace of the document.\n+3. Declaring types that conflict with existing imports.\n+\n+## Properties\n+Properties can be used to present arbitrary data and added to records, record fields, enums, enum symbols, aliased union members.\n+\n+Add properties to record and record field:\n+```\n+@prop = \"value\"\n+record Fruits {\n+  @validate.regex.regex = \"^(yes|no)$\"\n+  field: string\n+}\n+```\n+\n+Add properties to enum and enum symbols:\n+```\n+@prop = \"value\"\n+enum Fruits {\n+  @color = \"red\"\n+  APPLE\n+\n+  @color = \"orange\"\n+  ORANGE\n+\n+  @color = \"yellow\"\n+  BANANA\n+}\n+```\n+\n+Add properties to aliased union members:\n+```\n+record Question {\n+ answerFormat: union[\n+   @prop\n+   multipleChoice: MultipleChoice,\n+   shortAnswer: string,\n+   longAnswer: string\n+ ]\n+}\n+```\n+\n+### Property values can be any valid JSON type:\n+\n+For example:\n+```\n+@prop = 1\n+```\n+```\n+@prop = \"string\"\n+```\n+```\n+@prop = [1, 2, 3]\n+```\n+```\n+@prop = { \"a\": 1\", \"b\": { \"c\": true }}\n+\n+```\n+### Property values can also be empty:\n+\n+If you don't indicate an explicit property value, it will resuilt in an implicit value of `true`.", "originalCommit": "fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2NjcwMw==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365466703", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-01-10T23:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MjgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2Mjk4NA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365462984", "bodyText": "Add link to \"Properties\"", "author": "evanw555", "createdAt": "2020-01-10T22:56:30Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,876 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Enum Type](#enum-type)\n+-   [Fixed Type](#fixed-type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace)\n+-   [Import](#import)", "originalCommit": "fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2NjI3OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365466279", "bodyText": "added", "author": "nickibi", "createdAt": "2020-01-10T23:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2Mjk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MzQ0OQ==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365463449", "bodyText": "Sorry for suggesting this, it actually doesn't make any sense. Just say \"The default value for a field is expressed as a JSON value.\" Much simpler.", "author": "evanw555", "createdAt": "2020-01-10T22:58:24Z", "path": "pdl_syntax.md", "diffHunk": "@@ -0,0 +1,876 @@\n+---\n+layout: guide\n+title: PDL Syntax\n+permalink: /pdl_syntax\n+excerpt: Rest.li PDL Syntax.\n+---\n+\n+# PDL Syntax\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Enum Type](#enum-type)\n+-   [Fixed Type](#fixed-type)\n+-   [Typerefs](#typerefs)\n+-   [Namespace](#namespace)\n+-   [Import](#import)\n+-   [Deprecation](#deprecation)\n+-   [Package](#package)\n+\n+## PDL Schema Definition\n+\n+PDL is a Pegasus schema definition language, which is developer friendly and more concise than the JSON based schema format.\n+\n+## Creating a Schema\n+\n+Each schema should be stored in its own file with a `.pdl` extension.\n+The Pegasus code generator implements a resolver that is similar to Java\n+class loaders. If there is a reference to a named schema, the code\n+generator will try to look for a file in the code generator\u2019s resolver\n+path. The resolver path is similar to a Java classpath. The fully\n+qualified name of the named schema will be translated to a relative file\n+name. The relative file name is computed by replacing dots (\u201c.\u201d) in the\n+fully qualified name by the directory path separator (typically \u201c/\u201d) and\n+appending a `.pdl` extension. This relative file name is appended to\n+each path in the resolver path. The resolver opens each of these files\n+until it finds a file that contains the named schema.\n+\n+Pegasus supports different types of schemas: [Records](#record-type), [Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type), [Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and [Typerefs](#typerefs). \n+Please check the following documentations for details.\n+\n+\n+## Record Type\n+Records contain any number of fields, which can be primitive types, enums, unions, maps arrays or other records.\n+\n+A basic record type can contain a few fields.\n+\n+For example:\n+```\n+import org.example.time.DateTime\n+\n+record Example {\n+  field1: string\n+  field3: DateTime\n+}\n+```\n+Record fields can be optional.\n+\n+For example:\n+```\n+namespace com.example.models\n+\n+/**\n+ * A foo record\n+ */\n+record Foo {\n+   field1: string\n+   /**\n+    * field2 is an optional field.\n+    */\n+   field2: optional string\n+}\n+```\n+\n+Record fields may have default values. The default value for a field is represented as the JSON value for the field's type.", "originalCommit": "fd6532824b305b8f8a43b8de3d0bd3f5e256c7c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2NjYxNA==", "url": "https://github.com/linkedin/rest.li/pull/157#discussion_r365466614", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-01-10T23:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2MzQ0OQ=="}], "type": "inlineReview"}, {"oid": "64c49fddc3961ab5f2071d7ee28ca658f22ba153", "url": "https://github.com/linkedin/rest.li/commit/64c49fddc3961ab5f2071d7ee28ca658f22ba153", "message": "Add PDL syntax doc", "committedDate": "2020-01-10T23:16:56Z", "type": "commit"}]}