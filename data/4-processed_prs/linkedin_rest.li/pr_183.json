{"pr_number": 183, "pr_title": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "pr_createdAt": "2020-02-21T08:14:52Z", "pr_url": "https://github.com/linkedin/rest.li/pull/183", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQ5Mg==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382476492", "bodyText": "I don't think this is really testing this use case. Attempting to import from the root namespace is disallowed as a separate rule. You should import a Fruits type from a third namespace that is neither the root namespace nor this overridden namespace.\nFurthermore, to totally isolate this case from the root case, you should use a type that is not Fruits since this may be impacted by the fact that Fruits exists in the root namespace. You really want to be testing that some type com.linkedin.pegasus.generator.test.idl.enums.Foo is written as a simple name, and com.linkedin.pegasus.generator.test.idl.thirdnamespace.Foo is written as a FQN without an import (despite the fact that it's not in the root namespace and it doesn't conflict with anything in the root namespace).", "author": "evanw555", "createdAt": "2020-02-21T09:24:39Z", "path": "generator-test/src/test/pegasus/com/linkedin/pegasus/generator/test/idl/imports/ReferenceTypeConflict.pdl", "diffHunk": "@@ -0,0 +1,40 @@\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+/**\n+ * This record references two different Fruit enums, one in the same namespace, one from another namespace.\n+ * The external namespace type should not be imported as it would conflict with the simple reference of the type from\n+ * this record's namespace.\n+ */\n+record ReferenceTypeConflict {\n+  /**\n+   * This should be a simple reference as its namespace matches the root namespace.\n+   */\n+  simpleReference: Fruits\n+\n+  /**\n+   * Reference from external namespace is fully qualified. This should not be in imports as it would conflict with\n+   * the simpleReference field type above.\n+   */\n+  fqnReference: com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+\n+  /**\n+   * This field defines a namespace override. Within this overridden namespace, the same rule applies, ie, the type that\n+   * matches surrounding namespace is referenced using simple name, while the type using root namespace is fully\n+   * qualified.\n+   */\n+  inlineOverride: {\n+    namespace com.linkedin.pegasus.generator.test.idl.enums\n+    record InlineOverride {\n+      /**\n+       * This is a simple reference to the type matching the overriden namespace.\n+       */\n+      simpleReference: Fruits\n+\n+      /**\n+       * Uses a fully qualified reference even if the type matches root namespace as this is within the overridden\n+       * namespace.\n+       */\n+      fqnReference: com.linkedin.pegasus.generator.test.idl.imports.Fruits", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3Mzg4MQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382673881", "bodyText": "good catch. Fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3OTMxNw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382479317", "bodyText": "nit: overridden", "author": "evanw555", "createdAt": "2020-02-21T09:30:33Z", "path": "generator-test/src/test/pegasus/com/linkedin/pegasus/generator/test/idl/imports/ReferenceTypeConflict.pdl", "diffHunk": "@@ -0,0 +1,40 @@\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+/**\n+ * This record references two different Fruit enums, one in the same namespace, one from another namespace.\n+ * The external namespace type should not be imported as it would conflict with the simple reference of the type from\n+ * this record's namespace.\n+ */\n+record ReferenceTypeConflict {\n+  /**\n+   * This should be a simple reference as its namespace matches the root namespace.\n+   */\n+  simpleReference: Fruits\n+\n+  /**\n+   * Reference from external namespace is fully qualified. This should not be in imports as it would conflict with\n+   * the simpleReference field type above.\n+   */\n+  fqnReference: com.linkedin.pegasus.generator.test.idl.enums.Fruits\n+\n+  /**\n+   * This field defines a namespace override. Within this overridden namespace, the same rule applies, ie, the type that\n+   * matches surrounding namespace is referenced using simple name, while the type using root namespace is fully\n+   * qualified.\n+   */\n+  inlineOverride: {\n+    namespace com.linkedin.pegasus.generator.test.idl.enums\n+    record InlineOverride {\n+      /**\n+       * This is a simple reference to the type matching the overriden namespace.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3OTYzMA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382479630", "bodyText": "Technically, this is a simple reference because its namespace matches the surrounding namespace, not the root namespace.", "author": "evanw555", "createdAt": "2020-02-21T09:31:10Z", "path": "generator-test/src/test/pegasus/com/linkedin/pegasus/generator/test/idl/imports/ReferenceTypeConflict.pdl", "diffHunk": "@@ -0,0 +1,40 @@\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+/**\n+ * This record references two different Fruit enums, one in the same namespace, one from another namespace.\n+ * The external namespace type should not be imported as it would conflict with the simple reference of the type from\n+ * this record's namespace.\n+ */\n+record ReferenceTypeConflict {\n+  /**\n+   * This should be a simple reference as its namespace matches the root namespace.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDAxNA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382674014", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3OTYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382485977", "bodyText": "Technically, this isn't true. Inline types are not necessarily referenced by simple name (e.g. referencing an inline type with an overridden namespace). The point is that they can't be imported.\nTo be completely accurate, this set is just \"a set of simple type names which shouldn't be imported in this document\", because (1) importing types with the same simple name as an inline type is prohibited and will cause a parser error, and (2) being able to reference something in the current namespace by simple name is prioritized (thus anytime an intra-namespace reference is present, that simple name should be off-limits for importing).", "author": "evanw555", "createdAt": "2020-02-21T09:44:00Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +734,17 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can use simple reference because\n+    // 1. They are defined inline or", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MjUxOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382682519", "bodyText": "My comment was describing the same, made it clear now..", "author": "karthikbalasub", "createdAt": "2020-02-21T16:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382487053", "bodyText": "As my other comment mentions above, I'd rephrase this as \"add to the set of non-importable simple names\" (or something along those lines).", "author": "evanw555", "createdAt": "2020-02-21T09:46:06Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -749,25 +754,29 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   }\n \n   /**\n-   * Gather all types (both referenced and inlined) found in this schema and in all its descendents.\n+   * Gather all types (both referenced and inlined) and names of types that should use simple reference from this schema\n+   * and in all its descendents.\n    * @param schema schema to traverse.\n    * @param isDeclaredInline true if the schema should be treated as an inline declaration, false if it should be\n    *                         considered a by-name reference.\n    * @param encounteredTypes cumulative set of all encountered types in this schema (and its descendents).\n-   * @param inlinedTypeNames cumulative set of simple names of all inlined types in this schema (and its descendents).\n+   * @param typeNamesWithSimpleReference cumulative set of simple names of all types in this schema (and its\n+   *                                    descendents) that can use simple reference.\n+   * @param currentNamespace namespace of the current scope.\n    */\n   private void gatherTypes(DataSchema schema, boolean isDeclaredInline, Set<Name> encounteredTypes,\n-      Set<String> inlinedTypeNames)\n+      Set<String> typeNamesWithSimpleReference, String currentNamespace)\n   {\n     // If named type, add to the set of encountered types\n     if (schema instanceof NamedDataSchema)\n     {\n       NamedDataSchema namedSchema = (NamedDataSchema) schema;\n       encounteredTypes.add(new Name(namedSchema.getFullName()));\n-      // If declared inline, add to the set of inlined types\n-      if (isDeclaredInline)\n+      // If declared inline or of the namespace matches the current namespace, add to the set of types with simple\n+      // reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5MTAxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382691013", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489203", "bodyText": "nit: identifier -> simple name", "author": "evanw555", "createdAt": "2020-02-21T09:50:38Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NTc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382685799", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489523", "bodyText": "nit: Write only simple name for schemas in the current namespace only if there are no corresponding imports", "author": "evanw555", "createdAt": "2020-02-21T09:51:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.\n+      _builder.writeIdentifier(schema.getName());\n+    }\n+    else if (_namespace.equals(schema.getNamespace()) && !_importsByLocalName.containsKey(schema.getName()))\n+    {\n+      // Write only identifier for schemas in the current namespace only if there are no imports with the same simple", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjYxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382686613", "bodyText": "fixed.\ncorresponding imports -> conflicting imports", "author": "karthikbalasub", "createdAt": "2020-02-21T16:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382490129", "bodyText": "The javadoc for this method is now incorrect. Tbh you can probably just remove the detail and say it writes simple name or FQN depending on the current namespace and present imports.", "author": "evanw555", "createdAt": "2020-02-21T09:52:29Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NzM3NA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382687374", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382494340", "bodyText": "I'd say Importing the type wouldn't force some intra-namespace reference to become fully-qualified.", "author": "evanw555", "createdAt": "2020-02-21T10:01:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -719,6 +719,7 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n    * (1) The type is outside the root namespace of the document.\n    * (2) The type is declared outside the document (i.e. not inlined in this document).\n    * (3) The type's name does not conflict with name of an Inlined type.\n+   * (4) The type's name does not conflict with another type that can use simple reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4OTA4Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382689083", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA=="}], "type": "inlineReview"}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "commit"}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTYxMg==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382715612", "bodyText": "nit: scenarios", "author": "nickibi", "createdAt": "2020-02-21T17:40:58Z", "path": "generator-test/src/test/pegasus/com/linkedin/pegasus/generator/test/idl/imports/ReferenceTypeConflict.pdl", "diffHunk": "@@ -0,0 +1,42 @@\n+namespace com.linkedin.pegasus.generator.test.idl.imports\n+\n+/**\n+ * This record tests scenaris where two types with same simple name are used. One in the same namespace as the", "originalCommit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27869c9d66a4e6c93c0534b8e3c82d569ce91329", "url": "https://github.com/linkedin/rest.li/commit/27869c9d66a4e6c93c0534b8e3c82d569ce91329", "message": "Fix a typo", "committedDate": "2020-02-21T23:14:58Z", "type": "commit"}, {"oid": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "url": "https://github.com/linkedin/rest.li/commit/3ee790ea6db314b7baf23801bbf05a590cb7615e", "message": "Rename record name in test.", "committedDate": "2020-02-21T23:53:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTgwNw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382875807", "bodyText": "You should also name this to nonImportableTypeNames to be consistent.", "author": "evanw555", "createdAt": "2020-02-22T01:57:41Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +735,18 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can cause conflicts with imports because\n+    // 1. They are defined inline or\n+    // 2. They are in the same namespace as their surrounding context (including namespace overrides) and are\n+    //    preferred use simple reference\n+    Set<String> typeNamesWithSimpleReference = new HashSet<>();", "originalCommit": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a03ea42606adc6d24b7b38cb23936595feccaec", "url": "https://github.com/linkedin/rest.li/commit/6a03ea42606adc6d24b7b38cb23936595feccaec", "message": "Address Evan's comments", "committedDate": "2020-02-22T02:15:31Z", "type": "commit"}]}