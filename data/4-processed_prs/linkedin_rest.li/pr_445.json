{"pr_number": 445, "pr_title": "Add ExtensionSchemaAnnotationHandler ", "pr_createdAt": "2020-10-14T16:38:18Z", "pr_url": "https://github.com/linkedin/rest.li/pull/445", "timeline": [{"oid": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "url": "https://github.com/linkedin/rest.li/commit/4c0feb228b44f4185ab3473289a7d6a137c4fb61", "message": "Add PegasusExtensionSchemaAnnotationHandler for extension schema annotation compatibility check", "committedDate": "2020-10-14T17:44:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTA5NQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021095", "bodyText": "I am wondering if it could be written into a single\nif ... else if ... block\ninstead of two if blocks\nBecause that way, we will get to know this two logic are meant for output just one thing:\na pathspec to checkerContext map", "author": "BrianPin", "createdAt": "2020-10-16T03:19:33Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -49,36 +55,47 @@ public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order\n     }\n \n     DataSchema currentSchema = context.getCurrentSchema();\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n \n     ArrayDeque<String> pathToSchema = context.getSchemaPathSpec().clone();\n     pathToSchema.addFirst(((NamedDataSchema)context.getTopLevelSchema()).getName());\n-    PathSpec pathSpec = new PathSpec(pathToSchema);\n-\n-    CompatibilityCheckContext compatibilityCheckContext = new CompatibilityCheckContext();\n-\n-    compatibilityCheckContext.setCurrentDataSchema(currentSchema);\n-    compatibilityCheckContext.setSchemaField(context.getEnclosingField());\n-    compatibilityCheckContext.setUnionMember(context.getEnclosingUnionMember());\n-    compatibilityCheckContext.setPathSpecToSchema(pathSpec);\n \n-    // If there is no resolvedProperties but properties, used the properties for annotation check.\n-    Map<String, Object> properties;\n-    if (context.getEnclosingField() != null)\n+    // If current schema is a typeref schema, add TYPEREF_INDICATOR in the pathSpec\n+    // to avoid this node and it's child node have the same pathSpec.\n+    if (currentSchema instanceof TyperefDataSchema)\n     {\n-      RecordDataSchema.Field field = context.getEnclosingField();\n-      properties = chooseProperties(field.getResolvedProperties(), field.getProperties());\n+      context.getSchemaPathSpec().addLast(TYPEREF_INDICATOR);\n     }\n-    else if (context.getEnclosingUnionMember() != null)\n+\n+    // Current node is a field of a record schema, get the field's annotation.\n+    if (schemaField != null && pathToSchema.getLast().equals(context.getEnclosingField().getName()))\n     {\n-      // There is no resolvedProperty for unionMember\n-      properties = context.getEnclosingUnionMember().getProperties();\n+      // Add FIELD_INDICATOR in the pathSpec to differentiate field annotation and field type schema annotation.\n+      pathToSchema.addLast(FIELD_INDICATOR);\n+      PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+      _nodeToResolvedPropertiesMap.put(pathSpec,\n+          new ImmutablePair<>(generateCompatibilityCheckContext(schemaField, unionMember, currentSchema, pathSpec),\n+              chooseProperties(schemaField.getResolvedProperties(), schemaField.getProperties())));\n+      pathToSchema.removeLast();\n     }\n-    else\n+\n+    // Current node is a union member, get the union member key's annotation.", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MTY5NA==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506051694", "bodyText": "updated to use else if", "author": "nickibi", "createdAt": "2020-10-16T04:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTEzNg==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021136", "bodyText": "is -> are for grammar check", "author": "BrianPin", "createdAt": "2020-10-16T03:19:37Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -49,36 +55,47 @@ public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order\n     }\n \n     DataSchema currentSchema = context.getCurrentSchema();\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n \n     ArrayDeque<String> pathToSchema = context.getSchemaPathSpec().clone();\n     pathToSchema.addFirst(((NamedDataSchema)context.getTopLevelSchema()).getName());\n-    PathSpec pathSpec = new PathSpec(pathToSchema);\n-\n-    CompatibilityCheckContext compatibilityCheckContext = new CompatibilityCheckContext();\n-\n-    compatibilityCheckContext.setCurrentDataSchema(currentSchema);\n-    compatibilityCheckContext.setSchemaField(context.getEnclosingField());\n-    compatibilityCheckContext.setUnionMember(context.getEnclosingUnionMember());\n-    compatibilityCheckContext.setPathSpecToSchema(pathSpec);\n \n-    // If there is no resolvedProperties but properties, used the properties for annotation check.\n-    Map<String, Object> properties;\n-    if (context.getEnclosingField() != null)\n+    // If current schema is a typeref schema, add TYPEREF_INDICATOR in the pathSpec\n+    // to avoid this node and it's child node have the same pathSpec.\n+    if (currentSchema instanceof TyperefDataSchema)\n     {\n-      RecordDataSchema.Field field = context.getEnclosingField();\n-      properties = chooseProperties(field.getResolvedProperties(), field.getProperties());\n+      context.getSchemaPathSpec().addLast(TYPEREF_INDICATOR);\n     }\n-    else if (context.getEnclosingUnionMember() != null)\n+\n+    // Current node is a field of a record schema, get the field's annotation.\n+    if (schemaField != null && pathToSchema.getLast().equals(context.getEnclosingField().getName()))\n     {\n-      // There is no resolvedProperty for unionMember\n-      properties = context.getEnclosingUnionMember().getProperties();\n+      // Add FIELD_INDICATOR in the pathSpec to differentiate field annotation and field type schema annotation.\n+      pathToSchema.addLast(FIELD_INDICATOR);\n+      PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+      _nodeToResolvedPropertiesMap.put(pathSpec,\n+          new ImmutablePair<>(generateCompatibilityCheckContext(schemaField, unionMember, currentSchema, pathSpec),\n+              chooseProperties(schemaField.getResolvedProperties(), schemaField.getProperties())));\n+      pathToSchema.removeLast();\n     }\n-    else\n+\n+    // Current node is a union member, get the union member key's annotation.\n+    if (unionMember!= null && pathToSchema.getLast().equals(context.getEnclosingUnionMember().getUnionMemberKey()))\n     {\n-      properties = chooseProperties(currentSchema.getResolvedProperties(), currentSchema.getProperties());\n+      pathToSchema.addLast(UNION_MEMBER_KEY_INDICATOR);\n+      PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+      _nodeToResolvedPropertiesMap.put(pathSpec,\n+              new ImmutablePair<>(generateCompatibilityCheckContext(schemaField, unionMember, currentSchema, pathSpec), unionMember.getProperties()));\n+      pathToSchema.removeLast();\n     }\n \n-    _nodeToResolvedPropertiesMap.put(pathSpec, new ImmutablePair<>(compatibilityCheckContext, properties));\n+    // If there is no resolvedProperties but properties, used the properties for annotation check.", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTE1Mw==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021153", "bodyText": "And looks like the last part can be the else part of the logic", "author": "BrianPin", "createdAt": "2020-10-16T03:19:40Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -49,36 +55,47 @@ public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order\n     }\n \n     DataSchema currentSchema = context.getCurrentSchema();\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n \n     ArrayDeque<String> pathToSchema = context.getSchemaPathSpec().clone();\n     pathToSchema.addFirst(((NamedDataSchema)context.getTopLevelSchema()).getName());\n-    PathSpec pathSpec = new PathSpec(pathToSchema);\n-\n-    CompatibilityCheckContext compatibilityCheckContext = new CompatibilityCheckContext();\n-\n-    compatibilityCheckContext.setCurrentDataSchema(currentSchema);\n-    compatibilityCheckContext.setSchemaField(context.getEnclosingField());\n-    compatibilityCheckContext.setUnionMember(context.getEnclosingUnionMember());\n-    compatibilityCheckContext.setPathSpecToSchema(pathSpec);\n \n-    // If there is no resolvedProperties but properties, used the properties for annotation check.\n-    Map<String, Object> properties;\n-    if (context.getEnclosingField() != null)\n+    // If current schema is a typeref schema, add TYPEREF_INDICATOR in the pathSpec\n+    // to avoid this node and it's child node have the same pathSpec.\n+    if (currentSchema instanceof TyperefDataSchema)\n     {\n-      RecordDataSchema.Field field = context.getEnclosingField();\n-      properties = chooseProperties(field.getResolvedProperties(), field.getProperties());\n+      context.getSchemaPathSpec().addLast(TYPEREF_INDICATOR);\n     }\n-    else if (context.getEnclosingUnionMember() != null)\n+\n+    // Current node is a field of a record schema, get the field's annotation.\n+    if (schemaField != null && pathToSchema.getLast().equals(context.getEnclosingField().getName()))\n     {\n-      // There is no resolvedProperty for unionMember\n-      properties = context.getEnclosingUnionMember().getProperties();\n+      // Add FIELD_INDICATOR in the pathSpec to differentiate field annotation and field type schema annotation.\n+      pathToSchema.addLast(FIELD_INDICATOR);\n+      PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+      _nodeToResolvedPropertiesMap.put(pathSpec,\n+          new ImmutablePair<>(generateCompatibilityCheckContext(schemaField, unionMember, currentSchema, pathSpec),\n+              chooseProperties(schemaField.getResolvedProperties(), schemaField.getProperties())));\n+      pathToSchema.removeLast();\n     }\n-    else\n+\n+    // Current node is a union member, get the union member key's annotation.\n+    if (unionMember!= null && pathToSchema.getLast().equals(context.getEnclosingUnionMember().getUnionMemberKey()))\n     {\n-      properties = chooseProperties(currentSchema.getResolvedProperties(), currentSchema.getProperties());\n+      pathToSchema.addLast(UNION_MEMBER_KEY_INDICATOR);\n+      PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+      _nodeToResolvedPropertiesMap.put(pathSpec,\n+              new ImmutablePair<>(generateCompatibilityCheckContext(schemaField, unionMember, currentSchema, pathSpec), unionMember.getProperties()));\n+      pathToSchema.removeLast();\n     }\n \n-    _nodeToResolvedPropertiesMap.put(pathSpec, new ImmutablePair<>(compatibilityCheckContext, properties));\n+    // If there is no resolvedProperties but properties, used the properties for annotation check.\n+    Map<String, Object> properties = chooseProperties(currentSchema.getResolvedProperties(), currentSchema.getProperties());", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MDgwMw==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506050803", "bodyText": "We need to check field annotation and field type schema annotation. It cannot be an else branch.\nSame as union member key and union schema. See previous comment.", "author": "nickibi", "createdAt": "2020-10-16T04:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTIxMA==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021210", "bodyText": "nit: Wonder how do you feel about make it less lengthy:\nPegasusExtensionSchemaAnnotationHandler -> ExtensionSchemaAnnotationHandler\nAs a code review, I usually hope the code is readable, but also compact.\nI think Pegasus is being a bit extra since we know where we are.\nJust a nit suggestion!", "author": "BrianPin", "createdAt": "2020-10-16T03:19:48Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAzNTAyMg==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506035022", "bodyText": "Yes, we could call it 'ExtensionSchemaAnnotationHandler'", "author": "nickibi", "createdAt": "2020-10-16T03:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTIzOQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021239", "bodyText": "There are other definition of EXTENSION_ANNOTATION_NAMESPACE, please just make it one, and compact. It can be public, since it is final, nobody is able to change it. Also the lesser the defined string the more efficient memory use.", "author": "BrianPin", "createdAt": "2020-10-16T03:19:51Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0OTUxNQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506049515", "bodyText": "Make this constant as public static final. It can be used in ExtensionSchemaValidationCmdLineApp.java", "author": "nickibi", "createdAt": "2020-10-16T04:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI1Ng==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021256", "bodyText": "The semantic of the function name makes me believe it is actually doing some resolving action, it will be less expected to just return the a default ResolutionResult class instance.\nIf we want an instance of ResolutionResult, we can use other naming.", "author": "BrianPin", "createdAt": "2020-10-16T03:19:54Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";\n+\n+  @Override\n+  public ResolutionResult resolve(List<Pair<String, Object>> propertiesOverrides,\n+      ResolutionMetaData resolutionMetadata)\n+  {\n+    return new ResolutionResult();", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAzNDY0OQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506034649", "bodyText": "Same as 'validate' method. We only need checkCompatibility method from SchemaAnnotationHandler. However to implement SchemaAnnotationHandler we have to provide implementation for this resolve method. We could return null here, but it does not matter, because this method will not be called.", "author": "nickibi", "createdAt": "2020-10-16T03:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI3Nw==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021277", "bodyText": "If we make EXTENSION_ANNOTATION_NAMESPACE compact (just one place has it) and public (because it is finalized) maybe we can save this function.", "author": "BrianPin", "createdAt": "2020-10-16T03:19:57Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";\n+\n+  @Override\n+  public ResolutionResult resolve(List<Pair<String, Object>> propertiesOverrides,\n+      ResolutionMetaData resolutionMetadata)\n+  {\n+    return new ResolutionResult();\n+  }\n+\n+  @Override\n+  public String getAnnotationNamespace()\n+  {\n+    return EXTENSION_ANNOTATION_NAMESPACE;", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0NzA3Ng==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506047076", "bodyText": "This function has to be there. No matter where we define this constant.\nWhile we use this handler, we need to know the namespace of annotation before calling the checkCompatibility method.", "author": "nickibi", "createdAt": "2020-10-16T04:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI5OQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021299", "bodyText": "So I guess right now this class is just a place holder?", "author": "BrianPin", "createdAt": "2020-10-16T03:20:00Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";\n+\n+  @Override\n+  public ResolutionResult resolve(List<Pair<String, Object>> propertiesOverrides,\n+      ResolutionMetaData resolutionMetadata)\n+  {\n+    return new ResolutionResult();\n+  }\n+\n+  @Override\n+  public String getAnnotationNamespace()\n+  {\n+    return EXTENSION_ANNOTATION_NAMESPACE;\n+  }\n+\n+  @Override\n+  public AnnotationValidationResult validate(Map<String, Object> resolvedProperties, ValidationMetaData metaData)\n+  {\n+    return new AnnotationValidationResult();", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAzNDAxOA==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506034018", "bodyText": "We need to implement this method to implement SchemaAnnotationHandler. Actually, we do not need this 'validate' method. We could return null here. But it really does not matter, because this method will never be called.", "author": "nickibi", "createdAt": "2020-10-16T03:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTMyOQ==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021329", "bodyText": "Wonder if we can change prevResolvedProperties to snapshot...properties, because it is actually from the snapshot.", "author": "BrianPin", "createdAt": "2020-10-16T03:20:04Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";\n+\n+  @Override\n+  public ResolutionResult resolve(List<Pair<String, Object>> propertiesOverrides,\n+      ResolutionMetaData resolutionMetadata)\n+  {\n+    return new ResolutionResult();\n+  }\n+\n+  @Override\n+  public String getAnnotationNamespace()\n+  {\n+    return EXTENSION_ANNOTATION_NAMESPACE;\n+  }\n+\n+  @Override\n+  public AnnotationValidationResult validate(Map<String, Object> resolvedProperties, ValidationMetaData metaData)\n+  {\n+    return new AnnotationValidationResult();\n+  }\n+\n+  @Override\n+  public SchemaVisitor getVisitor()\n+  {\n+    // No need to override properties, use IdentitySchemaVisitor to skip schema traverse.\n+    return new IdentitySchemaVisitor();\n+  }\n+\n+  @Override\n+  public boolean implementsCheckCompatibility()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public AnnotationCompatibilityResult checkCompatibility(Map<String, Object> prevResolvedProperties, Map<String, Object> currResolvedProperties,", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAzNjAzNg==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506036036", "bodyText": "we have converted snapshot.pdl to DataSchema for compatibility check. Technically it is dataschema, not snapshot. So calling it 'snapshot...' is not accurate.", "author": "nickibi", "createdAt": "2020-10-16T03:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTM2Nw==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506021367", "bodyText": "The above logic only has 1 ANNOTATION_COMPATIBLE_CHANGE impact, all the other impact are incompatible.\nI wonder how is it better if split into two results (or just one result if you dont care comptaible message, btw why do we need compatible message?)\nIf we split to two results, and you can add all incompatible msg to a dedicated result. That will make these callers that are saving msg not need to pass the CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE and less repeating ourselves.", "author": "BrianPin", "createdAt": "2020-10-16T03:20:12Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/PegasusExtensionSchemaAnnotationHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This SchemaAnnotationHandler is used to check extension schema annotation(@extension) compatibility\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusExtensionSchemaAnnotationHandler implements SchemaAnnotationHandler\n+{\n+  private final String EXTENSION_ANNOTATION_NAMESPACE = \"extension\";\n+\n+  @Override\n+  public ResolutionResult resolve(List<Pair<String, Object>> propertiesOverrides,\n+      ResolutionMetaData resolutionMetadata)\n+  {\n+    return new ResolutionResult();\n+  }\n+\n+  @Override\n+  public String getAnnotationNamespace()\n+  {\n+    return EXTENSION_ANNOTATION_NAMESPACE;\n+  }\n+\n+  @Override\n+  public AnnotationValidationResult validate(Map<String, Object> resolvedProperties, ValidationMetaData metaData)\n+  {\n+    return new AnnotationValidationResult();\n+  }\n+\n+  @Override\n+  public SchemaVisitor getVisitor()\n+  {\n+    // No need to override properties, use IdentitySchemaVisitor to skip schema traverse.\n+    return new IdentitySchemaVisitor();\n+  }\n+\n+  @Override\n+  public boolean implementsCheckCompatibility()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public AnnotationCompatibilityResult checkCompatibility(Map<String, Object> prevResolvedProperties, Map<String, Object> currResolvedProperties,\n+      CompatibilityCheckContext prevContext, CompatibilityCheckContext currContext)\n+  {\n+    AnnotationCompatibilityResult result = new AnnotationCompatibilityResult();\n+    // Both prevResolvedProperties and currResolvedProperties contain extension annotation namespace, check any changes of annotations on the existing fields.\n+    if (prevResolvedProperties.containsKey(EXTENSION_ANNOTATION_NAMESPACE) && currResolvedProperties.containsKey(EXTENSION_ANNOTATION_NAMESPACE))\n+    {\n+      DataMap prevAnnotations = (DataMap) prevResolvedProperties.get(EXTENSION_ANNOTATION_NAMESPACE);\n+      DataMap currAnnotations = (DataMap) currResolvedProperties.get(EXTENSION_ANNOTATION_NAMESPACE);\n+      prevAnnotations.forEach((key, value) ->\n+      {\n+        if (currAnnotations.containsKey(key))\n+        {\n+          // Check annotation value changes.\n+          if (!prevAnnotations.get(key).equals(currAnnotations.get(key)))\n+          {\n+            appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+                \"Updating extension annotation field: \\\"%s\\\" value is considering as a backward incompatible change.\",\n+                key, currContext.getPathSpecToSchema());\n+          }\n+          currAnnotations.remove(key);\n+        }\n+        else\n+        {\n+          // An existing annotation field is removed.\n+          appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+              \"Removing extension annotation field: \\\"%s\\\" is considering as a backward incompatible change.\",\n+              key, currContext.getPathSpecToSchema());\n+        }\n+      });\n+\n+      currAnnotations.forEach((key, value) ->\n+      {\n+        // Adding an extension annotation field.\n+        appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+            \"Adding extension annotation field: \\\"%s\\\" is a backward incompatible change.\",\n+            key, currContext.getPathSpecToSchema());\n+      });\n+    }\n+    else if (prevResolvedProperties.containsKey(EXTENSION_ANNOTATION_NAMESPACE))\n+    {\n+      // Only previous schema has extension annotation, it means the extension annotation is removed in the current schema.\n+      if (currContext.getPathSpecToSchema() != null)\n+      {\n+        appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+            \"Removing extension annotation is a backward incompatible change.\",\n+            null, prevContext.getPathSpecToSchema());\n+      }\n+      else\n+      {\n+        // an existing field with extension annotation is removed\n+        appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+            \"Removing field: \\\"%s\\\" with extension annotation is a backward incompatible change.\",\n+            prevContext.getSchemaField().getName(), prevContext.getPathSpecToSchema());\n+      }\n+    }\n+    else\n+    {\n+      if (prevContext.getPathSpecToSchema() != null)\n+      {\n+        appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+            \"Adding extension annotation on an existing field: \\\"%s\\\" is backward incompatible change\",\n+            prevContext.getSchemaField().getName() , currContext.getPathSpecToSchema());\n+      }\n+      else\n+      {\n+        // Adding a new injected field with extension annotation.\n+        appendCompatibilityMessage(result, CompatibilityMessage.Impact.ANNOTATION_COMPATIBLE_CHANGE,\n+            \"Adding extension annotation on new field: \\\"%s\\\" is backward compatible change\", currContext.getSchemaField().getName() , currContext.getPathSpecToSchema());\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private void appendCompatibilityMessage(AnnotationCompatibilityResult result, CompatibilityMessage.Impact impact, String message, String context, PathSpec pathSpec)", "originalCommit": "4c0feb228b44f4185ab3473289a7d6a137c4fb61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAzMzMyNA==", "url": "https://github.com/linkedin/rest.li/pull/445#discussion_r506033324", "bodyText": "We only have ONE result here. result contains a message list which contains all messages no matter it is compatible or incompatible. We will not throw the exception for compatible change, but we do need such information to generate compatibility report. That will be the same user experience as schema compatibility check.", "author": "nickibi", "createdAt": "2020-10-16T03:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMTM2Nw=="}], "type": "inlineReview"}, {"oid": "eb46db2bfbb8f6846332611a6eff175bd110f4b0", "url": "https://github.com/linkedin/rest.li/commit/eb46db2bfbb8f6846332611a6eff175bd110f4b0", "message": "Add PegasusExtensionSchemaAnnotationHandler for extension schema annotation compatibility check", "committedDate": "2020-10-16T04:56:09Z", "type": "forcePushed"}, {"oid": "85798f5f643bbaffdde125e65818715d08b615b2", "url": "https://github.com/linkedin/rest.li/commit/85798f5f643bbaffdde125e65818715d08b615b2", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check", "committedDate": "2020-10-19T21:57:44Z", "type": "commit"}, {"oid": "85798f5f643bbaffdde125e65818715d08b615b2", "url": "https://github.com/linkedin/rest.li/commit/85798f5f643bbaffdde125e65818715d08b615b2", "message": "Add ExtensionSchemaAnnotationHandler for extension schema annotation compatibility check", "committedDate": "2020-10-19T21:57:44Z", "type": "forcePushed"}]}