{"pr_number": 435, "pr_title": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility", "pr_createdAt": "2020-10-03T06:13:54Z", "pr_url": "https://github.com/linkedin/rest.li/pull/435", "timeline": [{"oid": "c1a6e704f456feb841361258034c4ca6c76c93fb", "url": "https://github.com/linkedin/rest.li/commit/c1a6e704f456feb841361258034c4ca6c76c93fb", "message": "Add annotation compatibility check in checkPegasusSnapshotTask", "committedDate": "2020-10-03T06:00:19Z", "type": "forcePushed"}, {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae", "url": "https://github.com/linkedin/rest.li/commit/5be9a547810b7caa3627c8b8911bed07704b99ae", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-03T06:52:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM5OTk5OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499399999", "bodyText": "Can you rename this variable so it can be consistent with other naming (I see three naming, enclosingUnionMember, UnionMember, unionDataMember)", "author": "junchuanwang", "createdAt": "2020-10-05T07:45:16Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionDataMember = context.getEnclosingUnionMember();", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MTExNA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499951114", "bodyText": "enclosingUnionMember name is specifically in the context of traversing schemas. Here to provide some context of schema, I think calling it \"unionMember\" makes more sense rather than \"enclosingUnionMember\".\nI will update unionDataMember to unionMember.", "author": "nickibi", "createdAt": "2020-10-06T01:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM5OTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499400254", "bodyText": "Same here, there are two paths in context, you can rename it to pathSpecToSchema", "author": "junchuanwang", "createdAt": "2020-10-05T07:45:44Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionDataMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionDataMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MDY1MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499950650", "bodyText": "In the AnnotationCheckContext, I used String[] _pathToSchema. The reason why I convert pathSpec to String[] paths, because CompatibilityMessage requires String[] paths as input, I do not want users to convert it, which is unnecessary.\nI feel pathToSchema makes more sense here, because it is not PathSpec.", "author": "nickibi", "createdAt": "2020-10-06T01:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUzMzk0OA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501533948", "bodyText": "I think a better solution would be to update CompatibiliyMessage to accept PathSpec and convert to array if needed.\nThen you can re-use the PathSpec in the map key below and avoid creating a new array for every node.", "author": "karthikbalasub", "createdAt": "2020-10-08T08:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3NDA1Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501574052", "bodyText": "@nickibi CompatibilityMessage's path is not well defined (it could be anything, as long as a string array). Here you seems to be really storing the pathspec in the annotationCheckContext", "author": "junchuanwang", "createdAt": "2020-10-08T09:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNjQwOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502136409", "bodyText": "Add a new constructor for CompatibiliyMessage to accept PathSpec.", "author": "nickibi", "createdAt": "2020-10-09T02:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMjU2Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499402562", "bodyText": "If we make it default method, that means every handler will return a AnnotationCompatibilityResult. Is there a way to tell whether or not this check happened? How can we distinguish the two cases", "author": "junchuanwang", "createdAt": "2020-10-05T07:49:43Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,93 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwOTAxNA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499909014", "bodyText": "We would set up null as default value here to differentiate whether this method is conducted or not. But using null as default value is not ideal, I think adding a flag is a cleaner way to achieve it.", "author": "nickibi", "createdAt": "2020-10-05T22:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMjU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzE0MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499403140", "bodyText": "Similar to my other comment, maybe we can add a flag to tell whether this check has been conducted or not.", "author": "junchuanwang", "createdAt": "2020-10-05T07:50:42Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,93 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwOTEzMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499909131", "bodyText": "I will add a flag in this class.", "author": "nickibi", "createdAt": "2020-10-05T22:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzg5Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499403896", "bodyText": "How does the handler handle these Else branch cases?  Maybe add some brief comments", "author": "junchuanwang", "createdAt": "2020-10-05T07:51:59Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU2MDYxOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r500560618", "bodyText": "Updated the comments and also added logic to handle else branch cases.", "author": "nickibi", "createdAt": "2020-10-06T19:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwNDc1MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499404750", "bodyText": "similarly, perhaps add some comments here", "author": "junchuanwang", "createdAt": "2020-10-05T07:53:31Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+            {\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty\n+                  = olderResolvedPropertiesMap.get(pathSpec);\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> newerCheckContextAndResolvedProperty\n+                  = newerResolvedPropertiesMap.get(pathSpec);\n+\n+              Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+              Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+              if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(annotationNamespace))", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4ODU5Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499988592", "bodyText": "added comments", "author": "nickibi", "createdAt": "2020-10-06T03:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwNDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwOTU2MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499409561", "bodyText": "Add log before throwing exception", "author": "junchuanwang", "createdAt": "2020-10-05T08:00:35Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+            {\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty\n+                  = olderResolvedPropertiesMap.get(pathSpec);\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> newerCheckContextAndResolvedProperty\n+                  = newerResolvedPropertiesMap.get(pathSpec);\n+\n+              Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+              Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+              if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(annotationNamespace))\n+              {\n+                AnnotationCompatibilityResult result = handler.annotationCompatibilityCheck(olderResolvedProperties,\n+                    newerResolvedProperties, olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+                results.add(result);\n+              }\n+            }\n+          });\n+    }\n+    return results;\n+  }\n+\n+  private static Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> getNodeToResolvedProperties(\n+      SchemaAnnotationProcessor.SchemaAnnotationProcessResult result)\n+  {\n+    AnnotationCheckResolvedPropertiesVisitor visitor = new AnnotationCheckResolvedPropertiesVisitor();\n+    DataSchemaRichContextTraverser traverser = new DataSchemaRichContextTraverser(visitor);\n+    traverser.traverse(result.getResultSchema());\n+    return visitor.getNodeToResolvedPropertiesMap();\n+  }\n+\n+  private static SchemaAnnotationProcessor.SchemaAnnotationProcessResult processSchemaAnnotation(DataSchema dataSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult result =\n+        SchemaAnnotationProcessor.process(handlers, dataSchema, new SchemaAnnotationProcessor.AnnotationProcessOption());\n+    // If any of the nameDataSchema failed to be processed, throw exception\n+    if (result.hasError())\n+    {\n+      String schemaName = ((NamedDataSchema) dataSchema).getFullName();", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDMwNw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499870307", "bodyText": "log and throw exception is anti-pattern, right ? https://stackoverflow.com/questions/6639963/why-is-log-and-throw-considered-an-anti-pattern", "author": "nickibi", "createdAt": "2020-10-05T21:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU2MDY1Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r500560657", "bodyText": "Added log", "author": "nickibi", "createdAt": "2020-10-06T19:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwOTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMDQxMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499410411", "bodyText": "not throwing exception", "author": "junchuanwang", "createdAt": "2020-10-05T08:01:19Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMDUzNQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499410535", "bodyText": "same, not throwing exception", "author": "junchuanwang", "createdAt": "2020-10-05T08:01:26Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());\n+      }\n+    }\n+\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathUrls.toArray(new URL[handlerJarPathUrls.size()]),\n+        getClass().getClassLoader());\n+\n+    try\n+    {\n+      _handlerClassNames = SchemaAnnotationHandlerClassUtil.getAnnotationHandlerClassNames(_handlerJarPath, classLoader, getProject());\n+    }\n+    catch (IOException e)\n+    {\n+      new GradleException(\"Annotation compatibility check: could not get annotation handler class name. \" + e.getMessage());", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMTM3Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499411377", "bodyText": "The logic is still similar to ValidateSchemaAnnotationTask, do you think we can extract the common part to not repeat yourself? Later if we change the enforcement of expected number of hanlders per module, we don't need to change on two places", "author": "junchuanwang", "createdAt": "2020-10-05T08:02:09Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());\n+      }\n+    }\n+\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathUrls.toArray(new URL[handlerJarPathUrls.size()]),\n+        getClass().getClassLoader());\n+\n+    try\n+    {\n+      _handlerClassNames = SchemaAnnotationHandlerClassUtil.getAnnotationHandlerClassNames(_handlerJarPath, classLoader, getProject());\n+    }\n+    catch (IOException e)\n+    {\n+      new GradleException(\"Annotation compatibility check: could not get annotation handler class name. \" + e.getMessage());\n+    }\n+\n+    // For now, every schema annotation handler should be in its own module", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxMTc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499911785", "bodyText": "You are right, I will move this part to the SchemaAnnotationHandlerUtil.", "author": "nickibi", "createdAt": "2020-10-05T22:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMjM5OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499412399", "bodyText": "I will recommend to use longer name here, --handlerJarPath and handlerClassName. We don't need to be concise for this particular use case, but need to be explicit (for example later do a code search would be easier)", "author": "junchuanwang", "createdAt": "2020-10-05T08:03:07Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -76,6 +84,15 @@ public void checkPegasusSnapshot()\n       javaExecSpec.args(\"--report\", reportOutput);\n       javaExecSpec.args(_previousSnapshotDirectory);\n       javaExecSpec.args(_currentSnapshotDirectory);\n+      if (_isExtensionSchema)\n+      {\n+        javaExecSpec.args(\"--extensionSchema\");\n+      }\n+      else if(hasSchemaAnnotationHandler())\n+      {\n+        javaExecSpec.args(\"--jarPath\", _handlerJarPath);", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4ODQ2OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499988469", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-10-06T03:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxODcyOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499418728", "bodyText": "These code is still a lot similar to SchemaAnnotationValidatorCmdLineApp, should DRY", "author": "junchuanwang", "createdAt": "2020-10-05T08:14:48Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -345,4 +402,53 @@ private static void help()\n     }\n     return null;\n   }\n+\n+  private static List<SchemaAnnotationHandler> getAnnotationHandlers(String handlerJarPaths, String classNames)", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0Mzk4NA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499943984", "bodyText": "Yes, moved this one to a util class which can be used by both 'SchemaAnnotationValidatorCmdLineApp' and 'PegasusSchemaSnapshotCompatibilityChecker'.", "author": "nickibi", "createdAt": "2020-10-06T00:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxODcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMjkwNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499422906", "bodyText": "Can you also post example error message to this PR ? like your local test?\nOtherwise I was expecting to see it from some unit test.", "author": "junchuanwang", "createdAt": "2020-10-05T08:22:47Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityReport.java", "diffHunk": "@@ -55,11 +55,27 @@ public String createReport()\n         .map(it -> \"[MD-I]:\" + it)\n         .collect(Collectors.joining(\"\\n\"));\n \n+    String annotationCompat = \"\";\n+    String annotationIncompat = \"\";\n+    String annotationIsCompat = \"\";\n+    if(_infoMap.getAnnotationInfo(CompatibilityInfo.Level.INCOMPATIBLE).size() > 0 || _infoMap.getAnnotationInfo(CompatibilityInfo.Level.COMPATIBLE).size() > 0)", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5MzE3Mw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499993173", "bodyText": "Please check the following example:\n[checker] [RS-COMPAT]: true\n[checker] [MD-COMPAT]: true\n[checker] [SCHEMA-ANNOTATION-COMPAT]: false\n[checker] [SCHEMA-ANNOTATION-I]:distance: annotation check test, breaks new readers\n[checker] [SCHEMA-ANNOTATION-I]:lastName: annotation check test, breaks new readers\n> Task :datarealm-restaurants-models:checkPegasusSchemaSnapshot FAILED\nFAILURE: Build failed with an exception.\n\nWhat went wrong:\n\nExecution failed for task ':datarealm-restaurants-models:checkPegasusSchemaSnapshot'.\n\nThere are incompatible changes, find details in /Users/ybi/workspace/datarealm-restaurants_trunk/build/datarealm-restaurants-models/reports/checkPegasusSchema/compatibilityReport.txt", "author": "nickibi", "createdAt": "2020-10-06T04:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMjkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3MTIwOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501571209", "bodyText": "I meant Can you add this to the PR descritpion", "author": "junchuanwang", "createdAt": "2020-10-08T09:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ0MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499423440", "bodyText": "Just a thought: Unlike other message, Annotation incompatible  message doesn't have a message placeholder and description, which actually made it more difficult to be code-searched", "author": "junchuanwang", "createdAt": "2020-10-05T08:23:43Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/idlcheck/CompatibilityInfo.java", "diffHunk": "@@ -65,7 +65,9 @@\n     PAGING_ADDED(Level.COMPATIBLE, \"Method added paging support\"),\n     PAGING_REMOVED(Level.INCOMPATIBLE, \"Method removed paging support\"),\n     SERVICE_ERROR_ADDED(Level.INCOMPATIBLE, \"Service error \\\"%s\\\" now applies\"),\n-    SERVICE_ERROR_REMOVED(Level.COMPATIBLE, \"Service error \\\"%s\\\" no longer applies\");\n+    SERVICE_ERROR_REMOVED(Level.COMPATIBLE, \"Service error \\\"%s\\\" no longer applies\"),\n+    BREAK_OLD_CLIENTS(Level.INCOMPATIBLE, \"Deleting an schema is incompatible change, it breaks old clients\"),\n+    ANNOTATION_INCOMPATIBLE_CHANGE(Level.INCOMPATIBLE, \"%s\");", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyOTU2MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499929560", "bodyText": "This one is used for customer to define their custom compatibility rules, all the message info will be put here to replace \"%s\". Do you think we should provide something like - \" Annotation incompatible change: \"? Or maybe leave it as-is.", "author": "nickibi", "createdAt": "2020-10-05T23:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3NDY4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501574680", "bodyText": "I will agree with what you now proposed", "author": "junchuanwang", "createdAt": "2020-10-08T09:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE1MDAxNA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502150014", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-10-09T02:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjY1OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499426659", "bodyText": "I didn't understand why there is any other error message for annotation other than ANNOTATION_INCOMPATIBLE_CHANGE ?", "author": "junchuanwang", "createdAt": "2020-10-05T08:29:14Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java", "diffHunk": "@@ -296,4 +303,49 @@ public boolean addAll(CompatibilityInfoMap other)\n     }\n     return true;\n   }\n+\n+  public void addAnnotation(CompatibilityMessage message)\n+  {\n+    final CompatibilityInfo.Type infoType;\n+    CompatibilityInfo info;\n+    String infoMessage = String.format(message.getFormat(), message.getArgs());\n+\n+    if (message.isError())\n+    {\n+      switch (message.getImpact())\n+      {\n+        case BREAKS_NEW_READER:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER;\n+          break;\n+        case BREAKS_OLD_READER:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER;\n+          break;\n+        case BREAKS_NEW_AND_OLD_READERS:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS;\n+          break;\n+        case ANNOTATION_INCOMPATIBLE_CHANGE:", "originalCommit": "5be9a547810b7caa3627c8b8911bed07704b99ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODkxOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499928919", "bodyText": "Since we do not provide annotation compatibility rules, customers provide the way how they want to check the annotations. There are some common sense rules like - change breaks new reader, change breaks old reader or change breaks new and old reader. The ANNOTATION_INCOMPATIBLE_CHANGE provide an option to users to define the way how they want to define the compatibility other than above. We provide the framework to support it.", "author": "nickibi", "createdAt": "2020-10-05T23:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4Mjg0MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501582840", "bodyText": "then do you think CUSTOM_ANNOTATION_INCOMPATIBLE_CHANGE will be a better definition?", "author": "junchuanwang", "createdAt": "2020-10-08T09:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk4NDgxMw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501984813", "bodyText": "Discussed offline, we will only have ANNOTATION_INCOMPATIBLE_CHANGE  here.", "author": "nickibi", "createdAt": "2020-10-08T20:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjY1OQ=="}], "type": "inlineReview"}, {"oid": "a61c0f7337e1db8f07bd46b3b863509270efbc70", "url": "https://github.com/linkedin/rest.li/commit/a61c0f7337e1db8f07bd46b3b863509270efbc70", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-06T03:38:55Z", "type": "forcePushed"}, {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "url": "https://github.com/linkedin/rest.li/commit/ccc2767fc56e8017cf019b4c5484b907c451b73f", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-06T19:58:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NjE5Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501276196", "bodyText": "Sorry for late review,\nA consideration for this function is to make it readable, and reusable.\nWould it be possible if we can use some string formatted json to represent the all the datamap or properties.\nAnd use something like DataMapUtil's function to read those json formated string to dataMap objects?", "author": "BrianPin", "createdAt": "2020-10-07T20:03:10Z", "path": "data/src/test/java/com/linkedin/data/schema/compatibility/TestAnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.PegasusSchemaAnnotationHandlerImpl;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestAnnotationCompatibilityChecker\n+{\n+  @Test(dataProvider = \"annotationCompatibilityCheckTestData\")\n+  public void testCheckCompatibility(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers, List<SchemaAnnotationHandler.AnnotationCompatibilityResult> expectedResults)\n+  {\n+    List<SchemaAnnotationHandler.AnnotationCompatibilityResult> results = AnnotationCompatibilityChecker\n+        .getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+    Assert.assertEquals(results.size(), expectedResults.size());\n+    for (int i = 0; i < results.size(); i++)\n+    {\n+      Assert.assertEquals(results.get(i).isCheckAnnotation(), expectedResults.get(i).isCheckAnnotation());\n+      Assert.assertEquals(results.get(i).getMessages().size(), expectedResults.get(i).getMessages().size());\n+      List<CompatibilityMessage> actualCompatibilityMessage = (List<CompatibilityMessage>) results.get(i).getMessages();\n+      List<CompatibilityMessage> expectCompatibilityMessage = (List<CompatibilityMessage>) expectedResults.get(i).getMessages();\n+      for (int j = 0; j < actualCompatibilityMessage.size(); j++)\n+      {\n+        Assert.assertEquals(actualCompatibilityMessage.get(j).toString(), expectCompatibilityMessage.get(j).toString());\n+      }\n+    }\n+  }\n+\n+  @DataProvider\n+  private Object[][] annotationCompatibilityCheckTestData()", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzQ1MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501383450", "bodyText": "Discussed offline, update the test cases in a cleaner way.", "author": "nickibi", "createdAt": "2020-10-08T00:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODQ2NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501308465", "bodyText": "Maybe document on why?", "author": "BrianPin", "createdAt": "2020-10-07T21:03:11Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODkzNQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501308935", "bodyText": "Why in terms of not execute the callback on POST_ORDER", "author": "BrianPin", "createdAt": "2020-10-07T21:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM0MTYzMA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501341630", "bodyText": "In the DataSchemaRichContextTraverser, the schemaVisitor.callbackOnContext are triggered twice by default. First is PRE_ORDER, then is POST_ORDER.\nFor the usecase here, we only need to get the schema context of each node, traversing once is enough. Therefore, when it's POST_ORDER, we skip it.", "author": "nickibi", "createdAt": "2020-10-07T22:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM0MjUyNA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501342524", "bodyText": "Added comments.", "author": "nickibi", "createdAt": "2020-10-07T22:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwOTY3OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501309679", "bodyText": "style convention?", "author": "BrianPin", "createdAt": "2020-10-07T21:05:35Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());\n+\n+    Pair<AnnotationCheckContext, Map<String, Object>> annotationContextAndResolvedProperties =\n+        new ImmutablePair<>(annotationCheckContext, resolvedProperties);\n+\n+    _nodeToResolvedPropertiesMap.put(\n+          new PathSpec(context.getSchemaPathSpec()), annotationContextAndResolvedProperties);\n+  }\n+\n+  @Override\n+  public VisitorContext getInitialVisitorContext() {", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzOTQ1MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501339451", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-10-07T22:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwOTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxMDYwNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501310606", "bodyText": "Maybe we can move this statement that generates the annotationContextAndResolvedProperties object into the next line where it is the only place that it is being used?", "author": "BrianPin", "createdAt": "2020-10-07T21:07:33Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());\n+\n+    Pair<AnnotationCheckContext, Map<String, Object>> annotationContextAndResolvedProperties =", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzOTA2OA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501339068", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-10-07T22:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxMDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxNTM1NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501315355", "bodyText": "This function name seems confusing, in the comment it is meant for annotation check not the schema itself", "author": "BrianPin", "createdAt": "2020-10-07T21:17:25Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxNTY1MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501315650", "bodyText": "Please don't increase the length of checkPegasusSchemaCompatibility into checkPegasusSchemaAnnoationaCompatibility", "author": "BrianPin", "createdAt": "2020-10-07T21:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxNTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzODk4MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501338981", "bodyText": "Change name to 'checkPegasusSchemaAnnotation'. Later on I will add new method 'checkExtensionSchemaAnnotation' for extension annotation check.", "author": "nickibi", "createdAt": "2020-10-07T22:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxNTM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxODEzNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501318136", "bodyText": "Maybe we can have a new interface that specifically deals compatibility check.\nMy reason being the action to check compatibility maybe not needed for every schema annotation handler, so we create a new interface the inherit schema annotation handler, to add some more specific functions to schema annotation handler.\nThat way, you don't worry about using default here, and leave original schemaAnnotationHandler some flexibility.", "author": "BrianPin", "createdAt": "2020-10-07T21:23:12Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxOTc3Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501319777", "bodyText": "We had such discussion during the design phase. The main idea to put it into the SchemaAnnotationHandler is to complete the features of Schema Annotation Processor. In the handler, users provide how to resolve a custom annotation, how to validate a custom annotation. The compatibility check part was missing.\nAlso it would provide better developer experience to users, they just need to have one SchemaAnnotationHandler config.\nMore details can be found in the design doc.", "author": "nickibi", "createdAt": "2020-10-07T21:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxODEzNg=="}], "type": "inlineReview"}, {"oid": "02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "url": "https://github.com/linkedin/rest.li/commit/02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-08T00:21:24Z", "type": "forcePushed"}, {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "url": "https://github.com/linkedin/rest.li/commit/16887f070340eb82ba9d3b3f4427b9f566b5f32d", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-08T00:26:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NTk1Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501185957", "bodyText": "I prefer method names to start with a verb: doSomething..\nSo rename this to \"checkCompatibility\" ? \"annotation\" is implied by context.\nSpace between String, Object", "author": "karthikbalasub", "createdAt": "2020-10-07T17:26:51Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTg3MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502551871", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-10-09T16:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NjIzMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501186232", "bodyText": "CompatibilityCheckContext?\nAnnotation is implied by context.", "author": "karthikbalasub", "createdAt": "2020-10-07T17:27:19Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1Mjc5Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502552792", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-10-09T16:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NzAyOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501187029", "bodyText": "Add javadoc on these methods.", "author": "karthikbalasub", "createdAt": "2020-10-07T17:28:39Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzM5OA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502127398", "bodyText": "Removed this method, because add a method to indicate implement compatibility check on the handler.", "author": "nickibi", "createdAt": "2020-10-09T01:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NzAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NzQwMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501187402", "bodyText": "remove extra line", "author": "karthikbalasub", "createdAt": "2020-10-07T17:29:19Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()\n+    {\n+      return _checkAnnotation;\n+    }\n+\n+    public void setCheckAnnotation(boolean checkAnnotation)\n+    {\n+      _checkAnnotation = checkAnnotation;\n+    }\n+\n+    public AnnotationCompatibilityResult()\n+    {\n+      _messages = new MessageList<CompatibilityMessage>();\n+    }\n+\n+    @Override\n+", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4ODM1Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501188357", "bodyText": "It looks like the only way to add messages is by doing getMessages().add(..). It feels odd, why not add a method \"addMessage(...)\" to this class?", "author": "karthikbalasub", "createdAt": "2020-10-07T17:30:46Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()\n+    {\n+      return _checkAnnotation;\n+    }\n+\n+    public void setCheckAnnotation(boolean checkAnnotation)\n+    {\n+      _checkAnnotation = checkAnnotation;\n+    }\n+\n+    public AnnotationCompatibilityResult()\n+    {\n+      _messages = new MessageList<CompatibilityMessage>();\n+    }\n+\n+    @Override\n+\n+    public Collection<CompatibilityMessage> getMessages() {\n+      return _messages;", "originalCommit": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MDk4NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502550985", "bodyText": "Add a  addMessage() method.", "author": "nickibi", "createdAt": "2020-10-09T16:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4ODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MzcxMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501473712", "bodyText": "Document the syntax of this parameter.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:21:33Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -87,7 +97,22 @@\n         .withLongOpt(\"report\")\n         .hasArg()\n         .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .isRequired()\n         .create(\"report\"));\n+    _options.addOption(OptionBuilder.withArgName(\"annotation_handler_jarPaths\")\n+        .withLongOpt(\"handlerJarPath\")\n+        .hasArgs()\n+        .withDescription(\"path of the jars which contains the annotation handlers\")\n+        .create(\"jar\"));\n+    _options.addOption(OptionBuilder.withArgName(\"handler-classNames\")\n+        .withLongOpt(\"handlerClassName\")\n+        .hasArgs()\n+        .withDescription(\"class names of the handlers\")", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE1MTYzOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502151638", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-10-09T02:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDAzMw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474033", "bodyText": "document that this is a boolean flag.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:22:24Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -87,7 +97,22 @@\n         .withLongOpt(\"report\")\n         .hasArg()\n         .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .isRequired()\n         .create(\"report\"));\n+    _options.addOption(OptionBuilder.withArgName(\"annotation_handler_jarPaths\")\n+        .withLongOpt(\"handlerJarPath\")\n+        .hasArgs()\n+        .withDescription(\"path of the jars which contains the annotation handlers\")\n+        .create(\"jar\"));\n+    _options.addOption(OptionBuilder.withArgName(\"handler-classNames\")\n+        .withLongOpt(\"handlerClassName\")\n+        .hasArgs()\n+        .withDescription(\"class names of the handlers\")\n+        .create(\"className\"));\n+    _options.addOption(OptionBuilder.withArgName(\"extensionSchema\")\n+        .withLongOpt(\"extensionSchema\")\n+        .withDescription(\"Check pegasus extension schema annotation\")", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE0OTc4Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502149787", "bodyText": "Updated the description.", "author": "nickibi", "createdAt": "2020-10-09T02:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDE0Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474146", "bodyText": "also check if the value is true?", "author": "karthikbalasub", "createdAt": "2020-10-08T06:22:38Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2NTI3MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501865270", "bodyText": "There is no value for 'extensionSchema', having this option itself is a flag.\nIn checkPegasusSnapshotTask:\nif (_isExtensionSchema)\n{\njavaExecSpec.args(\"--extensionSchema\");\n}\nDo you think it provides enough info?", "author": "nickibi", "createdAt": "2020-10-08T16:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3OTE0Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501879142", "bodyText": "Nevermind, I was not sure how \"hasOption\" worked.", "author": "karthikbalasub", "createdAt": "2020-10-08T17:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDc4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474780", "bodyText": "Quit the checker if there is an error.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:24:34Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))\n+    {\n+      _checkExtensionSchemaAnnotation = true;\n+    }\n+\n+    if (cl.hasOption(\"jar\") && cl.hasOption(\"className\"))\n+    {\n+     String handlerJarPaths = cl.getOptionValue(\"jar\");\n+     String classNames = cl.getOptionValue(\"className\");\n+     try\n+     {\n+       _handlers = ClassJarPathUtil.getAnnotationHandlers(handlerJarPaths, classNames);\n+     }\n+     catch (IllegalStateException e)\n+     {\n+       _logger.error(\"Error while doing schema compatibility check, could not get SchemaAnnotationHandler classes: \" + e.getMessage());", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE1OTk1Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502159956", "bodyText": "fixed.", "author": "nickibi", "createdAt": "2020-10-09T03:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTA5OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501475099", "bodyText": "I don't think you need this flag, just use !_handlers.isEmpty() when needed.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:25:20Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))\n+    {\n+      _checkExtensionSchemaAnnotation = true;\n+    }\n+\n+    if (cl.hasOption(\"jar\") && cl.hasOption(\"className\"))\n+    {\n+     String handlerJarPaths = cl.getOptionValue(\"jar\");\n+     String classNames = cl.getOptionValue(\"className\");\n+     try\n+     {\n+       _handlers = ClassJarPathUtil.getAnnotationHandlers(handlerJarPaths, classNames);\n+     }\n+     catch (IllegalStateException e)\n+     {\n+       _logger.error(\"Error while doing schema compatibility check, could not get SchemaAnnotationHandler classes: \" + e.getMessage());\n+     }\n+\n+      _checkPegasusSchemaAnnotation = _handlers.size() > 0;", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE0OTg3Mw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502149873", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-10-09T02:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTQ3Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501475476", "bodyText": "Instead of doing this separately, just add the handler for extension annotation to the _handlers list.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:26:18Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -230,6 +276,24 @@ public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSc\n       result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n     }\n \n+    if (_checkPegasusSchemaAnnotation)\n+    {\n+      List<SchemaAnnotationHandler.AnnotationCompatibilityResult> annotationCompatibilityResults =\n+          AnnotationCompatibilityChecker.checkPegasusSchemaAnnotation(preSchema, currSchema, _handlers);\n+      for (SchemaAnnotationHandler.AnnotationCompatibilityResult annotationResult: annotationCompatibilityResults)\n+      {\n+        if (!annotationResult.getMessages().isEmpty())\n+        {\n+          annotationResult.getMessages().forEach(message -> _infoMap.addAnnotation(message));\n+        }\n+      }\n+    }\n+\n+    if (_checkExtensionSchemaAnnotation)\n+    {\n+      //TODO: extension schema annotation check", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3NTA4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501875080", "bodyText": "Actually, I am thinking about using a different method in AnnotationCompatibilityChecker for extension schema check.\nthe extension schema does not require the annotation processor to process the schema, there is no property resolve/override requirements for extension schemas. We just need a SchemaHandler which provides the compatibility check logic for extension schema. Also we need a schema visitor to get pathSpec and properties. It will traverse the schema once, which reduces the unnecessary schema traverse(process annotation).", "author": "nickibi", "createdAt": "2020-10-08T17:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg4Mzc2Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501883762", "bodyText": "I don't understand how it would be better. You are going to create another branch for extensions which does the. same thing as the annotation checker.\nIf you have only the extension annotation handler, its visitor would traverse the schema once and get you the same result, right? The path override based traversal will happen only if handlers for annotations that support such overrides are present.", "author": "karthikbalasub", "createdAt": "2020-10-08T17:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NjA1NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502556055", "bodyText": "Discussed offline.\nI introduced a new schema visitor - IdentitySchemaVisitor, which will not traverse the schema. It can be used for extension schema annotation check or other use cases which do not need override properties but would like to do the compatibility check. There will be no extra/unnecessary schema traverse for such case.\nNow all the annotation check use cases will fall into the same path: go to annotation processor to process the annotation, then do the annotation compatibility check.", "author": "nickibi", "createdAt": "2020-10-09T16:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3Njc4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501476780", "bodyText": "Include the original exception e in the new exception.", "author": "karthikbalasub", "createdAt": "2020-10-08T06:29:45Z", "path": "restli-tools/src/main/java/com/linkedin/restli/internal/tools/ClassJarPathUtil.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.linkedin.restli.internal.tools;\n+\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This utility is used to get Java classes based on the provided class jar paths\n+ *\n+ * @author Yingjie\n+ */\n+public class ClassJarPathUtil\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ClassJarPathUtil.class);\n+  private static final String DEFAULT_PATH_SEPARATOR = File.pathSeparator;\n+\n+  /**\n+   * A helper method which is used to get the SchemaAnnotationHandler classes based on the given handlerJarPaths and class names\n+   * @param handlerJarPaths\n+   * @param classNames\n+   * @return a list of SchemaAnnotationHandler classes. List<SchemaAnnotationHandler>\n+   * @throws IllegalStateException if it could not instantiate the given class.\n+   */\n+  public static List<SchemaAnnotationHandler> getAnnotationHandlers(String handlerJarPaths, String classNames) throws IllegalStateException\n+  {\n+    List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n+    ClassLoader classLoader = new URLClassLoader(parsePaths(handlerJarPaths)\n+        .stream()\n+        .map(str ->\n+        {\n+          try\n+          {\n+            return Paths.get(str).toUri().toURL();\n+          }\n+          catch (Exception e)\n+          {\n+            _logger.error(\"Parsing class jar path URL {} parsing failed\", str, e);\n+          }\n+          return null;\n+        }).filter(Objects::nonNull).toArray(URL[]::new));\n+\n+    for (String className: parsePaths(classNames))\n+    {\n+      try\n+      {\n+        Class<?> handlerClass = Class.forName(className, false, classLoader);\n+        SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n+        handlers.add(handler);\n+      }\n+      catch (Exception e)\n+      {\n+        throw new IllegalStateException(\"Error instantiating class: \" + className + e.getMessage());", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0OTg0MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502549841", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-10-09T16:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3Njc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMDM4Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501500382", "bodyText": "The first line is redundant. Document that this is a utility class to help with annotation compatibility checking.", "author": "karthikbalasub", "createdAt": "2020-10-08T07:22:06Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTQwMw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502551403", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-10-09T16:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMTc4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501501780", "bodyText": "link to the method in annotation handler.\nI think there is some repetition in this doc. Can you simplify it?", "author": "karthikbalasub", "createdAt": "2020-10-08T07:24:35Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMjIxOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501502218", "bodyText": "compatibilities -> compatibility", "author": "karthikbalasub", "createdAt": "2020-10-08T07:25:26Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMjM1OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501502359", "bodyText": "process -> Process\nolderSchema -> prevSchema\nnewerSchema -> currentSchema\n(to keep the naming consistent everywhere)", "author": "karthikbalasub", "createdAt": "2020-10-08T07:25:41Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMzUxNA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501503514", "bodyText": "remove if you are not adding any documentation.", "author": "karthikbalasub", "createdAt": "2020-10-08T07:27:56Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNDQyMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501504421", "bodyText": "just use e.getValue() to avoid a map lookup.", "author": "karthikbalasub", "createdAt": "2020-10-08T07:29:35Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjAzNw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501522037", "bodyText": "This logic feels odd. Did you consider adding a method on the handler directly?\neg, boolean implementsCompatibilityChecking()", "author": "karthikbalasub", "createdAt": "2020-10-08T08:00:42Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNzU4Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502007582", "bodyText": "add a method on the handler instead.", "author": "nickibi", "createdAt": "2020-10-08T20:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjcxMA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501522710", "bodyText": "or the field was deleted.\nThe logic here would be simple if you returned the empty resolveProperties instead if removing it (in AnnotationCheckResolvedPropertiesVisitor)\nSo the only case to handle is deleted field. At this point, does it make sense to do annotation compatibility checking? Would the schema compatibility checking be enough?", "author": "karthikbalasub", "createdAt": "2020-10-08T08:01:56Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzg1OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502043859", "bodyText": "Yes, I agree.\nI will return empty resolvedProperties in AnnotationCheckResolvedPropertiesVistor.\nThen, we do not need this else branch check at all.", "author": "nickibi", "createdAt": "2020-10-08T22:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MzY1MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502553651", "bodyText": "I think we should provide such check to the annotation check, if an existing field is removed. Users should decide whether they will do something or not.", "author": "nickibi", "createdAt": "2020-10-09T16:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNDAyNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501524026", "bodyText": "this duplication can be avoided if we added a method on the handler to check.", "author": "karthikbalasub", "createdAt": "2020-10-08T08:04:17Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxOTkwMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502019901", "bodyText": "add a method on the handler.", "author": "nickibi", "createdAt": "2020-10-08T21:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNDAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNTQyNQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501525425", "bodyText": "either because newer schema aded new annotations or added new field with annotations", "author": "karthikbalasub", "createdAt": "2020-10-08T08:06:27Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+        }\n+      }\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : newerResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+            newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(e.getKey());\n+        Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+        if (newerResolvedProperties.containsKey(annotationNamespace))\n+        {\n+          // newerResolvedPropertiesMap has a PathSpec which the olderResolvedPropertiesMap does not have,\n+          // it could be either newer schema add new annotations or adding new field with annotations, pass", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1Mzc5MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502553791", "bodyText": "Updated the logic here.", "author": "nickibi", "createdAt": "2020-10-09T16:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501528902", "bodyText": "How would the compatibility checker differentiate between a new field(compatible) vs adding new annotations(may not be compatible)?\nI think we should invoke the checker only for new annotations. And for new fields skip annotation checking?\nOr, send empty context/map for the case where new annotations were added. and use null when a new field was added.", "author": "karthikbalasub", "createdAt": "2020-10-08T08:12:13Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+        }\n+      }\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : newerResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+            newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(e.getKey());\n+        Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+        if (newerResolvedProperties.containsKey(annotationNamespace))\n+        {\n+          // newerResolvedPropertiesMap has a PathSpec which the olderResolvedPropertiesMap does not have,\n+          // it could be either newer schema add new annotations or adding new field with annotations, pass\n+          // an empty olderResolvedPropertiesMap and empty olderAnnotationContext to the annotation check.", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NjE5MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502046191", "bodyText": "Once we return empty resolvedProperties in AnnotationCheckResolvedPropertiesVistor. We would figure out adding new annotation on an existing field use case. Older schema and newer schema will have the same path specs. It will be handled in the previous check.\nFor this branch, only new field with new annotation use case will fall in to this check.\nMy question is for new field with new annotation case, do we need to do the compatibility check?", "author": "nickibi", "createdAt": "2020-10-08T22:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0ODUwNQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502048505", "bodyText": "My intuition says we can ignore the new field with new annotation case. Confirm with @junchuanwang as he has better context on annotations.", "author": "karthikbalasub", "createdAt": "2020-10-08T22:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MDU4Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502090586", "bodyText": "Discussed offline with @nickibi, I recommend to add this check for new field with new annotation", "author": "junchuanwang", "createdAt": "2020-10-09T00:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MjIxOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502552219", "bodyText": "Add check for new field with new annotation case.", "author": "nickibi", "createdAt": "2020-10-09T16:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyOTc1OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501529759", "bodyText": "Leave the empty resolvedProperties for fields without any annotation. It would simplify the compatibility checking logic.", "author": "karthikbalasub", "createdAt": "2020-10-08T08:13:41Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    // Skip execute when order is POST_ORDER to avoid traverse same node twice.\n+    // Only execute this callback when order is PRE_ORDER.\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODU2Mw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502128563", "bodyText": "Yes, that's right.\nUpdated.", "author": "nickibi", "createdAt": "2020-10-09T01:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyOTc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUzNTEzNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501535136", "bodyText": "add extra newline between methods.", "author": "karthikbalasub", "createdAt": "2020-10-08T08:22:42Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)", "originalCommit": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "url": "https://github.com/linkedin/rest.li/commit/0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-09T16:38:21Z", "type": "forcePushed"}, {"oid": "41566fdd40c9fda177ad21b58026a54fc1780776", "url": "https://github.com/linkedin/rest.li/commit/41566fdd40c9fda177ad21b58026a54fc1780776", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-09T16:41:09Z", "type": "forcePushed"}, {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "url": "https://github.com/linkedin/rest.li/commit/ddc665f8ee2ea507409b1974e02c21beaea70e66", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-09T16:42:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTkwMw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502775903", "bodyText": "You could refactor this logic to a utility method:\nchooseProperties(preferredProperties, fallbackProperties)", "author": "karthikbalasub", "createdAt": "2020-10-10T10:36:59Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import java.util.ArrayDeque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    // Skip execute when order is POST_ORDER to avoid traverse the same node twice.\n+    // Only execute this callback when order is PRE_ORDER.\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+\n+    ArrayDeque<String> pathToSchema = context.getSchemaPathSpec().clone();\n+    pathToSchema.addFirst(((NamedDataSchema)context.getTopLevelSchema()).getName());\n+    PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+    CompatibilityCheckContext compatibilityCheckContext = new CompatibilityCheckContext();\n+\n+    compatibilityCheckContext.setCurrentDataSchema(currentSchema);\n+    compatibilityCheckContext.setSchemaField(context.getEnclosingField());\n+    compatibilityCheckContext.setUnionMember(context.getEnclosingUnionMember());\n+    compatibilityCheckContext.setPathSpecToSchema(pathSpec);\n+\n+    // If there is no resolvedProperties but properties, used the properties for annotation check.\n+    Map<String, Object> properties;\n+    if (context.getEnclosingField() != null)\n+    {\n+      RecordDataSchema.Field field = context.getEnclosingField();\n+      if (field.getResolvedProperties().isEmpty())\n+      {\n+        properties = field.getProperties();\n+      }\n+      else\n+      {\n+        properties = field.getResolvedProperties();\n+      }", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODIyMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988222", "bodyText": "Updated to use a utility method.", "author": "nickibi", "createdAt": "2020-10-12T00:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTk4MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502775980", "bodyText": "Reword the doc to not be specific about compatibility check.\nThis is a visitor to use when override is not needed. compatibility is one such usecase.", "author": "karthikbalasub", "createdAt": "2020-10-10T10:38:14Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/IdentitySchemaVisitor.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+\n+\n+/**\n+ * This SchemaVisitor is used to not traverse the data schema.\n+ * Users may want to use Schema Annotation Processor framework to do annotation compatibility check,", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI1NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988255", "bodyText": "Updated the doc.", "author": "nickibi", "createdAt": "2020-10-12T00:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjA2MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776060", "bodyText": "Add a comment why this is needed", "author": "karthikbalasub", "createdAt": "2020-10-10T10:38:53Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/IdentitySchemaVisitor.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+\n+\n+/**\n+ * This SchemaVisitor is used to not traverse the data schema.\n+ * Users may want to use Schema Annotation Processor framework to do annotation compatibility check,\n+ * but they do need to override the annotations, they can use this visitor in the handler to skip annotation overriding.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class IdentitySchemaVisitor implements SchemaVisitor\n+{\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order) {\n+    // skip post order traverse\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    if (context.getParentSchema() == null)", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI0MA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988240", "bodyText": "Added a comment", "author": "nickibi", "createdAt": "2020-10-12T00:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjE5NQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776195", "bodyText": "nit: implementsCheckCompatibility", "author": "karthikbalasub", "createdAt": "2020-10-10T10:40:16Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementCheckCompatibility()", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjI1Nw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776257", "bodyText": "implement -> implements.", "author": "karthikbalasub", "createdAt": "2020-10-10T10:40:49Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI3Mg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988272", "bodyText": "fixed.", "author": "nickibi", "createdAt": "2020-10-12T00:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776319", "bodyText": "Users -> Subclasses\ncould -> should", "author": "karthikbalasub", "createdAt": "2020-10-10T10:41:28Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI4Mw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988283", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-10-12T00:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjcwOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776709", "bodyText": "This is odd, you shouldn't use static variables to store state. See my comment below", "author": "karthikbalasub", "createdAt": "2020-10-10T10:45:12Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationProcessor.java", "diffHunk": "@@ -51,6 +51,9 @@\n {\n   private static final Logger LOG = LoggerFactory.getLogger(SchemaAnnotationProcessor.class);\n \n+\n+  private static boolean _skipValidateProcessResult = false;", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODM1OQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988359", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-10-12T00:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjkyMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776921", "bodyText": "Don't do this. Instead have the actual implementation in this method, based on the input arg. The other method should call this with \"false\" for skipValidateProcessResult.\nnit: I personally prefer not to use negative for boolean params. So suggest using validateProcessResult as the arg and switch the condiation.", "author": "karthikbalasub", "createdAt": "2020-10-10T10:47:12Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationProcessor.java", "diffHunk": "@@ -125,36 +128,71 @@ public static SchemaAnnotationProcessResult process(List<SchemaAnnotationHandler\n       return processResult;\n     }\n \n-    // validate\n-    boolean hasValidationError = false;\n-    for (SchemaAnnotationHandler schemaAnnotationHandler: handlers)\n+    if (!_skipValidateProcessResult)\n     {\n-      LOG.debug(\"DEBUG:  starting validating using \\\"{}\\\" handler\", schemaAnnotationHandler.getAnnotationNamespace());\n-      SchemaAnnotationValidationVisitor validationVisitor = new SchemaAnnotationValidationVisitor(schemaAnnotationHandler);\n-      DataSchemaRichContextTraverser traverserBase = new DataSchemaRichContextTraverser(validationVisitor);\n-      try {\n-        traverserBase.traverse(processResult.getResultSchema());\n-      }\n-      catch (Exception e)\n+      // validate\n+      boolean hasValidationError = false;\n+      for (SchemaAnnotationHandler schemaAnnotationHandler: handlers)\n       {\n-        throw new IllegalStateException(String.format(\"Annotation validation failed in \\\"%s\\\" handler.\",\n-                                                      schemaAnnotationHandler.getAnnotationNamespace()), e);\n-      }\n-      SchemaVisitorTraversalResult handlerTraverseResult = validationVisitor.getSchemaVisitorTraversalResult();\n-      if (!handlerTraverseResult.isTraversalSuccessful())\n-      {\n-        hasValidationError = true;\n-        String errorMsgs = handlerTraverseResult.formatToErrorMessage();\n-        errorMsgBuilder.append(String.format(\"Annotation validation process failed in \\\"%s\\\" handler. \\n\",\n-                                             schemaAnnotationHandler.getAnnotationNamespace()));\n-        errorMsgBuilder.append(errorMsgs);\n+        LOG.debug(\"DEBUG:  starting validating using \\\"{}\\\" handler\", schemaAnnotationHandler.getAnnotationNamespace());\n+        SchemaAnnotationValidationVisitor validationVisitor = new SchemaAnnotationValidationVisitor(schemaAnnotationHandler);\n+        DataSchemaRichContextTraverser traverserBase = new DataSchemaRichContextTraverser(validationVisitor);\n+        try {\n+          traverserBase.traverse(processResult.getResultSchema());\n+        }\n+        catch (Exception e)\n+        {\n+          throw new IllegalStateException(String.format(\"Annotation validation failed in \\\"%s\\\" handler.\",\n+              schemaAnnotationHandler.getAnnotationNamespace()), e);\n+        }\n+        SchemaVisitorTraversalResult handlerTraverseResult = validationVisitor.getSchemaVisitorTraversalResult();\n+        if (!handlerTraverseResult.isTraversalSuccessful())\n+        {\n+          hasValidationError = true;\n+          String errorMsgs = handlerTraverseResult.formatToErrorMessage();\n+          errorMsgBuilder.append(String.format(\"Annotation validation process failed in \\\"%s\\\" handler. \\n\",\n+              schemaAnnotationHandler.getAnnotationNamespace()));\n+          errorMsgBuilder.append(errorMsgs);\n+        }\n       }\n+      processResult.setValidationSuccess(!hasValidationError);\n+      processResult.setErrorMsgs(errorMsgBuilder.toString());\n+    }\n+    else\n+    {\n+      processResult.setValidationSuccess(true);\n     }\n-    processResult.setValidationSuccess(!hasValidationError);\n-    processResult.setErrorMsgs(errorMsgBuilder.toString());\n+\n     return processResult;\n   }\n \n+  /**\n+   * This function creates  {@link DataSchemaRichContextTraverser} and use it to wrap {@link SchemaVisitor} to visit the {@link DataSchema}\n+   *\n+   * Note {@link SchemaAnnotationHandler}'s #resolve() and #validate() function are supposed to be called by {@link SchemaVisitor}\n+   *\n+   * For the given {@link DataSchema}, it will first invoke each {@link SchemaAnnotationHandler#resolve}\n+   * by using the {@link SchemaVisitor} returned by {@link SchemaAnnotationHandler#getVisitor()}\n+   *\n+   * then it uses {@link SchemaAnnotationValidationVisitor} to invoke each {@link SchemaAnnotationHandler#validate} to validate resolved schema annotation.\n+   * users would skip this validation, by passing skipValidateProcessResult as true;\n+   *\n+   * It will abort in case of unexpected exceptions.\n+   * Otherwise will aggregate error messages after all handlers' processing, to the final {@link SchemaAnnotationProcessResult}\n+   *\n+   * @param handlers the handlers that can resolve the annotation on the dataSchema and validate them\n+   * @param dataSchema the dataSchema to be processed\n+   * @param options additional options to help schema annotation processing\n+   * @param skipValidateProcessResult If it is true, skip validate {@link SchemaAnnotationValidationVisitor} .\n+   * @return result after process\n+   */\n+  public static SchemaAnnotationProcessResult process(List<SchemaAnnotationHandler> handlers,\n+      DataSchema dataSchema, AnnotationProcessOption options, boolean skipValidateProcessResult)\n+  {\n+    _skipValidateProcessResult = skipValidateProcessResult;", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODM4Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988386", "bodyText": "Updated based on the recommendation.", "author": "nickibi", "createdAt": "2020-10-12T00:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzIxMQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502777211", "bodyText": "I just realized this wouldn't work if there are multiple handlers. When the first handler is processed, it would remove all pathSpecs from the resolved properties map.", "author": "karthikbalasub", "createdAt": "2020-10-10T10:50:23Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the {@link SchemaAnnotationHandler#checkCompatibility} method.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibility\n+   * Process prevSchema and currSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param prevSchema previous data schema\n+   * @param currSchema current data schema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema prevSchema, DataSchema currSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult prevSchemaResult = processSchemaAnnotation(prevSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult currSchemaResult = processSchemaAnnotation(currSchema, handlers);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> prevResolvedPropertiesMap\n+        = getNodeToResolvedProperties(prevSchemaResult);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> currResolvedPropertiesMap\n+        = getNodeToResolvedProperties(currSchemaResult);\n+\n+    return getCompatibilityResult(prevResolvedPropertiesMap, currResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> prevResolvedPropertiesMap, Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> currResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      if(!handler.implementCheckCompatibility())\n+      {\n+        _log.info(\"There is no implementation of checkCompatibility method in SchemaAnnotationHandler: \"\n+            + handler.getClass().getName());\n+        continue;\n+      }\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> e : prevResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<CompatibilityCheckContext, Map<String, Object>> prevCheckContextAndResolvedProperty = e.getValue();\n+        Map<String, Object> prevResolvedProperties = prevCheckContextAndResolvedProperty.getValue();\n+\n+        if (currResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If previous schema node and current schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to check further.\n+          Pair<CompatibilityCheckContext, Map<String, Object>>\n+              currCheckContextAndResolvedProperty = currResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> currResolvedProperties = currCheckContextAndResolvedProperty.getValue();\n+\n+          // If prevResolvedProperties or currResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check.\n+          if (prevResolvedProperties.containsKey(annotationNamespace) || currResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.checkCompatibility(prevResolvedProperties, currResolvedProperties,\n+                    prevCheckContextAndResolvedProperty.getKey(), currCheckContextAndResolvedProperty.getKey());\n+            results.add(result);\n+          }\n+          currResolvedPropertiesMap.remove(pathSpec);", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODMzOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988338", "bodyText": "Good catch. I updated to use a copyResolvedPropertiesMap for each handler instead.", "author": "nickibi", "createdAt": "2020-10-12T00:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzkwMg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502777902", "bodyText": "Add a test with multiple handlers", "author": "karthikbalasub", "createdAt": "2020-10-10T10:57:50Z", "path": "data/src/test/java/com/linkedin/data/schema/compatibility/TestAnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.TestUtil;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.IdentitySchemaVisitor;\n+import com.linkedin.data.schema.annotation.PegasusSchemaAnnotationHandlerImpl;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaVisitor;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestAnnotationCompatibilityChecker\n+{\n+  private final static String ANNOTATION_NAMESPACE = \"bar\";\n+  private final static String ANNOTATION_FIELD_NAME = \"foo\";\n+\n+  @Test(dataProvider = \"annotationCompatibilityCheckTestData\")\n+  public void testCheckCompatibility(String prevSchemaFile, String currSchemaFile, List<SchemaAnnotationHandler> handlers, List<AnnotationCompatibilityResult> expectedResults)\n+      throws IOException\n+  {\n+    DataSchema prevSchema = TestUtil.dataSchemaFromPdlInputStream(getClass().getResourceAsStream(prevSchemaFile));\n+    DataSchema currSchema = TestUtil.dataSchemaFromPdlInputStream(getClass().getResourceAsStream(currSchemaFile));\n+    List<AnnotationCompatibilityResult> results = AnnotationCompatibilityChecker\n+        .checkPegasusSchemaAnnotation(prevSchema, currSchema, handlers);\n+    Assert.assertEquals(results.size(), expectedResults.size());\n+    for (int i = 0; i < results.size(); i++)\n+    {\n+      Assert.assertEquals(results.get(i).getMessages().size(), expectedResults.get(i).getMessages().size());\n+      List<CompatibilityMessage> actualCompatibilityMessage = (List<CompatibilityMessage>) results.get(i).getMessages();\n+      List<CompatibilityMessage> expectCompatibilityMessage = (List<CompatibilityMessage>) expectedResults.get(i).getMessages();\n+      for (int j = 0; j < actualCompatibilityMessage.size(); j++)\n+      {\n+        Assert.assertEquals(actualCompatibilityMessage.get(j).toString(), expectCompatibilityMessage.get(j).toString());\n+      }\n+    }\n+  }\n+\n+  @DataProvider\n+  private Object[][] annotationCompatibilityCheckTestData() throws IOException {\n+    // Set up expected result: both previous schema and current schema contain the same PathSpecs.\n+    CompatibilityCheckContext checkContext = generateAnnotationCheckContext(new PathSpec(\"TestSchema1/field1\"));\n+    CompatibilityCheckContext checkContext1 = generateAnnotationCheckContext(new PathSpec(\"TestSchema1/field2\"));\n+\n+    AnnotationCompatibilityResult expectResultWithCompatibleChange1 = generateExpectResult(new CompatibilityMessage(checkContext.getPathSpecToSchema(),\n+      CompatibilityMessage.Impact.ANNOTATION_COMPATIBLE_CHANGE,\n+        \"Updating annotation field \\\"%s\\\" value is backward compatible change\", ANNOTATION_FIELD_NAME));\n+    AnnotationCompatibilityResult expectResultWithInCompatibleChange1 = generateExpectResult(new CompatibilityMessage(checkContext1.getPathSpecToSchema(),\n+        CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+        \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+\n+    // Set up expected result: only previous schema contains the resolvedProperty with the same annotation namespace as SchemaAnnotationHandler\n+    CompatibilityCheckContext checkContext2 = generateAnnotationCheckContext(new PathSpec(\"TestSchema2/field1\"));\n+\n+    AnnotationCompatibilityResult expectResult2 = generateExpectResult(new CompatibilityMessage(checkContext2.getPathSpecToSchema(),\n+      CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+        \"Adding new annotation \\\"%s\\\" is backward compatible change\", ANNOTATION_NAMESPACE));\n+\n+    // Set up expected result: only current schema contains the resolvedProperty with the same annotation namespace as SchemaAnnotationHandler\n+    CompatibilityCheckContext checkContext3 = generateAnnotationCheckContext(new PathSpec(\"TestSchema3/field1\"));\n+    AnnotationCompatibilityResult expectResult3 = generateExpectResult(new CompatibilityMessage(checkContext3.getPathSpecToSchema(),\n+        CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+\n+    return new Object[][]\n+        {\n+            {\n+                \"previousSchema/TestSchema1.pdl\",\n+                \"currentSchema/TestSchema1.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Arrays.asList(expectResultWithCompatibleChange1, expectResultWithInCompatibleChange1)\n+            },\n+            {\n+                \"previousSchema/TestSchema2.pdl\",\n+                \"currentSchema/TestSchema2.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Collections.singletonList(expectResult2)\n+            },\n+            {\n+                \"previousSchema/TestSchema3.pdl\",\n+                \"currentSchema/TestSchema3.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Collections.singletonList(expectResult3)\n+            }\n+        };\n+  }\n+\n+  private List<SchemaAnnotationHandler> generateSchemaAnnotationHandlers()\n+  {\n+    SchemaAnnotationHandler testHandler = new PegasusSchemaAnnotationHandlerImpl(ANNOTATION_NAMESPACE)\n+    {\n+      @Override\n+      public String getAnnotationNamespace()\n+      {\n+        return ANNOTATION_NAMESPACE;\n+      }\n+\n+      @Override\n+      public boolean implementCheckCompatibility()\n+      {\n+        return true;\n+      }\n+\n+      @Override\n+      public SchemaVisitor getVisitor()\n+      {\n+        return new IdentitySchemaVisitor();\n+      }\n+\n+      @Override\n+      public AnnotationCompatibilityResult checkCompatibility(Map<String,Object> prevResolvedProperties, Map<String, Object> currResolvedProperties,\n+          CompatibilityCheckContext prevContext, CompatibilityCheckContext currContext)\n+      {\n+        AnnotationCompatibilityResult result = new AnnotationCompatibilityResult();\n+\n+        if (prevResolvedProperties.get(ANNOTATION_NAMESPACE) == null)\n+        {\n+          if (prevContext.getPathSpecToSchema() != null)\n+          {\n+            result.getMessages().add(new CompatibilityMessage(currContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Adding new annotation \\\"%s\\\" is backward compatible change\", ANNOTATION_NAMESPACE));\n+          }\n+        }\n+        else if (currResolvedProperties.get(ANNOTATION_NAMESPACE) == null)\n+        {\n+          if (currContext.getPathSpecToSchema() != null)\n+          {\n+            result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+          }\n+        }\n+        else\n+        {\n+          DataMap prev = (DataMap) prevResolvedProperties.get(ANNOTATION_NAMESPACE);\n+          DataMap curr = (DataMap) currResolvedProperties.get(ANNOTATION_NAMESPACE);\n+          if (prev.containsKey(ANNOTATION_FIELD_NAME) && !curr.containsKey(ANNOTATION_FIELD_NAME))\n+          {\n+            result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"remove annotation field \\\"%s\\\" is backward incompatible change\", ANNOTATION_FIELD_NAME));\n+          }\n+          if (prev.containsKey(ANNOTATION_FIELD_NAME) && curr.containsKey(ANNOTATION_FIELD_NAME))\n+          {\n+            if (prev.get(ANNOTATION_FIELD_NAME) != curr.get(ANNOTATION_FIELD_NAME))\n+            {\n+              result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                  CompatibilityMessage.Impact.ANNOTATION_COMPATIBLE_CHANGE, \"Updating annotation field \\\"%s\\\" value is backward compatible change\", ANNOTATION_FIELD_NAME));\n+            }\n+          }\n+        }\n+        return result;\n+      }\n+    };\n+    return Collections.singletonList(testHandler);", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODQyOQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988429", "bodyText": "Added a test with multiple handlers.", "author": "nickibi", "createdAt": "2020-10-12T00:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3ODA1MQ==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502778051", "bodyText": "Document the values to expect for different scenarios:\nField present, annotation deleted.\nField deleted\nField present, annotations added\nField added.", "author": "karthikbalasub", "createdAt": "2020-10-10T10:59:55Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementCheckCompatibility()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param prevResolvedProperties the older resolvedProperties\n+   * @param currResolvedProperties the newer resolvedProperties\n+   * @param prevContext the older annotationCheck context\n+   * @param currContext the newer annotationCheck context", "originalCommit": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODM5OA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502988398", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-10-12T00:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3ODA1MQ=="}], "type": "inlineReview"}, {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "url": "https://github.com/linkedin/rest.li/commit/a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-12T00:31:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA1NzQzNg==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503057436", "bodyText": "Also add a note to override implementsCheckCompatibility to return true.", "author": "karthikbalasub", "createdAt": "2020-10-12T06:08:56Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,121 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implements the checkCompatibility method.\n+   * @return false by default. Subclasses should override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementsCheckCompatibility()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Check annotations changes are compatible or not", "originalCommit": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1Mzc5Mw==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503453793", "bodyText": "Updated doc.", "author": "nickibi", "createdAt": "2020-10-12T18:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA1NzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5MjYyOA==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503092628", "bodyText": "This might be a problem for large schemas. Did you consider reversing the loops?\nremove handlers that don't implement compatibility\n\nforeach entry in prevResolvedProperties:\n  foreach hander:\n     check(entry)\n     remove path from currProperties\nforeach entry in currProperties\n   foreach handler:\n      check(entry)", "author": "karthikbalasub", "createdAt": "2020-10-12T07:33:16Z", "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the {@link SchemaAnnotationHandler#checkCompatibility} method.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibility\n+   * Process prevSchema and currSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param prevSchema previous data schema\n+   * @param currSchema current data schema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema prevSchema, DataSchema currSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult prevSchemaResult = processSchemaAnnotation(prevSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult currSchemaResult = processSchemaAnnotation(currSchema, handlers);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> prevResolvedPropertiesMap\n+        = getNodeToResolvedProperties(prevSchemaResult);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> currResolvedPropertiesMap\n+        = getNodeToResolvedProperties(currSchemaResult);\n+\n+    return getCompatibilityResult(prevResolvedPropertiesMap, currResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   */\n+  private static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> prevResolvedPropertiesMap, Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> currResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      if (!handler.implementsCheckCompatibility())\n+      {\n+        _log.info(\"There is no implementation of checkCompatibility method in SchemaAnnotationHandler: \"\n+            + handler.getClass().getName());\n+        continue;\n+      }\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      Map<PathSpec, Pair<CompatibilityCheckContext,\n+          Map<String, Object>>> copyOfCurrResolvedPropertiesMap = new HashMap<>(currResolvedPropertiesMap);", "originalCommit": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1NDA2Ng==", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503454066", "bodyText": "Refactored this part based on the recommendation.", "author": "nickibi", "createdAt": "2020-10-12T18:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5MjYyOA=="}], "type": "inlineReview"}, {"oid": "adca844268dc749b46c6df5836d0ce60b19f6fe4", "url": "https://github.com/linkedin/rest.li/commit/adca844268dc749b46c6df5836d0ce60b19f6fe4", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-12T18:03:22Z", "type": "forcePushed"}, {"oid": "c80fbca209b17c600412ad9bbe6b45a45cd53145", "url": "https://github.com/linkedin/rest.li/commit/c80fbca209b17c600412ad9bbe6b45a45cd53145", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-12T19:43:22Z", "type": "commit"}, {"oid": "c80fbca209b17c600412ad9bbe6b45a45cd53145", "url": "https://github.com/linkedin/rest.li/commit/c80fbca209b17c600412ad9bbe6b45a45cd53145", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided.", "committedDate": "2020-10-12T19:43:22Z", "type": "forcePushed"}]}