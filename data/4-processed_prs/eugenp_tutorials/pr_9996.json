{"pr_number": 9996, "pr_title": "BAEL-4558: Article for stopping execution after a certain time", "pr_createdAt": "2020-09-09T19:00:13Z", "pr_url": "https://github.com/eugenp/tutorials/pull/9996", "timeline": [{"oid": "444471a6a6b84727f2d88e133a1070acd674e603", "url": "https://github.com/eugenp/tutorials/commit/444471a6a6b84727f2d88e133a1070acd674e603", "message": "BAEL-4558: Article for stopping execution after a certain time", "committedDate": "2020-09-09T18:54:37Z", "type": "commit"}, {"oid": "69261078941d7e947638e85f91d8e96b4495d858", "url": "https://github.com/eugenp/tutorials/commit/69261078941d7e947638e85f91d8e96b4495d858", "message": "BAEL-4558: Article for stopping execution after a certain time", "committedDate": "2020-09-09T18:59:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk1Nw==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702957", "bodyText": "remove the extra blank line", "author": "KevinGilmore", "createdAt": "2020-09-20T15:35:47Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMjk4MQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491702981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testUsingLoop(){\n          \n          \n            \n                public void testUsingLoop() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:36:08Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA2MA==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703060", "bodyText": "opening brace should be at the end of a line, not on a line by itself", "author": "KevinGilmore", "createdAt": "2020-09-20T15:36:58Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA4OQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703089", "bodyText": "need a blank line between methods", "author": "KevinGilmore", "createdAt": "2020-09-20T15:37:24Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzA5Mw==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void testExecutor(){\n          \n          \n            \n                public static void testExecutor() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:37:33Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzMw==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703133", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testExecutor2(){\n          \n          \n            \n                public void testExecutor2() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:37:51Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzEzNw==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703137", "bodyText": "reduce to one blank line", "author": "KevinGilmore", "createdAt": "2020-09-20T15:38:04Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE0Ng==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testScheduledExecutor(){\n          \n          \n            \n                public void testScheduledExecutor() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:38:14Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE2MA==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testThreadAndInterrupt(){\n          \n          \n            \n                public void testThreadAndInterrupt() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:38:26Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzE5MQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testTimer(){\n          \n          \n            \n                public void testTimer() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:38:47Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzIwMg==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703202", "bodyText": "one blank line", "author": "KevinGilmore", "createdAt": "2020-09-20T15:38:58Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzI2NQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703265", "bodyText": "separate methods with a blank line", "author": "KevinGilmore", "createdAt": "2020-09-20T15:39:44Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMyMQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703321", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class LongRunningTask implements Runnable{\n          \n          \n            \n                class LongRunningTask implements Runnable {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:40:04Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzMzNQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningOperation(){\n          \n          \n            \n                    private void longRunningOperation() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:40:13Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM1Nw==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        catch (InterruptedException e){\n          \n          \n            \n                        catch (InterruptedException e) {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:40:26Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzM3Ng==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longRunningSort(){\n          \n          \n            \n                    private void longRunningSort() {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:40:36Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQxNA==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }catch (InterruptedException e){\n          \n          \n            \n                        }catch (InterruptedException e) {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:41:09Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQyNQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void longFileRead() throws InterruptedException{\n          \n          \n            \n                    private void longFileRead() throws InterruptedException {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:41:18Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcwMzQzNQ==", "url": "https://github.com/eugenp/tutorials/pull/9996#discussion_r491703435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException{\n          \n          \n            \n                    private void throwExceptionOnThreadInterrupt() throws InterruptedException {", "author": "KevinGilmore", "createdAt": "2020-09-20T15:41:27Z", "path": "core-java-modules/core-java-concurrency-basic-2/src/main/java/com/baeldung/concurrent/stopexecution/StopExecution.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package com.baeldung.concurrent.stopexecution;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class StopExecution {\n+    private static final Logger LOG = LoggerFactory.getLogger(StopExecution.class);\n+\n+    public static void main(String[] args) {\n+        StopExecution stopExecution = new StopExecution();\n+        //stopExecution.testUsingLoop();\n+        //stopExecution.testTimer();\n+        stopExecution.testScheduledExecutor();\n+        LOG.info(\"done\");\n+    }\n+\n+\n+    public void testUsingLoop(){\n+        long start = System.currentTimeMillis();\n+        long end = start + 5000;\n+        List<String> items = new ArrayList<>();\n+        int counter = 0;\n+\n+        // Let this loop run only upto 5 seconds\n+        while (System.currentTimeMillis() < end && counter < items.size())\n+        {\n+            // Fetch the item from the list.\n+            // Some expensive operation on the item.\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    public static void testThreads(){\n+        Thread thread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                LOG.info(\"inside run\");\n+\n+                try {\n+                    Thread.sleep(10000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                LOG.info(\"exit run\");\n+            }\n+        });\n+        thread.start();\n+        while (thread.getState() != Thread.State.TERMINATED){\n+            LOG.info(thread.getState().name());\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+    public static void testExecutor(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future<String> f = null;\n+        try {\n+             f = service.submit(() -> {\n+                // Do you long running calculation here\n+                try {\n+                    Thread.sleep(2737); // Simulate some delay\n+                }\n+                catch (InterruptedException e){\n+                    LOG.info(\"Interrupted\");\n+                    return \"interrupted\";\n+                }\n+                LOG.info(\"Sleep finished\");\n+                return \"42\";\n+            });\n+\n+            LOG.info(f.get(2, TimeUnit.SECONDS));\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdown();\n+        }\n+    }\n+\n+\n+    public void testExecutor2(){\n+        final ExecutorService service = Executors.newSingleThreadExecutor();\n+        Future f = null;\n+        try {\n+            f = service.submit(new LongRunningTask());\n+            LOG.info(\"testExecutor2\");\n+            f.get(1, TimeUnit.SECONDS);\n+        } catch (final TimeoutException e) {\n+            f.cancel(true);\n+            LOG.error(\"Calculation took to long\");\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            service.shutdownNow();\n+        }\n+    }\n+\n+    public void testScheduledExecutor(){\n+        LOG.info(\"testScheduledExecutor\");\n+        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n+        Future future = executor.submit(new LongRunningTask());\n+        executor.schedule(new Runnable(){\n+            public void run(){\n+                future.cancel(true);\n+            }\n+        }, 1000, TimeUnit.MILLISECONDS);\n+        executor.shutdown();\n+    }\n+    public void testThreadAndInterrupt(){\n+\n+        Thread t;\n+        try {\n+             t = new Thread(new LongRunningTask());\n+\n+            LOG.info(\"testExecutor3\");\n+            long end = System.currentTimeMillis() + 2000;\n+            t.start();\n+            while (t.isAlive() && System.currentTimeMillis() < end){\n+                Thread.sleep(50);\n+            }\n+            t.interrupt();\n+        } catch (final Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public void testTimer(){\n+        LOG.info(\"Timer test\");\n+        Thread t = new Thread(new LongRunningTask());\n+        Timer timeoutTimer = new Timer();\n+        timeoutTimer.schedule(new TimeOutTask(t, timeoutTimer), 1000);\n+        t.start();\n+    }\n+\n+    class MyRunnableTask implements Runnable{\n+        public void run()\n+        {\n+            try\n+            {\n+                LOG.info(\"MyRunnable...\");\n+                Thread.sleep(10000);\n+            }\n+            catch (InterruptedException ie)\n+            {\n+                LOG.info(\"MyRunnable interrupted...\");\n+            }\n+        }\n+    }\n+\n+\n+    class TimeOutTask extends TimerTask {\n+        private Thread t;\n+        private Timer timer;\n+\n+        TimeOutTask(Thread t, Timer timer){\n+            this.t = t;\n+            this.timer = timer;\n+        }\n+        public void run() {\n+            if (t != null && t.isAlive()) {\n+                t.interrupt();\n+                timer.cancel();\n+            }\n+        }\n+    }\n+\n+    class LongRunningTask implements Runnable{\n+        @Override\n+        public void run() {\n+            longRunningSort();\n+        }\n+\n+        private void longRunningOperation(){\n+            LOG.info(\"long Running operation started\");\n+\n+            try {\n+                //Thread.sleep(500);\n+                longFileRead();\n+                LOG.info(\"long running operation finished\");\n+            }\n+            catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longRunningSort(){\n+            LOG.info(\"long Running task started\");\n+            // Do you long running calculation here\n+            int len = 100000;\n+            List<Integer> numbers = new ArrayList<>();\n+            try {\n+                for (int i = len; i > 0; i--) {\n+                    //Thread.sleep(5)\n+                    numbers.add(i);\n+                }\n+\n+                int i = 0;\n+                for (i = 0; i < len; i++) {\n+                    int minIndex = i;\n+                    for (int j = i + 1; j < len; j++) {\n+                        if (numbers.get(minIndex) > numbers.get(j))\n+                            minIndex = j;\n+                    }\n+                    if (minIndex != i) {\n+                        int temp = numbers.get(i);\n+                        numbers.set(i, numbers.get(minIndex));\n+                        numbers.set(minIndex, temp);\n+                    }\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+                LOG.info(\"Index position: \" + i);\n+                LOG.info(\"Long running task finished\");\n+            }catch (InterruptedException e){\n+                LOG.info(\"long Running operation interrupted\");\n+            }\n+        }\n+\n+        private void longFileRead() throws InterruptedException{\n+            String file = \"input.txt\";\n+            ClassLoader classloader = getClass().getClassLoader();\n+\n+            try (InputStream inputStream = classloader.getResourceAsStream(file)){\n+                Reader inputStreamReader = new InputStreamReader(inputStream);\n+\n+                int data = inputStreamReader.read();\n+                while (data != -1) {\n+                    char theChar = (char) data;\n+                    data = inputStreamReader.read();\n+                    throwExceptionOnThreadInterrupt();\n+                }\n+            } catch (IOException e){\n+                LOG.error(\"Exception: \", e);\n+            }\n+        }\n+        private void throwExceptionOnThreadInterrupt() throws InterruptedException{", "originalCommit": "69261078941d7e947638e85f91d8e96b4495d858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "475f156bc2916ccf513dae8965434adc83c5c5b2", "url": "https://github.com/eugenp/tutorials/commit/475f156bc2916ccf513dae8965434adc83c5c5b2", "message": "Applied formatter", "committedDate": "2020-09-22T16:48:17Z", "type": "commit"}]}