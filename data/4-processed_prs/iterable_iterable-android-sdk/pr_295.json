{"pr_number": 295, "pr_title": "[MOB-2372][1] Refactor network requests and task storage", "pr_createdAt": "2020-12-12T05:53:39Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/295", "timeline": [{"oid": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "url": "https://github.com/Iterable/iterable-android-sdk/commit/716ae687c2fb0aa5849e36c3603dd4a0313493e4", "message": "Move column constants from IterableTask to IterableTaskManager\n\nMaking IterableTask a POJO, and all db knowledge lies in IterableTaskManager", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "url": "https://github.com/Iterable/iterable-android-sdk/commit/343f3a4e8084dbae369fa0b95a3aa08450e7f643", "message": "Add nextTask query", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "afb187868a57f3f65b67ea7c11acc87ebd4e821c", "url": "https://github.com/Iterable/iterable-android-sdk/commit/afb187868a57f3f65b67ea7c11acc87ebd4e821c", "message": "Rename IterableTaskManager to IterableTaskStorage", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "e4f693da77689c966cdb53442a5c6be554fe5664", "url": "https://github.com/Iterable/iterable-android-sdk/commit/e4f693da77689c966cdb53442a5c6be554fe5664", "message": "Refactor IterableRequest: create IterableApiResponse to hold responses", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "c68bb1ead1f263152929d96f24197d9339289558", "url": "https://github.com/Iterable/iterable-android-sdk/commit/c68bb1ead1f263152929d96f24197d9339289558", "message": "IterableRequest: move out JWT and retry determination to onPostExecute", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "a2bcef3c3da1786836e4a2de5a6ef3641c4f7298", "url": "https://github.com/Iterable/iterable-android-sdk/commit/a2bcef3c3da1786836e4a2de5a6ef3641c4f7298", "message": "IterableRequest: Extract request handling into static methods", "committedDate": "2020-12-12T06:02:59Z", "type": "commit"}, {"oid": "6b99a9a36ad2ad310eeb431aec1b660a636491ee", "url": "https://github.com/Iterable/iterable-android-sdk/commit/6b99a9a36ad2ad310eeb431aec1b660a636491ee", "message": "Rename IterableRequest -> IterableRequestTask", "committedDate": "2020-12-12T06:02:59Z", "type": "forcePushed"}, {"oid": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "url": "https://github.com/Iterable/iterable-android-sdk/commit/458607a1f40f7fd9c10413f3e8e6964e0047d506", "message": "Rename IterableRequest -> IterableRequestTask", "committedDate": "2020-12-12T06:11:16Z", "type": "commit"}, {"oid": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "url": "https://github.com/Iterable/iterable-android-sdk/commit/458607a1f40f7fd9c10413f3e8e6964e0047d506", "message": "Rename IterableRequest -> IterableRequestTask", "committedDate": "2020-12-12T06:11:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MzY4Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541973686", "bodyText": "Hmm not sure if there will be any behavorial change from moving this from doInBackground to onPostExecute", "author": "Ayyanchira", "createdAt": "2020-12-13T18:01:55Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequestTask.java", "diffHunk": "@@ -264,23 +262,27 @@ protected void onPostExecute(String s) {\n             handler.postDelayed(new Runnable() {\n                 @Override\n                 public void run() {\n-                    request.execute(iterableApiRequest);\n+                    requestTask.execute(iterableApiRequest);\n                 }\n             }, delay);\n             return;\n-        } else if (success) {\n+        } else if (response.success) {\n+            IterableApi.getInstance().getAuthManager().resetFailedAuth();\n             if (iterableApiRequest.successCallback != null) {\n-                iterableApiRequest.successCallback.onSuccess(requestResultJson);\n+                iterableApiRequest.successCallback.onSuccess(response.responseJson);\n             }\n         } else {\n+            if (matchesErrorCode(response.responseJson, ERROR_CODE_INVALID_JWT_PAYLOAD)) {\n+                IterableApi.getInstance().getAuthManager().requestNewAuthToken(true);\n+            }", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4MTM0MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542081341", "bodyText": "The only functional difference I can think of is that requestNewAuthToken will be called on the main thread now. It does call the handler on a background anyway, so it shouldn't matter.\nThe intent of this change is to separate pure network calls from other logic. The method that makes the request is already long and complicated on its own, and I wanted to extract that logic to use in an offline mode processor, without using the async code provided by IterableRequestTask.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MzY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NTMxNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541975317", "bodyText": "On the first glance, I felt nextTask should have been relative to some task. Or we can document that it returns a task from the top of the taskStorage table.\nI felt,\nnextTask implies that the task it returns is next to something. But it actually is the first task. It assumes that the previous ones should be deleted. May be it could be nextTaskTo(Task task1) which could delete the existing task and then pass the next one as Next Task.\nEither the next task should delete the current one in context and then pass the top one. Or the name should be something different. Like GetOldestTask, GetFirstTask, GetTask. Or we can just change the description of method on top.", "author": "Ayyanchira", "createdAt": "2020-12-13T18:11:28Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java", "diffHunk": "@@ -202,11 +228,28 @@ IterableTask getTask(String id) {\n         return taskIds;\n     }\n \n+    /**\n+     * Returns the next scheduled task for processing\n+     * @return next scheduled {@link IterableTask}\n+     */\n+    @Nullable\n+    IterableTask nextTask() {\n+        Cursor cursor = database.rawQuery(\"select * from OfflineTask order by scheduled limit 1\", null);\n+        IterableTask task = null;\n+        if (cursor.moveToFirst()) {\n+            task = createTaskFromCursor(cursor);\n+        }\n+        cursor.close();\n+        return task;\n+    }", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4MjkxOQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542082919", "bodyText": "I was mirroring iOS naming scheme in this case. nextTask in this case means 'next task to be processed', not adjacent or being in some kind of proximity. How exactly it is determined which task should be processed next should ideally be contained in a single class, in this case IterableTaskStorage.\nSince tasks are not physically located within any kind of space, I think nextTaskTo is even less clear.\nI can think of 2 solutions:\n\nAdd description to this method\nCall it getNextScheduledTask() or something similar. nextTask is not very descriptive, I agree.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0Njk0OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542146948", "bodyText": "Adding description should be good \ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-12-14T06:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA0MzMxMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r543043311", "bodyText": "Hm, wait, it already has a description.", "author": "vbabenkoru", "createdAt": "2020-12-15T04:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA0NDExOA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r543044118", "bodyText": "Renamed to getNextScheduledTask.", "author": "vbabenkoru", "createdAt": "2020-12-15T04:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NjQ1NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541976454", "bodyText": "I think the best place to deleteTask will be when we get task completion callback. This will also mean that when we ask for nextTask, we might still get the top one which is not deleted yet. Hence the point of nextTask being relative to another/existing task.\nWe can totally defer this for next version if applicable as there is no retries to be done in initial version.", "author": "Ayyanchira", "createdAt": "2020-12-13T18:17:53Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/OfflineRequestProcessor.java", "diffHunk": "@@ -52,13 +52,13 @@ void scheduleTask(IterableApiRequest request, @Nullable IterableHelper.SuccessHa\n \n     //Temporary function to convert database offline task to ITerableReuqest and execute.\n     void processTasks() {\n-        IterableTaskManager taskManager = IterableTaskManager.sharedInstance(IterableApi.getInstance().getMainActivityContext());\n-        ArrayList<String> taskIds = taskManager.getAllTaskIds();\n+        IterableTaskStorage taskStorage = IterableTaskStorage.sharedInstance(IterableApi.getInstance().getMainActivityContext());\n+        ArrayList<String> taskIds = taskStorage.getAllTaskIds();\n         for (String id : taskIds) {\n             try {\n-                IterableApiRequest request = makeRequestFromTask(taskManager.getTask(id));\n-                new IterableRequest().execute(request);\n-                taskManager.deleteTask(id);\n+                IterableApiRequest request = makeRequestFromTask(taskStorage.getTask(id));\n+                new IterableRequestTask().execute(request);\n+                taskStorage.deleteTask(id);", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4MzI1Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542083257", "bodyText": "Yeah, this is addressed in follow-up PRs.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NjQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NzYyMA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541977620", "bodyText": "Not sure but it's safe to have this function static right?\nWhat happens when multiple requests are fired together? How does the static method behaves in that scenario? Does a static function wait for other tasks to execute?\nWill look it up though... \ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-12-13T18:24:52Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequestTask.java", "diffHunk": "@@ -175,58 +176,64 @@ protected String doInBackground(IterableApiRequest... params) {\n                         errorMessage = jsonResponse.getString(\"msg\");\n                     } else if (responseCode >= 500) {\n                         errorMessage = \"Internal Server Error\";\n-                        retryRequest = true;\n                     }\n \n-                    handleFailure(errorMessage, jsonResponse);\n+                    apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, errorMessage);\n                 } else if (responseCode == 200) {\n                     if (error == null && requestResult.length() > 0) {\n                         if (jsonError != null) {\n-                            handleFailure(\"Could not parse json: \" + jsonError, null);\n+                            apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, \"Could not parse json: \" + jsonError);\n                         } else if (jsonResponse != null) {\n-                            IterableApi.getInstance().getAuthManager().resetFailedAuth();\n-                            handleSuccess(jsonResponse);\n+                            apiResponse = IterableApiResponse.success(responseCode, requestResult, jsonResponse);\n                         } else {\n-                            handleFailure(\"Response is not a JSON object\", jsonResponse);\n+                            apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, \"Response is not a JSON object\");\n                         }\n                     } else if (error == null && requestResult.length() == 0) {\n-                        handleFailure(\"No data received\", jsonResponse);\n+                        apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, \"No data received\");\n                     } else if (error != null) {\n-                        handleFailure(error, null);\n+                        apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, error);\n                     }\n                 } else {\n-                    handleFailure(\"Received non-200 response: \" + responseCode, jsonResponse);\n+                    apiResponse = IterableApiResponse.failure(responseCode, requestResult, jsonResponse, \"Received non-200 response: \" + responseCode);\n                 }\n             } catch (JSONException e) {\n-                logError(baseUrl, e);\n-                handleFailure(e.getMessage(), null);\n+                logError(iterableApiRequest, baseUrl, e);\n+                apiResponse = IterableApiResponse.failure(0, requestResult, null, e.getMessage());\n             } catch (IOException e) {\n-                logError(baseUrl, e);\n-                handleFailure(e.getMessage(), null);\n+                logError(iterableApiRequest, baseUrl, e);\n+                apiResponse = IterableApiResponse.failure(0, requestResult, null, e.getMessage());\n             } catch (ArrayIndexOutOfBoundsException e) {\n                 // This exception is sometimes thrown from the inside of HttpUrlConnection/OkHttp\n-                logError(baseUrl, e);\n-                handleFailure(e.getMessage(), null);\n+                logError(iterableApiRequest, baseUrl, e);\n+                apiResponse = IterableApiResponse.failure(0, requestResult, null, e.getMessage());\n             } catch (Exception e) {\n-                logError(baseUrl, e);\n-                handleFailure(e.getMessage(), null);\n+                logError(iterableApiRequest, baseUrl, e);\n+                apiResponse = IterableApiResponse.failure(0, requestResult, null, e.getMessage());\n             } finally {\n                 if (urlConnection != null) {\n                     urlConnection.disconnect();\n                 }\n             }\n             IterableLogger.v(TAG, \"======================================\");\n         }\n-        return requestResult;\n+        return apiResponse;\n     }\n \n-    private void logError(String baseUrl, Exception e) {\n+    private static boolean matchesErrorCode(JSONObject jsonResponse, String errorCode) {\n+        try {\n+            return jsonResponse != null && jsonResponse.has(\"code\") && jsonResponse.getString(\"code\").equals(errorCode);\n+        } catch (JSONException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void logError(IterableApiRequest iterableApiRequest, String baseUrl, Exception e) {\n         IterableLogger.e(TAG, \"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\" +\n                 \"Exception occurred for : \" + baseUrl + iterableApiRequest.resourcePath);\n         IterableLogger.e(TAG, e.getMessage(), e);\n     }\n \n-    private String buildHeaderString(HttpURLConnection urlConnection) {\n+    private static String buildHeaderString(HttpURLConnection urlConnection) {", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4MzQ4MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542083480", "bodyText": "As long as the function doesn't use any global shared state or modify shared objects, it should be fine. I think this method doesn't use any global variables, and HttpURLConnection passed to it is specific to a single request and is expected to be modified.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NzYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4NTI3OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r542085279", "bodyText": "Basically I wanted to extract all pure networking code from async handling and callbacks here. I guess Ideally it should be extracted to a separate class, but I kept it here for now.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NzYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3Nzc0OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541977749", "bodyText": "\ud83d\udc4c", "author": "Ayyanchira", "createdAt": "2020-12-13T18:25:36Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequestTask.java", "diffHunk": "@@ -368,3 +370,27 @@ static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper\n         return null;\n     }\n }\n+\n+class IterableApiResponse {", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3NzgxNQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/295#discussion_r541977815", "bodyText": "\ud83d\udc4c", "author": "Ayyanchira", "createdAt": "2020-12-13T18:26:12Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java", "diffHunk": "@@ -119,76 +139,82 @@ IterableTask getTask(String id) {\n         if (!isDatabaseReady()) {\n             return null;\n         }\n+        Cursor cursor = database.rawQuery(QUERY_GET_TASK_BY_ID, new String[]{id});\n \n-        String name = null;\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+\n+        IterableTask task = createTaskFromCursor(cursor);\n+\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        cursor.close();\n+        return task;\n+    }\n+\n+    private IterableTask createTaskFromCursor(Cursor cursor) {", "originalCommit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ee88a34335c6981c0d98325421b1f91c966ce53", "url": "https://github.com/Iterable/iterable-android-sdk/commit/5ee88a34335c6981c0d98325421b1f91c966ce53", "message": "Rename nextTask -> getNextScheduledTask", "committedDate": "2020-12-15T04:49:05Z", "type": "commit"}]}