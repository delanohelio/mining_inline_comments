{"pr_number": 296, "pr_title": "[MOB-2372][2] Implement IterableTaskRunner", "pr_createdAt": "2020-12-12T21:35:29Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/296", "timeline": [{"oid": "ab338c3e6b490c103e1d66a88d9df07758809f3e", "url": "https://github.com/Iterable/iterable-android-sdk/commit/ab338c3e6b490c103e1d66a88d9df07758809f3e", "message": "Implement lazy instantiation for RequestProcessor", "committedDate": "2020-12-12T21:47:13Z", "type": "forcePushed"}, {"oid": "003bf4ebf3a62749d5efac801b31366c1edb2532", "url": "https://github.com/Iterable/iterable-android-sdk/commit/003bf4ebf3a62749d5efac801b31366c1edb2532", "message": "Add tests for IterableTaskRunner and TaskScheduler", "committedDate": "2020-12-13T03:54:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3ODc2Mg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r541978762", "bodyText": "Yeah.. this is the delete I was initially talking about.\nShould the delete operation happen here? Or should we move it to taskCompletion handler?", "author": "Ayyanchira", "createdAt": "2020-12-13T18:31:24Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {\n+            boolean proceed = processNextTask();\n+            if (!proceed) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @WorkerThread\n+    private boolean processNextTask() {\n+        IterableTask task = taskStorage.nextTask();\n+\n+        if (task == null) {\n+            return false;\n+        }\n+\n+        if (task.taskType == IterableTaskType.API) {\n+            try {\n+                IterableApiRequest request = IterableApiRequest.fromJSON(new JSONObject(task.data), null, null);\n+                IterableApiResponse response = IterableRequestTask.executeApiRequest(request);\n+            } catch (Exception e) {\n+                IterableLogger.e(TAG, \"Error while processing request task\", e);\n+            }\n+            taskStorage.deleteTask(task.id);", "originalCommit": "003bf4ebf3a62749d5efac801b31366c1edb2532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA4NDIwNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r542084207", "bodyText": "Since the Runner is getting the next task immediately afterwards, if we move deletion farther away from it, it'd be heavily dependent on behavior of another class (if we remove or break deleteTask in another class, it'll make IterableTaskRunner get stuck in an infinite loop). I think it makes sense to have deletion here for now, unless we decide to add some more complicated conditional logic.", "author": "vbabenkoru", "createdAt": "2020-12-14T03:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3ODc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3OTA0Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r541979046", "bodyText": "\ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-12-13T18:32:48Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/OfflineRequestProcessor.java", "diffHunk": "@@ -1,38 +1,50 @@\n package com.iterable.iterableapi;\n \n+import android.content.Context;\n+\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n \n import org.json.JSONException;\n import org.json.JSONObject;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n \n class OfflineRequestProcessor implements RequestProcessor {\n+    private TaskScheduler taskScheduler;\n+    private IterableTaskRunner taskRunner;\n \n+    OfflineRequestProcessor(Context context) {\n+        IterableTaskStorage taskStorage = IterableTaskStorage.sharedInstance(context);\n+        taskScheduler = new TaskScheduler(taskStorage);\n+        taskRunner = new IterableTaskRunner(taskStorage, IterableActivityMonitor.getInstance());\n+    }\n \n     @Override\n     public void processGetRequest(@Nullable String apiKey, @NonNull String resourcePath, @NonNull JSONObject json, String authToken, @Nullable IterableHelper.IterableActionHandler onCallback) {\n-        //Invoke taskScheduler and add task to database\n+        // Call GET requests directly, without using the queue\n+        IterableApiRequest request = new IterableApiRequest(apiKey, resourcePath, json, IterableApiRequest.GET, authToken, onCallback);\n+        new IterableRequestTask().execute(request);", "originalCommit": "003bf4ebf3a62749d5efac801b31366c1edb2532", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f66eba7583582c21b7b230ba3e213bbacc49ad37", "url": "https://github.com/Iterable/iterable-android-sdk/commit/f66eba7583582c21b7b230ba3e213bbacc49ad37", "message": "Inject dependencies into TaskScheduler", "committedDate": "2020-12-15T04:50:32Z", "type": "commit"}, {"oid": "303b430224285664cd98cfb75050ade172fb3892", "url": "https://github.com/Iterable/iterable-android-sdk/commit/303b430224285664cd98cfb75050ade172fb3892", "message": "Add TaskCreatedListener to subscribe to new tasks", "committedDate": "2020-12-15T04:50:32Z", "type": "commit"}, {"oid": "d55698a7c5d4c2d84bfaffcd7f67d1a40d3eecca", "url": "https://github.com/Iterable/iterable-android-sdk/commit/d55698a7c5d4c2d84bfaffcd7f67d1a40d3eecca", "message": "Execute GET requests directly, without using the queue", "committedDate": "2020-12-15T04:50:32Z", "type": "commit"}, {"oid": "c753dc0e57702993391d09ef16c21aa4c16bcb76", "url": "https://github.com/Iterable/iterable-android-sdk/commit/c753dc0e57702993391d09ef16c21aa4c16bcb76", "message": "Implement IterableTaskRunner\n\nCurrently no network detection, just direct execution on a background thread", "committedDate": "2020-12-15T04:51:20Z", "type": "commit"}, {"oid": "c63566589a19f951ed86a5ac5451dfc7ba63fe4e", "url": "https://github.com/Iterable/iterable-android-sdk/commit/c63566589a19f951ed86a5ac5451dfc7ba63fe4e", "message": "Implement lazy instantiation for RequestProcessor", "committedDate": "2020-12-15T04:51:20Z", "type": "commit"}, {"oid": "22c23540ee1066c905be49ba498232a267d89e59", "url": "https://github.com/Iterable/iterable-android-sdk/commit/22c23540ee1066c905be49ba498232a267d89e59", "message": "Add tests for IterableTaskRunner and TaskScheduler", "committedDate": "2020-12-15T04:51:20Z", "type": "forcePushed"}, {"oid": "f82435906aa2fa803436b8c35b65eaee2f984f48", "url": "https://github.com/Iterable/iterable-android-sdk/commit/f82435906aa2fa803436b8c35b65eaee2f984f48", "message": "Add tests for IterableTaskRunner and TaskScheduler", "committedDate": "2020-12-15T04:53:31Z", "type": "forcePushed"}, {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87", "url": "https://github.com/Iterable/iterable-android-sdk/commit/f9a8208cb556781ad784bab12a3c4d12a0b53b87", "message": "Add tests for IterableTaskRunner and TaskScheduler", "committedDate": "2020-12-15T04:54:23Z", "type": "commit"}, {"oid": "f9a8208cb556781ad784bab12a3c4d12a0b53b87", "url": "https://github.com/Iterable/iterable-android-sdk/commit/f9a8208cb556781ad784bab12a3c4d12a0b53b87", "message": "Add tests for IterableTaskRunner and TaskScheduler", "committedDate": "2020-12-15T04:54:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwNjY0MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543506640", "bodyText": "May be we can also think of some name for this method too...\nnotifyTaskListener/ notifyHandler/ handleCallBackAndMessage", "author": "Ayyanchira", "createdAt": "2020-12-15T16:43:46Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {", "originalCommit": "f9a8208cb556781ad784bab12a3c4d12a0b53b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0NDUyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543644524", "bodyText": "This is not what it's doing though", "author": "vbabenkoru", "createdAt": "2020-12-15T19:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwNjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyMzEwNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543523104", "bodyText": "Thinking of a condition here... If in some case, our getNextScheduledTask fails to create a Task (because of improper data) and returns null, other entries in DB wont get a chance to run at all and we might not delete the one causing problem.", "author": "Ayyanchira", "createdAt": "2020-12-15T17:03:27Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskRunner.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.iterable.iterableapi;\n+\n+import android.os.Handler;\n+import android.os.HandlerThread;\n+import android.os.Message;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.WorkerThread;\n+\n+import org.json.JSONObject;\n+\n+class IterableTaskRunner implements IterableTaskStorage.TaskCreatedListener, Handler.Callback {\n+    private static final String TAG = \"IterableTaskRunner\";\n+    private IterableTaskStorage taskStorage;\n+    private IterableActivityMonitor activityMonitor;\n+\n+    private static final int OPERATION_PROCESS_TASKS = 100;\n+\n+    private final HandlerThread networkThread = new HandlerThread(\"NetworkThread\");\n+    Handler handler;\n+\n+    IterableTaskRunner(IterableTaskStorage taskStorage, IterableActivityMonitor activityMonitor) {\n+        this.taskStorage = taskStorage;\n+        this.activityMonitor = activityMonitor;\n+\n+        networkThread.start();\n+        handler = new Handler(networkThread.getLooper(), this);\n+        taskStorage.addTaskCreatedListener(this);\n+    }\n+\n+    @Override\n+    public void onTaskCreated(IterableTask iterableTask) {\n+        runNow();\n+    }\n+\n+    private void runNow() {\n+        handler.removeCallbacksAndMessages(this);\n+        handler.sendEmptyMessage(OPERATION_PROCESS_TASKS);\n+    }\n+\n+    @WorkerThread\n+    @Override\n+    public boolean handleMessage(@NonNull Message msg) {\n+        if (msg.what == OPERATION_PROCESS_TASKS) {\n+            processTasks();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @WorkerThread\n+    private void processTasks() {\n+        while (true) {", "originalCommit": "f9a8208cb556781ad784bab12a3c4d12a0b53b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0NTA5MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/296#discussion_r543645090", "bodyText": "Good idea. I think I'll handle this in a follow-up PR, since we'll have to deal with this when implementing network error handling anyway.", "author": "vbabenkoru", "createdAt": "2020-12-15T19:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUyMzEwNA=="}], "type": "inlineReview"}]}