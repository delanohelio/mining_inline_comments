{"pr_number": 830, "pr_title": "Handle header and endpoint rate limit responses consistently", "pr_createdAt": "2020-05-27T22:18:27Z", "pr_url": "https://github.com/hub4j/github-api/pull/830", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTc3OQ==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431475779", "bodyText": "This is a notable change.", "author": "bitwiseman", "createdAt": "2020-05-27T22:21:03Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjA3OQ==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * called TODO\n          \n          \n            \n                     * called the rate limit will refresh.", "author": "bitwiseman", "createdAt": "2020-05-27T22:21:49Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.\n+         *\n+         * {@link GitHubClient#rateLimit(String)} will not query for a new rate limit until the current Record expires.\n+         * When {@link GitHubClient} is initialized it includes a default {@link GHRateLimit#Default()} which has\n+         * expired rate limit records. This guarantees that the first time {@link GitHubClient#rateLimit(String)} is\n+         * called TODO", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjYzNA==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476634", "bodyText": "TODO javadoc", "author": "bitwiseman", "createdAt": "2020-05-27T22:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQ3MQ==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476471", "bodyText": "TODO javadoc", "author": "bitwiseman", "createdAt": "2020-05-27T22:22:47Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.\n+         *\n+         * {@link GitHubClient#rateLimit(String)} will not query for a new rate limit until the current Record expires.\n+         * When {@link GitHubClient} is initialized it includes a default {@link GHRateLimit#Default()} which has\n+         * expired rate limit records. This guarantees that the first time {@link GitHubClient#rateLimit(String)} is\n+         * called TODO\n+         *\n+         * The\n+         */\n+        static long unknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() * 1000;\n \n         static final int unknownLimit = 1000000;\n         static final int unknownRemaining = 999999;\n \n-        private UnknownLimitRecord() {\n-            super(unknownLimit, unknownRemaining, System.currentTimeMillis() / 1000L + unknownLimitResetSeconds);\n+        // The default UnknownLimitRecord is an expired record.\n+        private static final UnknownLimitRecord DEFAULT = new UnknownLimitRecord(Long.MIN_VALUE);\n+\n+        // The starting current UnknownLimitRecord is an expired record.\n+        private static UnknownLimitRecord current = DEFAULT;\n+\n+        /**\n+         * Internal For testing only.\n+         */\n+        UnknownLimitRecord() {\n+            this(System.currentTimeMillis() / 1000L + unknownLimitResetSeconds);\n+        }\n+\n+        /**\n+         * Not for use outside this class\n+         *\n+         * @param resetEpochSeconds\n+         *            the epoch second time when this record will expire.\n+         */\n+        private UnknownLimitRecord(long resetEpochSeconds) {\n+            super(unknownLimit, unknownRemaining, resetEpochSeconds);\n+        }\n+\n+        static synchronized Record current() {", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjcxMw==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476713", "bodyText": "TODO javadoc", "author": "bitwiseman", "createdAt": "2020-05-27T22:23:19Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -66,16 +66,43 @@\n     private final Record integrationManifest;\n \n     @Nonnull\n-    static GHRateLimit Unknown() {\n-        return new GHRateLimit(new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord());\n+    static GHRateLimit Default() {\n+        return new GHRateLimit(UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT);\n+    }\n+\n+    @Nonnull\n+    static GHRateLimit Unknown(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        return fromHeaderRecord(UnknownLimitRecord.current(), endpoint);\n     }\n \n     @Nonnull\n-    static GHRateLimit fromHeaderRecord(Record header) {\n-        return new GHRateLimit(header, new UnknownLimitRecord(), new UnknownLimitRecord(), new UnknownLimitRecord());\n+    static GHRateLimit fromHeaderRecord(@Nonnull Record header, @Nonnull GitHubRateLimitSpecifier rateLimitSpecifier) {", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Njc0MQ==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476741", "bodyText": "TODO javadoc", "author": "bitwiseman", "createdAt": "2020-05-27T22:23:22Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -66,16 +66,43 @@\n     private final Record integrationManifest;\n \n     @Nonnull\n-    static GHRateLimit Unknown() {\n-        return new GHRateLimit(new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord());\n+    static GHRateLimit Default() {", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzMwMA==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431477300", "bodyText": "TODO javadoc\nMention header information", "author": "bitwiseman", "createdAt": "2020-05-27T22:24:57Z", "path": "src/main/java/org/kohsuke/github/GitHub.java", "diffHunk": "@@ -373,12 +373,19 @@ public String getApiUrl() {\n     }\n \n     /**\n-     * Gets the current rate limit.\n+     * Gets the current rate limit from the server.\n+     *\n+     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In that\n+     * case, if the most recent {@link GHRateLimit} will be returned.", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODYxMQ==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431478611", "bodyText": "TODO, consider making fetch() take a builder instead of a urlPath?", "author": "bitwiseman", "createdAt": "2020-05-27T22:28:19Z", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -210,69 +211,106 @@ public boolean isAnonymous() {\n     /**\n      * Gets the current rate limit from the server.\n      *\n-     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In\n-     * that, if {@link #lastRateLimit()} is not {@code null} and is not expired, it will be returned. Otherwise, a\n-     * placeholder {@link GHRateLimit} instance with {@link GHRateLimit.UnknownLimitRecord}s will be returned.\n+     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In that\n+     * case, if the most recent {@link GHRateLimit} will be returned.\n+     *\n+     * For most use cases it would be better to implement a {@link RateLimitChecker} and add it via\n+     * {@link GitHubBuilder#withRateLimitChecker(RateLimitChecker)}.\n      *\n      * @return the rate limit\n      * @throws IOException\n      *             the io exception\n      */\n     @Nonnull\n     public GHRateLimit getRateLimit() throws IOException {\n+        return getRateLimit(GitHubRateLimitSpecifier.NONE);\n+    }\n+\n+    @Nonnull\n+    GHRateLimit getRateLimit(@Nonnull GitHubRateLimitSpecifier rateLimitSpecifier) throws IOException {\n         GHRateLimit result;\n         try {\n-            result = fetch(JsonRateLimit.class, \"/rate_limit\").resources;\n+            GitHubRequest request = GitHubRequest.newBuilder()", "originalCommit": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96a4a20b7ee55ddbd736c981675ec5892b428a3e", "url": "https://github.com/hub4j/github-api/commit/96a4a20b7ee55ddbd736c981675ec5892b428a3e", "message": "WIP", "committedDate": "2020-05-28T14:37:00Z", "type": "forcePushed"}, {"oid": "aa4f841fabef7b11764673ba52670d42dc9d9b4a", "url": "https://github.com/hub4j/github-api/commit/aa4f841fabef7b11764673ba52670d42dc9d9b4a", "message": "WIP", "committedDate": "2020-05-29T23:56:20Z", "type": "forcePushed"}, {"oid": "5d8414de9847df35956942b5925375868f39eb51", "url": "https://github.com/hub4j/github-api/commit/5d8414de9847df35956942b5925375868f39eb51", "message": "Clean up and reorganize changes\n\nChanged GitHubRateLimitSpecifier to RateLimitTarget\nMade RateLimitTarget public so it can be passed to GitHubBuilder", "committedDate": "2020-05-29T23:59:39Z", "type": "forcePushed"}, {"oid": "2c25ac2589e84f49c0757225be3b0c7ca3f18ca4", "url": "https://github.com/hub4j/github-api/commit/2c25ac2589e84f49c0757225be3b0c7ca3f18ca4", "message": "Add more tests for rate limit record selection", "committedDate": "2020-05-31T21:03:35Z", "type": "forcePushed"}, {"oid": "e0c9344b5810c2e87e7f4834c6149d7f4f512a06", "url": "https://github.com/hub4j/github-api/commit/e0c9344b5810c2e87e7f4834c6149d7f4f512a06", "message": "Clean up comments and javadoc", "committedDate": "2020-06-08T21:14:53Z", "type": "forcePushed"}, {"oid": "a0043fa4f730ef90f2ea3753a29dd514896317e4", "url": "https://github.com/hub4j/github-api/commit/a0043fa4f730ef90f2ea3753a29dd514896317e4", "message": "Clean up comments and javadoc", "committedDate": "2020-06-08T21:32:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQzNTU5Nw==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r451435597", "bodyText": "this seems a bit strange?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() / 1000;\n          \n          \n            \n                    private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).getSeconds();", "author": "timja", "createdAt": "2020-07-08T10:15:51Z", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -221,44 +264,112 @@ public int hashCode() {\n     }\n \n     /**\n-     * Gets the appropriate {@link Record} for a particular url path.\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated {@link Record}s.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s from these two instances. If the merged\n+     *         instance is equal to the current instance, the current instance is returned. If the merged instance is\n+     *         equal to the current instance, the current instance is returned.\n+     */\n+    @Nonnull\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n+    /**\n+     * Gets the specified {@link Record}.\n+     *\n+     * {@link RateLimitTarget#NONE} will return {@link UnknownLimitRecord#DEFAULT} to prevent any clients from\n+     * accidentally waiting on that record to reset before continuing.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n-     * @return the {@link Record} for a url path.\n+     * @param rateLimitTarget\n+     *            the target rate limit record\n+     * @return the target {@link Record} from this instance.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecord(@Nonnull RateLimitTarget rateLimitTarget) {\n+        if (rateLimitTarget == RateLimitTarget.CORE) {\n+            return getCore();\n+        } else if (rateLimitTarget == RateLimitTarget.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (rateLimitTarget == RateLimitTarget.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit target: \" + rateLimitTarget.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() / 1000;", "originalCommit": "d97218ffd5d2f4706c69b8520869f6489e959b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMTE3Mg==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r451901172", "bodyText": "@timja\nThere is a Duration.toSeconds(); but only in Java 11+.\ngetSeconds() is not quite the same as toSeconds(), but you are correct for this case it can be considered the same.", "author": "bitwiseman", "createdAt": "2020-07-09T00:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQzNTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzMTU0Nw==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r452931547", "bodyText": "Instead of trying to guess corresponding rate limit checker from the url path, depend on the requester to provide that information.  Much simpler.", "author": "bitwiseman", "createdAt": "2020-07-10T15:57:38Z", "path": "src/main/java/org/kohsuke/github/GitHubRateLimitChecker.java", "diffHunk": "@@ -122,24 +136,26 @@ void checkRateLimit(GitHubClient client, GitHubRequest request) throws IOExcepti\n \n     /**\n      * Gets the appropriate {@link RateLimitChecker} for a particular url path. Similar to\n-     * {@link GHRateLimit#getRecordForUrlPath(String)}.\n+     * {@link GHRateLimit#getRecord(RateLimitTarget)}.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n-     * @return the {@link RateLimitChecker} for a url path.\n+     * @param rateLimitTarget\n+     *            the rate limit to check\n+     * @return the {@link RateLimitChecker} for a particular target\n      */\n     @Nonnull\n-    private RateLimitChecker selectChecker(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n+    private RateLimitChecker selectChecker(@Nonnull RateLimitTarget rateLimitTarget) {", "originalCommit": "aa4a8341f000b4df87b6fa7dd5fe0e9f05002ce3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4ef0d0084629ed5da7ae6e51473e10adf7560bf7", "url": "https://github.com/hub4j/github-api/commit/4ef0d0084629ed5da7ae6e51473e10adf7560bf7", "message": "Integrate full rate limit checking", "committedDate": "2020-07-10T16:01:29Z", "type": "commit"}, {"oid": "52472e90ec3ba02e5b1b20b24a4da43526b62abf", "url": "https://github.com/hub4j/github-api/commit/52472e90ec3ba02e5b1b20b24a4da43526b62abf", "message": "Simplified rate limit record selection\n\nHere we have another example of trying to do something clever when simplicity is the better choice.\nRather than trying to guess the rate limit record for a request based on the url path,\nI added an enumeration which can be set on the request to say which rate limit record to applies.\n\nThis is simpler, safer, and faster than trying to guess the rate limit from the url path.", "committedDate": "2020-07-10T16:01:29Z", "type": "commit"}, {"oid": "46e3b2272edf4e18db52a978a97e9d19af439a3f", "url": "https://github.com/hub4j/github-api/commit/46e3b2272edf4e18db52a978a97e9d19af439a3f", "message": "Clean up and reorganize changes\n\nChanged GitHubRateLimitSpecifier to RateLimitTarget\nMade RateLimitTarget public so it can be passed to GitHubBuilder", "committedDate": "2020-07-10T16:01:29Z", "type": "commit"}, {"oid": "afa170ba7cabd5b515b1a2fcd42ffc3a84f7e2e5", "url": "https://github.com/hub4j/github-api/commit/afa170ba7cabd5b515b1a2fcd42ffc3a84f7e2e5", "message": "Add more tests for rate limit record selection", "committedDate": "2020-07-10T16:01:29Z", "type": "commit"}, {"oid": "4b3f81ee348e256a4d23af4cab15903619098d04", "url": "https://github.com/hub4j/github-api/commit/4b3f81ee348e256a4d23af4cab15903619098d04", "message": "Clean up comments and javadoc", "committedDate": "2020-07-10T17:51:20Z", "type": "commit"}, {"oid": "4b3f81ee348e256a4d23af4cab15903619098d04", "url": "https://github.com/hub4j/github-api/commit/4b3f81ee348e256a4d23af4cab15903619098d04", "message": "Clean up comments and javadoc", "committedDate": "2020-07-10T17:51:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4ODQ0Mg==", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r454588442", "bodyText": "Merge and equality logic moved into GHRateLimit.", "author": "bitwiseman", "createdAt": "2020-07-14T19:21:20Z", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -654,37 +641,6 @@ private boolean isPrivateModeEnabled() {\n         }\n     }\n \n-    /**\n-     * Determine if one {@link GHRateLimit.Record} should replace another. Header date is only accurate to the second,\n-     * so we look at the information in the record itself.\n-     *\n-     * {@link GHRateLimit.UnknownLimitRecord}s are always replaced by regular {@link GHRateLimit.Record}s. Regular\n-     * {@link GHRateLimit.Record}s are never replaced by {@link GHRateLimit.UnknownLimitRecord}s. Candidates with\n-     * resetEpochSeconds later than current record are more recent. Candidates with the same reset and a lower remaining\n-     * count are more recent. Candidates with an earlier reset are older.\n-     *\n-     * @param candidate\n-     *            {@link GHRateLimit.Record} constructed from the response header information\n-     * @param current\n-     *            the current {@link GHRateLimit.Record} record\n-     */\n-    static boolean shouldReplace(@Nonnull GHRateLimit.Record candidate, @Nonnull GHRateLimit.Record current) {", "originalCommit": "4b3f81ee348e256a4d23af4cab15903619098d04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "987c34c69e97202451af6b77d4a59dc1dffd787d", "url": "https://github.com/hub4j/github-api/commit/987c34c69e97202451af6b77d4a59dc1dffd787d", "message": "Merge branch 'master' into task/rate-limit/full", "committedDate": "2020-07-15T19:13:16Z", "type": "commit"}]}