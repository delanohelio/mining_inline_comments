{"pr_number": 652, "pr_title": "Docs for writing new instrumentation...", "pr_createdAt": "2020-07-09T06:04:46Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652", "timeline": [{"oid": "b92e6d29a08e1d197d24f6f84209f75d5d6c20e6", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b92e6d29a08e1d197d24f6f84209f75d5d6c20e6", "message": "Docs for writing new instrumentation", "committedDate": "2020-07-09T06:03:36Z", "type": "commit"}, {"oid": "4ac4552300ebfbe8fc65f45684184c0358defcad", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ac4552300ebfbe8fc65f45684184c0358defcad", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs", "committedDate": "2020-07-10T06:36:21Z", "type": "commit"}, {"oid": "46030a5b1f8c6db5c8379c25bf6cc5f5fe78e337", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/46030a5b1f8c6db5c8379c25bf6cc5f5fe78e337", "message": "Move aws sdk agent / library folders", "committedDate": "2020-07-10T06:55:34Z", "type": "commit"}, {"oid": "5a148a588b7afae05b044b89e33e62127c788ba1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5a148a588b7afae05b044b89e33e62127c788ba1", "message": "WIP", "committedDate": "2020-07-10T07:42:24Z", "type": "commit"}, {"oid": "d9d8bb754deeb037eee52c8d012c30acc8397f45", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d9d8bb754deeb037eee52c8d012c30acc8397f45", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs", "committedDate": "2020-07-13T05:20:17Z", "type": "commit"}, {"oid": "a1022a0b7dc545d06816f30c8a45e727ede6aab4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1022a0b7dc545d06816f30c8a45e727ede6aab4", "message": "SpockRunner", "committedDate": "2020-07-13T05:41:33Z", "type": "commit"}, {"oid": "ca8ce6a65434aaf95d9faee8d21df82fb728821c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ca8ce6a65434aaf95d9faee8d21df82fb728821c", "message": "Move testing -> testing-common", "committedDate": "2020-07-13T05:48:00Z", "type": "commit"}, {"oid": "ac77748ea3eac783e84ad84cbcd250d35e75611c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ac77748ea3eac783e84ad84cbcd250d35e75611c", "message": "Spotless and tweaks", "committedDate": "2020-07-13T06:03:46Z", "type": "commit"}, {"oid": "e4f3a3786e0a5f107f22b6e95b1963aa73a6fde8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4f3a3786e0a5f107f22b6e95b1963aa73a6fde8", "message": "Cleanups", "committedDate": "2020-07-13T06:21:12Z", "type": "commit"}, {"oid": "dd511304b3377c035b8ea75ceb29ca6e7b406ced", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dd511304b3377c035b8ea75ceb29ca6e7b406ced", "message": "Cleanups", "committedDate": "2020-07-13T06:22:18Z", "type": "commit"}, {"oid": "e2148cf071270beff25ed432649b5d248647fb06", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2148cf071270beff25ed432649b5d248647fb06", "message": "Spotless", "committedDate": "2020-07-13T06:31:59Z", "type": "commit"}, {"oid": "e2148cf071270beff25ed432649b5d248647fb06", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2148cf071270beff25ed432649b5d248647fb06", "message": "Spotless", "committedDate": "2020-07-13T06:31:59Z", "type": "forcePushed"}, {"oid": "cac54eac419f3c6272c01b97ab1a21022294f474", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cac54eac419f3c6272c01b97ab1a21022294f474", "message": "narc", "committedDate": "2020-07-13T06:42:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454923368", "bodyText": "It is worth mentioning here \"and the oldest version being target\"", "author": "iNikem", "createdAt": "2020-07-15T09:38:00Z", "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454923993", "bodyText": "Gradle files names should be unique, so likely yarpc-1.0-agent.gradle", "author": "iNikem", "createdAt": "2020-07-15T09:39:07Z", "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMTg3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455631876", "bodyText": "Yeah this is a hard point. Especially if we consider multiversion case, it would look like\ninstrumentation ->\n  yarpc ->\n    yarpc-1.0 ->\n      yarpc-1.0-agent ->\n        yarpc-1.0-agent.gradle\n      yarpc-1.0-library ->\n        yarpc-1.0-library.gradle\n\nIt's just so much repetition of yarpc. Of course, we can acknowledge that adding build files is not common and live with it - I'd need a paragraph here to explain why we do it though since I think every contributor will wonder why so much repetition. Is the reason because of the Gradle bug where a top-level module may collide if it has the same name and is imported?", "author": "anuraaga", "createdAt": "2020-07-16T08:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNzc3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456207770", "bodyText": "Maybe @iNikem meant this?\ninstrumentation ->\n  yarpc ->\n    yarpc-1.0 ->\n      agent ->\n        yarpc-1.0-agent.gradle\n      library ->\n        yarpc-1.0-library.gradle\n\nand module names\n\n:yarpc:yarpc-1.0:agent\n:yarpc:yarpc-1.0:library", "author": "trask", "createdAt": "2020-07-17T04:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxMDY0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456210641", "bodyText": "I think with that, we would need something like this in settings.gradle\nproject(':instrumentation:yarpc:yarpc-1.0:agent').name = 'yarpc-1.0-agent'\n\nwhich is pretty tedious. Don't believe there is a workaround for that since it's at the initial loading of the projects.", "author": "anuraaga", "createdAt": "2020-07-17T04:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxMjQwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456212402", "bodyText": "not saying it's a good idea, but we could probably add that logic to this existing code in settings.gradle:\ndef setBuildFile(project) {\n  project.buildFileName = \"${project.name}.gradle\"\n  project.children.each {\n    setBuildFile(it)\n  }\n}\n\nrootProject.children.each {\n  setBuildFile(it)\n}", "author": "trask", "createdAt": "2020-07-17T04:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyODIyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456228224", "bodyText": "I never noticed this code I could indeed tweak it. @iNikem is @trask's suggested structure what you were thinking?", "author": "anuraaga", "createdAt": "2020-07-17T05:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyOTc3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456229777", "bodyText": "Yes", "author": "iNikem", "createdAt": "2020-07-17T05:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1MjAzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456252038", "bodyText": "I dunno if I like it very much - I find there's a lot of cognitive load because of the file being composed of two parent directories. What do you think?", "author": "anuraaga", "createdAt": "2020-07-17T06:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5OTQ5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456599494", "bodyText": "It doesn't bother me, but I'm not well-versed in gradle convention, so nothing stands out to me as particularly off.\nJust throwing out another option if you want to keep gradle file in sync with module name:\ninstrumentation ->\n  yarpc ->\n    v1.0 ->    (i'm just guessing using only 1.0 without the \"v\" prefix might be an issue?)\n      yarpc-1.0-agent ->\n        yarpc-1.0-agent.gradle\n      yarpc-1.0-library ->\n        yarpc-1.0-library.gradle\n    v2.0 ->\n      yarpc-2.0-agent ->\n        yarpc-2.0-agent.gradle\n      yarpc-2.0-library ->\n        yarpc-2.0-library.gradle", "author": "trask", "createdAt": "2020-07-17T18:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjczOTUyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456739527", "bodyText": "I don't feel too strongly either, if both of you are ok with it than I'm ok with the current form too :)", "author": "anuraaga", "createdAt": "2020-07-18T02:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTc2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454925769", "bodyText": "We should point to an example instrumentation library right away, so that reader could see actual code behind following explanations.", "author": "iNikem", "createdAt": "2020-07-15T09:42:07Z", "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle\n+        library\n+            library.gradle\n+        testing\n+            testing.gradle\n+```\n+\n+and in the top level `settings.gradle`\n+\n+```groovy\n+\n+include 'instrumentation:yarpc-1.0:agent'\n+include 'instrumentation:yarpc-1.0:library'\n+include 'instrumentation:yarpc-1.0:testing'\n+```\n+\n+#### Writing manual instrumentation", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMjEyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455632121", "bodyText": "Luckily it's in same PR so easier than I thought :D", "author": "anuraaga", "createdAt": "2020-07-16T08:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODA2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454928066", "bodyText": "This doc is a very good starting point. But we have to write more extensive guide with code examples and, probably, method-by-method explanations. Or may be just a series of blog posts ;)", "author": "iNikem", "createdAt": "2020-07-15T09:46:02Z", "path": "CONTRIBUTING.md", "diffHunk": "@@ -78,6 +78,123 @@ available in bootstrap classloader.\n dependencies. Shaded during creation of `java-agent` jar file by Shadow\n Gradle plugin.\n \n+### Writing instrumentation\n+\n+**Warning**: The repository is still in the process of migrating to the structure described here.\n+\n+Any time we want to add OpenTelemetry support for a new Java library, e.g., so usage\n+of that library has tracing, we must write new instrumentation for that library. Let's\n+go over some terms first.\n+\n+**Manual Instrumentation**: This is logic that creates spans and enriches them with data\n+using library-specific monitoring APIs. For example, when instrumenting an RPC library,\n+the instrumentation will use some library-specific functionality to listen to events such\n+as the start and end of a request and will execute code to start and end spans in these\n+listeners. Many of these libraries will provide interception type APIs such as the gRPC\n+`ClientInterceptor` or servlet's `Filter`. Others will provide a Java interface whose methods\n+correspond to a request, and instrumentation can define an implementation which delegates\n+to the standard, wrapping methods with the logic to manage spans. Users will add code to their\n+apps that initialize the classes provided by manual instrumentation libraries and the libraries\n+can be found inside the user's app itself.\n+\n+Some libraries will have no way of intercepting requests because they only expose static APIs\n+and no interception hooks. For these libraries it is not possible to create manual\n+instrumentation.\n+\n+**Auto Instrumentation**: This is logic that is similar to manual instrumentation, but instead\n+of a user initializing classes themselves, a Java agent automatically initializes them during\n+class loading by manipulating byte code. This allows a user to develop their apps without thinking\n+about instrumentation and get it \"for free\". Often, the auto instrumentation will generate bytecode\n+that is more or less identical to what a user would have written themselves in their app.\n+\n+In addition to automatically initializing manual instrumentation, auto instrumentation can be used\n+for libraries where manual instrumentation is not possible, such as `URLConnection`, because it can\n+intercept even the JDK's classes. Such libraries will not have manual instrumentation but will have\n+auto instrumentation.\n+\n+#### Folder Structure\n+\n+When writing new instrumentation, create a new subfolder of `instrumentation` to correspond to the\n+instrumented library and the version being targeted. Ideally an old version of the library is\n+targeted in a way that the instrumentation applies to a large range of versions, but this may be\n+restricted by the interception APIs provided by the library.\n+\n+Within the subfolder, create three folders `library` (skip if manual instrumentation is not possible),\n+`agent`, and `testing`.\n+\n+For example, if we are targeting an RPC framework `yarpc` at version `1.0` we would have a tree like\n+\n+```\n+instrumentation ->\n+    ...\n+    yarpc-1.0 ->\n+        agent\n+            agent.gradle\n+        library\n+            library.gradle\n+        testing\n+            testing.gradle\n+```\n+\n+and in the top level `settings.gradle`\n+\n+```groovy\n+\n+include 'instrumentation:yarpc-1.0:agent'\n+include 'instrumentation:yarpc-1.0:library'\n+include 'instrumentation:yarpc-1.0:testing'\n+```\n+\n+#### Writing manual instrumentation\n+\n+Begin by writing the instrumentation for the library in `library`. This generally involves defining a", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMzcwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455633708", "bodyText": "Definitely - in particular it's still not helpful without refering to existing instrumentation (Document Muzzle will help though :P)\nJFYI, I like codelabs for tutorials\nhttps://developers.curioswitch.org/codelabs/writing-a-codelab/#0\nPretty easy to generate from Markdown using a tool, and much more lightweight than a full blown static site made with e.g., Gatsby\nhttps://github.com/googlecodelabs/tools/tree/master/claat", "author": "anuraaga", "createdAt": "2020-07-16T08:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQ2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454929463", "bodyText": "If we have naming convention for modules, as suggested above, we may replace this configuration with convention. publish.gradle should figure out itself that instrumentations should publish regular jars and only exporters and agent itself should publish fat jar.", "author": "iNikem", "createdAt": "2020-07-15T09:48:22Z", "path": "gradle/instrumentation-library.gradle", "diffHunk": "@@ -0,0 +1,29 @@\n+ext {\n+  noShadowPublish = true", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzOTgwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455639807", "bodyText": "I don't know if it's worth adding that which is sort of magic, we've already abstracted it away to instrumentation-library.gradle. Or are you suggesting projects shouldn't have to do apply from: \"instrumentation-library.gradle\"?\nIn my experience with some large Gradle projects, I've had better luck having top level logic respond to small signals from the subprojects, for example this apply from:, or for publish I'd usually just apply maven-publish in the subprojects and plugins.withId('maven-publish') in the top-level. Seems to reduce top-level spaghetti from what I've seen. But let me know if the removal of the apply from: is actually your idea here.", "author": "anuraaga", "createdAt": "2020-07-16T09:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDg0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456214842", "bodyText": "No, apply from: is fine, I don't object it at all.", "author": "iNikem", "createdAt": "2020-07-17T04:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1NjU0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r456256548", "bodyText": "So hopefully this is OK, as long as this detail isn't leaked into the project gradle files themselves, it seems a little nicer to have less magic here.", "author": "anuraaga", "createdAt": "2020-07-17T07:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDAwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454930005", "bodyText": "Same remark about module naming and convention over configuration", "author": "iNikem", "createdAt": "2020-07-15T09:49:20Z", "path": "gradle/instrumentation.gradle", "diffHunk": "@@ -3,6 +3,10 @@\n apply plugin: 'net.bytebuddy.byte-buddy'\n apply plugin: 'muzzle'\n \n+ext {\n+  packageInAgentBundle = true", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDY5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454930695", "bodyText": "Do we need extra folder layer? instrumentation/aws-sdk/aws-sdk-2.2 vs instrumentation/aws-sdk-2.2", "author": "iNikem", "createdAt": "2020-07-15T09:50:26Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/agent/agent.gradle", "diffHunk": "@@ -0,0 +1,36 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1ODM0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455258341", "bodyText": "The extra folder layer helps keep the instrumentation directory size down (e.g. in Intellij) which I think makes navigation easier", "author": "trask", "createdAt": "2020-07-15T18:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMTc3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454931774", "bodyText": "should this be compileOnly?", "author": "iNikem", "createdAt": "2020-07-15T09:52:14Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/library/library.gradle", "diffHunk": "@@ -0,0 +1,27 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  javaSubPackage = 'awssdk.v2_2'\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation-library.gradle\"\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  latestDepTest {\n+    dirName = 'test'\n+  }\n+}\n+\n+dependencies {\n+  api group: 'software.amazon.awssdk', name: 'aws-core', version: '2.2.0'", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMjM5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454932396", "bodyText": "Are you sure you want to call this on every method? Not in setupSpec?", "author": "iNikem", "createdAt": "2020-07-15T09:53:23Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy", "diffHunk": "@@ -72,15 +72,15 @@ class Aws2ClientCoreTest extends InstrumentationTestRunner {\n     }\n   }\n \n-  def \"send #operation request with builder {#builder.class.getName()} mocked response\"() {\n+  abstract void configureSdkClient(SdkClientBuilder builder)\n+\n+  def \"send #operation request with builder #builder.class.getName() mocked response\"() {\n     setup:\n+    configureSdkClient(builder)", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzNjE4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455636183", "bodyText": "I might be misreading, but I think it's not possible here since the builder is actually created in the where clause of the spec, it's one AWS SDK but there are actually many different types of builders. In lettuce, setupSpec works.", "author": "anuraaga", "createdAt": "2020-07-16T09:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMzYyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454933623", "bodyText": "Somewhere should be documentation about childSetupSpec and childSetup methods", "author": "iNikem", "createdAt": "2020-07-15T09:55:27Z", "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/AgentTestTrait.groovy", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.test\n+\n+import com.google.common.base.Predicate\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import io.opentelemetry.auto.test.asserts.InMemoryExporterAssert\n+import io.opentelemetry.sdk.trace.data.SpanData\n+\n+/**\n+ * A trait which initializes agent tests, including bytecode manipulation and a test span exporter.\n+ * All agent tests should implement this trait.\n+ */\n+trait AgentTestTrait {", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNDE2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r454934162", "bodyText": "Why do we need 2 traits?", "author": "iNikem", "createdAt": "2020-07-15T09:56:29Z", "path": "testing-common/src/main/groovy/io/opentelemetry/auto/test/InstrumentationTestTrait.groovy", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.test\n+\n+import com.google.common.base.Predicate\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import io.opentelemetry.auto.test.asserts.InMemoryExporterAssert\n+import io.opentelemetry.sdk.trace.data.SpanData\n+\n+/**\n+ * A trait which initializes instrumentation library tests, including a test span exporter. All\n+ * library tests should implement this trait.\n+ */\n+trait InstrumentationTestTrait {", "originalCommit": "cac54eac419f3c6272c01b97ab1a21022294f474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzNjk0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/652#discussion_r455636942", "bodyText": "Only only initializes the test span reporter TEST_WRITER, the other also initializes bytecode manipulation", "author": "anuraaga", "createdAt": "2020-07-16T09:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNDE2Mg=="}], "type": "inlineReview"}, {"oid": "91e30c959c09b02dc1b17204c5079d92eb2ec9d2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/91e30c959c09b02dc1b17204c5079d92eb2ec9d2", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into instrumentation-docs", "committedDate": "2020-07-16T08:09:44Z", "type": "commit"}, {"oid": "3dc70256e7c5e4c5d3174c78501548a54f65f91c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3dc70256e7c5e4c5d3174c78501548a54f65f91c", "message": "Fix archives name", "committedDate": "2020-07-16T09:09:14Z", "type": "commit"}, {"oid": "78b239723b657f77bf1328d5fb3929c426d36f57", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/78b239723b657f77bf1328d5fb3929c426d36f57", "message": "Document traits", "committedDate": "2020-07-16T09:13:01Z", "type": "commit"}, {"oid": "e4db78e1156b6a6c486050b53cbce6bdfc05f5c3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4db78e1156b6a6c486050b53cbce6bdfc05f5c3", "message": "agent -> auto and gradle files", "committedDate": "2020-07-17T07:00:53Z", "type": "commit"}, {"oid": "b86efb35a507dcc6be5d97114e2c0d368851a846", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b86efb35a507dcc6be5d97114e2c0d368851a846", "message": "Add auto for real", "committedDate": "2020-07-17T07:02:35Z", "type": "commit"}, {"oid": "b151f53c9ba3ba6d4aa3a52fd5e283250f125b47", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b151f53c9ba3ba6d4aa3a52fd5e283250f125b47", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into instrumentation-docs", "committedDate": "2020-07-17T07:03:21Z", "type": "commit"}, {"oid": "6f8b11701783e35b556ed5cc9911ea66a952f84e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f8b11701783e35b556ed5cc9911ea66a952f84e", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java-instrumentation into instrumentation-docs", "committedDate": "2020-07-19T04:56:40Z", "type": "commit"}]}