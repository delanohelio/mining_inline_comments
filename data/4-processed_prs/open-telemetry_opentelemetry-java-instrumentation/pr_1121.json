{"pr_number": 1121, "pr_title": "JDK 11 HttpClient instrumentation", "pr_createdAt": "2020-08-28T08:53:04Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121", "timeline": [{"oid": "6a5b1b23c163da6fb70a7d54a67a1c475b0b03e2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6a5b1b23c163da6fb70a7d54a67a1c475b0b03e2", "message": "JDK 11 HttpClient instrumentation\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-28T08:51:27Z", "type": "commit"}, {"oid": "e2ea534d3fcffa6cb63676c1b660bce5ce9618ac", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e2ea534d3fcffa6cb63676c1b660bce5ce9618ac", "message": "get rid of semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-28T09:03:08Z", "type": "commit"}, {"oid": "54a4f5902b91995874ef6ff69705023bfae76178", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/54a4f5902b91995874ef6ff69705023bfae76178", "message": "Merge branch 'master' into jdk-11-httpclient", "committedDate": "2020-08-31T12:18:30Z", "type": "commit"}, {"oid": "65133ca15795cee859a49c575e5bf4eaf544f35d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/65133ca15795cee859a49c575e5bf4eaf544f35d", "message": "trace sync request\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-01T15:49:38Z", "type": "commit"}, {"oid": "a87f33fd4e4e389ce771073b09edbb5919bd9983", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a87f33fd4e4e389ce771073b09edbb5919bd9983", "message": "get rid of unnecessary gradle options\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-02T01:26:19Z", "type": "commit"}, {"oid": "e1a63765316568f0b34fe057f9ed898a9044869e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e1a63765316568f0b34fe057f9ed898a9044869e", "message": "Merge branch 'master' into jdk-11-httpclient", "committedDate": "2020-09-02T01:27:14Z", "type": "commit"}, {"oid": "36ae437db8598ba66e79390567e937704201768d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/36ae437db8598ba66e79390567e937704201768d", "message": "wip\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-02T14:37:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482686479", "bodyText": "@malafeev Have you tried running with debug logs? I'm guessing this instrumentation is \"getting muzzled\". Lambdas create additional anonymous classes, so I believe you need to add something like `packageName + HttpClientInstrumentation$1\" to the helper classes list.\nBecause this is a bit magical I tend to avoid lambdas in instrumentation, and instead define a class that implements the interface (effectively same bytecode). Though I've found that even that doesn't always work...\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1153/files#r481762196", "author": "anuraaga", "createdAt": "2020-09-03T03:49:18Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".TracingBodyHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\")))\n+            .and(takesArgument(1, named(\"java.net.http.HttpResponse$BodyHandler\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Argument(value = 1, readOnly = false) BodyHandler<?> bodyHandler,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        bodyHandler = new TracingBodyHandler<>(bodyHandler, span);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC) CompletableFuture<?> future,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable != null) {\n+          TRACER.endExceptionally(span, null, throwable);\n+        } else {\n+          // FIXME: next lines breaks interception\n+          future =\n+              future.whenComplete(\n+                  (o, t) -> {", "originalCommit": "36ae437db8598ba66e79390567e937704201768d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcwNDM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482704368", "bodyText": "thanks @anuraaga, let me try", "author": "malafeev", "createdAt": "2020-09-03T04:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NTc0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r482965749", "bodyText": "it works !!!", "author": "malafeev", "createdAt": "2020-09-03T13:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjQ3OQ=="}], "type": "inlineReview"}, {"oid": "fb2d2529e145ac595736733fbb7e6ae48e06d5cf", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fb2d2529e145ac595736733fbb7e6ae48e06d5cf", "message": "end span when future completed\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-03T12:28:00Z", "type": "commit"}, {"oid": "39da54b66542af837c0a5cf4198407ad1d3269c3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/39da54b66542af837c0a5cf4198407ad1d3269c3", "message": "remove unneeded check\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-03T12:33:03Z", "type": "commit"}, {"oid": "c04109d1b61bd4c62abfba4b9958d8fe5811f0a3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c04109d1b61bd4c62abfba4b9958d8fe5811f0a3", "message": "get rid of repeated test code\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-03T13:35:36Z", "type": "commit"}, {"oid": "ec54179be024c07fd00cdabd5b8e86f23af9dd98", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec54179be024c07fd00cdabd5b8e86f23af9dd98", "message": "get rid of unneeded code\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-03T13:36:54Z", "type": "commit"}, {"oid": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "message": "remove semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-03T13:42:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTIzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381231", "bodyText": "Can you add classloader matcher as well? It usually gives a significant performance boost.", "author": "iNikem", "createdAt": "2020-09-09T06:58:23Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTYxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591619", "bodyText": "added", "author": "malafeev", "createdAt": "2020-09-09T13:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTM3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485381378", "bodyText": "Why two nameStartsWith are used differently?", "author": "iNikem", "createdAt": "2020-09-09T06:58:43Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTY5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591695", "bodyText": "fixed", "author": "malafeev", "createdAt": "2020-09-09T13:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382102", "bodyText": "So we don't support context propagation via this http client?", "author": "iNikem", "createdAt": "2020-09-09T07:00:11Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInjectAdapter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import java.net.http.HttpRequest;\n+\n+public class HttpHeadersInjectAdapter implements TextMapPropagator.Setter<HttpRequest> {\n+  public static final HttpHeadersInjectAdapter SETTER = new HttpHeadersInjectAdapter();\n+\n+  @Override\n+  public void set(HttpRequest carrier, String key, String value) {\n+    // Don't do anything because headers are immutable", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDY1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485584652", "bodyText": "context propagation is implemented via HttpHeadersInstrumentation.java otherwise tests would fail.\nthis class is a stub because I have to provide implementation to HttpClientTracer#getSetter()", "author": "malafeev", "createdAt": "2020-09-09T12:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTg4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591885", "bodyText": "added javadoc", "author": "malafeev", "createdAt": "2020-09-09T13:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjI2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485382264", "bodyText": "Remove commented code?", "author": "iNikem", "createdAt": "2020-09-09T07:00:32Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(ElementMatchers.<TypeDescription>nameStartsWith(\"jdk.internal.\"))\n+        // .and(not(named(\"jdk.internal.net.http.ImmutableHttpRequest\")))", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTk5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485591990", "bodyText": "removed", "author": "malafeev", "createdAt": "2020-09-09T13:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485383360", "bodyText": "Why taking cause? Also I recommend overriding io.opentelemetry.instrumentation.api.tracer.BaseTracer#unwrapThrowable in JdkHttpClientTracer", "author": "iNikem", "createdAt": "2020-09-09T07:02:49Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/ResponseConsumer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpResponse;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+\n+public class ResponseConsumer implements BiConsumer<HttpResponse<?>, Throwable> {\n+  private final Span span;\n+\n+  public ResponseConsumer(Span span) {\n+    this.span = span;\n+  }\n+\n+  @Override\n+  public void accept(HttpResponse<?> httpResponse, Throwable throwable) {\n+    if (throwable == null) {\n+      TRACER.end(span, httpResponse);\n+    } else {\n+      final Throwable cause = throwable.getCause();", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODY0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485588643", "bodyText": "because throwable here is java.util.concurrent.CompletionException.", "author": "malafeev", "createdAt": "2020-09-09T12:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjEyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485592123", "bodyText": "overrided", "author": "malafeev", "createdAt": "2020-09-09T13:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NDA1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485384059", "bodyText": "Move this near the check for java please.", "author": "iNikem", "createdAt": "2020-09-09T07:04:28Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/matcher/GlobalIgnoresMatcher.java", "diffHunk": "@@ -64,6 +64,10 @@ private GlobalIgnoresMatcher(boolean skipAdditionalLibraryMatcher) {\n   public boolean matches(T target) {\n     String name = target.getActualName();\n \n+    if (name.startsWith(\"jdk.internal.net.http.\")) {", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MjQwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485582407", "bodyText": "next if checks for name.startsWith(\"jdk.\"):\nif (name.startsWith(\"net.bytebuddy.\")\n        || name.startsWith(\"jdk.\")\n        || name.startsWith(\"org.aspectj.\")\n        || name.startsWith(\"com.intellij.rt.debugger.\")\n        || name.startsWith(\"com.p6spy.\")\n        || name.startsWith(\"com.dynatrace.\")\n        || name.startsWith(\"com.jloadtrace.\")\n        || name.startsWith(\"com.appdynamics.\")\n        || name.startsWith(\"com.singularity.\")\n        || name.startsWith(\"com.jinspired.\")\n        || name.startsWith(\"org.jinspired.\")) {\n      return true;\n    }\n\nThat's why I put it before this if", "author": "malafeev", "createdAt": "2020-09-09T12:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTU4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485451586", "bodyText": "@malafeev Go ahead and restore this after merging master :)", "author": "anuraaga", "createdAt": "2020-09-09T08:57:33Z", "path": "instrumentation/httpclient/httpclient.gradle", "diffHunk": "@@ -0,0 +1,12 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+// FIXME: how to pass muzzle (only for jdk 11+)\n+//muzzle {", "originalCommit": "c34ca7dd15fe37592edb1f4d0813fea7cc38697b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjMwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485592307", "bodyText": "done", "author": "malafeev", "createdAt": "2020-09-09T13:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTU4Ng=="}], "type": "inlineReview"}, {"oid": "cef48862cabab38c722c74e7fd12ab800031b5fe", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cef48862cabab38c722c74e7fd12ab800031b5fe", "message": "Merge branch 'master' into jdk-11-httpclient", "committedDate": "2020-09-09T12:27:10Z", "type": "commit"}, {"oid": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/106aa5d6ace77810e69b2349b9824a8ae23deb25", "message": "implement review comments\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-09T13:00:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMTEzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485911134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n          \n          \n            \n                        CompletableFuture<HttpResponse<?>> future,\n          \n          \n            \n                    @Advice.Return(readOnly = false) CompletableFuture<HttpResponse<?>> future,", "author": "trask", "createdAt": "2020-09-09T20:44:55Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return nameStartsWith(\"java.net.\")\n+        .or(nameStartsWith(\"jdk.internal.\"))\n+        .and(not(named(\"jdk.internal.net.http.HttpClientFacade\")))\n+        .and(extendsClass(named(\"java.net.http.HttpClient\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".HttpHeadersInjectAdapter\",\n+      packageName + \".JdkHttpClientTracer\",\n+      packageName + \".ResponseConsumer\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"send\"))\n+            .and(isPublic())\n+            .and(takesArguments(2))\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"sendAsync\"))\n+            .and(isPublic())\n+            .and(takesArgument(0, named(\"java.net.http.HttpRequest\"))),\n+        HttpClientInstrumentation.class.getName() + \"$SendAsyncAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class SendAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return HttpResponse result,\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        if (throwable == null) {\n+          TRACER.end(span, result);\n+        } else {\n+          TRACER.endExceptionally(span, result, throwable);\n+        }\n+      }\n+    }\n+  }\n+\n+  public static class SendAsyncAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void methodEnter(\n+        @Advice.Argument(value = 0) HttpRequest httpRequest,\n+        @Advice.Local(\"otelSpan\") Span span,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n+\n+      callDepth = TRACER.getCallDepth();\n+      if (callDepth.getAndIncrement() == 0) {\n+        span = TRACER.startSpan(httpRequest);\n+        if (span.getContext().isValid()) {\n+          scope = TRACER.startScope(span, httpRequest);\n+        }\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void methodExit(\n+        @Advice.Return(readOnly = false, typing = Typing.DYNAMIC)\n+            CompletableFuture<HttpResponse<?>> future,", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDc4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090783", "bodyText": "done", "author": "malafeev", "createdAt": "2020-09-10T06:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzA3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913079", "bodyText": "this looks unused\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(HttpClient.class.getName(), State.class.getName());\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-09-09T20:48:39Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDUyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090520", "bodyText": "removed", "author": "malafeev", "createdAt": "2020-09-10T06:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzE3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913171", "bodyText": "this looks unused\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n              @Override\n          \n          \n            \n              public Map<String, String> contextStore() {\n          \n          \n            \n                return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-09-09T20:48:50Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpClientInstrumentation extends Instrumenter.Default {\n+\n+  public HttpClientInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"java.net.http.HttpClient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"java.net.http.HttpRequest\", Context.class.getName());\n+  }", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MDg4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486090886", "bodyText": "removed", "author": "malafeev", "createdAt": "2020-09-10T06:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzgzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485913836", "bodyText": "good to add same classLoaderMatcher() here also from HttpClientInstrumentation", "author": "trask", "createdAt": "2020-09-09T20:50:08Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpHeadersInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import static io.opentelemetry.instrumentation.auto.httpclient.JdkHttpClientTracer.TRACER;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.instrumentation.auto.api.concurrent.State;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class HttpHeadersInstrumentation extends Instrumenter.Default {\n+\n+  public HttpHeadersInstrumentation() {\n+    super(\"httpclient\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(HttpClient.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTk1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089956", "bodyText": "added", "author": "malafeev", "createdAt": "2020-09-10T06:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNTU2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485915566", "bodyText": "this seems maybe too generic, same for the module name, maybe \"java-httpclient\"?", "author": "trask", "createdAt": "2020-09-09T20:53:30Z", "path": "instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/JdkHttpClientTracer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.httpclient;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import io.opentelemetry.instrumentation.api.tracer.HttpClientTracer;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n+import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap.Depth;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+\n+public class JdkHttpClientTracer extends HttpClientTracer<HttpRequest, HttpRequest, HttpResponse> {\n+  public static final JdkHttpClientTracer TRACER = new JdkHttpClientTracer();\n+\n+  public Depth getCallDepth() {\n+    return CallDepthThreadLocalMap.getCallDepth(HttpClient.class);\n+  }\n+\n+  @Override\n+  protected String getInstrumentationName() {\n+    return \"io.opentelemetry.auto.httpclient\";", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTgxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089818", "bodyText": "renamed", "author": "malafeev", "createdAt": "2020-09-10T06:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxNTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyMTg5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485921897", "bodyText": "and add followRedirects(HttpClient.Redirect.NORMAL) to http client configuration above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              boolean testRedirects() {\n          \n          \n            \n                // Generates 4 spans\n          \n          \n            \n              boolean testCircularRedirects() {", "author": "trask", "createdAt": "2020-09-09T21:06:07Z", "path": "instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.opentelemetry.auto.test.base.HttpClientTest\n+import spock.lang.Shared\n+import spock.lang.Timeout\n+\n+import java.net.http.HttpClient\n+import java.net.http.HttpRequest\n+import java.net.http.HttpResponse\n+import java.time.Duration\n+import java.time.temporal.ChronoUnit\n+\n+@Timeout(5)\n+abstract class JdkHttpClientTest extends HttpClientTest {\n+\n+  @Shared\n+  def client = HttpClient.newBuilder().connectTimeout(Duration.of(CONNECT_TIMEOUT_MS,\n+    ChronoUnit.MILLIS)).build()\n+\n+  @Override\n+  int doRequest(String method, URI uri, Map<String, String> headers, Closure callback) {\n+\n+    def builder = HttpRequest.newBuilder().uri(uri).method(method, HttpRequest.BodyPublishers.noBody())\n+\n+    headers.entrySet().each {\n+      builder.header(it.key, it.value)\n+    }\n+    def request = builder.build()\n+\n+    def resp = send(request)\n+    callback?.call()\n+    return resp.statusCode()\n+  }\n+\n+  abstract HttpResponse send(HttpRequest request)\n+\n+  @Override\n+  boolean testRedirects() {\n+    // Generates 4 spans", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MjY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486092654", "bodyText": "added", "author": "malafeev", "createdAt": "2020-09-10T06:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyMTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r485924758", "bodyText": "i think this name is too generic, since there are many httpclient instrumentations, i think my suggestion would be java-httpclient", "author": "trask", "createdAt": "2020-09-09T21:12:12Z", "path": "settings.gradle", "diffHunk": "@@ -91,6 +91,7 @@ include ':instrumentation:hibernate:hibernate-4.0'\n include ':instrumentation:hibernate:hibernate-4.3'\n include ':instrumentation:hibernate:hibernate-common'\n include ':instrumentation:http-url-connection'\n+include ':instrumentation:httpclient'", "originalCommit": "106aa5d6ace77810e69b2349b9824a8ae23deb25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTg4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1121#discussion_r486089880", "bodyText": "renamed", "author": "malafeev", "createdAt": "2020-09-10T06:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDc1OA=="}], "type": "inlineReview"}, {"oid": "0e3d8aaf39d5ddbd0793e163142782373ec3c392", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0e3d8aaf39d5ddbd0793e163142782373ec3c392", "message": "Update instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-09-10T06:01:30Z", "type": "commit"}, {"oid": "e5215b8a7ebcc9cc56b41486bd8c3ce19b3b6b67", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e5215b8a7ebcc9cc56b41486bd8c3ce19b3b6b67", "message": "Update instrumentation/httpclient/src/main/java/io/opentelemetry/instrumentation/auto/httpclient/HttpClientInstrumentation.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-09-10T06:01:44Z", "type": "commit"}, {"oid": "8446e1a92d4d99330674b44b90b2484ae8f4e2bb", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8446e1a92d4d99330674b44b90b2484ae8f4e2bb", "message": "Update instrumentation/httpclient/src/test/groovy/JdkHttpClientTest.groovy\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-09-10T06:02:07Z", "type": "commit"}, {"oid": "d051bb30aca4f9e3d014a1e28938f3d2f7441733", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d051bb30aca4f9e3d014a1e28938f3d2f7441733", "message": "rename to java-httpclient\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-10T06:15:23Z", "type": "commit"}, {"oid": "21eb8e8693958866434bc2bcbce51838542e90e9", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/21eb8e8693958866434bc2bcbce51838542e90e9", "message": "remove unused\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-10T06:17:48Z", "type": "commit"}, {"oid": "94011b5d4d10987f7ad6053fd59de7beb0368cb0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94011b5d4d10987f7ad6053fd59de7beb0368cb0", "message": "follow redirects\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-10T06:23:06Z", "type": "commit"}, {"oid": "ebc660a18959abb97df6ef4e55727084e436ee32", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ebc660a18959abb97df6ef4e55727084e436ee32", "message": "remove semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-10T06:28:19Z", "type": "commit"}]}