{"pr_number": 1379, "pr_title": "Muzzle improvements: docs, javadocs, renamings and minor refactoring", "pr_createdAt": "2020-10-13T12:58:41Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNDE1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504124156", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n          \n          \n            \n            class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n          \n          \n            \n            The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n          \n          \n            \n            in the class `Instrumenter.Default` and under the package `io.opentelemetry.javaagent.tooling.muzzle`.\n          \n      \n    \n    \n  \n\nor, maybe if we can move MuzzleMatcher from Instrumenter.Default to a top-level class in the muzzle package(?):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n          \n          \n            \n            class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n          \n          \n            \n            The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n          \n          \n            \n            under the package `io.opentelemetry.javaagent.tooling.muzzle`.", "author": "trask", "createdAt": "2020-10-13T17:12:31Z", "path": "docs/contributing/muzzle.md", "diffHunk": "@@ -1,42 +1,107 @@\n # Muzzle\n \n-Muzzle is a feature of the Java agent that ensures API compatibility\n-between libraries/symbols on the application classpath and APIs of instrumented\n-3rd party libraries used by the Agent. In other words the Muzzle ensures\n-that the API symbols used by the Agent are compatible with API symbols\n-on the application classpath. The Muzzle will prevent loading an instrumentation\n-if the APIs do not match.\n+Muzzle is a safety feature of the Java agent that prevents applying instrumentation when a mismatch\n+between the instrumentation code and the instrumented application code is detected.\n+It ensures API compatibility between symbols (classes, methods, fields) on the application classpath\n+and references to those symbols made by instrumentation advices defined in the agent.\n+In other words, muzzle ensures that the API symbols used by the agent are compatible with the API\n+symbols on the application classpath.\n \n-## How does it work\n+Muzzle will prevent loading an instrumentation if it detects any mismatch or conflict.\n \n-At build time, for each instrumentation the Muzzle ByteBuddy plugin collects symbols referring to both internal\n-and 3rd party APIs used by the currently processed instrumentation. The reference collection process starts\n-from advice classes - values of the map returned by the `Instrumenter.Default#transformers()` method.\n+## How it works\n \n-All those references are then used to create a `ReferenceMatcher` instance.\n-The matcher is stored in the instrumentation class in method `ReferenceMatcher getInstrumentationMuzzle()`.\n+Muzzle has two phases:\n+* at compile time it collects references to the third-party symbols;\n+* at runtime it compares those references to the actual API symbols on the classpath.\n \n-At runtime the Muzzle checks API compatibility between symbols used by the Agent\n-and symbols in the application class loader. If the symbols do not match the instrumentation is not loaded.\n-Because the muzzle matcher is expensive, it is only performed after a match has been made by the\n-`SomeInstrumentation.classLoaderMatcher()` and `SomeInstrumentation.typeMatcher()` matchers.\n+### Compile-time reference collection\n+\n+The compile-time reference collection and code generation process is implemented using a ByteBuddy\n+plugin (called `MuzzleCodeGenerationPlugin`).\n+\n+For each instrumentation the ByteBuddy plugin collects symbols referring to both internal and third\n+party APIs used by the currently processed instrumentation. The reference collection process starts\n+from advice classes (values of the map returned by the `Instrumenter.Default#transformers()` method)\n+and traverses the class graph until it encounters a reference to a non-instrumentation class.\n+\n+All collected references are then used to create a `ReferenceMatcher` instance. This matcher\n+is stored in the instrumentation class in the method `Instrumenter.Default#getMuzzleReferenceMatcher()`.\n+The bytecode of this method (basically an array of `Reference` builder calls) is generated\n+automatically by the ByteBuddy plugin using an ASM code visitor.\n+\n+The source code of the compile-time plugin is located in the `javaagent-tooling` module,\n+package `io.opentelemetry.javaagent.tooling.muzzle.collector`.\n+\n+### Runtime reference matching\n+\n+The runtime reference matching process is implemented as a ByteBuddy matcher in `Instrumenter.Default`.\n+`MuzzleMatcher` uses the `getMuzzleReferenceMatcher()` method generated during the compilation phase\n+to verify that the class loader of the instrumented type has all necessary symbols (classes,\n+methods, fields). If the `ReferenceMatcher` finds any mismatch between collected references and the\n+actual application classpath types the whole instrumentation is discarded.\n+\n+It is worth noting that because the muzzle check is expensive, it is only performed after a match\n+has been made by the `InstrumenterDefault#classLoaderMatcher()` and `Instrumenter.Default#typeMatcher()`\n+matchers.\n+\n+The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n+class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU0MzQ3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504543473", "bodyText": "I think I'll leave it here for the time being - it seems that placing it inside Instrumenter.Default was purposeful, see the Optimization comment at top of the MuzzleMatcher#matches() method.", "author": "mateuszrzeszutek", "createdAt": "2020-10-14T09:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNTc1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504125757", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Muzzle gradle plugin is just an additional utility for enhanced build-time checking.\n          \n          \n            \n            Muzzle gradle plugin is just an additional utility for enhanced build-time checking\n          \n          \n            \n            to alert us when there are breaking changes in the underlying third party library\n          \n          \n            \n            that will cause the instrumentation not to get applied.", "author": "trask", "createdAt": "2020-10-13T17:15:06Z", "path": "docs/contributing/muzzle.md", "diffHunk": "@@ -1,42 +1,107 @@\n # Muzzle\n \n-Muzzle is a feature of the Java agent that ensures API compatibility\n-between libraries/symbols on the application classpath and APIs of instrumented\n-3rd party libraries used by the Agent. In other words the Muzzle ensures\n-that the API symbols used by the Agent are compatible with API symbols\n-on the application classpath. The Muzzle will prevent loading an instrumentation\n-if the APIs do not match.\n+Muzzle is a safety feature of the Java agent that prevents applying instrumentation when a mismatch\n+between the instrumentation code and the instrumented application code is detected.\n+It ensures API compatibility between symbols (classes, methods, fields) on the application classpath\n+and references to those symbols made by instrumentation advices defined in the agent.\n+In other words, muzzle ensures that the API symbols used by the agent are compatible with the API\n+symbols on the application classpath.\n \n-## How does it work\n+Muzzle will prevent loading an instrumentation if it detects any mismatch or conflict.\n \n-At build time, for each instrumentation the Muzzle ByteBuddy plugin collects symbols referring to both internal\n-and 3rd party APIs used by the currently processed instrumentation. The reference collection process starts\n-from advice classes - values of the map returned by the `Instrumenter.Default#transformers()` method.\n+## How it works\n \n-All those references are then used to create a `ReferenceMatcher` instance.\n-The matcher is stored in the instrumentation class in method `ReferenceMatcher getInstrumentationMuzzle()`.\n+Muzzle has two phases:\n+* at compile time it collects references to the third-party symbols;\n+* at runtime it compares those references to the actual API symbols on the classpath.\n \n-At runtime the Muzzle checks API compatibility between symbols used by the Agent\n-and symbols in the application class loader. If the symbols do not match the instrumentation is not loaded.\n-Because the muzzle matcher is expensive, it is only performed after a match has been made by the\n-`SomeInstrumentation.classLoaderMatcher()` and `SomeInstrumentation.typeMatcher()` matchers.\n+### Compile-time reference collection\n+\n+The compile-time reference collection and code generation process is implemented using a ByteBuddy\n+plugin (called `MuzzleCodeGenerationPlugin`).\n+\n+For each instrumentation the ByteBuddy plugin collects symbols referring to both internal and third\n+party APIs used by the currently processed instrumentation. The reference collection process starts\n+from advice classes (values of the map returned by the `Instrumenter.Default#transformers()` method)\n+and traverses the class graph until it encounters a reference to a non-instrumentation class.\n+\n+All collected references are then used to create a `ReferenceMatcher` instance. This matcher\n+is stored in the instrumentation class in the method `Instrumenter.Default#getMuzzleReferenceMatcher()`.\n+The bytecode of this method (basically an array of `Reference` builder calls) is generated\n+automatically by the ByteBuddy plugin using an ASM code visitor.\n+\n+The source code of the compile-time plugin is located in the `javaagent-tooling` module,\n+package `io.opentelemetry.javaagent.tooling.muzzle.collector`.\n+\n+### Runtime reference matching\n+\n+The runtime reference matching process is implemented as a ByteBuddy matcher in `Instrumenter.Default`.\n+`MuzzleMatcher` uses the `getMuzzleReferenceMatcher()` method generated during the compilation phase\n+to verify that the class loader of the instrumented type has all necessary symbols (classes,\n+methods, fields). If the `ReferenceMatcher` finds any mismatch between collected references and the\n+actual application classpath types the whole instrumentation is discarded.\n+\n+It is worth noting that because the muzzle check is expensive, it is only performed after a match\n+has been made by the `InstrumenterDefault#classLoaderMatcher()` and `Instrumenter.Default#typeMatcher()`\n+matchers.\n+\n+The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n+class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n \n ## Muzzle gradle plugin\n \n-The `printReferences` task prints all API references in a given module.\n+The muzzle gradle plugin allows to perform the runtime reference matching process against different\n+third party library versions, when the project is built.\n \n-```bash\n-./gradlew :instrumentation:google-http-client-1.19:printReferences\n-```\n+Muzzle gradle plugin is just an additional utility for enhanced build-time checking.", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNjY5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504126691", "bodyText": "I'd suggest putting muzzle before printReferences since most important", "author": "trask", "createdAt": "2020-10-13T17:16:46Z", "path": "docs/contributing/muzzle.md", "diffHunk": "@@ -1,42 +1,107 @@\n # Muzzle\n \n-Muzzle is a feature of the Java agent that ensures API compatibility\n-between libraries/symbols on the application classpath and APIs of instrumented\n-3rd party libraries used by the Agent. In other words the Muzzle ensures\n-that the API symbols used by the Agent are compatible with API symbols\n-on the application classpath. The Muzzle will prevent loading an instrumentation\n-if the APIs do not match.\n+Muzzle is a safety feature of the Java agent that prevents applying instrumentation when a mismatch\n+between the instrumentation code and the instrumented application code is detected.\n+It ensures API compatibility between symbols (classes, methods, fields) on the application classpath\n+and references to those symbols made by instrumentation advices defined in the agent.\n+In other words, muzzle ensures that the API symbols used by the agent are compatible with the API\n+symbols on the application classpath.\n \n-## How does it work\n+Muzzle will prevent loading an instrumentation if it detects any mismatch or conflict.\n \n-At build time, for each instrumentation the Muzzle ByteBuddy plugin collects symbols referring to both internal\n-and 3rd party APIs used by the currently processed instrumentation. The reference collection process starts\n-from advice classes - values of the map returned by the `Instrumenter.Default#transformers()` method.\n+## How it works\n \n-All those references are then used to create a `ReferenceMatcher` instance.\n-The matcher is stored in the instrumentation class in method `ReferenceMatcher getInstrumentationMuzzle()`.\n+Muzzle has two phases:\n+* at compile time it collects references to the third-party symbols;\n+* at runtime it compares those references to the actual API symbols on the classpath.\n \n-At runtime the Muzzle checks API compatibility between symbols used by the Agent\n-and symbols in the application class loader. If the symbols do not match the instrumentation is not loaded.\n-Because the muzzle matcher is expensive, it is only performed after a match has been made by the\n-`SomeInstrumentation.classLoaderMatcher()` and `SomeInstrumentation.typeMatcher()` matchers.\n+### Compile-time reference collection\n+\n+The compile-time reference collection and code generation process is implemented using a ByteBuddy\n+plugin (called `MuzzleCodeGenerationPlugin`).\n+\n+For each instrumentation the ByteBuddy plugin collects symbols referring to both internal and third\n+party APIs used by the currently processed instrumentation. The reference collection process starts\n+from advice classes (values of the map returned by the `Instrumenter.Default#transformers()` method)\n+and traverses the class graph until it encounters a reference to a non-instrumentation class.\n+\n+All collected references are then used to create a `ReferenceMatcher` instance. This matcher\n+is stored in the instrumentation class in the method `Instrumenter.Default#getMuzzleReferenceMatcher()`.\n+The bytecode of this method (basically an array of `Reference` builder calls) is generated\n+automatically by the ByteBuddy plugin using an ASM code visitor.\n+\n+The source code of the compile-time plugin is located in the `javaagent-tooling` module,\n+package `io.opentelemetry.javaagent.tooling.muzzle.collector`.\n+\n+### Runtime reference matching\n+\n+The runtime reference matching process is implemented as a ByteBuddy matcher in `Instrumenter.Default`.\n+`MuzzleMatcher` uses the `getMuzzleReferenceMatcher()` method generated during the compilation phase\n+to verify that the class loader of the instrumented type has all necessary symbols (classes,\n+methods, fields). If the `ReferenceMatcher` finds any mismatch between collected references and the\n+actual application classpath types the whole instrumentation is discarded.\n+\n+It is worth noting that because the muzzle check is expensive, it is only performed after a match\n+has been made by the `InstrumenterDefault#classLoaderMatcher()` and `Instrumenter.Default#typeMatcher()`\n+matchers.\n+\n+The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n+class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n \n ## Muzzle gradle plugin\n \n-The `printReferences` task prints all API references in a given module.\n+The muzzle gradle plugin allows to perform the runtime reference matching process against different\n+third party library versions, when the project is built.\n \n-```bash\n-./gradlew :instrumentation:google-http-client-1.19:printReferences\n-```\n+Muzzle gradle plugin is just an additional utility for enhanced build-time checking.\n+**Even without using it muzzle reference matching is _always_ active in runtime**,\n+it's not an optional feature.\n+\n+The gradle plugin defines two tasks:\n+\n+* `printReferences` task prints all API references in a given module:\n+    ```sh\n+    ./gradlew :instrumentation:google-http-client-1.19:printReferences\n+    ```\n+\n+* `muzzle` task runs the runtime muzzle verification against different library versions:", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU0NzQxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504547418", "bodyText": "not related to this PR, but should we rename the printReferences to something that includes muzzle in the task name? e.g. muzzlePrintReferences?", "author": "pavolloffay", "createdAt": "2020-10-14T09:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNjY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3OTUyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r505079521", "bodyText": "@pavolloffay makes sense \ud83d\udc4d", "author": "trask", "createdAt": "2020-10-14T23:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzAxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504127011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                If a new, incompatible version is published it fails the build.\n          \n          \n            \n                If a new, incompatible version of the instrumented library is published it fails the build.", "author": "trask", "createdAt": "2020-10-13T17:17:19Z", "path": "docs/contributing/muzzle.md", "diffHunk": "@@ -1,42 +1,107 @@\n # Muzzle\n \n-Muzzle is a feature of the Java agent that ensures API compatibility\n-between libraries/symbols on the application classpath and APIs of instrumented\n-3rd party libraries used by the Agent. In other words the Muzzle ensures\n-that the API symbols used by the Agent are compatible with API symbols\n-on the application classpath. The Muzzle will prevent loading an instrumentation\n-if the APIs do not match.\n+Muzzle is a safety feature of the Java agent that prevents applying instrumentation when a mismatch\n+between the instrumentation code and the instrumented application code is detected.\n+It ensures API compatibility between symbols (classes, methods, fields) on the application classpath\n+and references to those symbols made by instrumentation advices defined in the agent.\n+In other words, muzzle ensures that the API symbols used by the agent are compatible with the API\n+symbols on the application classpath.\n \n-## How does it work\n+Muzzle will prevent loading an instrumentation if it detects any mismatch or conflict.\n \n-At build time, for each instrumentation the Muzzle ByteBuddy plugin collects symbols referring to both internal\n-and 3rd party APIs used by the currently processed instrumentation. The reference collection process starts\n-from advice classes - values of the map returned by the `Instrumenter.Default#transformers()` method.\n+## How it works\n \n-All those references are then used to create a `ReferenceMatcher` instance.\n-The matcher is stored in the instrumentation class in method `ReferenceMatcher getInstrumentationMuzzle()`.\n+Muzzle has two phases:\n+* at compile time it collects references to the third-party symbols;\n+* at runtime it compares those references to the actual API symbols on the classpath.\n \n-At runtime the Muzzle checks API compatibility between symbols used by the Agent\n-and symbols in the application class loader. If the symbols do not match the instrumentation is not loaded.\n-Because the muzzle matcher is expensive, it is only performed after a match has been made by the\n-`SomeInstrumentation.classLoaderMatcher()` and `SomeInstrumentation.typeMatcher()` matchers.\n+### Compile-time reference collection\n+\n+The compile-time reference collection and code generation process is implemented using a ByteBuddy\n+plugin (called `MuzzleCodeGenerationPlugin`).\n+\n+For each instrumentation the ByteBuddy plugin collects symbols referring to both internal and third\n+party APIs used by the currently processed instrumentation. The reference collection process starts\n+from advice classes (values of the map returned by the `Instrumenter.Default#transformers()` method)\n+and traverses the class graph until it encounters a reference to a non-instrumentation class.\n+\n+All collected references are then used to create a `ReferenceMatcher` instance. This matcher\n+is stored in the instrumentation class in the method `Instrumenter.Default#getMuzzleReferenceMatcher()`.\n+The bytecode of this method (basically an array of `Reference` builder calls) is generated\n+automatically by the ByteBuddy plugin using an ASM code visitor.\n+\n+The source code of the compile-time plugin is located in the `javaagent-tooling` module,\n+package `io.opentelemetry.javaagent.tooling.muzzle.collector`.\n+\n+### Runtime reference matching\n+\n+The runtime reference matching process is implemented as a ByteBuddy matcher in `Instrumenter.Default`.\n+`MuzzleMatcher` uses the `getMuzzleReferenceMatcher()` method generated during the compilation phase\n+to verify that the class loader of the instrumented type has all necessary symbols (classes,\n+methods, fields). If the `ReferenceMatcher` finds any mismatch between collected references and the\n+actual application classpath types the whole instrumentation is discarded.\n+\n+It is worth noting that because the muzzle check is expensive, it is only performed after a match\n+has been made by the `InstrumenterDefault#classLoaderMatcher()` and `Instrumenter.Default#typeMatcher()`\n+matchers.\n+\n+The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n+class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n \n ## Muzzle gradle plugin\n \n-The `printReferences` task prints all API references in a given module.\n+The muzzle gradle plugin allows to perform the runtime reference matching process against different\n+third party library versions, when the project is built.\n \n-```bash\n-./gradlew :instrumentation:google-http-client-1.19:printReferences\n-```\n+Muzzle gradle plugin is just an additional utility for enhanced build-time checking.\n+**Even without using it muzzle reference matching is _always_ active in runtime**,\n+it's not an optional feature.\n+\n+The gradle plugin defines two tasks:\n+\n+* `printReferences` task prints all API references in a given module:\n+    ```sh\n+    ./gradlew :instrumentation:google-http-client-1.19:printReferences\n+    ```\n+\n+* `muzzle` task runs the runtime muzzle verification against different library versions:\n+    ```sh\n+    ./gradlew :instrumentation:google-http-client-1.19:muzzle\n+    ```\n+    If a new, incompatible version is published it fails the build.", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyNzUzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504127535", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The source code of the gradle plugin is located in the `buildSrd` directory.\n          \n          \n            \n            The source code of the gradle plugin is located in the `buildSrc` directory.", "author": "trask", "createdAt": "2020-10-13T17:18:18Z", "path": "docs/contributing/muzzle.md", "diffHunk": "@@ -1,42 +1,107 @@\n # Muzzle\n \n-Muzzle is a feature of the Java agent that ensures API compatibility\n-between libraries/symbols on the application classpath and APIs of instrumented\n-3rd party libraries used by the Agent. In other words the Muzzle ensures\n-that the API symbols used by the Agent are compatible with API symbols\n-on the application classpath. The Muzzle will prevent loading an instrumentation\n-if the APIs do not match.\n+Muzzle is a safety feature of the Java agent that prevents applying instrumentation when a mismatch\n+between the instrumentation code and the instrumented application code is detected.\n+It ensures API compatibility between symbols (classes, methods, fields) on the application classpath\n+and references to those symbols made by instrumentation advices defined in the agent.\n+In other words, muzzle ensures that the API symbols used by the agent are compatible with the API\n+symbols on the application classpath.\n \n-## How does it work\n+Muzzle will prevent loading an instrumentation if it detects any mismatch or conflict.\n \n-At build time, for each instrumentation the Muzzle ByteBuddy plugin collects symbols referring to both internal\n-and 3rd party APIs used by the currently processed instrumentation. The reference collection process starts\n-from advice classes - values of the map returned by the `Instrumenter.Default#transformers()` method.\n+## How it works\n \n-All those references are then used to create a `ReferenceMatcher` instance.\n-The matcher is stored in the instrumentation class in method `ReferenceMatcher getInstrumentationMuzzle()`.\n+Muzzle has two phases:\n+* at compile time it collects references to the third-party symbols;\n+* at runtime it compares those references to the actual API symbols on the classpath.\n \n-At runtime the Muzzle checks API compatibility between symbols used by the Agent\n-and symbols in the application class loader. If the symbols do not match the instrumentation is not loaded.\n-Because the muzzle matcher is expensive, it is only performed after a match has been made by the\n-`SomeInstrumentation.classLoaderMatcher()` and `SomeInstrumentation.typeMatcher()` matchers.\n+### Compile-time reference collection\n+\n+The compile-time reference collection and code generation process is implemented using a ByteBuddy\n+plugin (called `MuzzleCodeGenerationPlugin`).\n+\n+For each instrumentation the ByteBuddy plugin collects symbols referring to both internal and third\n+party APIs used by the currently processed instrumentation. The reference collection process starts\n+from advice classes (values of the map returned by the `Instrumenter.Default#transformers()` method)\n+and traverses the class graph until it encounters a reference to a non-instrumentation class.\n+\n+All collected references are then used to create a `ReferenceMatcher` instance. This matcher\n+is stored in the instrumentation class in the method `Instrumenter.Default#getMuzzleReferenceMatcher()`.\n+The bytecode of this method (basically an array of `Reference` builder calls) is generated\n+automatically by the ByteBuddy plugin using an ASM code visitor.\n+\n+The source code of the compile-time plugin is located in the `javaagent-tooling` module,\n+package `io.opentelemetry.javaagent.tooling.muzzle.collector`.\n+\n+### Runtime reference matching\n+\n+The runtime reference matching process is implemented as a ByteBuddy matcher in `Instrumenter.Default`.\n+`MuzzleMatcher` uses the `getMuzzleReferenceMatcher()` method generated during the compilation phase\n+to verify that the class loader of the instrumented type has all necessary symbols (classes,\n+methods, fields). If the `ReferenceMatcher` finds any mismatch between collected references and the\n+actual application classpath types the whole instrumentation is discarded.\n+\n+It is worth noting that because the muzzle check is expensive, it is only performed after a match\n+has been made by the `InstrumenterDefault#classLoaderMatcher()` and `Instrumenter.Default#typeMatcher()`\n+matchers.\n+\n+The source code of the runtime muzzle matcher is located in the `javaagent-tooling` module,\n+class `Instrumenter.Default` and package `io.opentelemetry.javaagent.tooling.muzzle.matcher`.\n \n ## Muzzle gradle plugin\n \n-The `printReferences` task prints all API references in a given module.\n+The muzzle gradle plugin allows to perform the runtime reference matching process against different\n+third party library versions, when the project is built.\n \n-```bash\n-./gradlew :instrumentation:google-http-client-1.19:printReferences\n-```\n+Muzzle gradle plugin is just an additional utility for enhanced build-time checking.\n+**Even without using it muzzle reference matching is _always_ active in runtime**,\n+it's not an optional feature.\n+\n+The gradle plugin defines two tasks:\n+\n+* `printReferences` task prints all API references in a given module:\n+    ```sh\n+    ./gradlew :instrumentation:google-http-client-1.19:printReferences\n+    ```\n+\n+* `muzzle` task runs the runtime muzzle verification against different library versions:\n+    ```sh\n+    ./gradlew :instrumentation:google-http-client-1.19:muzzle\n+    ```\n+    If a new, incompatible version is published it fails the build.\n \n-The `muzzle` task downloads 3rd party libraries from maven central and checks API compatibility.\n-If a new incompatible version is published it fails the build.\n+The muzzle plugin needs to be configured in the module's `.gradle` file.\n+Example:\n \n-```bash\n-./gradlew :instrumentation:google-http-client-1.19:muzzle\n+```groovy\n+muzzle {\n+  // it is expected that muzzle fails the runtime check for this component\n+  fail {\n+    group = \"commons-httpclient\"\n+    module = \"commons-httpclient\"\n+    // versions from this range are checked\n+    versions = \"[,4.0)\"\n+    // this version is not checked by muzzle\n+    skipVersions += '3.1-jenkins-1'\n+  }\n+  // it is expected that muzzle passes the runtime check for this component\n+  pass {\n+    group = \"org.apache.httpcomponents\"\n+    module = \"httpclient\"\n+    versions = \"[4.0,)\"\n+    // verify that all other versions - [,4.0) in this case - fail the muzzle runtime check\n+    assertInverse = true\n+  }\n+  // ...\n+}\n ```\n \n-## Muzzle location\n+* Using either `pass` or `fail` directive allows to specify whether muzzle should treat the\n+  reference check failure as expected behavior;\n+* `versions` is a version range, where `[]` is inclusive and `()` is exclusive. It is not needed to\n+  specify the exact version to start/end, e.g. `[1.0.0,4)` would usually behave in the same way as\n+  `[1.0.0,4.0.0-Alpha)`;\n+* `assertInverse` is basically a shortcut for adding an opposite directive for all library versions\n+  that are not included in the specified `versions` range.\n \n-* `buildSrc` - Muzzle Gradle plugin\n-* `agent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle` - Muzzle ByteBuddy plugin\n+The source code of the gradle plugin is located in the `buildSrd` directory.", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTU4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504131583", "bodyText": "\ud83d\ude2e I didn't know about named regex groups!", "author": "trask", "createdAt": "2020-10-13T17:25:07Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/MuzzleCodeGenerator.java", "diffHunk": "@@ -462,9 +465,21 @@ public void visitEnd() {\n       super.visitEnd();\n     }\n \n-    /** Append a field initializer to the end of a method. */\n-    public class InitializeFieldVisitor extends MethodVisitor {\n-      public InitializeFieldVisitor(MethodVisitor methodVisitor) {\n+    private static final Pattern ANONYMOUS_ENUM_CONSTANT_CLASS =\n+        Pattern.compile(\"(?<enumClass>.*)\\\\$[0-9]+$\");\n+\n+    // drops \"$1\" suffix for enum constants that override/implement super class methods\n+    private String getEnumClassInternalName(Reference.Flag flag) {\n+      String fullInternalName = Utils.getInternalName(flag.getClass().getName());\n+      Matcher m = ANONYMOUS_ENUM_CONSTANT_CLASS.matcher(fullInternalName);\n+      return m.matches() ? m.group(\"enumClass\") : fullInternalName;", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU0NTQ3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504545471", "bodyText": "It's a really awesome feature when you're working with large patterns with many groups - although I use them pretty much everywhere, just for the readability benefit \ud83d\ude04", "author": "mateuszrzeszutek", "createdAt": "2020-10-14T09:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzA4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504133082", "bodyText": "\ud83d\udc4d", "author": "trask", "createdAt": "2020-10-13T17:27:42Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -62,20 +72,22 @@\n \n       try (InputStream in =\n           checkNotNull(\n-              loader.getResourceAsStream(Utils.getResourceName(className)),\n+              ReferenceCollector.class\n+                  .getClassLoader()\n+                  .getResourceAsStream(Utils.getResourceName(className)),", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzMzM1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504133357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeMinimumFieldAccess(Type from, Type to) {\n          \n          \n            \n              private static MinimumVisibilityFlag computeMinimumFieldAccess(Type from, Type to) {", "author": "trask", "createdAt": "2020-10-13T17:28:08Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -126,16 +138,16 @@ private static String internalPackageName(String internalName) {\n    *\n    * @return A reference flag with the required level of access.\n    */\n-  private static Reference.Flag computeMinimumFieldAccess(Type from, Type to) {\n+  private static Flag computeMinimumFieldAccess(Type from, Type to) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNDcxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504134713", "bodyText": "feels a little odd to return two different kinds of enum from this method, maybe add MinimumVisibilityFlag.PUBLIC\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeMinimumClassAccess(Type from, Type to) {\n          \n          \n            \n              private static MinimumVisibilityFlag computeMinimumClassAccess(Type from, Type to) {", "author": "trask", "createdAt": "2020-10-13T17:30:28Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -110,14 +122,14 @@ private static String internalPackageName(String internalName) {\n    *\n    * @return A reference flag with the required level of access.\n    */\n-  private static Reference.Flag computeMinimumClassAccess(Type from, Type to) {\n+  private static Flag computeMinimumClassAccess(Type from, Type to) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU2NDA4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504564084", "bodyText": "Done.", "author": "mateuszrzeszutek", "createdAt": "2020-10-14T10:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNTAxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504135015", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeMinimumMethodAccess(Type from, Type to, Type methodType) {\n          \n          \n            \n              private static MinimumVisibilityFlag computeMinimumMethodAccess(Type from, Type to, Type methodType) {", "author": "trask", "createdAt": "2020-10-13T17:30:56Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -144,13 +156,13 @@ private static String internalPackageName(String internalName) {\n    *\n    * @return A reference flag with the required level of access.\n    */\n-  private static Reference.Flag computeMinimumMethodAccess(Type from, Type to, Type methodType) {\n+  private static Flag computeMinimumMethodAccess(Type from, Type to, Type methodType) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNTY5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504135694", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeVisibilityFlag(int access) {\n          \n          \n            \n              private static VisibilityFlag computeVisibilityFlag(int access) {", "author": "trask", "createdAt": "2020-10-13T17:32:16Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -275,36 +287,33 @@ public MethodVisitor visitMethod(\n         super.visitMethod(access, name, descriptor, signature, exceptions));\n   }\n \n-  /** @see net.bytebuddy.description.modifier.Visibility */\n   private static Flag computeVisibilityFlag(int access) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNTkyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504135920", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeOwnershipFlag(int access) {\n          \n          \n            \n              private static OwnershipFlag computeOwnershipFlag(int access) {", "author": "trask", "createdAt": "2020-10-13T17:32:42Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -275,36 +287,33 @@ public MethodVisitor visitMethod(\n         super.visitMethod(access, name, descriptor, signature, exceptions));\n   }\n \n-  /** @see net.bytebuddy.description.modifier.Visibility */\n   private static Flag computeVisibilityFlag(int access) {\n-    if (Flag.PUBLIC.matches(access)) {\n-      return Flag.PUBLIC;\n-    } else if (Flag.PROTECTED.matches(access)) {\n-      return Flag.PROTECTED;\n-    } else if (Flag.PACKAGE.matches(access)) {\n-      return Flag.PACKAGE;\n+    if (VisibilityFlag.PUBLIC.matches(access)) {\n+      return VisibilityFlag.PUBLIC;\n+    } else if (VisibilityFlag.PROTECTED.matches(access)) {\n+      return VisibilityFlag.PROTECTED;\n+    } else if (VisibilityFlag.PACKAGE.matches(access)) {\n+      return VisibilityFlag.PACKAGE;\n     } else {\n-      return Flag.PRIVATE;\n+      return VisibilityFlag.PRIVATE;\n     }\n   }\n \n-  /** @see net.bytebuddy.description.modifier.Ownership */\n   private static Flag computeOwnershipFlag(int access) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjAwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504136002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static Flag computeTypeManifestationFlag(int access) {\n          \n          \n            \n              private static ManifestationFlag computeTypeManifestationFlag(int access) {", "author": "trask", "createdAt": "2020-10-13T17:32:52Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/collector/ReferenceCollector.java", "diffHunk": "@@ -275,36 +287,33 @@ public MethodVisitor visitMethod(\n         super.visitMethod(access, name, descriptor, signature, exceptions));\n   }\n \n-  /** @see net.bytebuddy.description.modifier.Visibility */\n   private static Flag computeVisibilityFlag(int access) {\n-    if (Flag.PUBLIC.matches(access)) {\n-      return Flag.PUBLIC;\n-    } else if (Flag.PROTECTED.matches(access)) {\n-      return Flag.PROTECTED;\n-    } else if (Flag.PACKAGE.matches(access)) {\n-      return Flag.PACKAGE;\n+    if (VisibilityFlag.PUBLIC.matches(access)) {\n+      return VisibilityFlag.PUBLIC;\n+    } else if (VisibilityFlag.PROTECTED.matches(access)) {\n+      return VisibilityFlag.PROTECTED;\n+    } else if (VisibilityFlag.PACKAGE.matches(access)) {\n+      return VisibilityFlag.PACKAGE;\n     } else {\n-      return Flag.PRIVATE;\n+      return VisibilityFlag.PRIVATE;\n     }\n   }\n \n-  /** @see net.bytebuddy.description.modifier.Ownership */\n   private static Flag computeOwnershipFlag(int access) {\n-    if (Flag.STATIC.matches(access)) {\n-      return Flag.STATIC;\n+    if (OwnershipFlag.STATIC.matches(access)) {\n+      return OwnershipFlag.STATIC;\n     } else {\n-      return Flag.NON_STATIC;\n+      return OwnershipFlag.NON_STATIC;\n     }\n   }\n \n-  /** @see net.bytebuddy.description.modifier.TypeManifestation */\n   private static Flag computeTypeManifestationFlag(int access) {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MDAzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1379#discussion_r504140037", "bodyText": "nice simplifications to this class \ud83d\udc4d", "author": "trask", "createdAt": "2020-10-13T17:40:15Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/HelperReferenceWrapper.java", "diffHunk": "@@ -35,10 +33,10 @@\n    * @return An iterable containing the wrapped type's super class (if exists) and implemented\n    *     interfaces.\n    */\n-  Iterable<HelperReferenceWrapper> getSuperTypes();\n+  Stream<HelperReferenceWrapper> getSuperTypes();\n \n   /** @return An iterable with all non-private, non-static methods declared in the wrapped type. */\n-  Iterable<Method> getMethods();\n+  Stream<Method> getMethods();\n \n   final class Method {", "originalCommit": "9b6c56c40b0aad7ea3f03dc23bbfc67f1ad90c95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74c533f83183a71b28d156dbe98f0d868e4d4ebf", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/74c533f83183a71b28d156dbe98f0d868e4d4ebf", "message": "Muzzle improvements: docs, javadocs, renamings and minor refactoring", "committedDate": "2020-10-14T09:49:19Z", "type": "commit"}, {"oid": "ae7023acbdaf6b9a9fb8ee2060380fb222b662f8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ae7023acbdaf6b9a9fb8ee2060380fb222b662f8", "message": "Apply suggestions from code review\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-10-14T09:49:19Z", "type": "commit"}, {"oid": "d700aeed2ee88b3c7e581f6a908714bd68560f23", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d700aeed2ee88b3c7e581f6a908714bd68560f23", "message": "Muzzle improvements: docs, javadocs, renamings and minor refactoring", "committedDate": "2020-10-14T10:16:33Z", "type": "commit"}, {"oid": "d700aeed2ee88b3c7e581f6a908714bd68560f23", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d700aeed2ee88b3c7e581f6a908714bd68560f23", "message": "Muzzle improvements: docs, javadocs, renamings and minor refactoring", "committedDate": "2020-10-14T10:16:33Z", "type": "forcePushed"}]}