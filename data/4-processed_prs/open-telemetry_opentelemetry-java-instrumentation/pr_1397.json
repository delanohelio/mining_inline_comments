{"pr_number": 1397, "pr_title": "apache camel 2.20.x instrumentation", "pr_createdAt": "2020-10-15T11:00:09Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDM0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505460349", "bodyText": "You don't need advices in helperClassNames()", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:16:08Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.apache.camel.CamelContext\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+\n+    return not(isAbstract()).and(implementsInterface(named(\"org.apache.camel.CamelContext\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      getClass().getName() + \"$ContextAdvice\",", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NjkyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505696928", "bodyText": "\ud83d\ude46\u200d\u2642\ufe0f", "author": "kubawach", "createdAt": "2020-10-15T16:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDg0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505460841", "bodyText": "Nitpicking: why not just \"camel\"?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:17:07Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NzU4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505697586", "bodyText": "In source lib authors always used \"apache camel\" not just \"camel\". I guess it's a matter of full, proper naming - ther eare many camels, but only one by apache ;)", "author": "kubawach", "createdAt": "2020-10-15T16:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTE1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505461155", "bodyText": "Nitpicking again (\ud83d\ude04 ): how about just Collections.singletonMap()?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:17:46Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.apache.camel.CamelContext\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+\n+    return not(isAbstract()).and(implementsInterface(named(\"org.apache.camel.CamelContext\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      getClass().getName() + \"$ContextAdvice\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.SpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.BaseSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.DbSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.MessagingSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.HttpSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.InternalSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.KafkaSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.LogSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.RestSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.TimerSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.DecoratorRegistry\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.ActiveSpanManager\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.ActiveSpanManager$SpanWithScope\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil$MapGetter\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil$MapSetter\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelTracer\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelEventNotifier\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelRoutePolicy\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelTracingService\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelContextInstrumentation\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5ODY1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505698657", "bodyText": "That's actually not that NITpicking - done.", "author": "kubawach", "createdAt": "2020-10-15T16:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Mjc4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505462789", "bodyText": "The package naming convention has changed recently, please rename this to io.opentelemetry.javaagent.instrumentation.apachecamel", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:20:53Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelTracingService.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzEyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505707120", "bodyText": "It had to be really recently \ud83d\ude03", "author": "kubawach", "createdAt": "2020-10-15T17:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NTYzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505465631", "bodyText": "Consider adding @Nullable to parent", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:26:22Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated span: \" + spanWithScope);\n+    }\n+  }\n+\n+  /**\n+   * This method deactivates an existing active span associated with the supplied exchange. Once\n+   * deactivated, if a parent span is found associated with the stack for the exchange, it will be\n+   * restored as the current span for that exchange.\n+   *\n+   * @param exchange The exchange\n+   */\n+  public static void deactivate(Exchange exchange) {\n+\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      spanWithScope.deactivate();\n+      exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope.getParent());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Deactivated span: \" + spanWithScope);\n+      }\n+    }\n+  }\n+\n+  public static class SpanWithScope {\n+    private SpanWithScope parent;", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzMzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505707336", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-15T17:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NjMzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505466331", "bodyText": "Camel has type-safe getProperty(String, Class<T>) variant, consider using it instead of casting.", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:27:35Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxODQxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506218412", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-16T09:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505467287", "bodyText": "Nitpicking: consider making it an enum singleton", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:29:25Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelPropagationUtil.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Getter;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import java.util.Map;\n+\n+public class CamelPropagationUtil {\n+\n+  static Context extractParent(final Map<String, Object> exchangeHeaders) {\n+    return OpenTelemetry.getPropagators()\n+        .getTextMapPropagator()\n+        .extract(Context.current(), exchangeHeaders, MapGetter.INSTANCE);\n+  }\n+\n+  static void injectParent(Context context, final Map<String, Object> exchangeHeaders) {\n+    OpenTelemetry.getPropagators()\n+        .getTextMapPropagator()\n+        .inject(context, exchangeHeaders, MapSetter.INSTANCE);\n+  }\n+\n+  private static class MapGetter implements Getter<Map<String, Object>> {\n+\n+    private static final MapGetter INSTANCE = new MapGetter();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NDY2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505754665", "bodyText": "I believe that in OTEL such instances are always static finals (multiple places, really).", "author": "kubawach", "createdAt": "2020-10-15T18:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505467564", "bodyText": "How about making it final and adding private default constructor (since it's a util class)?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:29:55Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelPropagationUtil.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Getter;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import java.util.Map;\n+\n+public class CamelPropagationUtil {", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1ODU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505758564", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-15T18:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505514758", "bodyText": "Shouldn't you use span.recordException(throwable); here?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T12:51:02Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.instrumentation.auto.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint) {\n+    span.setAttribute(\"camel.uri\", URISupport.sanitizeUri(endpoint.getEndpointUri()));\n+  }\n+\n+  @Override\n+  public void post(Span span, Exchange exchange, Endpoint endpoint) {\n+    if (exchange.isFailed()) {\n+      span.setAttribute(\"error\", true);\n+      if (exchange.getException() != null) {\n+        Attributes logEvent =\n+            Attributes.newBuilder()\n+                .setAttribute(\"error.kind\", \"Exception\")\n+                .setAttribute(\"message\", exchange.getException().getMessage())\n+                .build();\n+        span.addEvent(\"error\", logEvent);", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NzgzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505757838", "bodyText": "Didn't know about that feature, nice!", "author": "kubawach", "createdAt": "2020-10-15T18:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjM2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505542366", "bodyText": "All parameters are the DB name?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:29:32Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.toString();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxOTg3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506219878", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-16T09:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0ODA0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505548047", "bodyText": "What do you think about replacing this stuff with a regex pattern?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:37:11Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/RestSpanDecorator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class RestSpanDecorator extends HttpSpanDecorator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RestSpanDecorator.class);\n+\n+  protected static String getPath(String uri) {\n+    // Obtain the 'path' part of the URI format: rest://method:path[:uriTemplate]?[options]\n+    String path = null;\n+    int index = uri.indexOf(':');\n+    if (index != -1) {\n+      index = uri.indexOf(':', index + 1);\n+      if (index != -1) {\n+        path = uri.substring(index + 1);\n+        index = path.indexOf('?');\n+        if (index != -1) {\n+          path = path.substring(0, index);\n+        }", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1ODg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505758898", "bodyText": "Programmer had an issue. He decided to fix it with regexp. Now programmer had two issues.", "author": "kubawach", "createdAt": "2020-10-15T18:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0ODA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505552155", "bodyText": "These are different than attribute names in KafkaConsumerTracer and KafkaProducerTracer. And by the way, shouldn't we add semantic conventions for Kafka?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:42:26Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/KafkaSpanDecorator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class KafkaSpanDecorator extends MessagingSpanDecorator {\n+\n+  public static final String KAFKA_PARTITION_TAG = \"kafka.partition\";\n+  public static final String KAFKA_PARTITION_KEY_TAG = \"kafka.partition.key\";\n+  public static final String KAFKA_KEY_TAG = \"kafka.key\";\n+  public static final String KAFKA_OFFSET_TAG = \"kafka.offset\";", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIyMzc3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506223776", "bodyText": "Well, the instrumentation for Kafka was changed 3 days ago, it was hard 7 days ago to reference it :D", "author": "kubawach", "createdAt": "2020-10-16T09:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzE4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506253186", "bodyText": "But yeah, let's align.", "author": "kubawach", "createdAt": "2020-10-16T10:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2MTAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505561010", "bodyText": "I know that I'm being a bit pessimistic, but this will randomly fail sooner or later. Consider retrying getting the port, like HttpServerTest does it.", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:53:43Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/SingleServiceCamelSpringBootBasedTest.groovy", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.google.common.collect.ImmutableMap\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.OkHttpUtils\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+import okhttp3.FormBody\n+import okhttp3.HttpUrl\n+import okhttp3.OkHttpClient\n+import okhttp3.Request\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class SingleServiceCamelSpringBootBasedTest extends AgentTestRunner {\n+\n+  @Shared\n+  ConfigurableApplicationContext server\n+  @Shared\n+  OkHttpClient client = OkHttpUtils.client()\n+  @Shared\n+  int port = PortUtils.randomOpenPort()", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MDY1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505760657", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-15T18:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2MTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MDY0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505570647", "bodyText": "Is it possible to use the route for operation name? (ass suggested in semantic conventions)", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:05:21Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0NzQwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505747402", "bodyText": "Theoretically - yes, obviously. Practically- not that much.\n\nHttp decorator serves multiple components - ahc, http, jetty, undertow.\nComponent route can include all GET parameters (query) - would yield high cardinality\nSame decorator is used for both sides (SERVER, CLIENT) - so being conservative (always use HTTP method) won\n\nAt the same time if there is a consensus that using method in all cases is wrong, I'm open to discuss alternatives, like:\n\nadding more http decorators to handle different cases separately\nremoving query\nThis however won't allow us to eg sanitize path fragments that are values and inevitably yields high cardinality.", "author": "kubawach", "createdAt": "2020-10-15T18:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505572537", "bodyText": "Having two CLIENT spans in a row looks wrong -- semantic convention says that CLIENT must be a parent of SERVER span.\nCan you merge those two spans into one?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:07:45Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/TwoServicesCamelSpringBootBasedTest.groovy", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+import static io.opentelemetry.trace.Span.Kind.INTERNAL\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.google.common.collect.ImmutableMap\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+import org.apache.camel.CamelContext\n+import org.apache.camel.ProducerTemplate\n+import org.apache.camel.builder.RouteBuilder\n+import org.apache.camel.impl.DefaultCamelContext\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class TwoServicesCamelSpringBootBasedTest extends AgentTestRunner {\n+\n+  @Shared\n+  int portOne = PortUtils.randomOpenPort()\n+  @Shared\n+  int portTwo = PortUtils.randomOpenPort()\n+  @Shared\n+  ConfigurableApplicationContext server\n+  @Shared\n+  CamelContext clientContext\n+\n+  def setupSpec() {\n+    createServer()\n+  }\n+\n+  def createServer() {\n+    def app = new SpringApplication(TwoServicesConfig)\n+    app.setDefaultProperties(ImmutableMap.of(\"service.one.port\", portOne, \"service.two.port\", portTwo))\n+    server = app.run()\n+  }\n+\n+  def createAndStartClient() {\n+    clientContext = new DefaultCamelContext()\n+    clientContext.addRoutes(new RouteBuilder() {\n+      void configure() {\n+        from(\"direct:input\")\n+          .log(\"SENT Client request\")\n+          .to(\"http://localhost:$portOne/serviceOne\")\n+          .log(\"RECEIVED Client response\")\n+      }\n+    })\n+    clientContext.start()\n+  }\n+\n+  def cleanupSpec() {\n+    if (server != null) {\n+      server.close()\n+      server = null\n+    }\n+  }\n+\n+  def \"two camel service spans\"() {\n+    setup:\n+    createAndStartClient()\n+    ProducerTemplate template = clientContext.createProducerTemplate()\n+\n+    when:\n+    template.sendBody(\"direct:input\", \"Example request\")\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 9) {\n+        it.span(0) {\n+          name \"input\"\n+          kind CLIENT\n+          attributes {\n+            \"camel.uri\" \"direct://input\"\n+          }\n+        }\n+        it.span(1) {\n+          name \"input\"\n+          kind INTERNAL\n+          attributes {\n+            \"camel.uri\" \"direct://input\"\n+          }\n+        }\n+        it.span(2) {\n+          name \"POST\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://localhost:$portOne/serviceOne\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"camel.uri\" \"http://localhost:$portOne/serviceOne\"\n+          }\n+        }\n+        it.span(3) {\n+          name \"HTTP POST\"\n+          kind CLIENT", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNjI3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505726275", "bodyText": "It's not something that Camel instrumentation can control. The second CLIENT span is generated by \"commons-http-client\" instrumentation that kicks in the middle of execution (ie is called by camel implementation).", "author": "kubawach", "createdAt": "2020-10-15T17:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyOTM5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505729399", "bodyText": "Then camel instrumentation should not generate the first span in the first place, I believe", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T17:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MTI3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505761274", "bodyText": "Then you're loosing data that can be valuable for customers. Also, Camel instr does not know if any internals used to execute the call are instrumented and will generate the span or not. How would you approach that?", "author": "kubawach", "createdAt": "2020-10-15T18:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2NTk4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506165989", "bodyText": "As discussed offline, two ideas:\n\ncreate Camel spans as INTERNAL, counting on another instrumentation creating CLIENT just before sending a message\nchange some of our \"last stage before sending\" instrumentations (in this case - http client) to check if parent span was CLIENT - if so, change it's type to become INTERNAL\n\n@trask @iNikem any thoughts on the above?", "author": "kubawach", "createdAt": "2020-10-16T08:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ5MjkxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508492919", "bodyText": "I believe there is a separate issue to handle such cases (#465). Will leave this as it is then.", "author": "kubawach", "createdAt": "2020-10-20T13:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505573682", "bodyText": "Hmm, most HTTP server frameworks (JAX-RS, Spring, ...) usually rename their SERVER span so that it has the actual route as its name. IS it possible to do in camel?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:09:16Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/TwoServicesCamelSpringBootBasedTest.groovy", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+import static io.opentelemetry.trace.Span.Kind.INTERNAL\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.google.common.collect.ImmutableMap\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+import org.apache.camel.CamelContext\n+import org.apache.camel.ProducerTemplate\n+import org.apache.camel.builder.RouteBuilder\n+import org.apache.camel.impl.DefaultCamelContext\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class TwoServicesCamelSpringBootBasedTest extends AgentTestRunner {\n+\n+  @Shared\n+  int portOne = PortUtils.randomOpenPort()\n+  @Shared\n+  int portTwo = PortUtils.randomOpenPort()\n+  @Shared\n+  ConfigurableApplicationContext server\n+  @Shared\n+  CamelContext clientContext\n+\n+  def setupSpec() {\n+    createServer()\n+  }\n+\n+  def createServer() {\n+    def app = new SpringApplication(TwoServicesConfig)\n+    app.setDefaultProperties(ImmutableMap.of(\"service.one.port\", portOne, \"service.two.port\", portTwo))\n+    server = app.run()\n+  }\n+\n+  def createAndStartClient() {\n+    clientContext = new DefaultCamelContext()\n+    clientContext.addRoutes(new RouteBuilder() {\n+      void configure() {\n+        from(\"direct:input\")\n+          .log(\"SENT Client request\")\n+          .to(\"http://localhost:$portOne/serviceOne\")\n+          .log(\"RECEIVED Client response\")\n+      }\n+    })\n+    clientContext.start()\n+  }\n+\n+  def cleanupSpec() {\n+    if (server != null) {\n+      server.close()\n+      server = null\n+    }\n+  }\n+\n+  def \"two camel service spans\"() {\n+    setup:\n+    createAndStartClient()\n+    ProducerTemplate template = clientContext.createProducerTemplate()\n+\n+    when:\n+    template.sendBody(\"direct:input\", \"Example request\")\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 9) {\n+        it.span(0) {\n+          name \"input\"\n+          kind CLIENT\n+          attributes {\n+            \"camel.uri\" \"direct://input\"\n+          }\n+        }\n+        it.span(1) {\n+          name \"input\"\n+          kind INTERNAL\n+          attributes {\n+            \"camel.uri\" \"direct://input\"\n+          }\n+        }\n+        it.span(2) {\n+          name \"POST\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://localhost:$portOne/serviceOne\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"camel.uri\" \"http://localhost:$portOne/serviceOne\"\n+          }\n+        }\n+        it.span(3) {\n+          name \"HTTP POST\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://localhost:$portOne/serviceOne\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"$SemanticAttributes.NET_PEER_NAME.key\" \"localhost\"\n+            \"$SemanticAttributes.NET_PEER_PORT.key\" portOne\n+            \"$SemanticAttributes.NET_TRANSPORT.key\" \"IP.TCP\"\n+            \"$SemanticAttributes.HTTP_FLAVOR.key\" \"1.1\"\n+          }\n+        }\n+        it.span(4) {\n+          name \"POST\"\n+          kind SERVER\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://localhost:$portOne/serviceOne\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"camel.uri\" \"http://0.0.0.0:$portOne/serviceOne\"\n+          }\n+        }\n+        it.span(5) {\n+          name \"POST\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://0.0.0.0:$portTwo/serviceTwo\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"camel.uri\" \"http://0.0.0.0:$portTwo/serviceTwo\"\n+          }\n+        }\n+        it.span(6) {\n+          name \"HTTP POST\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"POST\"\n+            \"$SemanticAttributes.HTTP_URL.key\" \"http://0.0.0.0:$portTwo/serviceTwo\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"$SemanticAttributes.NET_PEER_NAME.key\" \"0.0.0.0\"\n+            \"$SemanticAttributes.NET_PEER_PORT.key\" portTwo\n+            \"$SemanticAttributes.NET_TRANSPORT.key\" \"IP.TCP\"\n+            \"$SemanticAttributes.HTTP_FLAVOR.key\" \"1.1\"\n+            \"$SemanticAttributes.HTTP_USER_AGENT.key\" \"Jakarta Commons-HttpClient/3.1\"\n+          }\n+        }\n+        it.span(7) {\n+          name \"CachedChain.doFilter\"", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNDQ2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505724462", "bodyText": "It's not Camel, it's a servlet instrumentation ;)))", "author": "kubawach", "createdAt": "2020-10-15T17:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMDA5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505730097", "bodyText": "I know, bu the point stays: the \"web framework\" usually changes the server/servlet span name. Can it be done in camel?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T17:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2NzM1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505767359", "bodyText": "If I understand correctly - you're asking if Camel can set the name of the servlet that is being exposed (by Jetty component in this case) and instrumented by servlet instrumentation, currently generating span with \"CachedChain.doFilter\" name? IF this is the question the answer is - I don't think so (see https://camel.apache.org/components/latest/jetty-component.html). Besides it's not something that Camel instrumentation would do.", "author": "kubawach", "createdAt": "2020-10-15T18:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3MzUxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506173515", "bodyText": "Also discussed offline. Will propse something, although this seems tricky, due to Camel nature.", "author": "kubawach", "createdAt": "2020-10-16T08:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2MDEwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506260104", "bodyText": "Done for HTTP components, although I'm not a huge fan of the implementation.", "author": "kubawach", "createdAt": "2020-10-16T10:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MzY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NTk1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505575951", "bodyText": "This is wrong too, there's no SERVER child for that span. direct camel component isn't really a server by the way, so maybe this trace should start with an INTERNAL span? It's not really a real-life scenario anyway, since you can only call direct:* from inside.", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:12:21Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/TwoServicesCamelSpringBootBasedTest.groovy", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+import static io.opentelemetry.trace.Span.Kind.INTERNAL\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.google.common.collect.ImmutableMap\n+import io.opentelemetry.auto.test.AgentTestRunner\n+import io.opentelemetry.auto.test.utils.PortUtils\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+import org.apache.camel.CamelContext\n+import org.apache.camel.ProducerTemplate\n+import org.apache.camel.builder.RouteBuilder\n+import org.apache.camel.impl.DefaultCamelContext\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class TwoServicesCamelSpringBootBasedTest extends AgentTestRunner {\n+\n+  @Shared\n+  int portOne = PortUtils.randomOpenPort()\n+  @Shared\n+  int portTwo = PortUtils.randomOpenPort()\n+  @Shared\n+  ConfigurableApplicationContext server\n+  @Shared\n+  CamelContext clientContext\n+\n+  def setupSpec() {\n+    createServer()\n+  }\n+\n+  def createServer() {\n+    def app = new SpringApplication(TwoServicesConfig)\n+    app.setDefaultProperties(ImmutableMap.of(\"service.one.port\", portOne, \"service.two.port\", portTwo))\n+    server = app.run()\n+  }\n+\n+  def createAndStartClient() {\n+    clientContext = new DefaultCamelContext()\n+    clientContext.addRoutes(new RouteBuilder() {\n+      void configure() {\n+        from(\"direct:input\")\n+          .log(\"SENT Client request\")\n+          .to(\"http://localhost:$portOne/serviceOne\")\n+          .log(\"RECEIVED Client response\")\n+      }\n+    })\n+    clientContext.start()\n+  }\n+\n+  def cleanupSpec() {\n+    if (server != null) {\n+      server.close()\n+      server = null\n+    }\n+  }\n+\n+  def \"two camel service spans\"() {\n+    setup:\n+    createAndStartClient()\n+    ProducerTemplate template = clientContext.createProducerTemplate()\n+\n+    when:\n+    template.sendBody(\"direct:input\", \"Example request\")\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 9) {\n+        it.span(0) {\n+          name \"input\"\n+          kind CLIENT", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczODI1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505738251", "bodyText": "That's a really good question.\nIMO setting \"direct\" as CLIENT is OK, as \"direct\" is a way to call a route (with remote services in line). We may model this as a Camel equivalent of a HttpClient. However as you pointed out - this does not go in line with SemConv recommendation. There may be some client side processing - producing INTERNAL spans before equivalent SERVER span is created. Heck, the route can be entirely local (without any SERVER spans). Same would apply to eg \"timer\" spans.\nAnyone else would like to comment on that matter? @iNikem ? @trask ? :)", "author": "kubawach", "createdAt": "2020-10-15T18:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ5MjI4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508492285", "bodyText": "Decided to reimplement internal components as \"INTERNAL\" spans. Data produced looks much better now.", "author": "kubawach", "createdAt": "2020-10-20T13:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NzA0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505577045", "bodyText": "Why stop at 2.20.3? Won't thiswork for later 2.x versions?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:13:51Z", "path": "instrumentation/apache-camel-2.20/apache-camel-2.20.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"org.apache.camel\"\n+    module = \"camel-core\"\n+    versions = \"[2.20.1,3)\"\n+  }\n+}\n+\n+dependencies {\n+  library group: 'org.apache.camel', name: 'camel-core', version: '2.20.1'\n+\n+  testImplementation project(':instrumentation:apache-httpclient:apache-httpclient-2.0')\n+  testImplementation project(':instrumentation:servlet:servlet-2.2')\n+  testImplementation project(':instrumentation:servlet:servlet-3.0')\n+\n+  testImplementation group: 'org.spockframework', name: 'spock-spring', version: \"$versions.spock\"\n+\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.5.17.RELEASE'\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter', version: '1.5.17.RELEASE'\n+\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-jetty-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-http-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-jaxb-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-undertow', version: '2.20.1'\n+\n+  testImplementation 'javax.xml.bind:jaxb-api:2.3.1'\n+\n+  latestDepTestLibrary group: 'org.apache.camel', name: 'camel-core', version: '2.20.3'", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNzQ3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505727471", "bodyText": "Haven't tested - can try latest 2.x (2.25.2)", "author": "kubawach", "createdAt": "2020-10-15T17:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NzA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyOTY4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505729686", "bodyText": "You can just remove this line if the latest one works", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T17:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3NzA0NQ=="}], "type": "inlineReview"}, {"oid": "7a7bff262b48b44feabf0644de6d7248fdfbe22f", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7a7bff262b48b44feabf0644de6d7248fdfbe22f", "message": "code review #2 / experimental server name update", "committedDate": "2020-10-16T10:24:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NjUyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506786521", "bodyText": "I'm trying this pattern and it seems to work well to keep the copyrights together, what do you think?\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/build.gradle#L331\nAlso if the original isn't shortened I don't know if we're allowed to - IANAL but my understanding is we need to preserve the original header without modification.", "author": "anuraaga", "createdAt": "2020-10-17T03:06:35Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+/*\n+ * Includes work from:", "originalCommit": "7a7bff262b48b44feabf0644de6d7248fdfbe22f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ5MTU0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508491544", "bodyText": "Excellent idea! Reformatted to put \"includes\" header right after our license. Also, unwinded the original one per suggestion.", "author": "kubawach", "createdAt": "2020-10-20T13:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxMTg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508711898", "bodyText": "super minor...but why the extra CR here at the beginning of the method? I see this on some methods, but not all of them.", "author": "jkwatson", "createdAt": "2020-10-20T17:30:57Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+", "originalCommit": "a678c0826714380753504a3e66299c7cfc38ad0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4NDM0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515984342", "bodyText": "Usually I add extra CR when I believe it increases readability of the code (due to long method signature). Rule of thumb frankly.", "author": "kubawach", "createdAt": "2020-11-02T13:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxMTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxNTAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508715036", "bodyText": "this method is really big. What do you think about extracting methods for each of the two branches?", "author": "jkwatson", "createdAt": "2020-10-20T17:36:23Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/CamelEventNotifier.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.trace.Span;\n+import java.util.EventObject;\n+import org.apache.camel.management.event.ExchangeSendingEvent;\n+import org.apache.camel.management.event.ExchangeSentEvent;\n+import org.apache.camel.support.EventNotifierSupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+final class CamelEventNotifier extends EventNotifierSupport {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CamelEventNotifier.class);\n+\n+  @Override\n+  public void notify(EventObject event) {\n+\n+    try {\n+      /** Camel about to send (outbound). */\n+      if (event instanceof ExchangeSendingEvent) {\n+        ExchangeSendingEvent ese = (ExchangeSendingEvent) event;\n+        SpanDecorator sd = CamelTracer.TRACER.getSpanDecorator(ese.getEndpoint());\n+        if (!sd.shouldStartNewSpan()) {\n+          return;\n+        }\n+\n+        Span span =\n+            CamelTracer.TRACER.startSpan(\n+                sd.getOperationName(ese.getExchange(), ese.getEndpoint()),\n+                sd.getInitiatorSpanKind());\n+        sd.pre(span, ese.getExchange(), ese.getEndpoint(), CamelDirection.OUTBOUND);\n+        CamelPropagationUtil.injectParent(\n+            Context.current(), ese.getExchange().getIn().getHeaders());\n+        ActiveSpanManager.activate(ese.getExchange(), span);\n+\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(\"[Exchange sending] Initiator span started \" + span);\n+        }\n+        /** Camel finished sending (outbound). Finish span and remove it from CAMEL holder. */\n+      } else if (event instanceof ExchangeSentEvent) {\n+        ExchangeSentEvent ese = (ExchangeSentEvent) event;\n+        SpanDecorator sd = CamelTracer.TRACER.getSpanDecorator(ese.getEndpoint());\n+        if (!sd.shouldStartNewSpan()) {\n+          return;\n+        }\n+        Span span = ActiveSpanManager.getSpan(ese.getExchange());\n+        if (span != null) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"[Exchange sent] Initiator span finished \" + span);\n+          }\n+          sd.post(span, ese.getExchange(), ese.getEndpoint());\n+          ActiveSpanManager.deactivate(ese.getExchange());\n+        } else {\n+          LOG.warn(\"Could not find managed span for exchange \" + ese.getExchange());\n+        }\n+      }\n+    } catch (Throwable t) {\n+      LOG.warn(\"Failed to capture tracing data\", t);\n+    }\n+  }", "originalCommit": "a678c0826714380753504a3e66299c7cfc38ad0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNjcyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510036727", "bodyText": "Done.", "author": "kubawach", "createdAt": "2020-10-22T10:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxNTAzNg=="}], "type": "inlineReview"}, {"oid": "cf28e5b441a5918c575b65ba4cf7639c845c7f20", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cf28e5b441a5918c575b65ba4cf7639c845c7f20", "message": "rebase changes", "committedDate": "2020-10-20T19:43:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MDEwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510160100", "bodyText": "Minor: those fields can be final", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:27:01Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated a span: \" + spanWithScope);\n+    }\n+  }\n+\n+  /**\n+   * This method deactivates an existing active span associated with the supplied exchange. Once\n+   * deactivated, if a parent span is found associated with the stack for the exchange, it will be\n+   * restored as the current span for that exchange.\n+   *\n+   * @param exchange The exchange\n+   */\n+  public static void deactivate(Exchange exchange) {\n+\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      spanWithScope.deactivate();\n+      exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope.getParent());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Deactivated span: \" + spanWithScope);\n+      }\n+    }\n+  }\n+\n+  public static class SpanWithScope {\n+    @Nullable private SpanWithScope parent;\n+    private Span span;\n+    private Scope scope;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTk1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511959958", "bodyText": "+3", "author": "kubawach", "createdAt": "2020-10-26T13:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MDEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MTcyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510161724", "bodyText": "You can use slf4j placeholders:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (LOG.isTraceEnabled()) {\n          \n          \n            \n                  LOG.trace(\"Activated a span: \" + spanWithScope);\n          \n          \n            \n                }\n          \n          \n            \n                LOG.trace(\"Activated a span: {}\", spanWithScope);", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:29:10Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated a span: \" + spanWithScope);\n+    }", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2Njc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510166795", "bodyText": "Is this really needed?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:36:00Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/CamelEventNotifier.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.trace.Span;\n+import java.util.EventObject;\n+import org.apache.camel.management.event.ExchangeSendingEvent;\n+import org.apache.camel.management.event.ExchangeSentEvent;\n+import org.apache.camel.support.EventNotifierSupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+final class CamelEventNotifier extends EventNotifierSupport {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CamelEventNotifier.class);\n+\n+  @Override\n+  public void notify(EventObject event) {\n+\n+    try {\n+      if (event instanceof ExchangeSendingEvent) {\n+        onExchangeSending((ExchangeSendingEvent) event);\n+      } else if (event instanceof ExchangeSentEvent) {\n+        onExchangeSent((ExchangeSentEvent) event);\n+      }\n+    } catch (Throwable t) {\n+      LOG.warn(\"Failed to capture tracing data\", t);\n+    }\n+  }\n+\n+  /** Camel about to send (outbound). */\n+  private void onExchangeSending(ExchangeSendingEvent event) {\n+    ExchangeSendingEvent ese = event;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MDUzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511960533", "bodyText": "Nope.", "author": "kubawach", "createdAt": "2020-10-26T13:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2Njc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MjY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510172661", "bodyText": "I don't think that span name can be null. Can you return any default string value? Like just \"Camel\"; I believe that is an edge case anyway.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:43:53Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTc3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511961777", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-26T13:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3NzY4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510177689", "bodyText": "I don't think that this is in accordance with the spec.\nFor the case when exchange.getException() is null (so the exchange message has a fault, whatever that means) how about you add an almost-empty exception event? Without stacktrace or anything, just a message saying that the exchange had a fault.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:50:25Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    span.setAttribute(\"camel.uri\", URISupport.sanitizeUri(endpoint.getEndpointUri()));\n+  }\n+\n+  @Override\n+  public void post(Span span, Exchange exchange, Endpoint endpoint) {\n+    if (exchange.isFailed()) {\n+      span.setAttribute(\"error\", true);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3NjgzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511976830", "bodyText": "Digging deeper - I'll change the attribute to status (span.setStatus(StatusCanonicalCode.ERROR). Adding an exception however IMO goes against the spec that specifically describes exception (not error in general) handling. Also looking into eg BaseDecorator class we see that there is no \"empty exception\" added if throwable passed is null.", "author": "kubawach", "createdAt": "2020-10-26T13:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3NzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510179869", "bodyText": "We should probably mask those statements - I'm in the middle of implementing masking for all databases that don't have it, so how about you create another issue for using those in camel?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:53:13Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          URI uri = URI.create(endpoint.getEndpointUri());\n+          if (uri.getPath() != null && uri.getPath().length() > 0) {\n+            // Strip leading '/' from path\n+            return uri.getPath().substring(1);\n+          }\n+        }\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"indexName\")) {\n+            return queryParameters.get(\"indexName\");\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    span.setAttribute(SemanticAttributes.DB_SYSTEM, system);\n+    String statement = getStatement(exchange, endpoint);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcyNDU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512724564", "bodyText": "Yep. Good idea.", "author": "kubawach", "createdAt": "2020-10-27T14:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcyNzMwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512727307", "bodyText": "#1499", "author": "kubawach", "createdAt": "2020-10-27T14:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MDIzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510180233", "bodyText": "db.name is same as db.statement?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:53:41Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MDc1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512740751", "bodyText": "Good catch, should serialize all params for statement.", "author": "kubawach", "createdAt": "2020-10-27T14:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MDIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MjI0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510182246", "bodyText": "You can use 2.+ instead", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:56:15Z", "path": "instrumentation/apache-camel-2.20/apache-camel-2.20.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"org.apache.camel\"\n+    module = \"camel-core\"\n+    versions = \"[2.20.1,3)\"\n+  }\n+}\n+\n+dependencies {\n+  library group: 'org.apache.camel', name: 'camel-core', version: '2.20.1'\n+\n+  testImplementation project(':instrumentation:apache-httpclient:apache-httpclient-2.0')\n+  testImplementation project(':instrumentation:servlet:servlet-2.2')\n+  testImplementation project(':instrumentation:servlet:servlet-3.0')\n+\n+  testImplementation group: 'org.spockframework', name: 'spock-spring', version: \"$versions.spock\"\n+\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.5.17.RELEASE'\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter', version: '1.5.17.RELEASE'\n+\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-jetty-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-http-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-jaxb-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-undertow', version: '2.20.1'\n+\n+  testImplementation 'javax.xml.bind:jaxb-api:2.3.1'\n+\n+  latestDepTestLibrary group: 'org.apache.camel', name: 'camel-core', version: '2.25.2'", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0NzIzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512747236", "bodyText": "I don't really believe that there will be more releases of 2.x stream, but yeah, why not.", "author": "kubawach", "createdAt": "2020-10-27T14:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1MzcwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512753705", "bodyText": "Yeah, it's more for the readability - when you see 2.+ you're immediately sure that it covers all versions.", "author": "mateuszrzeszutek", "createdAt": "2020-10-27T14:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNTcxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510225715", "bodyText": "s/partition/value/", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T14:50:10Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/KafkaSpanDecorator.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class KafkaSpanDecorator extends MessagingSpanDecorator {\n+\n+  private static final String PARTITION_KEY = \"kafka.PARTITION_KEY\";\n+  private static final String PARTITION = \"kafka.PARTITION\";\n+  private static final String KEY = \"kafka.KEY\";\n+  private static final String TOPIC = \"kafka.TOPIC\";\n+  private static final String OFFSET = \"kafka.OFFSET\";\n+\n+  public KafkaSpanDecorator() {\n+    super(\"kafka\");\n+  }\n+\n+  @Override\n+  public String getDestination(Exchange exchange, Endpoint endpoint) {\n+    String topic = (String) exchange.getIn().getHeader(TOPIC);\n+    if (topic == null) {\n+      Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+      topic = queryParameters.get(\"topic\");\n+    }\n+    return topic != null ? topic : super.getDestination(exchange, endpoint);\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    span.setAttribute(SemanticAttributes.MESSAGING_OPERATION, \"process\");\n+    span.setAttribute(SemanticAttributes.MESSAGING_DESTINATION_KIND, \"topic\");\n+\n+    String partition = getValue(exchange, PARTITION, Integer.class);\n+    if (partition != null) {\n+      span.setAttribute(\"partition\", partition);\n+    }\n+\n+    String partitionKey = (String) exchange.getIn().getHeader(PARTITION_KEY);\n+    if (partitionKey != null) {\n+      span.setAttribute(\"partitionKey\", partitionKey);\n+    }\n+\n+    String key = (String) exchange.getIn().getHeader(KEY);\n+    if (key != null) {\n+      span.setAttribute(\"key\", key);\n+    }\n+\n+    String offset = getValue(exchange, OFFSET, Long.class);\n+    if (offset != null) {\n+      span.setAttribute(\"offset\", offset);\n+    }\n+  }\n+\n+  /**\n+   * Extracts header value from the exchange for given header\n+   *\n+   * @param exchange the {@link Exchange}\n+   * @param header the header name\n+   * @param type the class type of the exchange header\n+   * @return\n+   */\n+  private <T> String getValue(final Exchange exchange, final String header, Class<T> type) {\n+    T partition = exchange.getIn().getHeader(header, type);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjczMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511962730", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-26T13:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510232175", "bodyText": "Hmm, why are you storing all the path params as attributes?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T14:58:22Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/RestSpanDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class RestSpanDecorator extends HttpSpanDecorator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RestSpanDecorator.class);\n+\n+  protected static String getPath(String uri) {\n+    // Obtain the 'path' part of the URI format: rest://method:path[:uriTemplate]?[options]\n+    String path = null;\n+    int index = uri.indexOf(':');\n+    if (index != -1) {\n+      index = uri.indexOf(':', index + 1);\n+      if (index != -1) {\n+        path = uri.substring(index + 1);\n+        index = path.indexOf('?');\n+        if (index != -1) {\n+          path = path.substring(0, index);\n+        }\n+        path = path.replaceAll(\":\", \"\");\n+        try {\n+          path = URLDecoder.decode(path, \"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+          LOG.debug(\"Failed to decode URL path '\" + path + \"', ignoring exception\", e);\n+        }\n+      }\n+    }\n+    return path;\n+  }\n+\n+  protected static List<String> getParameters(String path) {\n+    List<String> parameters = null;\n+\n+    int startIndex = path.indexOf('{');\n+    while (startIndex != -1) {\n+      int endIndex = path.indexOf('}', startIndex);\n+      if (endIndex != -1) {\n+        if (parameters == null) {\n+          parameters = new ArrayList<>();\n+        }\n+        parameters.add(path.substring(startIndex + 1, endIndex));\n+        startIndex = path.indexOf('{', endIndex);\n+      } else {\n+        // Break out of loop as no valid end token\n+        startIndex = -1;\n+      }\n+    }\n+\n+    return parameters == null ? Collections.emptyList() : parameters;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    return getPath(endpoint.getEndpointUri());\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    getParameters(getPath(endpoint.getEndpointUri()))\n+        .forEach(\n+            param -> {\n+              Object value = exchange.getIn().getHeader(param);\n+              if (value != null) {\n+                span.setAttribute(param, (String) value);\n+              }\n+            });", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MTQzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511971435", "bodyText": "This was Camel's authors decision to store all REST parameters as separate attributes. The idea behind that is a mystery for me. The question is - does this fit into our (OTEL) spec? It's clearly not \"semantic\" but may be of some benefit for customers.", "author": "kubawach", "createdAt": "2020-10-26T13:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjA3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512092071", "bodyText": "All other web frameworks do not log params. Besides, the full URI is still available as http.url, right?", "author": "mateuszrzeszutek", "createdAt": "2020-10-26T16:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNTE0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512215148", "bodyText": "It is - but as camel.uri. I can remove the params, the question is if a customer already using Camel instrumentation won't miss these.", "author": "kubawach", "createdAt": "2020-10-26T19:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510235852", "bodyText": "I guess that for server components (jetty, servlet, ...) it's fine to just use the path, there shouldn't be any path parameters there. But for rest component we should use the route - can you make sure that RestSpanDecorator uses the correct value here?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T15:03:08Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.instrumentation.api.tracer.BaseTracer;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    String httpUrl = getHttpURL(exchange, endpoint);\n+    if (httpUrl != null) {\n+      span.setAttribute(SemanticAttributes.HTTP_URL, httpUrl);\n+    }\n+\n+    span.setAttribute(SemanticAttributes.HTTP_METHOD, getHttpMethod(exchange, endpoint));\n+\n+    Span serverSpan = BaseTracer.CONTEXT_SERVER_SPAN_KEY.get(Context.current());\n+    if (shouldUpdateServerSpanName(serverSpan, camelDirection)) {\n+      updateServerSpanName(serverSpan, httpUrl);\n+    }\n+  }\n+\n+  private boolean shouldUpdateServerSpanName(Span serverSpan, CamelDirection camelDirection) {\n+\n+    return (serverSpan != null && CamelDirection.INBOUND.equals(camelDirection));\n+  }\n+\n+  private void updateServerSpanName(Span serverSpan, String httpUrl) {\n+    try {\n+      URL url = new URL(httpUrl);\n+      serverSpan.updateName(url.getPath());\n+    } catch (MalformedURLException e) {\n+      // ignored\n+    }", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2NDcwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511964700", "bodyText": "It's for inbound only - so jetty, servlet, undertow, restlet server. After previous code review i decided to use path (instead of operation name). What do you mean by \"route\" then ?", "author": "kubawach", "createdAt": "2020-10-26T13:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjcyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512092720", "bodyText": "What do you mean by \"route\" then ?\n\nThe URI template, like /resource/{id}/something", "author": "mateuszrzeszutek", "createdAt": "2020-10-26T16:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNTk0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512215947", "bodyText": "But it is - have a look at the RestSpanDecorator - it logs \"path\" of the rest component.", "author": "kubawach", "createdAt": "2020-10-26T19:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzOTkzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510239937", "bodyText": "HTTP clients should use HTTP METHOD span name:\n\nHTTP client spans SHOULD be using conservative, low cardinality names formed from the available parameters of an HTTP request, such as \"HTTP {METHOD_NAME}\".\n\nIn case of inbound spans I think using the path would be fine here.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T15:08:34Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.instrumentation.api.tracer.BaseTracer;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4Mjc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511982795", "bodyText": "Yep, we can do that, since we already update server span.", "author": "kubawach", "createdAt": "2020-10-26T14:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzOTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjAzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510242033", "bodyText": "Are you sure that this is 100% deterministic?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T15:11:23Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/MulticastDirectCamelTest.groovy", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.INTERNAL\n+\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import org.apache.camel.CamelContext\n+import org.apache.camel.ProducerTemplate\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class MulticastDirectCamelTest extends AgentTestRunner {\n+\n+  @Shared\n+  ConfigurableApplicationContext server\n+\n+  def setupSpec() {\n+    def app = new SpringApplication(MulticastConfig)\n+    server = app.run()\n+  }\n+\n+  def cleanupSpec() {\n+    if (server != null) {\n+      server.close()\n+      server = null\n+    }\n+  }\n+\n+  def \"parallel multicast to two child services\"() {\n+    setup:\n+    def camelContext = server.getBean(CamelContext)\n+    ProducerTemplate template = camelContext.createProducerTemplate()\n+\n+    when:\n+    template.sendBody(\"direct:input\", \"Example request\")\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 3) {\n+        def parent = it\n+        it.span(0) {\n+          name \"input\"\n+          kind INTERNAL\n+          hasNoParent()\n+          attributes {\n+            \"camel.uri\" \"direct://input\"\n+          }\n+        }\n+        it.span(1) {\n+          name \"second\"", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3ODk3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511978975", "bodyText": "In all of the tests I performed it was, although I could not find a way to prove this synthetically.", "author": "kubawach", "createdAt": "2020-10-26T13:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0MjAzMw=="}], "type": "inlineReview"}, {"oid": "4ca07f65841955813dda2c92e1e44bfdc12db906", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ca07f65841955813dda2c92e1e44bfdc12db906", "message": "code review changes, REST tests added", "committedDate": "2020-10-26T22:15:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgzNTA3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512835076", "bodyText": "Would it be possible to make the method that generates parent span name protected and override it in rest decorator? Ideally the span name would be /api/{module}/unit/{unitId}", "author": "mateuszrzeszutek", "createdAt": "2020-10-27T16:19:20Z", "path": "instrumentation/apache-camel-2.20/src/test/groovy/test/RestCamelTest.groovy", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package test\n+\n+import static io.opentelemetry.trace.Span.Kind.CLIENT\n+import static io.opentelemetry.trace.Span.Kind.INTERNAL\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.google.common.collect.ImmutableMap\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import io.opentelemetry.instrumentation.test.utils.PortUtils\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+import org.apache.camel.CamelContext\n+import org.apache.camel.ProducerTemplate\n+import org.springframework.boot.SpringApplication\n+import org.springframework.context.ConfigurableApplicationContext\n+import spock.lang.Shared\n+\n+class RestCamelTest extends AgentTestRunner {\n+\n+  @Shared\n+  ConfigurableApplicationContext server\n+  @Shared\n+  int port\n+\n+  def setupSpec() {\n+    withRetryOnAddressAlreadyInUse({\n+      setupSpecUnderRetry()\n+    })\n+  }\n+\n+  def setupSpecUnderRetry() {\n+    port = PortUtils.randomOpenPort()\n+    def app = new SpringApplication(RestConfig)\n+    app.setDefaultProperties(ImmutableMap.of(\"restServer.port\", port))\n+    server = app.run()\n+    println getClass().name + \" http server started at: http://localhost:$port/\"\n+  }\n+\n+  def cleanupSpec() {\n+    if (server != null) {\n+      server.close()\n+      server = null\n+    }\n+  }\n+\n+  def \"rest component - server and client call with jetty backend\"() {\n+    setup:\n+    def camelContext = server.getBean(CamelContext)\n+    ProducerTemplate template = camelContext.createProducerTemplate()\n+\n+    when:\n+    // run client and server in separate threads to simulate \"real\" rest client/server call\n+    new Thread(new Runnable() {\n+      @Override\n+      void run() {\n+        template.sendBodyAndHeaders(\"direct:start\", null, ImmutableMap.of(\"module\", \"firstModule\", \"unitId\", \"unitOne\"))\n+      }\n+    }\n+    ).start()\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 5) {\n+        it.span(0) {\n+          name \"start\"\n+          kind INTERNAL\n+          attributes {\n+            \"camel.uri\" \"direct://start\"\n+          }\n+        }\n+        it.span(1) {\n+          name \"GET\"\n+          kind CLIENT\n+          attributes {\n+            \"$SemanticAttributes.HTTP_METHOD.key\" \"GET\"\n+            \"$SemanticAttributes.HTTP_STATUS_CODE.key\" 200\n+            \"camel.uri\" \"rest://get:api/%7Bmodule%7D/unit/%7BunitId%7D\"\n+          }\n+        }\n+        it.span(2) {\n+          name \"/api/firstModule/unit/unitOne\"\n+          kind SERVER", "originalCommit": "ef7e66be07bca9520250797d8450bdc2ac85165a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzODUwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r513338506", "bodyText": "Done, now also server span update for REST follows desired convention.", "author": "kubawach", "createdAt": "2020-10-28T10:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgzNTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMxMjg3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r514312876", "bodyText": "Why do you want both?", "author": "iNikem", "createdAt": "2020-10-29T14:42:04Z", "path": "instrumentation/apache-camel-2.20/apache-camel-2.20.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"org.apache.camel\"\n+    module = \"camel-core\"\n+    versions = \"[2.20.1,3)\"\n+  }\n+}\n+\n+dependencies {\n+  library group: 'org.apache.camel', name: 'camel-core', version: '2.20.1'\n+\n+  testImplementation project(':instrumentation:apache-httpclient:apache-httpclient-2.0')\n+  testImplementation project(':instrumentation:servlet:servlet-2.2')\n+  testImplementation project(':instrumentation:servlet:servlet-3.0')", "originalCommit": "db74f28b2aec874ec7a2f90a80d3a4186e969c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4NzA5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515987093", "bodyText": "I was under the impression that both are needed for tests (different camel components using different servlet impl under the hood). After retest - only 3.0 is needed, so removing the other one.", "author": "kubawach", "createdAt": "2020-11-02T13:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMxMjg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMxMzE4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r514313185", "bodyText": "Duplicate?", "author": "iNikem", "createdAt": "2020-10-29T14:42:27Z", "path": "instrumentation/apache-camel-2.20/apache-camel-2.20.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"$rootDir/gradle/instrumentation.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"org.apache.camel\"\n+    module = \"camel-core\"\n+    versions = \"[2.20.1,3)\"\n+  }\n+}\n+\n+dependencies {\n+  library group: 'org.apache.camel', name: 'camel-core', version: '2.20.1'\n+\n+  testImplementation project(':instrumentation:apache-httpclient:apache-httpclient-2.0')\n+  testImplementation project(':instrumentation:servlet:servlet-2.2')\n+  testImplementation project(':instrumentation:servlet:servlet-3.0')\n+\n+  testImplementation group: 'org.spockframework', name: 'spock-spring', version: \"$versions.spock\"\n+\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.5.17.RELEASE'\n+  testImplementation group: 'org.springframework.boot', name: 'spring-boot-starter', version: '1.5.17.RELEASE'\n+\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'\n+  testImplementation group: 'org.apache.camel', name: 'camel-spring-boot-starter', version: '2.20.1'", "originalCommit": "db74f28b2aec874ec7a2f90a80d3a4186e969c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4NTU0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515985542", "bodyText": "Yes, removed.", "author": "kubawach", "createdAt": "2020-11-02T13:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMxMzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMDIzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r514320234", "bodyText": "All other classes have to be public? Or some of them can have reduce visibility?", "author": "iNikem", "createdAt": "2020-10-29T14:51:21Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {", "originalCommit": "db74f28b2aec874ec7a2f90a80d3a4186e969c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4ODQ1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515988453", "bodyText": "Following are public:\n\ndecorator registry (used from another package)\ndecorator interface (used from another package)\ndirection enum (used from another package)\nservice (as injected into camel code)\ninstrumentation (accessed externally)\nRest is already package-protected.", "author": "kubawach", "createdAt": "2020-11-02T13:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMDIzNA=="}], "type": "inlineReview"}, {"oid": "fcecece016ab4e92cac25a41cd2c4d1c3c16c198", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fcecece016ab4e92cac25a41cd2c4d1c3c16c198", "message": "apache camel 2.20.x instrumentation", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "60a887b580d923ff1ac8b42c54c833f6a87bff95", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/60a887b580d923ff1ac8b42c54c833f6a87bff95", "message": "removed instrumentation advice from helper classes", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "18b4e43ab600c425afce6160e54e95a1433501ea", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/18b4e43ab600c425afce6160e54e95a1433501ea", "message": "code review #1", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "672e2c1b7ae736818b84c4ed6f35ff3185e6e024", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/672e2c1b7ae736818b84c4ed6f35ff3185e6e024", "message": "code review #2 / experimental server name update", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "155f9f3e710c2937d9ea954f2904bd6504b648e2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/155f9f3e710c2937d9ea954f2904bd6504b648e2", "message": "code review changes / new tests, improved direct, new license header", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "80ce95dc8f9bc77bc6917647c3aefe4391028e64", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/80ce95dc8f9bc77bc6917647c3aefe4391028e64", "message": "rebase changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "a1574361bf0ef6878c38926bf2d6347519afa0c7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1574361bf0ef6878c38926bf2d6347519afa0c7", "message": "code review changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "72e789f56f4cdc9a53a81d6973804da3c36f97c7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/72e789f56f4cdc9a53a81d6973804da3c36f97c7", "message": "code review changes, REST tests added", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "a32561c5ab8a77a0a494b1eb6d582826193f17d8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a32561c5ab8a77a0a494b1eb6d582826193f17d8", "message": "changes after rebase to newest master", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "5c217a79c4b1aec550d13c3ebdcb13449e813dbe", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5c217a79c4b1aec550d13c3ebdcb13449e813dbe", "message": "code review changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "b700b3ef0371ff9ecfb75c87092a2674d1d995e3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b700b3ef0371ff9ecfb75c87092a2674d1d995e3", "message": "code review", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "d4eeeb68eb299bde2d124033b7c3b596e91a9480", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d4eeeb68eb299bde2d124033b7c3b596e91a9480", "message": "code review", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "message": "rebase to master", "committedDate": "2020-11-02T15:28:01Z", "type": "commit"}, {"oid": "94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "message": "rebase to master", "committedDate": "2020-11-02T15:28:01Z", "type": "forcePushed"}]}