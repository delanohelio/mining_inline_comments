{"pr_number": 505, "pr_title": "First section of the tutorial 1/3", "pr_createdAt": "2020-06-12T19:10:47Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505", "timeline": [{"oid": "b8f8a1b497a65eb2997f729e1859f1dede25ed50", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8f8a1b497a65eb2997f729e1859f1dede25ed50", "message": "First section of the tutorial 1/3", "committedDate": "2020-06-12T19:03:51Z", "type": "commit"}, {"oid": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/eb6fb4950d54ced866b91be25eb858d4ae48b308", "message": "Update README.md", "committedDate": "2020-06-12T21:23:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NjY1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439666652", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n          \n          \n            \n            In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-instrumentation-spring package which can improve this process.", "author": "trask", "createdAt": "2020-06-12T22:29:33Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NzQ0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439667446", "bodyText": "replace tabs with spaces everywhere, e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<groupId>io.opentelemetry</groupId>\n          \n          \n            \n                <groupId>io.opentelemetry</groupId>", "author": "trask", "createdAt": "2020-06-12T22:32:45Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Nzg3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439667872", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n          \n          \n            \n            To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration class. In section 3 we will use an annotation to set up this configuration.", "author": "trask", "createdAt": "2020-06-12T22:34:40Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2ODE4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439668188", "bodyText": "is \\\\TODO: accidental?", "author": "trask", "createdAt": "2020-06-12T22:35:58Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3MjE3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439672176", "bodyText": "if you indent these blocks at least 3 spaces, it will indent it visually, and more importantly, it will won't split up the ordered list into multiple ordered lists in the generated markdown, which is especially good for screen readers \ud83d\udc4d", "author": "trask", "createdAt": "2020-06-12T22:54:10Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3MjQ5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439672493", "bodyText": "the second one will overwrite the first one since they have the same name", "author": "trask", "createdAt": "2020-06-12T22:55:42Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3MjY1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439672656", "bodyText": "no need for cryptic abbreviation \ud83d\ude04\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static String SS_URL = \"http://localhost:8081/time\";\n          \n          \n            \n              private static String SECOND_SERVICE_URL = \"http://localhost:8081/time\";", "author": "trask", "createdAt": "2020-06-12T22:56:27Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3MjkxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439672917", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n          \n          \n            \n            HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, we used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.", "author": "trask", "createdAt": "2020-06-12T22:57:38Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3MzI4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439673289", "bodyText": "this is often declared static and initialized inline", "author": "trask", "createdAt": "2020-06-12T22:59:20Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NDA5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439674091", "bodyText": "I think this API has changed (probably worth re-checking all of the code against 0.5.0)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Span currentSpan = tracer.getCurrentSpan();\n          \n          \n            \n                textFormat.inject(currentSpan.getContext(), headers, setter);\n          \n          \n            \n                textFormat.inject(Context.current(), headers, setter);", "author": "trask", "createdAt": "2020-06-12T23:02:56Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;\n+\n+  public HttpUtils(Tracer tracer) {\n+    textFormat = tracer.getHttpTextFormat();\n+    setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+      @Override\n+      public void put(HttpHeaders headers, String key, String value) {\n+        headers.set(key, value);\n+      }\n+    };\n+  }\n+\n+  public String callEndpoint(String url) throws Exception {\n+    HttpHeaders headers = new HttpHeaders();\n+\n+    Span currentSpan = tracer.getCurrentSpan();\n+    textFormat.inject(currentSpan.getContext(), headers, setter);", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NDQxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439674419", "bodyText": "it's not clear the reason for having a scope here", "author": "trask", "createdAt": "2020-06-12T23:04:37Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;\n+\n+  public HttpUtils(Tracer tracer) {\n+    textFormat = tracer.getHttpTextFormat();\n+    setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+      @Override\n+      public void put(HttpHeaders headers, String key, String value) {\n+        headers.set(key, value);\n+      }\n+    };\n+  }\n+\n+  public String callEndpoint(String url) throws Exception {\n+    HttpHeaders headers = new HttpHeaders();\n+\n+    Span currentSpan = tracer.getCurrentSpan();\n+    textFormat.inject(currentSpan.getContext(), headers, setter);\n+\n+    HttpEntity<String> entity = new HttpEntity<String>(headers);\n+    RestTemplate restTemplate = new RestTemplate();\n+\n+    ResponseEntity<String> response =\n+        restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\n+\n+    return response.getBody();\n+  }\n+}\n+```\n+### SecondService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+  \n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(SecondServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for SecondService\n+5. Start a span to wrap the SecondServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @GetMapping\n+  public String callSecondTracedMethod() {\n+    Span span = tracer.spanBuilder(\"time\").startSpan();\n+    span.addEvent(\"SecondServiceController Entered\");\n+    span.setAttribute(\"what.am.i\", \"Tu es une legume\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"It's time to get a watch\";\n+    } finally {", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NDgyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439674823", "bodyText": "i'm not sure, i think the url is not correct, and the suggestion to remove the word sample is just to avoid confusion with sampling\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/time` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:\n          \n          \n            \n            Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. To send a request enter the following in a browser of your choice:", "author": "trask", "createdAt": "2020-06-12T23:06:23Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;\n+\n+  public HttpUtils(Tracer tracer) {\n+    textFormat = tracer.getHttpTextFormat();\n+    setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+      @Override\n+      public void put(HttpHeaders headers, String key, String value) {\n+        headers.set(key, value);\n+      }\n+    };\n+  }\n+\n+  public String callEndpoint(String url) throws Exception {\n+    HttpHeaders headers = new HttpHeaders();\n+\n+    Span currentSpan = tracer.getCurrentSpan();\n+    textFormat.inject(currentSpan.getContext(), headers, setter);\n+\n+    HttpEntity<String> entity = new HttpEntity<String>(headers);\n+    RestTemplate restTemplate = new RestTemplate();\n+\n+    ResponseEntity<String> response =\n+        restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\n+\n+    return response.getBody();\n+  }\n+}\n+```\n+### SecondService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+  \n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(SecondServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for SecondService\n+5. Start a span to wrap the SecondServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @GetMapping\n+  public String callSecondTracedMethod() {\n+    Span span = tracer.spanBuilder(\"time\").startSpan();\n+    span.addEvent(\"SecondServiceController Entered\");\n+    span.setAttribute(\"what.am.i\", \"Tu es une legume\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"It's time to get a watch\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+### Run FirstService and SecondService\n+\n+***To view your distributed traces ensure either LogExporter or Jaeger is configured in the OtelConfig.java file*** \n+\n+To view traces on the Jaeger UI, deploy a Jaeger Exporter on localhost by running the command in terminal:\n+\n+`docker run --rm -it --network=host jaegertracing/all-in-one` \n+\n+After running Jaeger locally, navigate to the url below. Make sure to refresh the UI to view the exported traces from the two web services:\n+\n+`http://localhost:16686`\n+ \n+Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/time` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTI1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439675250", "bodyText": "i'm not sure, i think the url is not correct\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `http://localhost:8080/time`\n          \n          \n            \n            `http://localhost:8080/message`", "author": "trask", "createdAt": "2020-06-12T23:08:38Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;\n+\n+  public HttpUtils(Tracer tracer) {\n+    textFormat = tracer.getHttpTextFormat();\n+    setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+      @Override\n+      public void put(HttpHeaders headers, String key, String value) {\n+        headers.set(key, value);\n+      }\n+    };\n+  }\n+\n+  public String callEndpoint(String url) throws Exception {\n+    HttpHeaders headers = new HttpHeaders();\n+\n+    Span currentSpan = tracer.getCurrentSpan();\n+    textFormat.inject(currentSpan.getContext(), headers, setter);\n+\n+    HttpEntity<String> entity = new HttpEntity<String>(headers);\n+    RestTemplate restTemplate = new RestTemplate();\n+\n+    ResponseEntity<String> response =\n+        restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\n+\n+    return response.getBody();\n+  }\n+}\n+```\n+### SecondService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+  \n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(SecondServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for SecondService\n+5. Start a span to wrap the SecondServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @GetMapping\n+  public String callSecondTracedMethod() {\n+    Span span = tracer.spanBuilder(\"time\").startSpan();\n+    span.addEvent(\"SecondServiceController Entered\");\n+    span.setAttribute(\"what.am.i\", \"Tu es une legume\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"It's time to get a watch\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+### Run FirstService and SecondService\n+\n+***To view your distributed traces ensure either LogExporter or Jaeger is configured in the OtelConfig.java file*** \n+\n+To view traces on the Jaeger UI, deploy a Jaeger Exporter on localhost by running the command in terminal:\n+\n+`docker run --rm -it --network=host jaegertracing/all-in-one` \n+\n+After running Jaeger locally, navigate to the url below. Make sure to refresh the UI to view the exported traces from the two web services:\n+\n+`http://localhost:16686`\n+ \n+Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/time` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:\n+\n+`http://localhost:8080/time`", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTYyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r439675624", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SS_URL. ***\n          \n          \n            \n            ***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SECOND_SERVICE_URL. ***", "author": "trask", "createdAt": "2020-06-12T23:10:35Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,344 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-contrib-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-api</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-sdk</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\t\n+<dependency>\n+    <groupId>io.grpc</groupId>\n+    <artifactId>grpc-context</artifactId>\n+    <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-logging</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+\t<groupId>io.opentelemetry</groupId>\n+\t<artifactId>opentelemetry-exporters-jaeger</artifactId>\n+\t<version>0.5.0</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-protobuf</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+<dependency>\n+\t<groupId>io.grpc</groupId>\n+\t<artifactId>grpc-netty</artifactId>\n+\t<version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration file. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+  private static tracerName = \"foo\"; \\\\TODO:\n+  @Bean\n+  public Tracer otelTracer() throws Exception {\n+    final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+    SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+    OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+    \n+    return tracer;\n+  }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+        .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+            .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+            .build())\n+        .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+     \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(FirstServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @Autowired\n+  HttpUtils httpUtils;\n+\n+  private static String SS_URL = \"http://localhost:8081/time\";\n+\n+  @GetMapping\n+  public String firstTracedMethod() {\n+    Span span = tracer.spanBuilder(\"message\").startSpan();\n+    span.addEvent(\"Controller Entered\");\n+    span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"Second Service says: \" + httpUtils.callEndpoint(SS_URL);\n+    } catch (Exception e) {\n+      span.setAttribute(\"error\", e.toString());\n+      span.setAttribute(\"error\", true);\n+      return \"ERROR: I can't tell the time\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, I used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+  @Autowired\n+  private Tracer tracer;\n+\n+  private HttpTextFormat<SpanContext> textFormat;\n+  private HttpTextFormat.Setter<HttpHeaders> setter;\n+\n+  public HttpUtils(Tracer tracer) {\n+    textFormat = tracer.getHttpTextFormat();\n+    setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+      @Override\n+      public void put(HttpHeaders headers, String key, String value) {\n+        headers.set(key, value);\n+      }\n+    };\n+  }\n+\n+  public String callEndpoint(String url) throws Exception {\n+    HttpHeaders headers = new HttpHeaders();\n+\n+    Span currentSpan = tracer.getCurrentSpan();\n+    textFormat.inject(currentSpan.getContext(), headers, setter);\n+\n+    HttpEntity<String> entity = new HttpEntity<String>(headers);\n+    RestTemplate restTemplate = new RestTemplate();\n+\n+    ResponseEntity<String> response =\n+        restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\n+\n+    return response.getBody();\n+  }\n+}\n+```\n+### SecondService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+  \n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+  public static void main(String[] args) throws IOException {\n+    SpringApplication.run(SecondServiceApplication.class, args);\n+  }\n+}\n+```\n+\n+4. Create a RestController for SecondService\n+5. Start a span to wrap the SecondServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+  @Autowired\n+  private Tracer tracer;\n+\n+  @GetMapping\n+  public String callSecondTracedMethod() {\n+    Span span = tracer.spanBuilder(\"time\").startSpan();\n+    span.addEvent(\"SecondServiceController Entered\");\n+    span.setAttribute(\"what.am.i\", \"Tu es une legume\");\n+\n+    try (Scope scope = tracer.withSpan(span)) {\n+      return \"It's time to get a watch\";\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+### Run FirstService and SecondService\n+\n+***To view your distributed traces ensure either LogExporter or Jaeger is configured in the OtelConfig.java file*** \n+\n+To view traces on the Jaeger UI, deploy a Jaeger Exporter on localhost by running the command in terminal:\n+\n+`docker run --rm -it --network=host jaegertracing/all-in-one` \n+\n+After running Jaeger locally, navigate to the url below. Make sure to refresh the UI to view the exported traces from the two web services:\n+\n+`http://localhost:16686`\n+ \n+Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/time` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:\n+\n+`http://localhost:8080/time`\n+\n+***Note: The default port for the Apache Tomcat is 8080. On localhost both FirstService and SecondService services will attempt to run on this port raising an error. To avoid this add `server.port=8081` to the resources/application.properties file. Ensure the port specified corresponds to port referenced by FirstServiceController.SS_URL. ***", "originalCommit": "eb6fb4950d54ced866b91be25eb858d4ae48b308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8eed0d09b53b9df337d37a3fa12d38560c948809", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8eed0d09b53b9df337d37a3fa12d38560c948809", "message": "Update instrumentation-core/spring/README.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-14T19:31:39Z", "type": "commit"}, {"oid": "cd83e3f488c9373d71d17fed6cf29a8bf63f6462", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cd83e3f488c9373d71d17fed6cf29a8bf63f6462", "message": "Update instrumentation-core/spring/README.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-15T13:58:16Z", "type": "commit"}, {"oid": "6ef70ad8fa9d37e02491838629fd5fcab2367cf0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6ef70ad8fa9d37e02491838629fd5fcab2367cf0", "message": "Update instrumentation-core/spring/README.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-15T14:00:01Z", "type": "commit"}, {"oid": "fdffbcc99e98c83f5a69c20975bc95610b05787a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fdffbcc99e98c83f5a69c20975bc95610b05787a", "message": "Update instrumentation-core/spring/README.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-15T14:03:49Z", "type": "commit"}, {"oid": "f80cfe1483c243215e26bfbe6f8f87746b7db3aa", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f80cfe1483c243215e26bfbe6f8f87746b7db3aa", "message": "trask changes", "committedDate": "2020-06-15T14:36:58Z", "type": "commit"}, {"oid": "80c11c07dd18c05f6dc14e22e8034058a9d8d689", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/80c11c07dd18c05f6dc14e22e8034058a9d8d689", "message": "line space and general clean up", "committedDate": "2020-06-15T14:45:10Z", "type": "commit"}, {"oid": "e3602717f2019c37197aac7553adfa0be99e2d40", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e3602717f2019c37197aac7553adfa0be99e2d40", "message": "Merge branch 'master' into master", "committedDate": "2020-06-15T14:49:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNDg1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r440314856", "bodyText": "and move to the top of the class is common for static fields\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private HttpTextFormat.Setter<HttpHeaders> setter = new HttpTextFormat.Setter<HttpHeaders>() {\n          \n          \n            \n               private static final HttpTextFormat.Setter<HttpHeaders> setter = new HttpTextFormat.Setter<HttpHeaders>() {", "author": "trask", "createdAt": "2020-06-15T16:55:04Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,345 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-instrumentation-spring package. This section will equip you with new tools to streamline the setup and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-instrumentation-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-api</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-sdk</artifactId>\n+   <version>0.5.0</version>\n+</dependency>   \n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-context</artifactId>\n+   <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-exporters-logging</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-exporters-jaeger</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-protobuf</artifactId>\n+   <version>1.27.2</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-netty</artifactId>\n+   <version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration class. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+   private static tracerName = \"fooTracer\"; \n+   @Bean\n+   public Tracer otelTracer() throws Exception {\n+      final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+      SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+      OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+      \n+      return tracer;\n+   }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+            .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+                  .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+                  .build())\n+            .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+       \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String secondServiceUrl = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+      Span span = tracer.spanBuilder(\"message\").startSpan();\n+      span.addEvent(\"Controller Entered\");\n+      span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+      try (Scope scope = tracer.withSpan(span)) {\n+         return \"Second Service says: \" + httpUtils.callEndpoint(secondServiceUrl);\n+      } catch (Exception e) {\n+         span.addEvent(e.toString());\n+         span.setAttribute(\"error\", true);\n+         return \"ERROR: I can't tell the time\";\n+      } finally {\n+         span.end();\n+      }\n+   }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, we used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.grpc.Context;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private HttpTextFormat<SpanContext> textFormat;\n+   private HttpTextFormat.Setter<HttpHeaders> setter = new HttpTextFormat.Setter<HttpHeaders>() {", "originalCommit": "e3602717f2019c37197aac7553adfa0be99e2d40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxODU1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/505#discussion_r440318555", "bodyText": "It's not clear to me what the part I removed below is for, so I suggest either removing or clarifying that it\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:\n          \n          \n            \n            \n          \n          \n            \n            `http://localhost:8081/time`\n          \n          \n            \n            Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace.", "author": "trask", "createdAt": "2020-06-15T17:01:17Z", "path": "instrumentation-core/spring/README.md", "diffHunk": "@@ -2,11 +2,345 @@\n <!-- ReadMe is in progress -->\n <!-- TO DO: Add sections for starter guide -->\n \n-\n This package streamlines the manual instrumentation process of OpenTelemetry for [Spring](https://spring.io/projects/spring-framework) and [Spring Boot](https://spring.io/projects/spring-boot) applications. It will enable you to add traces to requests and database calls with minimal changes to application code. This package will not fully automate your OpenTelemetry instrumentation, instead, it will provide you with better tools to instrument your own code. \n \n-The first section will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n+The [first section](#manual-instrumentation-with-java-sdk) will walk you through span creation and propagation using the OpenTelemetry Java API and [Spring's RestTemplate Http Web Client](https://spring.io/guides/gs/consuming-rest/). This approach will use the \"vanilla\" OpenTelemetry API to make explicit tracing calls within an application's controller. \n \n The second section will build on the first. It will walk you through implementing spring-web handler and interceptor interfaces to create traces with minimal changes to existing application code. Using the OpenTelemetry API, this approach involves copy and pasting files and a significant amount of manual configurations. \n \n-The third section will walk you through the annotations and configurations defined in the opentelemetry-contrib-spring package. This section will equip you with new tools to streamline the set up and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.  \n+The third section will walk you through the annotations and configurations defined in the opentelemetry-instrumentation-spring package. This section will equip you with new tools to streamline the setup and instrumentation of OpenTelemetry on Spring and Spring Boot applications. With these tools you will be able to setup distributed tracing with little to no changes to existing configurations and easily customize traces with minor additions to application code.\n+\n+In this guide we will be using a running example. In section one and two, we will create two spring web services using Spring Boot. We will then trace the requests between these services using two different approaches. Finally, in section three we will explore tools in the opentelemetry-instrumentation-spring package which can improve this process.\n+\n+# Manual Instrumentation Guide\n+\n+## Create two Spring Projects\n+\n+Using the [spring project initializer](https://start.spring.io/), we will create two spring projects.  Name one project `FirstService` and the other `SecondService`. Make sure to select maven, Spring Boot 2.3, Java, and add the spring-web dependency. After downloading the two projects include the OpenTelemetry dependencies and configuration listed below. \n+\n+## Setup for Manual Instrumentation\n+\n+Add the dependencies below to enable OpenTelemetry in `FirstService` and `SecondService`. The Jaeger and LoggingExporter packages are recommended for exporting traces but are not required. As of May 2020, Jaeger, Zipkin, OTLP, and Logging exporters are supported by opentelemetry-java. Feel free to use whatever exporter you are most comfortable with. \n+\n+### Maven\n+ \n+#### OpenTelemetry\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-api</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-sdk</artifactId>\n+   <version>0.5.0</version>\n+</dependency>   \n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-context</artifactId>\n+   <version>1.24.0</version>\n+</dependency>\n+\n+```\n+\n+#### LoggingExporter\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-exporters-logging</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+```\n+\n+#### JaegerExporter\n+```xml\n+<dependency>\n+   <groupId>io.opentelemetry</groupId>\n+   <artifactId>opentelemetry-exporters-jaeger</artifactId>\n+   <version>0.5.0</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-protobuf</artifactId>\n+   <version>1.27.2</version>\n+</dependency>\n+<dependency>\n+   <groupId>io.grpc</groupId>\n+   <artifactId>grpc-netty</artifactId>\n+   <version>1.27.2</version>\n+</dependency>\n+```\n+\n+### Gradle\n+ \n+#### OpenTelemetry\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-api:0.5.0\"\n+compile \"io.opentelemetry:opentelemetry-sdk:0.5.0\"\n+compile \"io.grpc:grpc-context:1.24.0\"\n+```\n+\n+#### LoggingExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-logging:0.5.0\"\n+```\n+\n+#### JaegerExporter\n+```gradle\n+compile \"io.opentelemetry:opentelemetry-exporters-jaeger:0.5.0\"\n+compile \"io.grpc:grpc-protobuf:1.27.2\"\n+compile \"io.grpc:grpc-netty:1.27.2\"\n+```\n+\n+### Tracer Configuration\n+\n+To enable tracing in your OpenTelemetry project configure a Tracer Bean. This bean will be auto wired to controllers to create and propagate spans. This can be seen in the `Tracer otelTracer()` method below. If you plan to use a trace exporter remember to also include it in this configuration class. In section 3 we will use an annotation to set up this configuration.\n+\n+A sample OpenTelemetry configuration using LoggingExporter is shown below: \n+\n+```java\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+import io.grpc.ManagedChannelBuilder;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.exporters.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporters.logging.*;\n+\n+@Configuration\n+public class OtelConfig {\n+   private static tracerName = \"fooTracer\"; \n+   @Bean\n+   public Tracer otelTracer() throws Exception {\n+      final Tracer tracer = OpenTelemetry.getTracer(tracerName);\n+\n+      SpanProcessor logProcessor = SimpleSpanProcessor.newBuilder(new LoggingSpanExporter()).build();\n+      OpenTelemetrySdk.getTracerProvider().addSpanProcessor(logProcessor);\n+      \n+      return tracer;\n+   }\n+}\n+```\n+\n+\n+The file above configures an OpenTelemetry tracer and a span processor. The span processor builds a log exporter which will output spans to the console. Similarly, one could add another exporter, such as the `JaegerExporter`, to visualize traces on a different back-end. Similar to how the `LoggingExporter` is configured, a Jaeger configuration can be added to the `OtelConfig` class above. \n+\n+Sample configuration for a Jaeger Exporter:\n+\n+```java\n+\n+SpanProcessor jaegerProcessor = SimpleSpanProcessor\n+            .newBuilder(JaegerGrpcSpanExporter.newBuilder().setServiceName(tracerName)\n+                  .setChannel(ManagedChannelBuilder.forAddress(\"localhost\", 14250).usePlaintext().build())\n+                  .build())\n+            .build();\n+OpenTelemetrySdk.getTracerProvider().addSpanProcessor(jaegerProcessor);\n+```\n+       \n+### Project Background\n+\n+Here we will create rest controllers for `FirstService` and `SecondService`.\n+`FirstService` will send a GET request to `SecondService` to retrieve the current time. After this request is resolved, `FirstService` then will append a message to time and return a string to the client. \n+\n+## Manual Instrumentation with Java SDK\n+\n+### Add OpenTelemetry to FirstService and SecondService\n+\n+Required dependencies and configurations for FirstService and SecondService projects can be found [here](#setup-for-manual-instrumentation).\n+\n+### FirstService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+```java\n+@SpringBootApplication\n+public class FirstServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(FirstServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+4. Create a RestController for FirstService\n+5. Create a span to wrap the FirstServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+import HttpUtils;\n+\n+@RestController\n+@RequestMapping(value = \"/message\")\n+public class FirstServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @Autowired\n+   HttpUtils httpUtils;\n+\n+   private static String secondServiceUrl = \"http://localhost:8081/time\";\n+\n+   @GetMapping\n+   public String firstTracedMethod() {\n+      Span span = tracer.spanBuilder(\"message\").startSpan();\n+      span.addEvent(\"Controller Entered\");\n+      span.setAttribute(\"what.are.you\", \"Je suis attribute\");\n+\n+      try (Scope scope = tracer.withSpan(span)) {\n+         return \"Second Service says: \" + httpUtils.callEndpoint(secondServiceUrl);\n+      } catch (Exception e) {\n+         span.addEvent(e.toString());\n+         span.setAttribute(\"error\", true);\n+         return \"ERROR: I can't tell the time\";\n+      } finally {\n+         span.end();\n+      }\n+   }\n+}\n+```\n+\n+6. Configure `HttpUtils.callEndpoint` to inject span context into request. This is key to propagate the trace to the SecondService\n+\n+HttpUtils is a helper class that injects the current span context into outgoing requests. This involves adding the tracer id and the trace-state to a request header. For this example, we used `RestTemplate` to send requests from `FirstService` to `SecondService`. A similar approach can be used with popular Java Web Clients such as [okhttp](https://square.github.io/okhttp/) and [apache http client](https://www.tutorialspoint.com/apache_httpclient/apache_httpclient_quick_guide.htm). The key to this implementation is to override the put method in `HttpTextFormat.Setter<?>` to handle your request format. `HttpTextFormat.inject` will use this setter to set `traceparent` and `tracestate` headers in your requests. These values will be used to propagate your span context to external services.\n+\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+\n+import io.grpc.Context;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Tracer;\n+\n+@Component\n+public class HttpUtils {\n+\n+   @Autowired\n+   private Tracer tracer;\n+\n+   private HttpTextFormat<SpanContext> textFormat;\n+   private HttpTextFormat.Setter<HttpHeaders> setter = new HttpTextFormat.Setter<HttpHeaders>() {\n+         @Override\n+         public void set(HttpHeaders headers, String key, String value) {\n+            headers.set(key, value);\n+         }\n+      };\n+\n+   public HttpUtils(Tracer tracer) {\n+      textFormat = tracer.getHttpTextFormat();\n+   }\n+\n+   public String callEndpoint(String url) throws Exception {\n+      HttpHeaders headers = new HttpHeaders();\n+\n+      textFormat.inject(Context.current(), headers, setter);\n+\n+      HttpEntity<String> entity = new HttpEntity<String>(headers);\n+      RestTemplate restTemplate = new RestTemplate();\n+\n+      ResponseEntity<String> response =\n+            restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\n+\n+      return response.getBody();\n+   }\n+}\n+```\n+### SecondService\n+\n+1. Ensure OpenTelemetry dependencies are included\n+2. Ensure an OpenTelemetry Tracer is configured\n+3. Ensure a Spring Boot main class was created by the Spring initializer\n+\n+\n+```java\n+import java.io.IOException;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+\n+@SpringBootApplication\n+public class SecondServiceApplication {\n+\n+   public static void main(String[] args) throws IOException {\n+      SpringApplication.run(SecondServiceApplication.class, args);\n+   }\n+}\n+```\n+\n+4. Create a RestController for SecondService\n+5. Start a span to wrap the SecondServiceController\n+\n+```java\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+\n+@RestController\n+@RequestMapping(value = \"/time\")\n+public class SecondServiceController {\n+   @Autowired\n+   private Tracer tracer;\n+\n+   @GetMapping\n+   public String callSecondTracedMethod() {\n+      Span span = tracer.spanBuilder(\"time\").startSpan();\n+      span.addEvent(\"SecondServiceController Entered\");\n+      span.setAttribute(\"what.am.i\", \"Tu es une legume\");\n+\n+      try{\n+         return \"It's time to get a watch\";\n+      } finally {\n+         span.end();\n+      }\n+   }\n+}\n+```\n+\n+### Run FirstService and SecondService\n+\n+***To view your distributed traces ensure either LogExporter or Jaeger is configured in the OtelConfig.java file*** \n+\n+To view traces on the Jaeger UI, deploy a Jaeger Exporter on localhost by running the command in terminal:\n+\n+`docker run --rm -it --network=host jaegertracing/all-in-one` \n+\n+After running Jaeger locally, navigate to the url below. Make sure to refresh the UI to view the exported traces from the two web services:\n+\n+`http://localhost:16686`\n+\n+Run FirstService and SecondService from command line or using an IDE. The end point of interest for FirstService is `http://localhost:8080/message` and  `http://localhost:8081/time` for SecondService. Entering `localhost:8080/message` in a browser should call FirstService and then SecondService, creating a trace. To send a sample request enter the following in a browser of your choice:\n+\n+`http://localhost:8081/time`", "originalCommit": "e3602717f2019c37197aac7553adfa0be99e2d40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96e34ab7a674aea5f08517a3142c35295349e06a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/96e34ab7a674aea5f08517a3142c35295349e06a", "message": "some more clean ups", "committedDate": "2020-06-15T21:04:43Z", "type": "commit"}, {"oid": "a1bdedec1b7c6f64ec7c6ad837f2432141d0a8bf", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1bdedec1b7c6f64ec7c6ad837f2432141d0a8bf", "message": "Merge branch 'master' into master", "committedDate": "2020-06-15T21:43:28Z", "type": "commit"}, {"oid": "297f928342832b075473caddccd2470d71c5963d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/297f928342832b075473caddccd2470d71c5963d", "message": "Merge branch 'master' into master", "committedDate": "2020-06-16T00:54:07Z", "type": "commit"}]}