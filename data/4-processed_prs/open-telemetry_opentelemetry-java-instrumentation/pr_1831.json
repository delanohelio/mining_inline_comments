{"pr_number": 1831, "pr_title": "Support faas.id & cloud.account.id attributes in AWS Lambda", "pr_createdAt": "2020-12-04T09:54:34Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NTc3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r537185776", "bodyText": "I wonder if we can just set a boolean by checking with normal reflection and guard the call to the function, given Java doesn't link until call-time? I'm not aware of any advantage of method handles for guarding against different versions vs that (code is a bit simpler IMO) but maybe no one has ever told me them yet :P", "author": "anuraaga", "createdAt": "2020-12-07T02:15:58Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaTracer.java", "diffHunk": "@@ -19,12 +21,30 @@\n import io.opentelemetry.api.trace.attributes.SemanticAttributes.FaasTriggerValues;\n import io.opentelemetry.context.Scope;\n import io.opentelemetry.instrumentation.api.tracer.BaseTracer;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n import java.util.Collections;\n import java.util.Map;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n \n public class AwsLambdaTracer extends BaseTracer {\n \n   private static final String AWS_TRACE_HEADER_ENV_KEY = \"_X_AMZN_TRACE_ID\";\n+  private static final MethodHandle GET_FUNCTION_ARN;\n+\n+  static {\n+    MethodHandles.Lookup lookup = MethodHandles.publicLookup();", "originalCommit": "fbff95b5b15a8aad8b2b9d5ebbe0413d41462b4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYzMTY2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r537631660", "bodyText": "Yeah, we certainly can -- I used MethodHandle without thinking because that's kind of a default in the agent \ud83d\ude05", "author": "mateuszrzeszutek", "createdAt": "2020-12-07T16:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYzODg2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r537638869", "bodyText": "Hmm, there's one issue that appears when I use the method directly: I need to bump the AWS lambda API to 1.2.0, which also requires bumping javaagent lib version to 1.2.0 because muzzle'll fail. That pretty much means dropping support for <1.2.0... @anuraaga are we OK with that?", "author": "mateuszrzeszutek", "createdAt": "2020-12-07T16:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA2NDA2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538064062", "bodyText": "Ah I guess muzzle is too smart for enough - in that case let's stick to the current approach!", "author": "anuraaga", "createdAt": "2020-12-08T06:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NzA0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r537187048", "bodyText": "Since account ID is constant, how about storing it into a lazy-inited field? We probably don't need to make it volatile since it'll converge eventually.", "author": "anuraaga", "createdAt": "2020-12-07T02:20:49Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaTracer.java", "diffHunk": "@@ -69,13 +89,37 @@ private SpanBuilder createSpan(Context context, Object input, Map<String, String\n   }\n \n   private void setAttributes(SpanBuilder span, Context context, Object input) {\n-    span.setAttribute(FAAS_EXECUTION, context.getAwsRequestId());\n+    setCommonAttributes(span, context);\n     if (input instanceof APIGatewayProxyRequestEvent) {\n       span.setAttribute(FAAS_TRIGGER, FaasTriggerValues.HTTP.getValue());\n       httpSpanAttributes.onRequest(span, (APIGatewayProxyRequestEvent) input);\n     }\n   }\n \n+  private void setCommonAttributes(SpanBuilder span, Context context) {\n+    span.setAttribute(FAAS_EXECUTION, context.getAwsRequestId());\n+    String arn = getFunctionArn(context);\n+    if (arn != null) {\n+      span.setAttribute(FAAS_ID, arn);\n+      String[] arnParts = arn.split(\":\");\n+      if (arnParts.length >= 5) {\n+        span.setAttribute(CLOUD_ACCOUNT_ID, arnParts[4]);", "originalCommit": "fbff95b5b15a8aad8b2b9d5ebbe0413d41462b4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0MTAxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r537641016", "bodyText": "I can store the value (whole ARN actually) in a lazy field, but is there any point in doing this? I mean, right now this code will only execute once per whole lambda so it won't be reused anywhere.", "author": "mateuszrzeszutek", "createdAt": "2020-12-07T16:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NzA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA2NDQ4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538064487", "bodyText": "Isn't it called once per span, meaning once per lambda invocation? And I think by caching we wouldn't need to recompute on every invocation.", "author": "anuraaga", "createdAt": "2020-12-08T06:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NzA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwNDc3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538204775", "bodyText": "You can add initialization code outside of your handler method to reuse resources across multiple invocations. When the runtime loads your handler, it runs static code and the class constructor. Resources that are created during initialization stay in memory between invocations, and can be reused by the handler thousands of times.\n\n\ud83d\ude2e\nFor some reason I was convinced that the whole JVM gets initialized for each lambda invocation. OK, now everything makes sense -- I'll cache it, that's a very good suggestion. Thanks!", "author": "mateuszrzeszutek", "createdAt": "2020-12-08T10:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NzA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1NDQzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538254439", "bodyText": "That'd be a pretty crazy slow runtime ;)", "author": "anuraaga", "createdAt": "2020-12-08T11:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE4NzA0OA=="}], "type": "inlineReview"}, {"oid": "8454e5c7fdd122dae18768852554070bfcbf61bb", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8454e5c7fdd122dae18768852554070bfcbf61bb", "message": "Support faas.id & cloud.account.id attributes in AWS Lambda", "committedDate": "2020-12-08T11:06:33Z", "type": "commit"}, {"oid": "45b262509f27ca6c62efe081f70b160d3ac577fc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/45b262509f27ca6c62efe081f70b160d3ac577fc", "message": "Cache accountId", "committedDate": "2020-12-08T11:06:33Z", "type": "commit"}, {"oid": "45b262509f27ca6c62efe081f70b160d3ac577fc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/45b262509f27ca6c62efe081f70b160d3ac577fc", "message": "Cache accountId", "committedDate": "2020-12-08T11:06:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1Mzg3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538253876", "bodyText": "Since we're locking and volatile don't need to use AtomicReference, it just ends up being another volatile lookup inside it.", "author": "anuraaga", "createdAt": "2020-12-08T11:16:30Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaTracer.java", "diffHunk": "@@ -69,13 +92,55 @@ private SpanBuilder createSpan(Context context, Object input, Map<String, String\n   }\n \n   private void setAttributes(SpanBuilder span, Context context, Object input) {\n-    span.setAttribute(FAAS_EXECUTION, context.getAwsRequestId());\n+    setCommonAttributes(span, context);\n     if (input instanceof APIGatewayProxyRequestEvent) {\n       span.setAttribute(FAAS_TRIGGER, FaasTriggerValues.HTTP.getValue());\n       httpSpanAttributes.onRequest(span, (APIGatewayProxyRequestEvent) input);\n     }\n   }\n \n+  private void setCommonAttributes(SpanBuilder span, Context context) {\n+    span.setAttribute(FAAS_EXECUTION, context.getAwsRequestId());\n+    String arn = getFunctionArn(context);\n+    if (arn != null) {\n+      span.setAttribute(FAAS_ID, arn);\n+    }\n+    String accountId = getAccountId(arn);\n+    if (accountId != null) {\n+      span.setAttribute(CLOUD_ACCOUNT_ID, accountId);\n+    }\n+  }\n+\n+  @Nullable\n+  private String getFunctionArn(Context context) {\n+    if (GET_FUNCTION_ARN == null) {\n+      return null;\n+    }\n+    try {\n+      return (String) GET_FUNCTION_ARN.invoke(context);\n+    } catch (Throwable throwable) {\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  private String getAccountId(@Nullable String arn) {\n+    if (accountId == null) {\n+      synchronized (this) {\n+        if (accountId == null) {\n+          accountId = new AtomicReference<>();", "originalCommit": "45b262509f27ca6c62efe081f70b160d3ac577fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2MTgxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1831#discussion_r538261813", "bodyText": "Hmm, that is true. Okay, I went a little overboard with the thread safety \ud83d\ude1b", "author": "mateuszrzeszutek", "createdAt": "2020-12-08T11:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1Mzg3Ng=="}], "type": "inlineReview"}, {"oid": "ed8da5062b163563bf14559dc1ccdc4640f3cbf7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ed8da5062b163563bf14559dc1ccdc4640f3cbf7", "message": "Cache accountId", "committedDate": "2020-12-08T11:29:27Z", "type": "commit"}]}