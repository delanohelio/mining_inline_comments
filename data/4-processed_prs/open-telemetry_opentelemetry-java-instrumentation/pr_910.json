{"pr_number": 910, "pr_title": "Add document describing current problem with context propagation", "pr_createdAt": "2020-08-06T11:34:14Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910", "timeline": [{"oid": "47cb63ea0f9c6837ca01907245da201699f623bc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/47cb63ea0f9c6837ca01907245da201699f623bc", "message": "Add document describing current problem with context propagation", "committedDate": "2020-08-06T11:33:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0Nzg4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r466547882", "bodyText": "Add the note about cleaning context on SERVER span creation.", "author": "iNikem", "createdAt": "2020-08-06T16:49:17Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -0,0 +1,87 @@\n+# The story of context propagation across threads\n+\n+## The need\n+Take a look at the following two pseudo-code snippets (see below for explanations).\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    Future f1 = pool.submit(() -> {\n+        return userRepository.queryShippingAddress(requet)\n+    })\n+    Future f2 = pool.submit(() -> {\n+        return warehouse.currentState(requet)\n+    })\n+    writeResponse(response, f1.get(), f2.get())\n+}\n+```\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    final AsyncContext acontext = request.startAsync();\n+    acontext.start(() -> {\n+            String address = userRepository.queryShippingAddress(requet)\n+            HttpServletResponse response = acontext.getResponse();\n+            writeResponse(response, address)\n+            acontext.complete();\n+   }\n+}\n+```\n+\n+In both cases request processing requires some potentially long operation and application developer\n+wants to do them off the main thread. In the first case this hand-off between request accepting thread\n+and request processing thread happens manually, by submitting work into some thread pool.\n+In the second case it is the framework that handles separate thread pool and passing work to it.\n+\n+In cases like this proper tracing solution should still combine into a single trace all the work\n+required for request processing, irregardless in what thread that work happened. With proper\n+parent-child relationship between span: span representing shipping address query should be the child\n+of the span which denotes accepting HTTP request.\n+\n+## The solution\n+Java auto instrumentation uses an obvious solution to the requirement above: we attach current execution\n+context (represented in the code by `io.grpc.Context`) with each `Runnable`, `Callable` and `ForkJoinTask`.\n+\"Current\" means the context active on the thread which calls `Executor.execute` (and its analogues\n+such as `submit`, `invokeAll` etc) at the moment of that call. Whenever some other thread starts\n+actual execution of that `Runnable` (or `Callable` or `ForkJoinTask`), that context get restored\n+on that thread for the duration of the execution. This can be illustrated by the following pseudo-code:\n+\n+```\n+    var job = () -> {\n+        try(Scope scope = withScopedContext(this.context)) {\n+            return userRepository.queryShippingAddress(requet)\n+        }}\n+    job.context = Context.current()\n+    Future f1 = pool.submit()\n+\n+```\n+\n+## The drawback\n+There are some runtime environments which, simplifying, do the following:\n+```\n+pool.submit(new AcceptRequestRunnable() {\n+    Request req = readRequest()\n+    pool.submit(new ProcessRequestRunnable(req) {\n+        writeResponse(process(req))\n+        pool.submit(new AcceptRequestRunnable() {\n+        ... repeat untill shutdown\n+    })\n+})\n+```\n+\n+This means that mechanism described in the previous section will propagate the execution context\n+of one request processing to a thread accepting some next, unrelated, request.\n+This will result in spans representing the accepting and processing of the second request will join\n+the same trace as those of the first span. This mistakenly correlates unrelated requests and may lead\n+to huge traces being active for hours and hours.\n+\n+In addition this makes some of our tests extremely flaky.\n+\n+## The currently accepted trade-offs", "originalCommit": "47cb63ea0f9c6837ca01907245da201699f623bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTM0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r467209349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            required for request processing, irregardless in what thread that work happened. With proper\n          \n          \n            \n            required for request processing, regardless in what thread that work happened. With proper", "author": "trask", "createdAt": "2020-08-07T18:43:10Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -0,0 +1,87 @@\n+# The story of context propagation across threads\n+\n+## The need\n+Take a look at the following two pseudo-code snippets (see below for explanations).\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    Future f1 = pool.submit(() -> {\n+        return userRepository.queryShippingAddress(requet)\n+    })\n+    Future f2 = pool.submit(() -> {\n+        return warehouse.currentState(requet)\n+    })\n+    writeResponse(response, f1.get(), f2.get())\n+}\n+```\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    final AsyncContext acontext = request.startAsync();\n+    acontext.start(() -> {\n+            String address = userRepository.queryShippingAddress(requet)\n+            HttpServletResponse response = acontext.getResponse();\n+            writeResponse(response, address)\n+            acontext.complete();\n+   }\n+}\n+```\n+\n+In both cases request processing requires some potentially long operation and application developer\n+wants to do them off the main thread. In the first case this hand-off between request accepting thread\n+and request processing thread happens manually, by submitting work into some thread pool.\n+In the second case it is the framework that handles separate thread pool and passing work to it.\n+\n+In cases like this proper tracing solution should still combine into a single trace all the work\n+required for request processing, irregardless in what thread that work happened. With proper", "originalCommit": "47cb63ea0f9c6837ca01907245da201699f623bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMDI3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r467210278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ... repeat untill shutdown\n          \n          \n            \n                    ... repeat until shutdown", "author": "trask", "createdAt": "2020-08-07T18:45:14Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -0,0 +1,87 @@\n+# The story of context propagation across threads\n+\n+## The need\n+Take a look at the following two pseudo-code snippets (see below for explanations).\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    Future f1 = pool.submit(() -> {\n+        return userRepository.queryShippingAddress(requet)\n+    })\n+    Future f2 = pool.submit(() -> {\n+        return warehouse.currentState(requet)\n+    })\n+    writeResponse(response, f1.get(), f2.get())\n+}\n+```\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    final AsyncContext acontext = request.startAsync();\n+    acontext.start(() -> {\n+            String address = userRepository.queryShippingAddress(requet)\n+            HttpServletResponse response = acontext.getResponse();\n+            writeResponse(response, address)\n+            acontext.complete();\n+   }\n+}\n+```\n+\n+In both cases request processing requires some potentially long operation and application developer\n+wants to do them off the main thread. In the first case this hand-off between request accepting thread\n+and request processing thread happens manually, by submitting work into some thread pool.\n+In the second case it is the framework that handles separate thread pool and passing work to it.\n+\n+In cases like this proper tracing solution should still combine into a single trace all the work\n+required for request processing, irregardless in what thread that work happened. With proper\n+parent-child relationship between span: span representing shipping address query should be the child\n+of the span which denotes accepting HTTP request.\n+\n+## The solution\n+Java auto instrumentation uses an obvious solution to the requirement above: we attach current execution\n+context (represented in the code by `io.grpc.Context`) with each `Runnable`, `Callable` and `ForkJoinTask`.\n+\"Current\" means the context active on the thread which calls `Executor.execute` (and its analogues\n+such as `submit`, `invokeAll` etc) at the moment of that call. Whenever some other thread starts\n+actual execution of that `Runnable` (or `Callable` or `ForkJoinTask`), that context get restored\n+on that thread for the duration of the execution. This can be illustrated by the following pseudo-code:\n+\n+```\n+    var job = () -> {\n+        try(Scope scope = withScopedContext(this.context)) {\n+            return userRepository.queryShippingAddress(requet)\n+        }}\n+    job.context = Context.current()\n+    Future f1 = pool.submit()\n+\n+```\n+\n+## The drawback\n+There are some runtime environments which, simplifying, do the following:\n+```\n+pool.submit(new AcceptRequestRunnable() {\n+    Request req = readRequest()\n+    pool.submit(new ProcessRequestRunnable(req) {\n+        writeResponse(process(req))\n+        pool.submit(new AcceptRequestRunnable() {\n+        ... repeat untill shutdown", "originalCommit": "47cb63ea0f9c6837ca01907245da201699f623bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMjkzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r467212933", "bodyText": "the example in this section shows how if we leak to the first pool.submit, then it will keep leaking, but i don't think it answers the question of how we leak to the first pool.submit.\nmaybe the more concrete example you tracked down with tomcat / async dispatch would be more illustrative of the problem?", "author": "trask", "createdAt": "2020-08-07T18:51:14Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -0,0 +1,87 @@\n+# The story of context propagation across threads\n+\n+## The need\n+Take a look at the following two pseudo-code snippets (see below for explanations).\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    Future f1 = pool.submit(() -> {\n+        return userRepository.queryShippingAddress(requet)\n+    })\n+    Future f2 = pool.submit(() -> {\n+        return warehouse.currentState(requet)\n+    })\n+    writeResponse(response, f1.get(), f2.get())\n+}\n+```\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    final AsyncContext acontext = request.startAsync();\n+    acontext.start(() -> {\n+            String address = userRepository.queryShippingAddress(requet)\n+            HttpServletResponse response = acontext.getResponse();\n+            writeResponse(response, address)\n+            acontext.complete();\n+   }\n+}\n+```\n+\n+In both cases request processing requires some potentially long operation and application developer\n+wants to do them off the main thread. In the first case this hand-off between request accepting thread\n+and request processing thread happens manually, by submitting work into some thread pool.\n+In the second case it is the framework that handles separate thread pool and passing work to it.\n+\n+In cases like this proper tracing solution should still combine into a single trace all the work\n+required for request processing, irregardless in what thread that work happened. With proper\n+parent-child relationship between span: span representing shipping address query should be the child\n+of the span which denotes accepting HTTP request.\n+\n+## The solution\n+Java auto instrumentation uses an obvious solution to the requirement above: we attach current execution\n+context (represented in the code by `io.grpc.Context`) with each `Runnable`, `Callable` and `ForkJoinTask`.\n+\"Current\" means the context active on the thread which calls `Executor.execute` (and its analogues\n+such as `submit`, `invokeAll` etc) at the moment of that call. Whenever some other thread starts\n+actual execution of that `Runnable` (or `Callable` or `ForkJoinTask`), that context get restored\n+on that thread for the duration of the execution. This can be illustrated by the following pseudo-code:\n+\n+```\n+    var job = () -> {\n+        try(Scope scope = withScopedContext(this.context)) {\n+            return userRepository.queryShippingAddress(requet)\n+        }}\n+    job.context = Context.current()\n+    Future f1 = pool.submit()\n+\n+```\n+\n+## The drawback\n+There are some runtime environments which, simplifying, do the following:", "originalCommit": "47cb63ea0f9c6837ca01907245da201699f623bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU5MDAyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r467590029", "bodyText": "I don't quite understand what do you mean by \"leak the first pool.submit\"? My idea was to show that any context, which was active during the first pool.submit will continue to be active for all runnables submitted via this started chain. That second AcceptRequestRunnable will have the same active context as the first one.", "author": "iNikem", "createdAt": "2020-08-09T14:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY4MTAzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r467681034", "bodyText": "I'm not clear, are you showing that the context (e.g. spanId) from REQUEST#1 below will leak to REQUEST#2? I don't think it will, at least I don't think it will via the java-concurrent instrumentation alone.\nThis is what it looks like to me:\npool.submit(new AcceptRequestRunnable() {    <!--- assuming clean context to start with\n    Request req = readRequest()    <--- REQUEST#1\n    pool.submit(new ProcessRequestRunnable(req) {    <!--- the clean context from above will be propagated\n        writeResponse(process(req))    <--- REQUEST#1\n        pool.submit(new AcceptRequestRunnable() {    <!--- the clean context from above will be propagated\n            Request req = readRequest()    <--- REQUEST#2\n            ... repeat until shutdown\n    })\n})", "author": "trask", "createdAt": "2020-08-10T04:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMjkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MDU0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r468360541", "bodyText": "I tried to add clarifications, PTAL", "author": "iNikem", "createdAt": "2020-08-11T06:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMjkzMw=="}], "type": "inlineReview"}, {"oid": "92e4ab02dbfbc8036c6e07670c4b343d67f6609a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/92e4ab02dbfbc8036c6e07670c4b343d67f6609a", "message": "Update docs/contributing/inter-thread-context-propagation.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-08-09T14:23:29Z", "type": "commit"}, {"oid": "90689e4ea4c0a9cb99ddc464226dface20d9f9e4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/90689e4ea4c0a9cb99ddc464226dface20d9f9e4", "message": "Update docs/contributing/inter-thread-context-propagation.md\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-08-09T14:23:35Z", "type": "commit"}, {"oid": "417aea42d88251bd47394d3f38fecaab54d01446", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/417aea42d88251bd47394d3f38fecaab54d01446", "message": "More clarifications", "committedDate": "2020-08-11T06:43:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjYwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r468362602", "bodyText": "At this point Context.current() will have a started span\n\nthis is the part of the example that I'm not following, how does the (thread-bound) Context with the started span escape readRequest()?", "author": "trask", "createdAt": "2020-08-11T06:50:05Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -0,0 +1,94 @@\n+# The story of context propagation across threads\n+\n+## The need\n+Take a look at the following two pseudo-code snippets (see below for explanations).\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    Future f1 = pool.submit(() -> {\n+        return userRepository.queryShippingAddress(requet)\n+    })\n+    Future f2 = pool.submit(() -> {\n+        return warehouse.currentState(requet)\n+    })\n+    writeResponse(response, f1.get(), f2.get())\n+}\n+```\n+\n+```\n+Executor pool = Executors.newFixedThreadPool(10)\n+\n+public void doGet(HttpServletRequest request, HttpServletResponse response) {\n+    final AsyncContext acontext = request.startAsync();\n+    acontext.start(() -> {\n+            String address = userRepository.queryShippingAddress(requet)\n+            HttpServletResponse response = acontext.getResponse();\n+            writeResponse(response, address)\n+            acontext.complete();\n+   }\n+}\n+```\n+\n+In both cases request processing requires some potentially long operation and application developer\n+wants to do them off the main thread. In the first case this hand-off between request accepting thread\n+and request processing thread happens manually, by submitting work into some thread pool.\n+In the second case it is the framework that handles separate thread pool and passing work to it.\n+\n+In cases like this proper tracing solution should still combine into a single trace all the work\n+required for request processing, regardless in what thread that work happened. With proper\n+parent-child relationship between span: span representing shipping address query should be the child\n+of the span which denotes accepting HTTP request.\n+\n+## The solution\n+Java auto instrumentation uses an obvious solution to the requirement above: we attach current execution\n+context (represented in the code by `io.grpc.Context`) with each `Runnable`, `Callable` and `ForkJoinTask`.\n+\"Current\" means the context active on the thread which calls `Executor.execute` (and its analogues\n+such as `submit`, `invokeAll` etc) at the moment of that call. Whenever some other thread starts\n+actual execution of that `Runnable` (or `Callable` or `ForkJoinTask`), that context get restored\n+on that thread for the duration of the execution. This can be illustrated by the following pseudo-code:\n+\n+```\n+    var job = () -> {\n+        try(Scope scope = withScopedContext(this.context)) {\n+            return userRepository.queryShippingAddress(requet)\n+        }}\n+    job.context = Context.current()\n+    Future f1 = pool.submit()\n+\n+```\n+\n+## The drawback\n+There are some runtime environments which, simplifying, do the following:\n+```\n+pool.submit(new AcceptRequestRunnable() {\n+    Request req = readRequest()\n+    // At this point Context.current() will have a started span", "originalCommit": "417aea42d88251bd47394d3f38fecaab54d01446", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NTY3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r468375672", "bodyText": "And now?", "author": "iNikem", "createdAt": "2020-08-11T07:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjYwMg=="}], "type": "inlineReview"}, {"oid": "f1605ddf0d028d909933a8898a45fa44ee268825", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f1605ddf0d028d909933a8898a45fa44ee268825", "message": "More clarifications", "committedDate": "2020-08-11T07:18:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4ODQzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/910#discussion_r468388432", "bodyText": "why would we instrument service(req) above, and not instrument writeResponse(process(req)), which would solve the propagation issue for this example? let's add this to agenda for tomorrow's special topic meeting, will be easier to discuss, i have a feeling i'm not expressing my thoughts about this (complicated topic) very well", "author": "trask", "createdAt": "2020-08-11T07:44:18Z", "path": "docs/contributing/inter-thread-context-propagation.md", "diffHunk": "@@ -64,15 +64,17 @@ There are some runtime environments which, simplifying, do the following:\n ```\n pool.submit(new AcceptRequestRunnable() {\n     Request req = readRequest()\n-    // At this point Context.current() will have a started span\n-    // recording monitoring data about `req`\n-    pool.submit(new ProcessRequestRunnable(req) {\n-        // The same context from above is active here\n-        writeResponse(process(req))\n-        pool.submit(new AcceptRequestRunnable() {\n-        // The same context from above is propagated here as well\n-        ... repeat until shutdown\n-    })\n+    service(req){ <- This method is instrumented and we start new scope here\n+        // At this point Context.current() will have a started span\n+        // recording monitoring data about `req`\n+        pool.submit(new ProcessRequestRunnable(req) {\n+            // The same context from above is active here\n+            writeResponse(process(req))", "originalCommit": "f1605ddf0d028d909933a8898a45fa44ee268825", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad238351e71652d13edac91bde95025fc2a80fdc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad238351e71652d13edac91bde95025fc2a80fdc", "message": "Better example", "committedDate": "2020-08-12T07:39:00Z", "type": "commit"}]}