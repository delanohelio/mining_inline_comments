{"pr_number": 1917, "pr_title": "Add support for Undertow server runtime", "pr_createdAt": "2020-12-16T12:01:51Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917", "timeline": [{"oid": "dfe868e0fe7bd3467a0a78d92f21b63b00315b4e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dfe868e0fe7bd3467a0a78d92f21b63b00315b4e", "message": "Add support for Undertow server runtime", "committedDate": "2020-12-16T12:00:18Z", "type": "commit"}, {"oid": "8001d0ee0aa9303448adc854def48735cbcf3a48", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8001d0ee0aa9303448adc854def48735cbcf3a48", "message": "Polish", "committedDate": "2020-12-16T13:01:59Z", "type": "commit"}, {"oid": "7726dbbbf5bb0c42761ec6862aa68843d7715a49", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7726dbbbf5bb0c42761ec6862aa68843d7715a49", "message": "Damn be classloaders", "committedDate": "2020-12-16T14:58:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MzI2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544653260", "bodyText": "this is a great idea, definitely other places we can take advantage of this", "author": "trask", "createdAt": "2020-12-16T21:59:53Z", "path": "javaagent/javaagent.gradle", "diffHunk": "@@ -32,10 +32,15 @@ CopySpec isolateSpec(Collection<Project> projectsWithShadowJar) {\n     from({ projectsWithShadowJar.tasks.shadowJar.collect { zipTree(it.archiveFile) } }) {\n       // important to keep prefix 'inst' short, as it is prefixed to lots of strings in runtime mem\n       into 'inst'\n+      exclude 'io/opentelemetry/javaagent/instrumentation/api/**/*.class'\n       rename '(^.*)\\\\.class$', '$1.classdata'\n       // Rename LICENSE file since it clashes with license dir on non-case sensitive FSs (i.e. Mac)\n       rename '^LICENSE$', 'LICENSE.renamed'\n     }\n+    //This allows every instrumentation to have their own classes that should go to bootstrap classloader", "originalCommit": "7726dbbbf5bb0c42761ec6862aa68843d7715a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTgyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544655826", "bodyText": "I don't think we generally perform this check (maybe we should?)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (!Java8BytecodeBridge.currentContext().equals(attachedContext)) {\n          \n          \n            \n                        scope = attachedContext.makeCurrent();\n          \n          \n            \n                      }\n          \n          \n            \n                      scope = attachedContext.makeCurrent();", "author": "trask", "createdAt": "2020-12-16T22:04:20Z", "path": "instrumentation/undertow/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/undertow/UndertowInstrumentationModule.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.undertow;\n+\n+import static io.opentelemetry.javaagent.instrumentation.undertow.UndertowHttpServerTracer.tracer;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import io.undertow.server.HttpServerExchange;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class UndertowInstrumentationModule extends InstrumentationModule {\n+\n+  public UndertowInstrumentationModule() {\n+    super(\"undertow\", \"undertow-2.0\");\n+  }\n+\n+  @Override\n+  public ElementMatcher.Junction<ClassLoader> classLoaderMatcher() {\n+    return hasClassesNamed(\"io.undertow.server.HttpHandler\");\n+  }\n+\n+  @Override\n+  public List<TypeInstrumentation> typeInstrumentations() {\n+    return singletonList(new HandlerInstrumentation());\n+  }\n+\n+  public static class HandlerInstrumentation implements TypeInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<TypeDescription> typeMatcher() {\n+      return implementsInterface(named(\"io.undertow.server.HttpHandler\"));\n+    }\n+\n+    @Override\n+    public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+      return singletonMap(\n+          named(\"handleRequest\")\n+              .and(takesArgument(0, named(\"io.undertow.server.HttpServerExchange\")))\n+              .and(isPublic()),\n+          UndertowHandlerAdvice.class.getName());\n+    }\n+\n+    public static class UndertowHandlerAdvice {\n+      @Advice.OnMethodEnter(suppress = Throwable.class)\n+      public static void onEnter(\n+          @Advice.Origin Method method,\n+          @Advice.Argument(value = 0, readOnly = false) HttpServerExchange exchange,\n+          @Advice.Local(\"otelScope\") Scope scope) {\n+        Context attachedContext = tracer().getServerContext(exchange);\n+        if (attachedContext != null) {\n+          if (!Java8BytecodeBridge.currentContext().equals(attachedContext)) {\n+            scope = attachedContext.makeCurrent();\n+          }", "originalCommit": "7726dbbbf5bb0c42761ec6862aa68843d7715a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMTU1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r546631556", "bodyText": "This is similar to rescoping check in Servlet3. If there is server context attached to the request and it differs from the current context, then we rescope into server context. If they are the same, no point in calling makeCurrent, is it?", "author": "iNikem", "createdAt": "2020-12-21T10:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MzM2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r546883363", "bodyText": "I thought you were always on the side of less code in the Advice classes \ud83d\ude04", "author": "trask", "createdAt": "2020-12-21T19:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk0NzExMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r546947111", "bodyText": "I am, but I still want to prevent unnecessary makeCurrent :)", "author": "iNikem", "createdAt": "2020-12-21T21:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1Nzg3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544657870", "bodyText": "is this needed? (see javadoc on classLoaderMatcher)", "author": "trask", "createdAt": "2020-12-16T22:08:06Z", "path": "instrumentation/undertow/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/undertow/UndertowInstrumentationModule.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.undertow;\n+\n+import static io.opentelemetry.javaagent.instrumentation.undertow.UndertowHttpServerTracer.tracer;\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.javaagent.instrumentation.api.Java8BytecodeBridge;\n+import io.opentelemetry.javaagent.tooling.InstrumentationModule;\n+import io.opentelemetry.javaagent.tooling.TypeInstrumentation;\n+import io.undertow.server.HttpServerExchange;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(InstrumentationModule.class)\n+public class UndertowInstrumentationModule extends InstrumentationModule {\n+\n+  public UndertowInstrumentationModule() {\n+    super(\"undertow\", \"undertow-2.0\");\n+  }\n+\n+  @Override\n+  public ElementMatcher.Junction<ClassLoader> classLoaderMatcher() {\n+    return hasClassesNamed(\"io.undertow.server.HttpHandler\");\n+  }", "originalCommit": "7726dbbbf5bb0c42761ec6862aa68843d7715a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjYzMjI2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r546632268", "bodyText": "Moved to HandlerInstrumentation as classLoaderOptimization", "author": "iNikem", "createdAt": "2020-12-21T10:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1Nzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544661955", "bodyText": "two thoughts:\n\na bootstrap class can't really reference the AttachmentKey class, the reason this is working is because of erasure, but think better to not hide that, and use Object here in the signature\nI think better to use Map<ClassLoader, Object> (where the value is AttachmentKey), in case undertow itself is loaded by two different class loaders, in which case you really do need two different AttachmentKey instances. The key of the map would be AttachmentKey.class.getClassLoader().", "author": "trask", "createdAt": "2020-12-16T22:15:49Z", "path": "instrumentation/undertow/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/api/KeyHolder.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.api;\n+\n+import io.opentelemetry.context.Context;\n+import io.undertow.server.HttpServerExchange;\n+import io.undertow.util.AttachmentKey;\n+import java.util.IdentityHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Undertow's {@link HttpServerExchange} uses {@link AttachmentKey} as a key for storing arbitrary\n+ * data. It uses {@link IdentityHashMap} and thus all keys are compared for equality by object\n+ * reference. This means that we cannot hold an instance of {@link AttachmentKey} in a static field\n+ * of the corresponding Tracer, as we usually do. Tracers are loaded into user's classloaders and\n+ * thus it is totally possible to have several instances of tracers. Each of those instances will\n+ * have a separate value in a static field and {@link HttpServerExchange} will treat them as\n+ * different keys then.\n+ *\n+ * <p>That is why this class exists and resides in a separate package. This package is treated in a\n+ * special way and is always loaded by bootstrap classloader. This makes sure that this class is\n+ * available to all tracers from every classloader.\n+ *\n+ * <p>But at the same time, being loaded by bootstrap classloader, this class itself cannot initiate\n+ * the loading of {@link AttachmentKey} class. Class has to be loaded by <i>any</i> classloader that\n+ * has it, e.g. by the classloader of a Tracer that uses this key holder. After that, <i>all</i>\n+ * Tracers, loaded by all classloaders, will be able to use exactly the same sole instance of the\n+ * key.\n+ */\n+public class KeyHolder {\n+  public static final AtomicReference<AttachmentKey<Context>> contextKey = new AtomicReference<>();", "originalCommit": "7726dbbbf5bb0c42761ec6862aa68843d7715a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2MTU2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544761569", "bodyText": "How about a map from class to object to allow scaling this to any type? WeakMap<Class<?>, Object>. And since classes from different classloaders aren't equal (I presume), wouldn't need ClassLoader in the key I believe.", "author": "anuraaga", "createdAt": "2020-12-17T02:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NTgxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544765819", "bodyText": "ya, I like that, it's approximately \"contextStore\" for a single static field", "author": "trask", "createdAt": "2020-12-17T02:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMDA5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r544900090", "bodyText": "Why do I want two different key instance if Undertow is loaded from two different classloaders? And how is the latter possible?\nImportant point is that any given request must use the same key all the time it passes through Undertow and WildFly.", "author": "iNikem", "createdAt": "2020-12-17T08:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3MTc3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r545471774", "bodyText": "It's not going to happen in wildfly, since wildfly provides undertow in its root class loader, but it's possible, e.g. say you had two tomcat apps that each included undertow library.\nAnd if you have two class loaders each with their own copy of undertow classes, and if you store an AttachmentKey from one class loader into the AtomicReference, and read it back out from the other class loader and cast it to AttachmentKey you will get ClassCastException.", "author": "trask", "createdAt": "2020-12-17T23:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTYwNjUwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r545606503", "bodyText": "Now I understand :) Thank you for your patience :)", "author": "iNikem", "createdAt": "2020-12-18T06:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1Mjg5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r546652890", "bodyText": "Done", "author": "iNikem", "createdAt": "2020-12-21T11:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2MTk1NQ=="}], "type": "inlineReview"}, {"oid": "d380d5c5302a117d3bc7c275c2c7b8697bd7850a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d380d5c5302a117d3bc7c275c2c7b8697bd7850a", "message": "Merge remote-tracking branch 'upstream/master' into undertow", "committedDate": "2020-12-17T12:42:53Z", "type": "commit"}, {"oid": "9d2ac5f54d8ff78d80b64b9e50bb31446b65c882", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9d2ac5f54d8ff78d80b64b9e50bb31446b65c882", "message": "Fix correct span name", "committedDate": "2020-12-17T14:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE5MjczOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1917#discussion_r545192739", "bodyText": "Consider creating an undertow sub-package.", "author": "mateuszrzeszutek", "createdAt": "2020-12-17T15:46:33Z", "path": "instrumentation/undertow/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/api/KeyHolder.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.api;", "originalCommit": "9d2ac5f54d8ff78d80b64b9e50bb31446b65c882", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fd6feb9536dd9cd58d3c8f279695631dfd6ad17", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7fd6feb9536dd9cd58d3c8f279695631dfd6ad17", "message": "Polish", "committedDate": "2020-12-21T11:34:13Z", "type": "commit"}]}