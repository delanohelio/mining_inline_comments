{"pr_number": 1493, "pr_title": "Replace ContextStore for context bridge with a custom context storage\u2026", "pr_createdAt": "2020-10-27T07:14:38Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493", "timeline": [{"oid": "705aba607778f77da89ca0b6fc9d0796843aca42", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/705aba607778f77da89ca0b6fc9d0796843aca42", "message": "Replace ContextStore for context bridge with a custom context storage provider.", "committedDate": "2020-10-27T07:09:34Z", "type": "commit"}, {"oid": "1b461995ae06e6965f83b6a511bf4c1d1e7f6840", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1b461995ae06e6965f83b6a511bf4c1d1e7f6840", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into contextstorage-override", "committedDate": "2020-10-27T08:21:23Z", "type": "commit"}, {"oid": "e90fbd5f3739717f4f4b7a279a8b0da2de9d9483", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e90fbd5f3739717f4f4b7a279a8b0da2de9d9483", "message": "Handle context mapping at storage layer.", "committedDate": "2020-10-28T02:41:40Z", "type": "commit"}, {"oid": "2070bdf0044ae4f844f8c9f0eaf0f1ee1eb4a3cb", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/2070bdf0044ae4f844f8c9f0eaf0f1ee1eb4a3cb", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into contextstorage-override", "committedDate": "2020-10-28T02:41:46Z", "type": "commit"}, {"oid": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "message": "Cleanup", "committedDate": "2020-10-28T04:22:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjYxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172611", "bodyText": "We used to instrument all the methods of the package-private class TracingContextUtils, now we do still end up with one instrumentation of DefaultContext along with the reflective access to the context key.", "author": "anuraaga", "createdAt": "2020-10-28T04:24:50Z", "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/ContextInstrumentation.java", "diffHunk": "@@ -6,65 +6,48 @@\n package io.opentelemetry.javaagent.instrumentation.opentelemetryapi;\n \n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n \n import application.io.opentelemetry.context.Context;\n-import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.context.ContextStorage;\n import com.google.auto.service.AutoService;\n-import io.opentelemetry.javaagent.instrumentation.api.ContextStore;\n-import io.opentelemetry.javaagent.instrumentation.api.InstrumentationContext;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context.AgentContextStorage;\n import io.opentelemetry.javaagent.tooling.Instrumenter;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.Map;\n import net.bytebuddy.asm.Advice;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n \n+/**\n+ * Returns {@link AgentContextStorage} as the implementation of {@link ContextStorage} in the\n+ * application classpath. We do this instead of using the normal service loader mechanism to make\n+ * sure there is no dependency on a system property or possibility of a user overriding this since\n+ * it's required for instrumentation in the agent to work properly.\n+ */\n @AutoService(Instrumenter.class)\n public class ContextInstrumentation extends AbstractInstrumentation {\n \n   @Override\n   public ElementMatcher<? super TypeDescription> typeMatcher() {\n-    return named(\"application.io.opentelemetry.context.Context\");\n+    return named(\"application.io.opentelemetry.context.DefaultContext\");", "originalCommit": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513172711", "bodyText": "Since an agent can take over apps, I'm assuming this is allowed? Not sure", "author": "anuraaga", "createdAt": "2020-10-28T04:25:11Z", "path": "instrumentation/opentelemetry-api-beta/src/main/java/io/opentelemetry/javaagent/instrumentation/opentelemetryapi/context/AgentContextStorage.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.opentelemetryapi.context;\n+\n+import application.io.opentelemetry.context.Context;\n+import application.io.opentelemetry.context.ContextKey;\n+import application.io.opentelemetry.context.ContextStorage;\n+import application.io.opentelemetry.context.Scope;\n+import application.io.opentelemetry.trace.Span;\n+import io.opentelemetry.javaagent.instrumentation.opentelemetryapi.trace.Bridging;\n+import java.lang.reflect.Field;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ContextStorage} which stores the {@link Context} in the user's application inside the\n+ * {@link Context} in the agent. This allows for context interaction to be maintained between the\n+ * app and agent.\n+ *\n+ * <p>This storage allows for implicit parenting of context to exist between the agent and\n+ * application by storing the concrete application context in the agent context and returning a\n+ * wrapper which accesses into this stored concrete context.\n+ *\n+ * <p>This storage also makes sure that OpenTelemetry objects are shared within the context. To do\n+ * this, it recognizes the keys for OpenTelemetry objects (e.g, {@link Span}, Baggage (WIP)) and\n+ * always stores and retrieves them from the agent context, even when accessed from the application.\n+ * All other accesses are to the concrete application context.\n+ */\n+public class AgentContextStorage implements ContextStorage {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(AgentContextStorage.class);\n+\n+  public static final AgentContextStorage INSTANCE = new AgentContextStorage();\n+\n+  public static io.opentelemetry.context.Context getAgentContext(Context applicationContext) {\n+    if (applicationContext instanceof AgentContextWrapper) {\n+      return ((AgentContextWrapper) applicationContext).toAgentContext();\n+    }\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\n+          \"unexpected context: {}\", applicationContext, new Exception(\"unexpected context\"));\n+    }\n+    return io.opentelemetry.context.Context.root();\n+  }\n+\n+  static final io.opentelemetry.context.ContextKey<Context> APPLICATION_CONTEXT =\n+      io.opentelemetry.context.ContextKey.named(\"otel-context\");\n+\n+  static final io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span>\n+      AGENT_SPAN_CONTEXT_KEY;\n+  static final ContextKey<Span> APPLICATION_SPAN_CONTEXT_KEY;\n+\n+  static {\n+    io.opentelemetry.context.ContextKey<io.opentelemetry.trace.Span> agentSpanContextKey;\n+    try {\n+      Class<?> tracingContextUtils = Class.forName(\"io.opentelemetry.trace.TracingContextUtils\");\n+      Field contextSpanKeyField = tracingContextUtils.getDeclaredField(\"CONTEXT_SPAN_KEY\");\n+      contextSpanKeyField.setAccessible(true);", "originalCommit": "60644edbe70da71eaea0ac32bd1c46711a2b1ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk2OTU4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513969582", "bodyText": "let's figure this out later \ud83d\ude04 created #1520 and referenced this comment to track", "author": "trask", "createdAt": "2020-10-29T04:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MjcxMQ=="}], "type": "inlineReview"}, {"oid": "a2e63f4ae73cd03ddba5de2459f020f7471d7fd6", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a2e63f4ae73cd03ddba5de2459f020f7471d7fd6", "message": "Add interop test", "committedDate": "2020-10-29T03:37:20Z", "type": "commit"}, {"oid": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "message": "Small comment", "committedDate": "2020-10-29T03:39:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513974462", "bodyText": "does this test show interop, or just side-by-side, since everything is in the same thread?\nwould it be better to Context.root().makeCurrent().withCloseable {} (for both agent and non-agent) around each existing makeCurrent().withCloseable {} (except for the first) below?", "author": "trask", "createdAt": "2020-10-29T05:07:32Z", "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {", "originalCommit": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAwODU3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514008579", "bodyText": "I don't think this one shows interop indeed, just the context parenting. The below tests have \"another thread\" for propagation test.\nNot sure I understand would it be better to Context.root().makeCurrent().withCloseable {} - if we mount root in the middle of the tree it's like resetting context, right?", "author": "anuraaga", "createdAt": "2020-10-29T06:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAxNzQ3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514017476", "bodyText": "ya, you're right, the test below addresses propagating across threads, so no need for that in this test", "author": "trask", "createdAt": "2020-10-29T06:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3NDQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3ODUxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r513978511", "bodyText": "these tests run with our java-concurrent, so I think that will auto-propagate agentContext(?) which makes it hard to reason about this test\nmaybe cleaner to do the Context.root().makeCurrent().withScoped {} on both, then call context.wrap(runnable).run() inside of that, and not mess with threads?", "author": "trask", "createdAt": "2020-10-29T05:15:54Z", "path": "instrumentation/opentelemetry-api-beta/src/test/groovy/ContextBridgeTest.groovy", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import application.io.opentelemetry.OpenTelemetry\n+import application.io.opentelemetry.context.Context\n+import application.io.opentelemetry.context.ContextKey\n+import application.io.opentelemetry.trace.Span\n+import io.opentelemetry.instrumentation.test.AgentTestRunner\n+import java.util.concurrent.ExecutorService\n+import java.util.concurrent.Executors\n+import java.util.concurrent.atomic.AtomicReference\n+import spock.lang.Shared\n+\n+class ContextBridgeTest extends AgentTestRunner {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\")\n+\n+  private static final io.opentelemetry.context.ContextKey<String> FOOD =\n+    io.opentelemetry.context.ContextKey.named(\"food\")\n+  private static final io.opentelemetry.context.ContextKey<String> COUNTRY =\n+    io.opentelemetry.context.ContextKey.named(\"country\")\n+\n+  @Shared\n+  ExecutorService otherThread\n+\n+  def setupSpec() {\n+    otherThread = Executors.newSingleThreadExecutor()\n+  }\n+\n+  def cleanupSpec() {\n+    otherThread.shutdown()\n+  }\n+\n+  def \"agent and application mix\"() {\n+    expect:\n+    def agentContext = io.opentelemetry.context.Context.current().with(COUNTRY, \"japan\")\n+    io.opentelemetry.context.Context.current().get(COUNTRY) == null\n+    agentContext.makeCurrent().withCloseable {\n+      io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+      Context.current().with(ANIMAL, \"cat\").makeCurrent().withCloseable {\n+        Context.current().get(ANIMAL) == \"cat\"\n+        io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+\n+        def agentContext2 = io.opentelemetry.context.Context.current().with(FOOD, \"cheese\")\n+        io.opentelemetry.context.Context.current().get(FOOD) == null\n+        agentContext2.makeCurrent().withCloseable {\n+          io.opentelemetry.context.Context.current().get(FOOD) == \"cheese\"\n+          io.opentelemetry.context.Context.current().get(COUNTRY) == \"japan\"\n+          Context.current().get(ANIMAL) == \"cat\"\n+        }\n+      }\n+    }\n+  }\n+\n+  // The difference between \"standard\" context interop and our bridge is that with normal interop,\n+  // keys are still isolated completely. We have special logic to share the same data for our known\n+  // types like span.\n+  def \"agent and application share span\"() {\n+    when:\n+    def applicationTracer = OpenTelemetry.getGlobalTracer(\"test\")\n+    def agentTracer = io.opentelemetry.OpenTelemetry.getGlobalTracer(\"test\")\n+\n+    then:\n+    !Span.current().spanContext.isValid()\n+    !io.opentelemetry.trace.Span.current().spanContext.isValid()\n+\n+    def applicationSpan = applicationTracer.spanBuilder(\"test1\").startSpan()\n+    applicationSpan.spanContext.isValid()\n+    applicationSpan.makeCurrent().withCloseable {\n+      Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+      io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+\n+      def agentSpan = agentTracer.spanBuilder(\"test2\").startSpan()\n+      agentSpan.makeCurrent().withCloseable {\n+        Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == agentSpan.spanContext.spanIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == agentSpan.spanContext.traceIdAsHexString\n+        io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+\n+        def applicationSpan2 = applicationTracer.spanBuilder(\"test3\").startSpan()\n+        applicationSpan2.makeCurrent().withCloseable {\n+          Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.spanIdAsHexString == applicationSpan2.spanContext.spanIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan2.spanContext.traceIdAsHexString\n+          io.opentelemetry.trace.Span.current().spanContext.traceIdAsHexString == applicationSpan.spanContext.traceIdAsHexString\n+        }\n+      }\n+    }\n+  }\n+\n+  def \"agent wraps\"() {", "originalCommit": "ee5c35eef7c745c79e98bc28e475f8ecdaef0355", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAxMDA4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1493#discussion_r514010080", "bodyText": "Heh forgot about that. Yeah that seems like it will test it well.", "author": "anuraaga", "createdAt": "2020-10-29T06:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk3ODUxMQ=="}], "type": "inlineReview"}, {"oid": "11b115bee094dcccc172505f6c871a2a1de5ab60", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/11b115bee094dcccc172505f6c871a2a1de5ab60", "message": "No threads", "committedDate": "2020-10-29T06:19:29Z", "type": "commit"}, {"oid": "a62f3eb866d18b8bfac671bdb924e6b7cdc17ce0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a62f3eb866d18b8bfac671bdb924e6b7cdc17ce0", "message": "Groovy", "committedDate": "2020-10-29T06:26:52Z", "type": "commit"}]}