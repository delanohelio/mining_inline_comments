{"pr_number": 1396, "pr_title": "Actually use requested number of versions to test muzzle", "pr_createdAt": "2020-10-15T10:24:43Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1396", "timeline": [{"oid": "7d48fd3fb261bb1ab3914606a4cb9a2db0b36992", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7d48fd3fb261bb1ab3914606a4cb9a2db0b36992", "message": "Actually use requested number of versions to test muzzle", "committedDate": "2020-10-15T10:23:14Z", "type": "commit"}, {"oid": "014364577653bbf3779ed2d8973b8c9ae1fd2a72", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/014364577653bbf3779ed2d8973b8c9ae1fd2a72", "message": "Fix inverse", "committedDate": "2020-10-15T10:51:29Z", "type": "commit"}, {"oid": "a4ac359ab7d8b3aa919be08e61a2d75f896058b3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a4ac359ab7d8b3aa919be08e61a2d75f896058b3", "message": "Polish", "committedDate": "2020-10-15T11:07:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyMzU4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1396#discussion_r506023584", "bodyText": "I think maybe good not to apply predicate test to highestVersion, so we can find out early that we may issue with future version.\nThough then we tend to just limit the max version, and we never get notified when a non-\"beta\" version is released, which is worse.\nSo ignore me, all good \ud83d\ude04.", "author": "trask", "createdAt": "2020-10-16T03:26:02Z", "path": "buildSrc/src/main/groovy/MuzzlePlugin.groovy", "diffHunk": "@@ -244,47 +239,92 @@ class MuzzlePlugin implements Plugin<Project> {\n   private static Set<MuzzleDirective> inverseOf(MuzzleDirective muzzleDirective, RepositorySystem system, RepositorySystemSession session) {\n     Set<MuzzleDirective> inverseDirectives = new HashSet<>()\n \n-    Artifact allVerisonsArtifact = new DefaultArtifact(muzzleDirective.group, muzzleDirective.module, \"jar\", \"[,)\")\n+    Artifact allVersionsArtifact = new DefaultArtifact(muzzleDirective.group, muzzleDirective.module, \"jar\", \"[,)\")\n     Artifact directiveArtifact = new DefaultArtifact(muzzleDirective.group, muzzleDirective.module, \"jar\", muzzleDirective.versions)\n \n-\n     VersionRangeRequest allRangeRequest = new VersionRangeRequest()\n     allRangeRequest.setRepositories(MUZZLE_REPOS)\n-    allRangeRequest.setArtifact(allVerisonsArtifact)\n+    allRangeRequest.setArtifact(allVersionsArtifact)\n     VersionRangeResult allRangeResult = system.resolveVersionRange(session, allRangeRequest)\n \n     VersionRangeRequest rangeRequest = new VersionRangeRequest()\n     rangeRequest.setRepositories(MUZZLE_REPOS)\n     rangeRequest.setArtifact(directiveArtifact)\n     VersionRangeResult rangeResult = system.resolveVersionRange(session, rangeRequest)\n-    Set<Version> versions = rangeResult.versions.toSet()\n-\n-    filterVersion(allRangeResult.versions.toSet(), muzzleDirective.skipVersions).collect { version ->\n-      if (!versions.contains(version)) {\n-        MuzzleDirective inverseDirective = new MuzzleDirective()\n-        inverseDirective.group = muzzleDirective.group\n-        inverseDirective.module = muzzleDirective.module\n-        inverseDirective.versions = \"$version\"\n-        inverseDirective.assertPass = !muzzleDirective.assertPass\n-        inverseDirectives.add(inverseDirective)\n-      }\n+\n+    allRangeResult.getVersions().removeAll(rangeResult.getVersions())\n+\n+    filterVersions(allRangeResult, muzzleDirective.skipVersions).each { version ->\n+      MuzzleDirective inverseDirective = new MuzzleDirective()\n+      inverseDirective.group = muzzleDirective.group\n+      inverseDirective.module = muzzleDirective.module\n+      inverseDirective.versions = version\n+      inverseDirective.assertPass = !muzzleDirective.assertPass\n+      inverseDirectives.add(inverseDirective)\n     }\n \n     return inverseDirectives\n   }\n \n-  private static void limitLargeRanges(VersionRangeResult result, Set<Version> versions, Set<String> skipVersions) {\n-    List<Version> copy = new ArrayList<>(versions)\n-    copy.removeAll(skipVersions)\n+  private static Set<String> filterVersions(VersionRangeResult range, Set<String> skipVersions) {\n+    Set<String> result = new HashSet<>()\n+\n+    def predicate = new AcceptableVersions(range, skipVersions)\n+    if (predicate.test(range.lowestVersion)) {\n+      result.add(range.lowestVersion.toString())\n+    }\n+    if (predicate.test(range.highestVersion)) {\n+      result.add(range.highestVersion.toString())\n+    }", "originalCommit": "a4ac359ab7d8b3aa919be08e61a2d75f896058b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}