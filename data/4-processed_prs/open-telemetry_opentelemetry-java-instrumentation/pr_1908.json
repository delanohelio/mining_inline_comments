{"pr_number": 1908, "pr_title": "HTTP client instrumentation cleanup: http-url-connection", "pr_createdAt": "2020-12-15T01:26:11Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908", "timeline": [{"oid": "74b9cacc68dec9b75684778a23db707a68efd5d2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/74b9cacc68dec9b75684778a23db707a68efd5d2", "message": "HttpClientTracer cleanup: http-url-connection", "committedDate": "2020-12-15T01:24:31Z", "type": "commit"}, {"oid": "f9bff43281b156650b3e06df48baf8c16c52fcb2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f9bff43281b156650b3e06df48baf8c16c52fcb2", "message": "Checkstyle", "committedDate": "2020-12-15T01:50:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543091550", "bodyText": "We don't have similar condition in other instrumentations, right? Why do we need it here?", "author": "iNikem", "createdAt": "2020-12-15T06:55:51Z", "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -79,75 +81,65 @@ public HttpUrlConnectionInstrumentationModule() {\n   public static class HttpUrlConnectionAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static HttpUrlState methodEnter(\n+    public static void methodEnter(\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"connected\") boolean connected,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpURLConnection.class);\n-      if (callDepth > 0) {\n-        return null;\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+\n+      callDepth = CallDepthThreadLocalMap.getCallDepth(HttpURLConnection.class);\n+      if (callDepth.getAndIncrement() > 0) {\n+        // only want the rest of the instrumentation rules (which are complex enough) to apply to\n+        // top-level HttpURLConnection calls\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      ContextStore<HttpURLConnection, HttpUrlState> contextStore =\n-          InstrumentationContext.get(HttpURLConnection.class, HttpUrlState.class);\n-      HttpUrlState state = contextStore.putIfAbsent(connection, HttpUrlState::new);\n-\n-      synchronized (state) {\n-        if (!state.initialized) {\n-          Context parentContext = currentContext();\n-          if (tracer().shouldStartSpan(parentContext)) {\n-            state.context = tracer().startSpan(parentContext, connection, connection);\n-            if (!connected) {\n-              scope = state.context.makeCurrent();\n-            }\n-          }\n-          state.initialized = true;\n-        }\n+      // putting into storage for a couple of reasons:\n+      // - to start an operation in connect() and end it in getInputStream()\n+      // - to avoid creating new operation on multiple subsequent calls to getInputStream()\n+      ContextStore<HttpURLConnection, Context> storage =\n+          InstrumentationContext.get(HttpURLConnection.class, Context.class);\n+      context = storage.get(connection);\n+\n+      if (context == null) {\n+        context = tracer().startSpan(parentContext, connection);\n+        storage.put(connection, context);\n       }\n-      return state;\n+\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter HttpUrlState state,\n         @Advice.This HttpURLConnection connection,\n         @Advice.FieldValue(\"responseCode\") int responseCode,\n         @Advice.Thrown Throwable throwable,\n         @Advice.Origin(\"#m\") String methodName,\n-        @Advice.Local(\"otelScope\") Scope scope) {\n-\n-      if (scope != null) {\n-        scope.close();\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() > 0) {\n+        return;\n       }\n-      if (state == null) {\n+      if (scope == null) {\n         return;\n       }\n-      CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n-\n-      synchronized (state) {\n-        if (state.context != null && !state.finished) {\n-          if (throwable != null) {\n-            tracer().endExceptionally(state.context, throwable);\n-            state.finished = true;\n-          } else if (\"getInputStream\".equals(methodName)) {\n-            // responseCode field is sometimes not populated.\n-            // We can't call getResponseCode() due to some unwanted side-effects\n-            // (e.g. breaks getOutputStream).\n-            if (responseCode > 0) {\n-              tracer().end(state.context, new HttpUrlResponse(connection, responseCode));\n-              state.finished = true;\n-            }\n-          }\n+      scope.close();\n+      if (Span.fromContext(context).isRecording()) {", "originalCommit": "f9bff43281b156650b3e06df48baf8c16c52fcb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNTk1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543335954", "bodyText": "isRecording() is the same as previous !state.finished. No idea why it was used here though", "author": "mateuszrzeszutek", "createdAt": "2020-12-15T13:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NjA1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1908#discussion_r543756052", "bodyText": "It's needed here because HttpURLConnection is a messy API and so instrumenting it is messy.\nBut I do think of checking isRecording as more of an optimization for avoiding costly things when Sampling is enabled, so think the usage here is a bit confusing, so brought back HttpUrlState.finished to track this (and added more comments).", "author": "trask", "createdAt": "2020-12-15T23:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA5MTU1MA=="}], "type": "inlineReview"}, {"oid": "fc45d8d307365d84b2072c9a460e447e90b5eeda", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fc45d8d307365d84b2072c9a460e447e90b5eeda", "message": "Feedback", "committedDate": "2020-12-15T23:11:39Z", "type": "commit"}]}