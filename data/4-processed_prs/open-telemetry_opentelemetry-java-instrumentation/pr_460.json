{"pr_number": 460, "pr_title": "Move client span creation to decorator and automatically suppress creation of neste\u2026", "pr_createdAt": "2020-05-31T06:06:44Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460", "timeline": [{"oid": "9db9927bd2764d127c8a2ae3a8b42ba56d216aeb", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9db9927bd2764d127c8a2ae3a8b42ba56d216aeb", "message": "Move client span creation to decorator and suppress creation of nested client spans.", "committedDate": "2020-05-31T06:01:56Z", "type": "commit"}, {"oid": "c2ee0436f8185534bdb6b17b7b611f540c99d19c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/c2ee0436f8185534bdb6b17b7b611f540c99d19c", "message": "Retry TODO", "committedDate": "2020-05-31T06:09:08Z", "type": "commit"}, {"oid": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d57444707cad6ea1aa1d0370d03e5654784b7ced", "message": "Store subtree client span in context.", "committedDate": "2020-06-02T08:10:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5ODMyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433698323", "bodyText": "Ah noticed this is fixed in master of the SDK :)", "author": "anuraaga", "createdAt": "2020-06-02T08:13:08Z", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {\n+      final Context context = ClientDecorator.withSpan(span, Context.current());\n+      // TODO(anuraaga): Seems like a bug that invalid context still gets injected by the injector.", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433802338", "bodyText": "Setting parent is not required here. It will come automatically from current context", "author": "iNikem", "createdAt": "2020-06-02T11:21:37Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMTQ5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434131499", "bodyText": "Setting the parent here does save a thread-local lookup since we already have the current context from above", "author": "trask", "createdAt": "2020-06-02T19:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NTA4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434255084", "bodyText": "Yup the optimization is the only reason I did so", "author": "anuraaga", "createdAt": "2020-06-03T01:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNjgyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433806828", "bodyText": "This method certainly can delegate to withSpan below", "author": "iNikem", "createdAt": "2020-06-02T11:30:37Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807162", "bodyText": "Here we are sure that we are currently creating first client span. I think this should be the right place to put that span into current context under CONTEXT_CLIENT_SPAN_KEY key.", "author": "iNikem", "createdAt": "2020-06-02T11:31:12Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  public Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();\n+    }\n+\n+    final Span current = TracingContextUtils.getSpan(context);\n+    return tracer.spanBuilder(name).setSpanKind(Kind.CLIENT).setParent(current).startSpan();", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NjMyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434256324", "bodyText": "I really wish I could - but context is immutable so AFAIK, we can really only \"add to context\" when mounting it, in these withSpan type of methods. I have left some comments in the context discussion doc before coincidentally, and it is running into these sort of cases where I really don't enjoy immutable context ;)\nIf there is an entrypoint that is guaranteed to be called with a new context, than it would be possible to put mutable state in at that point and then here we'd just update it. But I couldn't find one, if this span is the root of a trace (some non-server app running AWS SDK call for example), this span will be created before a new context is and we wouldn't have anywhere to store it until a call to with*.\nLet me know if I'm missing anything, I'd be happy to be since this API is otherwise somewhat ackward for duplicating the APIs in TracingContextUtils.", "author": "anuraaga", "createdAt": "2020-06-03T01:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0ODg3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434448870", "bodyText": "I see what you mean. As long as you return Span from this method, you really cannot modify Context", "author": "iNikem", "createdAt": "2020-06-03T09:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r433807639", "bodyText": "Do we still need this ScopeHolder? Why getting span from current context is not enough?", "author": "iNikem", "createdAt": "2020-06-02T11:32:20Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/src/main/java8/io/opentelemetry/auto/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -135,7 +132,7 @@ public void beforeTransmission(\n     if (span != null) {\n       // This scope will be closed by AwsHttpClientInstrumentation since ExecutionInterceptor API\n       // doesn't provide a way to run code in the same thread after transmission has been scheduled.\n-      ScopeHolder.CURRENT.set(currentContextWith(span));\n+      ScopeHolder.CURRENT.set(ClientDecorator.currentContextWith(span));", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzUxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257517", "bodyText": "We get the span from current context here, but afterTransmission may be called on a different thread, e.g., from netty, so the current context won't be accessible there. This ScopeHolder is only to allow closing in that method where we don't have context.", "author": "anuraaga", "createdAt": "2020-06-03T01:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0OTE2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434449169", "bodyText": "And we don't have context propagation between here and Netty threads?", "author": "iNikem", "createdAt": "2020-06-03T09:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMzcwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434523706", "bodyText": "Don't seem to yet. Here's the negative test we have in master\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/master/instrumentation/aws-sdk/aws-sdk-2.2/src/test/groovy/Aws2ClientTest.groovy#L223", "author": "anuraaga", "createdAt": "2020-06-03T12:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjIwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434136200", "bodyText": "i think?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n          \n          \n            \n                    clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "author": "trask", "createdAt": "2020-06-02T19:48:14Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434164216", "bodyText": "I'm guessing you know something that we don't about this not being needed anymore? \ud83d\ude04", "author": "trask", "createdAt": "2020-06-02T20:43:43Z", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/src/main/java/io/opentelemetry/auto/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentation.java", "diffHunk": "@@ -172,16 +171,14 @@ public ApacheHttpClientInstrumentation() {\n \n   public static class HelperMethods {\n     public static SpanWithScope doMethodEnter(final HttpUriRequest request) {\n-      final Span span =\n-          TRACER.spanBuilder(DECORATE.spanNameForRequest(request)).setSpanKind(CLIENT).startSpan();\n+      final Span span = DECORATE.getOrCreateSpan(request, TRACER);\n \n       DECORATE.afterStart(span);\n       DECORATE.onRequest(span, request);\n \n-      final Context context = withSpan(span, Context.current());\n-      final boolean awsClientCall = request.getHeaders(\"amz-sdk-invocation-id\").length > 0;\n-      // AWS calls are often signed, so we can't add headers without breaking the signature.\n-      if (!awsClientCall) {", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1NzAxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434257012", "bodyText": "Now that there's only the SDK span and no Apache span, there's nothing to propagate here. That being said, it does seem safer to keep the check just in case something changes, at the same time, it seems pretty hacky to have the AWS-specific code here so it feels nice to remove it.", "author": "anuraaga", "createdAt": "2020-06-03T01:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDAwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434710007", "bodyText": "Oh, I understand now, right.\nDo the aws-sdk tests protect us here? If so I'm good removing it.", "author": "trask", "createdAt": "2020-06-03T16:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjY4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522686", "bodyText": "Yup the tests cover it. It's how I found this line of code :)", "author": "anuraaga", "createdAt": "2020-06-08T08:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r434184540", "bodyText": "It looks like this is only called with Context.current(), so maybe this method isn't needed?", "author": "trask", "createdAt": "2020-06-02T21:25:31Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,51 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  private static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.currentContextWith(clientSpan);\n+    }\n+    return ContextUtils.withScopedContext(\n+        TracingContextUtils.withSpan(\n+            clientSpan, Context.current().withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan)));\n+  }\n+\n+  public static Context withSpan(final Span clientSpan, final Context context) {", "originalCommit": "d57444707cad6ea1aa1d0370d03e5654784b7ced", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1Mjk0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436452949", "bodyText": "I noticed the same lack of symmetry in TracingContextUtils and followed the pattern. Let me know if it's worth diverging.", "author": "anuraaga", "createdAt": "2020-06-08T04:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTI2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485263", "bodyText": "io.opentelemetry.trace.TracingContextUtils#withSpan can potentially be called with contexts other than current during context extraction via io.opentelemetry.trace.propagation.HttpTraceContext#extract method. This client decorator is not general purpose util, but more specific one. Thus I think we indeed can merge these two methods together.", "author": "iNikem", "createdAt": "2020-06-08T06:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4NDU0MA=="}], "type": "inlineReview"}, {"oid": "84ac8099c26700e520ec619526136db76d474b9c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/84ac8099c26700e520ec619526136db76d474b9c", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into suppress-nested-client-spans", "committedDate": "2020-06-05T07:34:51Z", "type": "commit"}, {"oid": "76b32219cdbca9385344d4d07a2d1e7566b423af", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/76b32219cdbca9385344d4d07a2d1e7566b423af", "message": "Apply new pattern to AWS V1 SDK instrumentation too, cleanup, and javadoc", "committedDate": "2020-06-05T08:41:23Z", "type": "commit"}, {"oid": "95d8115c353b7ffdd8fb4d4746de96d48e29fc37", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/95d8115c353b7ffdd8fb4d4746de96d48e29fc37", "message": "Update test", "committedDate": "2020-06-08T04:19:08Z", "type": "commit"}, {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9051e500537a0ff117ae71141c2e62057c8ff6c0", "message": "Unit tests", "committedDate": "2020-06-08T05:05:18Z", "type": "commit"}, {"oid": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9051e500537a0ff117ae71141c2e62057c8ff6c0", "message": "Unit tests", "committedDate": "2020-06-08T05:05:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTYxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436485614", "bodyText": "I would extract common call to TracingContextUtils.withSpan from the if above.", "author": "iNikem", "createdAt": "2020-06-08T06:44:53Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(", "originalCommit": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487489", "bodyText": "Here is the interesting question: should we return clientSpan from here? This way lower level instrumentations can fill in e.g. net.* attributes", "author": "iNikem", "createdAt": "2020-06-08T06:49:46Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/ClientDecorator.java", "diffHunk": "@@ -15,10 +15,59 @@\n  */\n package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n \n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextUtils;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.DefaultSpan;\n import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.TracingContextUtils;\n \n public abstract class ClientDecorator extends BaseDecorator {\n \n+  // Keeps track of the client span in a subtree corresponding to a client request.\n+  // Visible for testing\n+  static final Context.Key<Span> CONTEXT_CLIENT_SPAN_KEY =\n+      Context.key(\"opentelemetry-trace-auto-client-span-key\");\n+\n+  /**\n+   * Creates a {@link Context} with the provided {@link Span} and sets it as the current {@link\n+   * Context}\n+   *\n+   * @return a {@link Scope} that will restore the previous context. All callers of this method must\n+   *     also call {@link Scope#close()} when this next context is no longer needed.\n+   */\n+  public static Scope currentContextWith(final Span clientSpan) {\n+    return ContextUtils.withScopedContext(withSpan(clientSpan, Context.current()));\n+  }\n+\n+  /** Returns a new {@link Context} forked from {@code context} with the {@link Span} set. */\n+  public static Context withSpan(final Span clientSpan, final Context context) {\n+    if (!clientSpan.getContext().isValid()) {\n+      return TracingContextUtils.withSpan(clientSpan, context);\n+    }\n+    return TracingContextUtils.withSpan(\n+        clientSpan, context.withValue(CONTEXT_CLIENT_SPAN_KEY, clientSpan));\n+  }\n+\n+  /**\n+   * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n+   * Context}, or an invalid {@link Span} otherwise.\n+   */\n+  public static Span getOrCreateSpan(String name, Tracer tracer) {\n+    final Context context = Context.current();\n+    final Span clientSpan = CONTEXT_CLIENT_SPAN_KEY.get(context);\n+\n+    if (clientSpan != null) {\n+      // We don't want to create two client spans for a given client call, suppress inner spans.\n+      return DefaultSpan.getInvalid();", "originalCommit": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjE3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522173", "bodyText": "Returning the span as is is dangerous due to methods like .end. I think we should return a wrapper that guards against these, but am thinking of prototyping such in a followup. But let me know if it seems better here.", "author": "anuraaga", "createdAt": "2020-06-08T08:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMzg2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436523860", "bodyText": "Aah, makes sense.", "author": "iNikem", "createdAt": "2020-06-08T08:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzgxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436487814", "bodyText": "Can this be made private/protected now?", "author": "iNikem", "createdAt": "2020-06-08T06:50:30Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpClientDecorator.java", "diffHunk": "@@ -35,6 +36,10 @@\n \n   protected abstract Integer status(RESPONSE response);\n \n+  public Span getOrCreateSpan(REQUEST request, Tracer tracer) {\n+    return getOrCreateSpan(spanNameForRequest(request), tracer);\n+  }\n+\n   public String spanNameForRequest(final REQUEST request) {", "originalCommit": "9051e500537a0ff117ae71141c2e62057c8ff6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMjQzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/460#discussion_r436522432", "bodyText": "Think it can when we migrate all the instrumentation to use getOrCeateSpan. Another PR?", "author": "anuraaga", "createdAt": "2020-06-08T08:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzgxNA=="}], "type": "inlineReview"}, {"oid": "6f07eb92a7e53492f697b3be574c6b4d6f7267cc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f07eb92a7e53492f697b3be574c6b4d6f7267cc", "message": "Cleanups", "committedDate": "2020-06-08T08:07:51Z", "type": "commit"}, {"oid": "0e18e087311bd2034643bbcf22528854a5e66944", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0e18e087311bd2034643bbcf22528854a5e66944", "message": "Merge branch 'master' into suppress-nested-client-spans", "committedDate": "2020-06-08T18:26:45Z", "type": "commit"}]}