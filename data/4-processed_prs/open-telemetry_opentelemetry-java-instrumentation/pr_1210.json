{"pr_number": 1210, "pr_title": "Add instrumentation of SQS.", "pr_createdAt": "2020-09-16T07:50:37Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210", "timeline": [{"oid": "24be1ef6c88b6c0804747b675aa4928e4f56b0d5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/24be1ef6c88b6c0804747b675aa4928e4f56b0d5", "message": "Add instrumentation of SQS.", "committedDate": "2020-09-16T07:50:14Z", "type": "commit"}, {"oid": "fbdf7b09160039a98aada397b2be23deed97860d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fbdf7b09160039a98aada397b2be23deed97860d", "message": "More play", "committedDate": "2020-09-17T04:32:07Z", "type": "commit"}, {"oid": "650d4d0537523b3b56a216fb0743f7373f093b6d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/650d4d0537523b3b56a216fb0743f7373f093b6d", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into sqs-instrumentation", "committedDate": "2020-09-18T05:51:10Z", "type": "commit"}, {"oid": "ad11320d95e7de22aff66932c7f2803abf0588f1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad11320d95e7de22aff66932c7f2803abf0588f1", "message": "Finish", "committedDate": "2020-09-18T07:11:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODI5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r490748298", "bodyText": "I wonder if I should instead of a separate instrumentation module, aws-lambda-sqs-2.2.1 due to this extra, optional dependency. Not quite sure where we want to set boundaries for highly related instrumentation like this case, let me know any thoughts.", "author": "anuraaga", "createdAt": "2020-09-18T07:14:18Z", "path": "instrumentation/aws-lambda-1.0/auto/aws-lambda-1.0-auto.gradle", "diffHunk": "@@ -21,6 +21,7 @@ muzzle {\n     group = \"com.amazonaws\"\n     module = \"aws-lambda-java-core\"\n     versions = \"[1.0.0,)\"\n+    extraDependency('com.amazonaws:aws-lambda-java-events:2.2.1')", "originalCommit": "ad11320d95e7de22aff66932c7f2803abf0588f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5MDU4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r493890581", "bodyText": "I think it makes sense here to add muzzle requirement on aws-lambda-java-events also, e.g.\n  pass {\n    group = \"com.amazonaws\"\n    module = \"aws-lambda-java-events\"\n    versions = \"[2.2.1,)\"\n    extraDependency('com.amazonaws:aws-lambda-java-core:1.0.0')\n  }", "author": "trask", "createdAt": "2020-09-23T20:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r490748848", "bodyText": "If I separated out a different module, though, not sure it'd be even possible to do this pattern.", "author": "anuraaga", "createdAt": "2020-09-18T07:15:27Z", "path": "instrumentation/aws-lambda-1.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/awslambda/v1_0/AwsLambdaRequestHandlerInstrumentation.java", "diffHunk": "@@ -53,12 +56,28 @@\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return Collections.singletonMap(\n+    // Order of transformation matters. A bit fragile, but our unit tests will catch breakage\n+    // easily.\n+    Map<ElementMatcher<? super MethodDescription>, String> transformers = new LinkedHashMap<>();\n+\n+    // First instrument the function invocation itself.\n+    transformers.put(\n         isMethod()\n             .and(isPublic())\n             .and(named(\"handleRequest\"))\n             .and(takesArgument(1, named(\"com.amazonaws.services.lambda.runtime.Context\"))),\n         AwsLambdaRequestHandlerInstrumentation.class.getName() + \"$HandleRequestAdvice\");\n+\n+    // Then instrument message handling if appropriate.", "originalCommit": "ad11320d95e7de22aff66932c7f2803abf0588f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NDUzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r490874533", "bodyText": "I don't like this strict dependency between 2 instrumentations :(", "author": "iNikem", "createdAt": "2020-09-18T11:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NTU1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491285552", "bodyText": "I think it's similar to our servlet instrumentation - it seems to happen when there's an overall framework, with subframeworks built on top of it. Is it that bad?", "author": "anuraaga", "createdAt": "2020-09-19T06:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMwMTcwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491301703", "bodyText": "In general inter-instrumentation dependencies are Ok, I guess. But in this case they apply to the same method and the order is important. This seems fragile", "author": "iNikem", "createdAt": "2020-09-19T07:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwNzc3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491807771", "bodyText": "i'm ok with current approach\nthe other option I see is to combine into a single advice, e.g.\n  public static class HandleEventAdvice {\n    @Advice.OnMethodEnter(suppress = Throwable.class)\n    public static void onEnter(\n        @Advice.Argument(value = 0, typing = Typing.DYNAMIC) Object arg,\n        @Advice.Argument(1) Context context,\n        @Advice.Local(\"otelFunctionSpan\") Span functionSpan,\n        @Advice.Local(\"otelFunctionScope\") Scope functionScope,\n        @Advice.Local(\"otelMessageSpan\") Span messageSpan,\n        @Advice.Local(\"otelMessageScope\") Scope messageScope) {\n      functionSpan = FUNCTION_TRACER.startSpan(context, Kind.SERVER);\n      functionScope = FUNCTION_TRACER.startScope(functionSpan);\n      if (arg instanceof SQSEvent) {\n        messageSpan = MESSAGE_TRACER.startSpan(context, (SQSEvent) arg);\n        messageScope = MESSAGE_TRACER.startScope(messageSpan);\n      }\n    }\n\n    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n    public static void stopSpan(\n        @Advice.Thrown Throwable throwable,\n        @Advice.Local(\"otelFunctionSpan\") Span functionSpan,\n        @Advice.Local(\"otelFunctionScope\") Scope functionScope,\n        @Advice.Local(\"otelMessageSpan\") Span messageSpan,\n        @Advice.Local(\"otelMessageScope\") Scope messageScope) {\n\n      if (messageScope != null) {\n        messageScope.close();\n        if (throwable != null) {\n          MESSAGE_TRACER.endExceptionally(messageSpan, throwable);\n        } else {\n          MESSAGE_TRACER.end(messageSpan);\n        }\n      }\n\n      functionScope.close();\n      if (throwable != null) {\n        FUNCTION_TRACER.endExceptionally(functionSpan, throwable);\n      } else {\n        FUNCTION_TRACER.end(functionSpan);\n      }\n      OpenTelemetrySdkAccess.forceFlush(1, TimeUnit.SECONDS);\n    }\n  }", "author": "trask", "createdAt": "2020-09-21T06:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0NTg1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r493245854", "bodyText": "Thanks this is better!", "author": "anuraaga", "createdAt": "2020-09-23T07:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc0ODg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NzI4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r490877289", "bodyText": "So, we can have nested CONSUMER spans? But not CLIENT?", "author": "iNikem", "createdAt": "2020-09-18T11:16:15Z", "path": "instrumentation/aws-lambda-1.0/library/src/test/groovy/io/opentelemetry/instrumentation/awslambda/v1_0/AwsLambdaSqsMessageHandlerTest.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0\n+\n+import static io.opentelemetry.trace.Span.Kind.CONSUMER\n+import static io.opentelemetry.trace.Span.Kind.SERVER\n+\n+import com.amazonaws.services.lambda.runtime.Context\n+import com.amazonaws.services.lambda.runtime.events.SQSEvent\n+import io.opentelemetry.auto.test.InstrumentationSpecification\n+import io.opentelemetry.auto.test.InstrumentationTestTrait\n+import io.opentelemetry.trace.attributes.SemanticAttributes\n+\n+class AwsLambdaSqsMessageHandlerTest extends InstrumentationSpecification implements InstrumentationTestTrait {\n+\n+  private static final String AWS_TRACE_HEADER1 = \"Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad8;Sampled=1\"\n+  private static final String AWS_TRACE_HEADER2 = \"Root=1-5759e988-bd862e3fe1be46a994272793;Parent=53995c3f42cd8ad9;Sampled=1\"\n+\n+  class TestHandler extends TracingSQSMessageHandler {\n+    @Override\n+    protected void handleMessage(SQSEvent.SQSMessage event, Context context) {\n+    }\n+  }\n+\n+  def \"messages with process spans\"() {\n+    when:\n+    def context = Mock(Context)\n+    context.getFunctionName() >> \"my_function\"\n+    context.getAwsRequestId() >> \"1-22-333\"\n+\n+    def message1 = new SQSEvent.SQSMessage()\n+    message1.setAttributes([\"AWSTraceHeader\": AWS_TRACE_HEADER1])\n+    message1.setMessageId(\"message1\")\n+    message1.setEventSource(\"queue1\")\n+\n+    def message2 = new SQSEvent.SQSMessage()\n+    message2.setAttributes([\"AWSTraceHeader\": AWS_TRACE_HEADER2])\n+    message2.setMessageId(\"message2\")\n+    message2.setEventSource(\"queue1\")\n+\n+    def event = new SQSEvent()\n+    event.setRecords([message1, message2])\n+\n+    new TestHandler().handleRequest(event, context)\n+\n+    then:\n+    assertTraces(1) {\n+      trace(0, 4) {\n+        span(0) {\n+          operationName(\"my_function\")\n+          spanKind SERVER\n+          attributes {\n+            \"${SemanticAttributes.FAAS_EXECUTION}\" \"1-22-333\"\n+          }\n+        }\n+        span(1) {\n+          operationName(\"queue1 receive\")\n+          spanKind CONSUMER\n+          parentId(span(0).spanId)\n+          attributes {\n+            \"${SemanticAttributes.MESSAGING_SYSTEM}\" \"AmazonSQS\"\n+            \"${SemanticAttributes.MESSAGING_OPERATION}\" \"receive\"\n+          }\n+          hasLink(\"5759e988bd862e3fe1be46a994272793\", \"53995c3f42cd8ad8\")\n+          hasLink(\"5759e988bd862e3fe1be46a994272793\", \"53995c3f42cd8ad9\")\n+        }\n+        span(2) {\n+          operationName(\"queue1 process\")\n+          spanKind CONSUMER\n+          parentId(span(1).spanId)\n+          attributes {\n+            \"${SemanticAttributes.MESSAGING_SYSTEM}\" \"AmazonSQS\"\n+            \"${SemanticAttributes.MESSAGING_OPERATION}\" \"process\"\n+            \"${SemanticAttributes.MESSAGING_MESSAGE_ID}\" \"message1\"\n+            \"${SemanticAttributes.MESSAGING_DESTINATION}\" \"queue1\"\n+          }\n+          hasLink(\"5759e988bd862e3fe1be46a994272793\", \"53995c3f42cd8ad8\")\n+        }\n+        span(3) {\n+          operationName(\"queue1 process\")\n+          spanKind CONSUMER", "originalCommit": "ad11320d95e7de22aff66932c7f2803abf0588f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4NTkzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491285935", "bodyText": "Yeah our spec currently has an example of it\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md#batch-receiving\nSince CONSUMER / PRODUCER aren't parent/child, I guess 1:1 doesn't matter as much. So in open-telemetry/opentelemetry-specification#963 I'm also trying to clarify whether those kinds have any meaning other than INTERNAL anyways.\nI'm happy to keep this instrumentation up to date as spec is updated, which I'm sure it will be :)", "author": "anuraaga", "createdAt": "2020-09-19T06:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NzI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMTQyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491801427", "bodyText": "oh ya, message batches are confusing...\nnice to have our first implementation of this \ud83d\udc4d", "author": "trask", "createdAt": "2020-09-21T05:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NzI4OQ=="}], "type": "inlineReview"}, {"oid": "b3bd8f598c3477c613a4aa5355ed6791584dc1e2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b3bd8f598c3477c613a4aa5355ed6791584dc1e2", "message": "process instead of weird", "committedDate": "2020-09-19T06:11:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDA3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491174077", "bodyText": "\ud83d\udc4d", "author": "trask", "createdAt": "2020-09-18T20:26:17Z", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/BaseTracer.java", "diffHunk": "@@ -29,6 +29,8 @@\n \n public abstract class BaseTracer {\n   // Keeps track of the server span for the current trace.\n+  // TODO(anuraaga): Should probably be renamed to local root key since it could be a consumer span\n+  // or other non-server root.", "originalCommit": "ad11320d95e7de22aff66932c7f2803abf0588f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5Nzg3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491797879", "bodyText": "this is odd because this class is not part of instrumentation-javaagent-instrumentation-api\nwhat do you think of requiring a javaagent running in lambda to be configured with the xray propagator, and then using normal extract?\nor if that's not good, maybe we can shade a copy of AwsXRayPropagator in this instrumentation (since it's an internal implementation detail of this particular instrumentation)?\nno need to change for now, maybe just a comment", "author": "trask", "createdAt": "2020-09-21T05:19:51Z", "path": "instrumentation/aws-lambda-1.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/awslambda/v1_0/AbstractAwsLambdaInstrumentation.java", "diffHunk": "@@ -28,7 +28,10 @@ public AbstractAwsLambdaInstrumentation() {\n   public final String[] helperClassNames() {\n     return new String[] {\n       packageName + \".AwsLambdaInstrumentationHelper\",\n-      \"io.opentelemetry.instrumentation.awslambda.v1_0.AwsLambdaTracer\"\n+      \"io.opentelemetry.extensions.trace.propagation.AwsXRayPropagator\",", "originalCommit": "b3bd8f598c3477c613a4aa5355ed6791584dc1e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIzODE2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r493238161", "bodyText": "Sounds like a good idea to me, it's a good idea when using AWS SDK instrumentation too", "author": "anuraaga", "createdAt": "2020-09-23T06:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5Nzg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc5ODk4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r491798980", "bodyText": "should the dependency on xray propagator be compile (not compileOnly)?\nrelated to above comment, what do you think of requiring that lambda users configure the xray propagator and then this instrumentation can use normal extract?", "author": "trask", "createdAt": "2020-09-21T05:25:01Z", "path": "instrumentation/aws-lambda-1.0/library/aws-lambda-1.0-library.gradle", "diffHunk": "@@ -24,5 +24,14 @@ dependencies {\n   library group: 'com.amazonaws', name: 'aws-lambda-java-core', version: '1.0.0'\n   compileOnly deps.opentelemetrySdk\n \n+  // First version to includes support for SQSEvent, currently the most popular message queue used\n+  // with lambda.\n+  // NB: 2.2.0 includes a class called SQSEvent but isn't usable due to it returning private classes\n+  // in public API.\n+  library group: 'com.amazonaws', name: 'aws-lambda-java-events', version: '2.2.1'\n+\n+  compileOnly deps.opentelemetrySdk\n+  compileOnly deps.opentelemetryTraceProps", "originalCommit": "b3bd8f598c3477c613a4aa5355ed6791584dc1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f60541a9ae64a2289bf162f7a1ad03116b9c6c0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1f60541a9ae64a2289bf162f7a1ad03116b9c6c0", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-auto-instr-java into sqs-instrumentation", "committedDate": "2020-09-23T06:52:51Z", "type": "commit"}, {"oid": "85ed1d4ffa3ab6b92b9ff61492cd62caff7bc4bc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/85ed1d4ffa3ab6b92b9ff61492cd62caff7bc4bc", "message": "Cleanups", "committedDate": "2020-09-23T07:10:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDUzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1210#discussion_r493884538", "bodyText": "I think can remove this now:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"io.opentelemetry.extensions.trace.propagation.AwsXRayPropagator\",", "author": "trask", "createdAt": "2020-09-23T20:45:57Z", "path": "instrumentation/aws-lambda-1.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/awslambda/v1_0/AbstractAwsLambdaInstrumentation.java", "diffHunk": "@@ -28,7 +28,10 @@ public AbstractAwsLambdaInstrumentation() {\n   public final String[] helperClassNames() {\n     return new String[] {\n       packageName + \".AwsLambdaInstrumentationHelper\",\n-      \"io.opentelemetry.instrumentation.awslambda.v1_0.AwsLambdaTracer\"\n+      \"io.opentelemetry.extensions.trace.propagation.AwsXRayPropagator\",", "originalCommit": "85ed1d4ffa3ab6b92b9ff61492cd62caff7bc4bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82225dcb1f5d64f2eac663521598ac043c676811", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/82225dcb1f5d64f2eac663521598ac043c676811", "message": "Update instrumentation/aws-lambda-1.0/auto/src/main/java/io/opentelemetry/instrumentation/auto/awslambda/v1_0/AbstractAwsLambdaInstrumentation.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-09-23T23:45:09Z", "type": "commit"}]}