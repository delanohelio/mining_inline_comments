{"pr_number": 1811, "pr_title": "Use Context more in HttpClientTracer", "pr_createdAt": "2020-12-01T07:23:21Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811", "timeline": [{"oid": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/752a635b994becb81a5ab2dd69ff75f59a6579d3", "message": "Use Context more in HttpClientTracer", "committedDate": "2020-12-01T07:20:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ0MzM4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533443385", "bodyText": "Nit: consider renaming context to parentContext", "author": "mateuszrzeszutek", "createdAt": "2020-12-01T14:21:56Z", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context context) {", "originalCommit": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDE2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533460169", "bodyText": "Scope is closed in the helper onMethodExit() method below", "author": "mateuszrzeszutek", "createdAt": "2020-12-01T14:42:04Z", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentationModule.java", "diffHunk": "@@ -147,127 +149,175 @@ public ApacheHttpClientInstrumentationModule() {\n \n   public static class UriRequestAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(@Advice.Argument(0) HttpUriRequest request) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+    public static void methodEnter(\n+        @Advice.Argument(0) HttpUriRequest request,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      return ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);\n+      scope = context.makeCurrent();\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter SpanWithScope spanWithScope,\n         @Advice.Return Object result,\n-        @Advice.Thrown Throwable throwable) {\n-      ApacheHttpClientHelper.doMethodExitAndResetCallDepthThread(spanWithScope, result, throwable);\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();\n+        ApacheHttpClientHelper.doMethodExit(context, scope, result, throwable);\n+      }\n     }\n   }\n \n   public static class UriRequestWithHandlerAdvice {\n \n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(\n+    public static void methodEnter(\n         @Advice.Argument(0) HttpUriRequest request,\n         @Advice.Argument(\n                 value = 1,\n                 optional = true,\n                 typing = Assigner.Typing.DYNAMIC,\n                 readOnly = false)\n-            Object handler) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+            Object handler,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      SpanWithScope spanWithScope = ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);\n+      scope = context.makeCurrent();\n \n       // Wrap the handler so we capture the status code\n       if (handler instanceof ResponseHandler) {\n-        handler =\n-            new WrappingStatusSettingResponseHandler(\n-                spanWithScope.getSpan(), (ResponseHandler) handler);\n+        handler = new WrappingStatusSettingResponseHandler(context, (ResponseHandler) handler);\n       }\n-      return spanWithScope;\n     }\n \n     @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n     public static void methodExit(\n-        @Advice.Enter SpanWithScope spanWithScope,\n         @Advice.Return Object result,\n-        @Advice.Thrown Throwable throwable) {\n-      ApacheHttpClientHelper.doMethodExitAndResetCallDepthThread(spanWithScope, result, throwable);\n+        @Advice.Thrown Throwable throwable,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      if (callDepth.decrementAndGet() == 0 && scope != null) {\n+        scope.close();", "originalCommit": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0MDY3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533740677", "bodyText": "fixed (removed scope close from onMethodExit())", "author": "trask", "createdAt": "2020-12-01T21:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533472001", "bodyText": "We lose some span attributes in several instrumentations with this change - can you create an issue for restoring them?", "author": "mateuszrzeszutek", "createdAt": "2020-12-01T14:51:46Z", "path": "instrumentation/elasticsearch/elasticsearch-rest-5.0/javaagent/src/test/groovy/Elasticsearch5RestClientTest.groovy", "diffHunk": "@@ -98,18 +98,6 @@ class Elasticsearch5RestClientTest extends AgentTestRunner {\n             \"${SemanticAttributes.DB_OPERATION.key()}\" \"GET _cluster/health\"\n           }\n         }\n-        span(1) {\n-          name expectedOperationName(\"GET\")\n-          kind CLIENT\n-          childOf span(0)\n-          attributes {\n-            \"${SemanticAttributes.NET_TRANSPORT.key()}\" \"IP.TCP\"\n-            \"${SemanticAttributes.HTTP_URL.key()}\" \"_cluster/health\"\n-            \"${SemanticAttributes.HTTP_METHOD.key()}\" \"GET\"\n-            \"${SemanticAttributes.HTTP_STATUS_CODE.key()}\" 200\n-            \"${SemanticAttributes.HTTP_FLAVOR.key()}\" \"1.1\"", "originalCommit": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0NzkxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533747913", "bodyText": "I think elasticsearch-rest is the only instrumentation affected, and it only lost http semantic attributes, which I think is ok because it should be following database semantic conventions (same as elasticsearch-transport instrumentation).\nI removed the remaining 2 http semantic attributes just now to make it more clear, let me know if this seems better.", "author": "trask", "createdAt": "2020-12-01T21:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NDAyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533954028", "bodyText": "I agree with Mateusz: this seems like undesired collateral damage", "author": "iNikem", "createdAt": "2020-12-02T07:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2MDEzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r534660132", "bodyText": "does #1822 sound good?\nI'm not too fond of mixing db and http semantic conventions on the same span (e.g. people writing span processors may then have to think through this odd case), but I do like the idea of capturing nested http requests as events on the db span.", "author": "trask", "createdAt": "2020-12-03T04:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTE1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533475159", "bodyText": "Does this comment still apply? There's no type casting here", "author": "mateuszrzeszutek", "createdAt": "2020-12-01T14:55:47Z", "path": "instrumentation/http-url-connection/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/httpurlconnection/HttpUrlConnectionInstrumentationModule.java", "diffHunk": "@@ -120,62 +125,30 @@ public static void methodExit(\n       CallDepthThreadLocalMap.reset(HttpURLConnection.class);\n \n       synchronized (state) {\n-        if (state.hasSpan() && !state.isFinished()) {\n+        if (state.context != null && !state.finished) {\n           if (throwable != null) {\n-            state.finishSpan(throwable);\n+            tracer().endExceptionally(state.context, throwable);\n+            state.finished = true;\n           } else if (\"getInputStream\".equals(methodName)) {\n-            state.finishSpan(responseCode);\n+            // responseCode field is sometimes not populated.\n+            // We can't call getResponseCode() due to some unwanted side-effects\n+            // (e.g. breaks getOutputStream).\n+            if (responseCode > 0) {\n+              // Need to explicitly cast to boxed type to make sure correct method is called.\n+              // https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/946\n+              tracer().end(state.context, responseCode);", "originalCommit": "752a635b994becb81a5ab2dd69ff75f59a6579d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc0MDQxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533740410", "bodyText": "good point, it sort of got masked by my change, but underlying issue was still there, reworked and this PR resolves #946 now", "author": "trask", "createdAt": "2020-12-01T21:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTE1OQ=="}], "type": "inlineReview"}, {"oid": "9462ee431a484af3d1110b60c2b367ccc5736fcd", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9462ee431a484af3d1110b60c2b367ccc5736fcd", "message": "Better http-url-connection response object", "committedDate": "2020-12-01T21:35:22Z", "type": "commit"}, {"oid": "968a8e0f36b5deb44a5341708c27fac1a0569080", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/968a8e0f36b5deb44a5341708c27fac1a0569080", "message": "Better param name", "committedDate": "2020-12-01T21:35:46Z", "type": "commit"}, {"oid": "3eb93899f1695c2f2acbf5ce3ba98a242230f7b7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3eb93899f1695c2f2acbf5ce3ba98a242230f7b7", "message": "Fix double scope close", "committedDate": "2020-12-01T21:38:24Z", "type": "commit"}, {"oid": "ec2d4849c08bd824aac5eda34ac6c168a010f690", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec2d4849c08bd824aac5eda34ac6c168a010f690", "message": "Follow database semantic conv for elasticsearch-rest", "committedDate": "2020-12-01T21:54:05Z", "type": "commit"}, {"oid": "7ca8ab322b154937368a81528a218fc685582712", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7ca8ab322b154937368a81528a218fc685582712", "message": "fixup! Follow database semantic conv for elasticsearch-rest", "committedDate": "2020-12-01T22:13:33Z", "type": "commit"}, {"oid": "5041e3276adfb7574d3417044d1fe340475287ab", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5041e3276adfb7574d3417044d1fe340475287ab", "message": "Merge remote-tracking branch 'upstream/master' into http-client-tracer", "committedDate": "2020-12-02T01:50:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NTg1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533885857", "bodyText": "This seems like a very boring method, do we need it?", "author": "anuraaga", "createdAt": "2020-12-02T04:16:52Z", "path": "instrumentation/apache-httpasyncclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpasyncclient/ApacheHttpAsyncClientTracer.java", "diffHunk": "@@ -30,6 +32,17 @@ public static ApacheHttpAsyncClientTracer tracer() {\n     return TRACER;\n   }\n \n+  public Context startSpan(Context parentContext) {\n+    Span span = super.startSpan(DEFAULT_SPAN_NAME, Span.Kind.CLIENT);\n+    return parentContext.with(span);\n+  }\n+\n+  public void inject(Context context, HttpRequest request) {\n+    OpenTelemetry.getGlobalPropagators()", "originalCommit": "5041e3276adfb7574d3417044d1fe340475287ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4ODI4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533888286", "bodyText": "removed \ud83d\ude02", "author": "trask", "createdAt": "2020-12-02T04:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NjMwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533886301", "bodyText": "I might be missing a detail, but instead of shouldStartSpan everywhere, can't startSpan just return parentContext if it shouldn't start a new span?", "author": "anuraaga", "createdAt": "2020-12-02T04:18:24Z", "path": "instrumentation/apache-httpclient/apache-httpclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpclient/v4_0/ApacheHttpClientInstrumentationModule.java", "diffHunk": "@@ -147,127 +149,175 @@ public ApacheHttpClientInstrumentationModule() {\n \n   public static class UriRequestAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope methodEnter(@Advice.Argument(0) HttpUriRequest request) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(HttpClient.class);\n-      if (callDepth > 0) {\n-        return null;\n+    public static void methodEnter(\n+        @Advice.Argument(0) HttpUriRequest request,\n+        @Advice.Local(\"otelContext\") Context context,\n+        @Advice.Local(\"otelScope\") Scope scope,\n+        @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n+      callDepth = tracer().getCallDepth();\n+      if (callDepth.getAndIncrement() != 0) {\n+        return;\n+      }\n+      Context parentContext = currentContext();\n+      if (!tracer().shouldStartSpan(parentContext)) {\n+        return;\n       }\n \n-      return ApacheHttpClientHelper.doMethodEnter(request);\n+      context = tracer().startSpan(parentContext, request, request);", "originalCommit": "5041e3276adfb7574d3417044d1fe340475287ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NzIxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533887211", "bodyText": "the problem is how to know if the instrumentation should call end on the span in the returned context", "author": "trask", "createdAt": "2020-12-02T04:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5NzI5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533897293", "bodyText": "Ah remember now - had the idea a loong time ago (one of my first issues in the repo :D) that for this case, we might wrap the span in something that would still allow propagation and setting attributes (e.g., to enrich in HTTP instrumentation) without forwarding end or any other dangerous methods (update span name also probably not forwarded). If this seems like a reasonable idea not sure if it's better to do it now or later.", "author": "anuraaga", "createdAt": "2020-12-02T04:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1NzA4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r534657085", "bodyText": "I wrote up #1822 based on the discussion about this from yesterday", "author": "trask", "createdAt": "2020-12-03T04:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4NjMwMQ=="}], "type": "inlineReview"}, {"oid": "f7b5c0b571a07486c127d5154e482cc751c05146", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f7b5c0b571a07486c127d5154e482cc751c05146", "message": "Remove boring method", "committedDate": "2020-12-02T04:24:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0NjM5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533946393", "bodyText": "This is outdated", "author": "iNikem", "createdAt": "2020-12-02T07:24:09Z", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context parentContext) {\n+    return parentContext.get(CONTEXT_CLIENT_SPAN_KEY) == null;\n   }\n \n-  public Span startSpan(REQUEST request, long startTimeNanos) {\n-    return internalStartSpan(request, spanNameForRequest(request), startTimeNanos);\n+  public Context startSpan(Context parentContext, REQUEST request, CARRIER carrier) {\n+    return startSpan(parentContext, request, carrier, -1);\n   }\n \n-  public Scope startScope(Span span, CARRIER carrier) {\n-    Context context = Context.current().with(span);\n-\n+  public Context startSpan(\n+      Context parentContext, REQUEST request, CARRIER carrier, long startTimeNanos) {\n+    Span span =\n+        internalStartSpan(parentContext, request, spanNameForRequest(request), startTimeNanos);\n     Setter<CARRIER> setter = getSetter();\n     if (setter == null) {\n       throw new IllegalStateException(\n           \"getSetter() not defined but calling startScope(), either getSetter must be implemented or the scope should be setup manually\");\n     }\n+    Context context = parentContext.with(span).with(CONTEXT_CLIENT_SPAN_KEY, span);\n     OpenTelemetry.getGlobalPropagators().getTextMapPropagator().inject(context, carrier, setter);\n-    context = context.with(CONTEXT_CLIENT_SPAN_KEY, span);\n-    return context.makeCurrent();\n+    return context;\n   }\n \n-  public void end(Span span, RESPONSE response) {\n-    end(span, response, -1);\n+  public void end(Context context, RESPONSE response) {\n+    end(context, response, -1);\n   }\n \n-  public void end(Span span, RESPONSE response, long endTimeNanos) {\n+  public void end(Context context, RESPONSE response, long endTimeNanos) {\n+    Span span = Span.fromContext(context);\n     onResponse(span, response);\n     super.end(span, endTimeNanos);\n   }\n \n-  public void endExceptionally(Span span, RESPONSE response, Throwable throwable) {\n-    endExceptionally(span, response, throwable, -1);\n+  public void end(Context context) {\n+    Span span = Span.fromContext(context);\n+    super.end(span);\n+  }\n+\n+  public void endExceptionally(Context context, RESPONSE response, Throwable throwable) {\n+    endExceptionally(context, response, throwable, -1);\n   }\n \n   public void endExceptionally(\n-      Span span, RESPONSE response, Throwable throwable, long endTimeNanos) {\n+      Context context, RESPONSE response, Throwable throwable, long endTimeNanos) {\n+    Span span = Span.fromContext(context);\n     onResponse(span, response);\n     super.endExceptionally(span, throwable, endTimeNanos);\n   }\n \n+  public void endExceptionally(Context context, Throwable throwable) {\n+    Span span = Span.fromContext(context);\n+    super.endExceptionally(span, throwable, -1);\n+  }\n+\n   /**\n    * Returns a new client {@link Span} if there is no client {@link Span} in the current {@link\n    * Context}, or an invalid {@link Span} otherwise.", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0ODIyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533948222", "bodyText": "Should this update client span in context as well?", "author": "iNikem", "createdAt": "2020-12-02T07:28:20Z", "path": "instrumentation/apache-httpasyncclient-4.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/apachehttpasyncclient/ApacheHttpAsyncClientTracer.java", "diffHunk": "@@ -30,6 +31,11 @@ public static ApacheHttpAsyncClientTracer tracer() {\n     return TRACER;\n   }\n \n+  public Context startSpan(Context parentContext) {\n+    Span span = super.startSpan(DEFAULT_SPAN_NAME, Span.Kind.CLIENT);\n+    return parentContext.with(span);", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0OTgxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533949818", "bodyText": "inline?", "author": "iNikem", "createdAt": "2020-12-02T07:31:57Z", "path": "instrumentation/armeria-1.0/library/src/main/java/io/opentelemetry/instrumentation/armeria/v1_0/client/OpenTelemetryClient.java", "diffHunk": "@@ -52,8 +53,10 @@ public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Ex\n     long requestStartTimeMicros =\n         ctx.log().ensureAvailable(RequestLogProperty.REQUEST_START_TIME).requestStartTimeMicros();\n     long requestStartTimeNanos = TimeUnit.MICROSECONDS.toNanos(requestStartTimeMicros);\n-    Span span = clientTracer.startSpan(ctx, requestStartTimeNanos);\n+    Context parentContext = Context.current();", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MTE2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533951169", "bodyText": "Can contextWithParent be null or not? These two ifs clearly disagrees on this.", "author": "iNikem", "createdAt": "2020-12-02T07:34:43Z", "path": "instrumentation/async-http-client-1.9/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/asynchttpclient/ResponseAdvice.java", "diffHunk": "@@ -26,14 +25,14 @@ public static Scope onEnter(\n     // After response was handled by user provided handler.\n     ContextStore<AsyncHandler, Pair> contextStore =\n         InstrumentationContext.get(AsyncHandler.class, Pair.class);\n-    Pair<Context, Span> spanWithParent = contextStore.get(handler);\n-    if (null != spanWithParent) {\n+    Pair<Context, Context> contextWithParent = contextStore.get(handler);\n+    if (contextWithParent != null) {\n       contextStore.put(handler, null);\n     }\n-    if (spanWithParent.hasRight()) {\n-      AsyncHttpClientTracer.tracer().end(spanWithParent.getRight(), response);\n+    if (contextWithParent.hasRight()) {", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MjEyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533952125", "bodyText": "I think this is very suspicious. Why we make the context, which were active before http call on some other thread, active on response thread? Probably a separate issue from this PR but still", "author": "iNikem", "createdAt": "2020-12-02T07:36:43Z", "path": "instrumentation/async-http-client-1.9/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/asynchttpclient/ResponseAdvice.java", "diffHunk": "@@ -26,14 +25,14 @@ public static Scope onEnter(\n     // After response was handled by user provided handler.\n     ContextStore<AsyncHandler, Pair> contextStore =\n         InstrumentationContext.get(AsyncHandler.class, Pair.class);\n-    Pair<Context, Span> spanWithParent = contextStore.get(handler);\n-    if (null != spanWithParent) {\n+    Pair<Context, Context> contextWithParent = contextStore.get(handler);\n+    if (contextWithParent != null) {\n       contextStore.put(handler, null);\n     }\n-    if (spanWithParent.hasRight()) {\n-      AsyncHttpClientTracer.tracer().end(spanWithParent.getRight(), response);\n+    if (contextWithParent.hasRight()) {\n+      AsyncHttpClientTracer.tracer().end(contextWithParent.getRight(), response);\n     }\n-    return spanWithParent.hasLeft() ? spanWithParent.getLeft().makeCurrent() : null;\n+    return contextWithParent.hasLeft() ? contextWithParent.getLeft().makeCurrent() : null;", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNDM0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r534524347", "bodyText": "this existing behavior seems good to me, so that any callbacks will get associated to the request instead of lost in the void", "author": "trask", "createdAt": "2020-12-02T22:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MjEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1MzUxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533953517", "bodyText": "Not sure about that. Seems like unrelated change and may be undesired", "author": "iNikem", "createdAt": "2020-12-02T07:39:50Z", "path": "instrumentation/elasticsearch/elasticsearch-rest-5.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/elasticsearch/rest/v5_0/Elasticsearch5RestClientInstrumentationModule.java", "diffHunk": "@@ -71,7 +71,6 @@ public static void onEnter(\n       span = tracer().startSpan(null, method + \" \" + endpoint);\n       scope = tracer().startScope(span);\n \n-      tracer().onRequest(span, method, endpoint);", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjkzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533956934", "bodyText": "I think this was used to allow for context injection into outgoing headers. Are you sure this still works?", "author": "iNikem", "createdAt": "2020-12-02T07:47:14Z", "path": "instrumentation/khttp-0.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/khttp/KHttpAdvice.java", "diffHunk": "@@ -22,33 +23,36 @@ public static void methodEnter(\n       @Advice.Argument(value = 0) String method,\n       @Advice.Argument(value = 1) String uri,\n       @Advice.Argument(value = 2, readOnly = false) Map<String, String> headers,\n-      @Advice.Local(\"otelSpan\") Span span,\n+      @Advice.Local(\"otelContext\") Context context,\n       @Advice.Local(\"otelScope\") Scope scope,\n-      @Advice.Local(\"otelCallDepth\") Depth callDepth) {\n-\n+      @Advice.Local(\"otelCallDepth\") CallDepth callDepth) {\n     callDepth = tracer().getCallDepth();\n-    if (callDepth.getAndIncrement() == 0) {\n-      span = tracer().startSpan(new RequestWrapper(method, uri, headers));\n-      if (span.getSpanContext().isValid()) {\n-        headers = asWritable(headers);\n-        scope = tracer().startScope(span, headers);\n-      }\n+    if (callDepth.getAndIncrement() != 0) {\n+      return;\n     }\n+    Context parentContext = currentContext();\n+    if (!tracer().shouldStartSpan(parentContext)) {\n+      return;\n+    }\n+\n+    context = tracer().startSpan(parentContext, new RequestWrapper(method, uri, headers), headers);\n+    headers = asWritable(headers);", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY1MDQyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r534650426", "bodyText": "oh no, thanks for catching this, fixed", "author": "trask", "createdAt": "2020-12-03T03:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MjI2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r533962268", "bodyText": "Is it a good idea to inject new context into outgoing request during startSpan? Technically, creating a new span does not make it \"active\" yet. It may never become one and then propagating its context is wrong. In this sense old startScope method was much better suited for context propagation.", "author": "iNikem", "createdAt": "2020-12-02T07:58:07Z", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpClientTracer.java", "diffHunk": "@@ -60,60 +59,67 @@ protected HttpClientTracer(Tracer tracer) {\n     super(tracer);\n   }\n \n-  public Span startSpan(REQUEST request) {\n-    return startSpan(request, -1);\n+  public boolean shouldStartSpan(Context parentContext) {\n+    return parentContext.get(CONTEXT_CLIENT_SPAN_KEY) == null;\n   }\n \n-  public Span startSpan(REQUEST request, long startTimeNanos) {\n-    return internalStartSpan(request, spanNameForRequest(request), startTimeNanos);\n+  public Context startSpan(Context parentContext, REQUEST request, CARRIER carrier) {\n+    return startSpan(parentContext, request, carrier, -1);\n   }\n \n-  public Scope startScope(Span span, CARRIER carrier) {\n-    Context context = Context.current().with(span);\n-\n+  public Context startSpan(\n+      Context parentContext, REQUEST request, CARRIER carrier, long startTimeNanos) {\n+    Span span =\n+        internalStartSpan(parentContext, request, spanNameForRequest(request), startTimeNanos);\n     Setter<CARRIER> setter = getSetter();\n     if (setter == null) {\n       throw new IllegalStateException(\n           \"getSetter() not defined but calling startScope(), either getSetter must be implemented or the scope should be setup manually\");\n     }\n+    Context context = parentContext.with(span).with(CONTEXT_CLIENT_SPAN_KEY, span);\n     OpenTelemetry.getGlobalPropagators().getTextMapPropagator().inject(context, carrier, setter);\n-    context = context.with(CONTEXT_CLIENT_SPAN_KEY, span);\n-    return context.makeCurrent();\n+    return context;", "originalCommit": "f7b5c0b571a07486c127d5154e482cc751c05146", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNTcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1811#discussion_r534525711", "bodyText": "I don't think injecting context into outgoing http requests is related to putting the context in scope, e.g. async http clients never put the context in scope", "author": "trask", "createdAt": "2020-12-02T22:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MjI2OA=="}], "type": "inlineReview"}, {"oid": "65a31911a4eda6fd4bfe4bbd206adc4811107902", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/65a31911a4eda6fd4bfe4bbd206adc4811107902", "message": "Feedback", "committedDate": "2020-12-02T21:51:09Z", "type": "commit"}, {"oid": "815cf1da3d0bc5f954cbc04c59b7d45f0e0fde7e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/815cf1da3d0bc5f954cbc04c59b7d45f0e0fde7e", "message": "Fix khttp advice", "committedDate": "2020-12-03T03:57:48Z", "type": "commit"}, {"oid": "9428a58d8e93b68a4f29854d96cbe35da967da66", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9428a58d8e93b68a4f29854d96cbe35da967da66", "message": "Remove unnecessary CallDepth tracking", "committedDate": "2020-12-03T04:58:17Z", "type": "commit"}]}