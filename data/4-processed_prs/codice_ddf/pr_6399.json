{"pr_number": 6399, "pr_title": "[2.19.x] DDF-6043 Allow DDF to register external attribute validators", "pr_createdAt": "2020-10-26T14:29:53Z", "pr_url": "https://github.com/codice/ddf/pull/6399", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE0MDA5Nw==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512140097", "bodyText": "Wrapping and rethrowing with the same exception type will just make the stack trace harder to read. The exception thrown from findAndRegisterValidator probably shouldn't be caught here.", "author": "jrnorth", "createdAt": "2020-10-26T17:26:03Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE0MzAzNg==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512143036", "bodyText": "\u270f\ufe0f Consider using an if instead since there are only two cases.", "author": "jrnorth", "createdAt": "2020-10-26T17:30:29Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NzczOA==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512177738", "bodyText": "\u270f\ufe0f clazz will always be AttributeValidator so the parameter can be omitted.", "author": "jrnorth", "createdAt": "2020-10-26T18:25:22Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {\n+      case \"AttributeValidator\":\n+        AttributeValidator av = getAttributeValidator(AttributeValidator.class.getName(), filter);\n+        if (av != null) {\n+          wrapper.attributeValidator(av);\n+        } else {\n+          String errorMsg =\n+              String.format(\n+                  \"Appropriate service not found for validatorType=%s, serviceId=%s, filter=%s\",\n+                  validatorType, serviceId, filter);\n+          throw new IllegalStateException(errorMsg);\n+        }\n+        break;\n+      default:\n+        String errorMsg =\n+            String.format(\"ValidatorType of %s is not a supported validator type\", validatorType);\n+        throw new IllegalStateException(errorMsg);\n+    }\n+  }\n+\n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref.length > 1)\n+        throw new InvalidSyntaxException(\"Multiple service references found\", filter);\n+      if (ref.length < 1) throw new InvalidSyntaxException(\"No service references found\", filter);\n+      return bundleContext.getService(ref[0]);\n+    } catch (InvalidSyntaxException e) {\n+      LOGGER.error(String.format(\"Invalid filter: %s\", filter));\n+    } catch (NullPointerException e) {\n+      LOGGER.debug(\n+          String.format(\"Service Reference for class %s not found. Returning NULL\", clazz));\n+    }\n+    return null;\n+  }\n+\n+  private AttributeValidator getAttributeValidator(String clazz, String filter) {", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4MjA2OA==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512182068", "bodyText": "\u2757Use parameterized logging\nAlso, error is probably not the right level since this exception will not cause the system to break.", "author": "jrnorth", "createdAt": "2020-10-26T18:32:29Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {\n+      case \"AttributeValidator\":\n+        AttributeValidator av = getAttributeValidator(AttributeValidator.class.getName(), filter);\n+        if (av != null) {\n+          wrapper.attributeValidator(av);\n+        } else {\n+          String errorMsg =\n+              String.format(\n+                  \"Appropriate service not found for validatorType=%s, serviceId=%s, filter=%s\",\n+                  validatorType, serviceId, filter);\n+          throw new IllegalStateException(errorMsg);\n+        }\n+        break;\n+      default:\n+        String errorMsg =\n+            String.format(\"ValidatorType of %s is not a supported validator type\", validatorType);\n+        throw new IllegalStateException(errorMsg);\n+    }\n+  }\n+\n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref.length > 1)\n+        throw new InvalidSyntaxException(\"Multiple service references found\", filter);\n+      if (ref.length < 1) throw new InvalidSyntaxException(\"No service references found\", filter);\n+      return bundleContext.getService(ref[0]);\n+    } catch (InvalidSyntaxException e) {\n+      LOGGER.error(String.format(\"Invalid filter: %s\", filter));", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4MzA4MA==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512183080", "bodyText": "\u2757We should check for a null reference ourselves instead of using it and catching a NPE.", "author": "jrnorth", "createdAt": "2020-10-26T18:34:09Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {\n+      case \"AttributeValidator\":\n+        AttributeValidator av = getAttributeValidator(AttributeValidator.class.getName(), filter);\n+        if (av != null) {\n+          wrapper.attributeValidator(av);\n+        } else {\n+          String errorMsg =\n+              String.format(\n+                  \"Appropriate service not found for validatorType=%s, serviceId=%s, filter=%s\",\n+                  validatorType, serviceId, filter);\n+          throw new IllegalStateException(errorMsg);\n+        }\n+        break;\n+      default:\n+        String errorMsg =\n+            String.format(\"ValidatorType of %s is not a supported validator type\", validatorType);\n+        throw new IllegalStateException(errorMsg);\n+    }\n+  }\n+\n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref.length > 1)\n+        throw new InvalidSyntaxException(\"Multiple service references found\", filter);\n+      if (ref.length < 1) throw new InvalidSyntaxException(\"No service references found\", filter);\n+      return bundleContext.getService(ref[0]);\n+    } catch (InvalidSyntaxException e) {\n+      LOGGER.error(String.format(\"Invalid filter: %s\", filter));\n+    } catch (NullPointerException e) {", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4Mzg0MQ==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512183841", "bodyText": "I think these if statements will fail checkstyle without braces.", "author": "jrnorth", "createdAt": "2020-10-26T18:35:17Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {\n+      case \"AttributeValidator\":\n+        AttributeValidator av = getAttributeValidator(AttributeValidator.class.getName(), filter);\n+        if (av != null) {\n+          wrapper.attributeValidator(av);\n+        } else {\n+          String errorMsg =\n+              String.format(\n+                  \"Appropriate service not found for validatorType=%s, serviceId=%s, filter=%s\",\n+                  validatorType, serviceId, filter);\n+          throw new IllegalStateException(errorMsg);\n+        }\n+        break;\n+      default:\n+        String errorMsg =\n+            String.format(\"ValidatorType of %s is not a supported validator type\", validatorType);\n+        throw new IllegalStateException(errorMsg);\n+    }\n+  }\n+\n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref.length > 1)", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4NDIzNg==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r512184236", "bodyText": "I don't think InvalidSyntaxException is appropriate for either case.", "author": "jrnorth", "createdAt": "2020-10-26T18:35:54Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,73 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\");\n+          }\n+\n+          String serviceId = validators[0];\n+          String validatorType = validators[1];\n+          String filter = String.format(\"(id=%s)\", serviceId);\n+\n+          try {\n+            findAndRegisterValidator(wrapper, validatorType, serviceId, filter);\n+          } catch (IllegalStateException ise) {\n+            throw new IllegalStateException(\n+                \"Validator does not exist. (\" + validator.validator + \")\", ise);\n+          }\n+          break;\n+        }\n     }\n     return wrapper;\n   }\n \n+  private void findAndRegisterValidator(\n+      ValidatorWrapper wrapper, String validatorType, String serviceId, String filter) {\n+    switch (validatorType) {\n+      case \"AttributeValidator\":\n+        AttributeValidator av = getAttributeValidator(AttributeValidator.class.getName(), filter);\n+        if (av != null) {\n+          wrapper.attributeValidator(av);\n+        } else {\n+          String errorMsg =\n+              String.format(\n+                  \"Appropriate service not found for validatorType=%s, serviceId=%s, filter=%s\",\n+                  validatorType, serviceId, filter);\n+          throw new IllegalStateException(errorMsg);\n+        }\n+        break;\n+      default:\n+        String errorMsg =\n+            String.format(\"ValidatorType of %s is not a supported validator type\", validatorType);\n+        throw new IllegalStateException(errorMsg);\n+    }\n+  }\n+\n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref.length > 1)\n+        throw new InvalidSyntaxException(\"Multiple service references found\", filter);", "originalCommit": "d49c4a6c06b8d07aad95148219adf755218e77a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "14a69a281b6e4994b844ece41bff88d037c992b1", "url": "https://github.com/codice/ddf/commit/14a69a281b6e4994b844ece41bff88d037c992b1", "message": "[2.19.x] DDF-6043 Allow DDF to register external attribute validators", "committedDate": "2020-11-18T15:06:11Z", "type": "commit"}, {"oid": "59e9b7490c1f4fee754961ec5683cf6fc86a5224", "url": "https://github.com/codice/ddf/commit/59e9b7490c1f4fee754961ec5683cf6fc86a5224", "message": "refactor DefinitionParser", "committedDate": "2020-11-18T15:06:11Z", "type": "commit"}, {"oid": "8a70b220404e2ec9aaee93f1d9598164b51b70bd", "url": "https://github.com/codice/ddf/commit/8a70b220404e2ec9aaee93f1d9598164b51b70bd", "message": "added a successful test case for validator registration", "committedDate": "2020-11-18T15:06:11Z", "type": "commit"}, {"oid": "9bfcaf79dc9de08b1f8a5f3b63449554252b94cc", "url": "https://github.com/codice/ddf/commit/9bfcaf79dc9de08b1f8a5f3b63449554252b94cc", "message": "single class imports and fix invalid external validators test case", "committedDate": "2020-11-18T15:06:11Z", "type": "commit"}, {"oid": "3e826224a1a99aeebeefbb45b0879bd83b1ffac8", "url": "https://github.com/codice/ddf/commit/3e826224a1a99aeebeefbb45b0879bd83b1ffac8", "message": "Use parameterized logging", "committedDate": "2020-11-18T15:06:11Z", "type": "commit"}, {"oid": "3e826224a1a99aeebeefbb45b0879bd83b1ffac8", "url": "https://github.com/codice/ddf/commit/3e826224a1a99aeebeefbb45b0879bd83b1ffac8", "message": "Use parameterized logging", "committedDate": "2020-11-18T15:06:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MjM2Ng==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r526252366", "bodyText": "\u2753What is validatorType used for?", "author": "jrnorth", "createdAt": "2020-11-18T17:01:28Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -633,11 +641,46 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           break;\n         }\n       default:\n-        throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n+        {\n+          String[] validators = validator.validator.split(\"::\");\n+          if (validators.length != 2) {\n+            throw new IllegalStateException(\n+                \"Validator should be in format of 'validatorId::validatorType', not '\"", "originalCommit": "3e826224a1a99aeebeefbb45b0879bd83b1ffac8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NjAyMA==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r526266020", "bodyText": "It's there to infer which validator type an attribute should be, in order to cast to a validator type. But since it's only supporting AttributeValidator I could just take that out.", "author": "frnkshin", "createdAt": "2020-11-18T17:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MjM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI3NTkxNg==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r526275916", "bodyText": "I think it's actually better to just add a new case, maybe downstream, and add what's currently in the default case logic in the downstream case, and just leave default stay as it was.", "author": "frnkshin", "createdAt": "2020-11-18T17:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MjM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzNzI5Ng==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r526337296", "bodyText": "That sounds like a good solution.", "author": "jrnorth", "createdAt": "2020-11-18T18:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MjM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyNTI0Mg==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r530125242", "bodyText": "And.. I just updated it.", "author": "frnkshin", "createdAt": "2020-11-25T05:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MjM2Ng=="}], "type": "inlineReview"}, {"oid": "661481a1cefa3a167257a9535bdbc441f6b19000", "url": "https://github.com/codice/ddf/commit/661481a1cefa3a167257a9535bdbc441f6b19000", "message": "use a new custom validator for attribute instead of just directing it to default case in definition parser", "committedDate": "2020-11-19T07:48:22Z", "type": "commit"}, {"oid": "3f6819a36a867967a2ed594560a4e485f8a3555f", "url": "https://github.com/codice/ddf/commit/3f6819a36a867967a2ed594560a4e485f8a3555f", "message": "Add custom validator logic in DefinitionParser. Update test cases", "committedDate": "2020-11-25T04:28:44Z", "type": "commit"}, {"oid": "fe599150950576341feee2dbf6c96fef78c3639a", "url": "https://github.com/codice/ddf/commit/fe599150950576341feee2dbf6c96fef78c3639a", "message": "Remove unused method", "committedDate": "2020-11-25T05:29:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxMzYxMA==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r530513610", "bodyText": "As it is currently if there is more than one service reference it will fail to enter this if statement, return null, and then silently not add the attribute validator.\nI would recommend changing this to ref.length > 0, Unless you are specifically trying to prevent the case that multiple versions might be registered. While we usually only have one bundle providing a service its always possible there could be more than one, so we should handle that case. In many places we pick the first service reference in the list (which is probably fine) , but you could also do a LOGGER.warn that there were multiple services and we chose the first in the list. (maybe printing the list of service references that we chose from would provide some useful information if they have implemented toString methods)", "author": "rzwiefel", "createdAt": "2020-11-25T16:47:36Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -632,12 +640,42 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           wrapper.reportingMetacardValidator(relationshipValidator);\n           break;\n         }\n+      case \"custom\":\n+        {\n+          List<Outer.Validator> collection = ((Outer.ValidatorCollection) validator).validators;\n+          collection.forEach(\n+              item -> {\n+                AttributeValidator av =\n+                    (AttributeValidator)\n+                        this.getService(\n+                            AttributeValidator.class.getName(),\n+                            (String.format(\"(id=%s)\", item.validator)));\n+                if (av != null) {\n+                  wrapper.attributeValidator(av);\n+                }\n+              });\n+          break;\n+        }\n       default:\n         throw new IllegalStateException(\"Validator does not exist. (\" + validator.validator + \")\");\n     }\n     return wrapper;\n   }\n \n+  private Object getService(String clazz, String filter) {\n+    BundleContext bundleContext = getBundleContext();\n+    ServiceReference<?>[] ref;\n+    try {\n+      ref = bundleContext.getServiceReferences(clazz, filter);\n+      if (ref != null && ref.length == 1) {", "originalCommit": "fe599150950576341feee2dbf6c96fef78c3639a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "71c987f1cf42015e952da9399e7354c170cf0772", "url": "https://github.com/codice/ddf/commit/71c987f1cf42015e952da9399e7354c170cf0772", "message": "Allow mapping first found validator service to an attribute", "committedDate": "2020-11-25T22:16:35Z", "type": "commit"}, {"oid": "cd43ad7de311b9b4f561254aac855fb6048fd97d", "url": "https://github.com/codice/ddf/commit/cd43ad7de311b9b4f561254aac855fb6048fd97d", "message": "fix formatting issue", "committedDate": "2020-11-25T22:44:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0MzAzOQ==", "url": "https://github.com/codice/ddf/pull/6399#discussion_r532743039", "bodyText": "\u270f\ufe0f Unnecessary parentheses", "author": "jrnorth", "createdAt": "2020-11-30T16:49:05Z", "path": "catalog/core/catalog-core-definitionparser/src/main/java/ddf/catalog/definition/impl/DefinitionParser.java", "diffHunk": "@@ -632,12 +641,50 @@ private ValidatorWrapper getValidator(String key, Outer.Validator validator) {\n           wrapper.reportingMetacardValidator(relationshipValidator);\n           break;\n         }\n+      case \"custom\":\n+        {\n+          List<Outer.Validator> collection = ((Outer.ValidatorCollection) validator).validators;\n+          collection.forEach(\n+              item -> {\n+                AttributeValidator av =\n+                    (AttributeValidator)\n+                        this.getService(\n+                            AttributeValidator.class.getName(),\n+                            (String.format(\"(id=%s)\", item.validator)));", "originalCommit": "cd43ad7de311b9b4f561254aac855fb6048fd97d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4be25ceb866eab13c4acc8822873f713d801da9c", "url": "https://github.com/codice/ddf/commit/4be25ceb866eab13c4acc8822873f713d801da9c", "message": "fix formatting - remove unnecessary parens", "committedDate": "2020-11-30T17:09:00Z", "type": "commit"}]}