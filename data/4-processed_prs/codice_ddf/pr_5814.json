{"pr_number": 5814, "pr_title": "[2.19.x] DDF-5793 anyGeo search validation refactor and UX improvements", "pr_createdAt": "2020-02-05T00:07:14Z", "pr_url": "https://github.com/codice/ddf/pull/5814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNjM1Nw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379116357", "bodyText": "\u2753 does polygonPoints need to be JSON stringified as well?", "author": "hayleynorton", "createdAt": "2020-02-13T21:02:06Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.polygon.js", "diffHunk": "@@ -72,7 +76,7 @@ class PolygonRenderView extends GeometryRenderView {\n     this.primitive = new Cesium.PolylineCollection()\n     this.cameraMagnitude = this.map.camera.getMagnitude()\n     ;(polygons || []).forEach(polygonPoints => {\n-      if (!polygonPoints || polygonPoints.length < 3) {\n+      if (validateGeo('polygon', polygonPoints).error) {", "originalCommit": "a3e38d57c2fa20caef917599a5833cea3d52eca5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMjg5Nw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379122897", "bodyText": "yes :0)", "author": "cassandrabailey293", "createdAt": "2020-02-13T21:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNjM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODk1Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379118952", "bodyText": "\u270f\ufe0f If you changed this function to this:\nfunction validateLinePolygon(mode: string, currentValue: string) {\ntry {\nconst parsedCoords = JSON.parse(currentValue)\nif (!is2DArray(parsedCoords)) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\nreturn validateListOfPoints(parsedCoords, mode)\n} catch (e) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\n}\nthen is2DArray could be simplified to:\nfunction is2DArray(coordinates: string) {\nreturn Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n}", "author": "hayleynorton", "createdAt": "2020-02-13T21:07:56Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,448 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}", "originalCommit": "a3e38d57c2fa20caef917599a5833cea3d52eca5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6bca96d3fe2f2d977d8e03ab479517d49fae51ff", "url": "https://github.com/codice/ddf/commit/6bca96d3fe2f2d977d8e03ab479517d49fae51ff", "message": "DDF-5793 address comments", "committedDate": "2020-02-13T21:09:13Z", "type": "commit"}, {"oid": "d0cd813b49b248ae9345539851eb38afbf37ff1c", "url": "https://github.com/codice/ddf/commit/d0cd813b49b248ae9345539851eb38afbf37ff1c", "message": "Update ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>", "committedDate": "2020-02-13T21:10:32Z", "type": "commit"}, {"oid": "a6b9edfa681536cded7ab5948f87bf7a782bef30", "url": "https://github.com/codice/ddf/commit/a6b9edfa681536cded7ab5948f87bf7a782bef30", "message": "DDF-5793 do validation after polygon has been constructed", "committedDate": "2020-02-13T22:01:08Z", "type": "commit"}, {"oid": "c49fe58012c5737b6235c60c8ced02fcb684f9c0", "url": "https://github.com/codice/ddf/commit/c49fe58012c5737b6235c60c8ced02fcb684f9c0", "message": "DDF-5793 refactor", "committedDate": "2020-02-13T22:29:50Z", "type": "commit"}, {"oid": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3", "url": "https://github.com/codice/ddf/commit/61d3144f463e5f2fbd1e68a7abda04fed03b24b3", "message": "DDF-5793 format", "committedDate": "2020-02-13T22:46:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0ODg5NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379548895", "bodyText": "This case can be removed now that the model is being set upon JSON.parse failure", "author": "hayleynorton", "createdAt": "2020-02-14T17:16:22Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,153 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(\n+        typeof props[geometryKey] === 'string'\n+          ? props[geometryKey]\n+          : JSON.stringify(props[geometryKey])\n+      )\n+      if (props.drawing) {\n+        if (\n+          geometryKey === 'line' &&\n+          (lineWidth === undefined || Number(lineWidth) <= 0)\n+        ) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })", "originalCommit": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "106c075fb4abce47185637b17e14c1f33d952aea", "url": "https://github.com/codice/ddf/commit/106c075fb4abce47185637b17e14c1f33d952aea", "message": "DDF-5793 remove uneecessary conditional", "committedDate": "2020-02-14T20:58:30Z", "type": "commit"}, {"oid": "f3023c4bcdc6e4081f83d5cadf69d4ed19c8e904", "url": "https://github.com/codice/ddf/commit/f3023c4bcdc6e4081f83d5cadf69d4ed19c8e904", "message": "DDF-5793 haurd against undefined model for drawing and remove unnecessary code", "committedDate": "2020-02-18T15:52:14Z", "type": "commit"}, {"oid": "06102b4433d4fd283366c845603778ec6fafcddb", "url": "https://github.com/codice/ddf/commit/06102b4433d4fd283366c845603778ec6fafcddb", "message": "DDF-5793 add multis to validation switch", "committedDate": "2020-02-18T19:22:43Z", "type": "commit"}, {"oid": "ca6bf32769454fe6b34f95dd2d2c981574797f70", "url": "https://github.com/codice/ddf/commit/ca6bf32769454fe6b34f95dd2d2c981574797f70", "message": "DDF-5793 ensure distance is a number", "committedDate": "2020-02-18T22:42:40Z", "type": "commit"}, {"oid": "e12533a14084de76392726ef54d2f931d838cdca", "url": "https://github.com/codice/ddf/commit/e12533a14084de76392726ef54d2f931d838cdca", "message": "DDF-5793 fix polygon/line initial error and Draw clicking issue", "committedDate": "2020-02-19T19:29:57Z", "type": "commit"}, {"oid": "1d37e31dcee779ccdf10f60d73e9a76947c79d32", "url": "https://github.com/codice/ddf/commit/1d37e31dcee779ccdf10f60d73e9a76947c79d32", "message": "DDF-5793 fix drawing error and stale error messages", "committedDate": "2020-02-19T21:20:42Z", "type": "commit"}, {"oid": "d4f3fe12d6aaeca2f3f4c39fab9a8d15a3264cd7", "url": "https://github.com/codice/ddf/commit/d4f3fe12d6aaeca2f3f4c39fab9a8d15a3264cd7", "message": "DDF-5793 formatting", "committedDate": "2020-02-20T21:43:44Z", "type": "commit"}, {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902", "url": "https://github.com/codice/ddf/commit/8ddacff3a14d526e65ce956598108acf9acb2902", "message": "DDF-5793 change buffer validation to be specific to units", "committedDate": "2020-02-24T18:06:59Z", "type": "commit"}, {"oid": "da7705ae67f0c5b3bed1e5e4641bd95d39b32236", "url": "https://github.com/codice/ddf/commit/da7705ae67f0c5b3bed1e5e4641bd95d39b32236", "message": "DDF-5793 add new validation to all point radius options", "committedDate": "2020-02-24T18:56:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MDAwNQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r384070005", "bodyText": "\u2753 Just curious as to why setting the error state has been removed from the onChange here", "author": "hayleynorton", "createdAt": "2020-02-25T19:15:10Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -134,20 +134,35 @@ const BaseLine = props => {\n             typeof setBufferState === 'function'\n               ? setBufferState(unitKey, value)\n               : setState({ [unitKey]: value })\n+            if (widthKey === 'lineWidth') {\n+              setBufferError(\n+                validateGeo('lineWidth', {\n+                  value: props[widthKey],\n+                  units: value,\n+                })\n+              )\n+            }\n           }}\n         >\n           <TextField\n             type=\"number\"\n             label=\"Buffer width\"\n             value={String(props[widthKey])}\n             onChange={value => {\n-              if (widthKey === 'lineWidth') {", "originalCommit": "8ddacff3a14d526e65ce956598108acf9acb2902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MzIyNA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r384183224", "bodyText": "I made this change because of the different way we're checking if there is an error or not.. before, we were just doing it if the buffer was 0 or empty. now we're doing it based on that conversion (if its less than one meter or equivalent). because it's more complicated now I moved this validation to the onBlur.", "author": "cassandrabailey293", "createdAt": "2020-02-25T23:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MDAwNQ=="}], "type": "inlineReview"}, {"oid": "98b28abd57796839d7bbfa95bf2ec70efa739dc6", "url": "https://github.com/codice/ddf/commit/98b28abd57796839d7bbfa95bf2ec70efa739dc6", "message": "DDF-5793 fix unit tests", "committedDate": "2020-02-27T21:40:28Z", "type": "commit"}, {"oid": "92f4217f676f735fe116d80fbc3543366dcb6aac", "url": "https://github.com/codice/ddf/commit/92f4217f676f735fe116d80fbc3543366dcb6aac", "message": "DDF-5793 add min buffer check for polygon and persist buffer errors after drawing", "committedDate": "2020-02-27T22:43:45Z", "type": "commit"}, {"oid": "cb31b24685213b2c60d45d60ff77fa38f1397b29", "url": "https://github.com/codice/ddf/commit/cb31b24685213b2c60d45d60ff77fa38f1397b29", "message": "DDF-5793 formt", "committedDate": "2020-02-27T22:44:54Z", "type": "commit"}, {"oid": "9af04a73a60444afb470cc4e800bcafc6bb86813", "url": "https://github.com/codice/ddf/commit/9af04a73a60444afb470cc4e800bcafc6bb86813", "message": "DDF-5793 guard against undefined multiline", "committedDate": "2020-02-28T15:45:43Z", "type": "commit"}, {"oid": "1ec8a13480af9e07c686143d697811ead81183d2", "url": "https://github.com/codice/ddf/commit/1ec8a13480af9e07c686143d697811ead81183d2", "message": "DDF-5793 change error messaging for polygon", "committedDate": "2020-02-28T16:48:36Z", "type": "commit"}, {"oid": "6dc69622b2a78b85ecfb80cf68044b6eb565b6e6", "url": "https://github.com/codice/ddf/commit/6dc69622b2a78b85ecfb80cf68044b6eb565b6e6", "message": "DDF-5793 format", "committedDate": "2020-02-28T16:50:06Z", "type": "commit"}, {"oid": "05821e7c0d36e2552716c9ed8dcafdc635302e02", "url": "https://github.com/codice/ddf/commit/05821e7c0d36e2552716c9ed8dcafdc635302e02", "message": "DDF-5793 only default drawing buffer for line and change error message for brevity", "committedDate": "2020-02-28T18:11:44Z", "type": "commit"}, {"oid": "74680376f33b0caf1de479abbea737d611fe6039", "url": "https://github.com/codice/ddf/commit/74680376f33b0caf1de479abbea737d611fe6039", "message": "DDF-5841 delete last coordinate to prevent stale coordinates", "committedDate": "2020-02-28T18:24:04Z", "type": "commit"}, {"oid": "2decca30e9748dce772f8f3712bfb1ca819895c4", "url": "https://github.com/codice/ddf/commit/2decca30e9748dce772f8f3712bfb1ca819895c4", "message": "DDF-5793 formatting", "committedDate": "2020-02-28T18:44:39Z", "type": "commit"}, {"oid": "f494618dd395b5e1e5ce7fde03895e85c27b09d4", "url": "https://github.com/codice/ddf/commit/f494618dd395b5e1e5ce7fde03895e85c27b09d4", "message": "DDF-5793 fix poly buffer logic and remove line error when set to 1", "committedDate": "2020-02-28T21:31:33Z", "type": "commit"}, {"oid": "cefb365fa0f3302a13d48801598e80fb7b13afa4", "url": "https://github.com/codice/ddf/commit/cefb365fa0f3302a13d48801598e80fb7b13afa4", "message": "DDF-5793 formatting", "committedDate": "2020-02-28T21:40:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjYzNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375372637", "bodyText": "The testValidity logic could be moved to a validateLineAndPolygon function in validation.js and this call could be replaced with validateGeo(mode, currentValue)", "author": "hayleynorton", "createdAt": "2020-02-05T16:41:15Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateListOfPoints,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n-  }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n-  }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n-          <TextField\n-            label={label}\n-            value={this.state.value}\n-            onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n-              }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n-            }}\n-          />\n-          <Units value={props[unitKey]} onChange={cursor(unitKey)}>\n-            <TextField\n-              type=\"number\"\n-              label=\"Buffer width\"\n-              min={0.000001}\n-              value={`${props[widthKey]}`}\n-              onChange={cursor(widthKey)}\n-            />\n-          </Units>\n-        </div>\n-        {this.state.isValid ? (\n-          ''\n-        ) : (\n-          <Invalid>\n-            &nbsp;\n-            <span className=\"fa fa-exclamation-triangle\" />\n-            &nbsp; {this.invalidMessage} &nbsp; &nbsp;\n-            <span className=\"fa fa-times\" onClick={this.removeErrorBox} />\n-          </Invalid>\n-        )}\n-      </React.Fragment>\n-    )\n-  }\n-  removeErrorBox() {\n-    this.setState({ isValid: true })\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  isValidInput(value) {\n-    this.invalidMessage = ''\n-    this.setState({ value, isValid: this.isValidPolygon(value) })\n-  }\n-  is2DArray(coordinates) {\n-    try {\n-      const parsedCoords = JSON.parse(coordinates)\n-      return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n-    } catch (e) {\n-      return false\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  validatePoint(point) {\n-    if (\n-      point.length !== 2 ||\n-      (Number.isNaN(Number.parseFloat(point[0])) &&\n-        Number.isNaN(Number.parseFloat(point[1])))\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    } else if (\n-      point[0] > 180 ||\n-      point[0] < -180 ||\n-      point[1] > 90 ||\n-      point[1] < -90\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    }\n-    return ''\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  validateListOfPoints(coordinates) {\n-    let message = ''\n-    const isLine = this.props.mode.includes('line')\n-    let numPoints = isLine ? 2 : 4\n-    if (!this.props.mode.includes('multi')) {\n-      if (coordinates.some(coords => coords.length > 2)) {\n-        message = ''\n-      } else if (coordinates.length < numPoints) {\n-        message = `Minimum of ${numPoints} points needed for ${\n-          isLine ? 'Line' : 'Polygon'\n-        }`\n-      }\n-    }\n-    for (let i = 0; i < coordinates.length; i++) {\n-      if (coordinates[i].length > 2) {\n-        coordinates[i].forEach(coordinate => {\n-          if (this.validatePoint(coordinate)) {\n-            message = this.validatePoint(coordinate)\n-          }\n-        })\n-      } else {\n-        if (this.props.mode.includes('multi')) {\n-          message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n-        } else if (this.validatePoint(coordinates[i])) {\n-          message = this.validatePoint(coordinates[i])\n-        }\n-      }\n-    }\n-    if (message !== '') {\n-      this.invalidMessage = message\n-      throw 'Invalid coordinates.'\n-    }\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+function is2DArray(coordinates) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n   }\n-  isValidPolygon(coordinates) {\n-    if (!this.is2DArray(coordinates)) {\n-      this.invalidMessage = 'Not an acceptable value.'\n-      return false\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, unitKey, widthKey, mode } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  function testValidity() {\n+    if (!is2DArray(currentValue)) {\n+      return { error: true, message: 'Not an acceptable value' }\n     }\n     try {\n-      this.validateListOfPoints(JSON.parse(coordinates))\n-      return true\n+      return validateListOfPoints(JSON.parse(currentValue), mode)\n     } catch (e) {\n-      return false\n+      //do nothing\n     }\n   }\n-  convertWkt(value, numCoords) {\n-    const coordinatePairs = value.match(coordinatePairRegex)\n-    if (!coordinatePairs || coordinatePairs.length < numCoords) {\n-      return value\n-    }\n-    const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n-    return `[[${coordinates.join('],[')}]]`\n-  }\n-  convertMultiWkt(isPolygon, value) {\n-    if (isPolygon && !value.endsWith(')))')) {\n-      return value\n-    } else if (!value.endsWith('))')) {\n-      return value\n-    }\n-    const splitter = isPolygon ? '))' : ')'\n-    const numPoints = isPolygon ? 4 : 2\n-    let shapes = value\n-      .split(splitter)\n-      .map(shape => shape.match(coordinatePairRegex))\n-    shapes = shapes\n-      .filter(shape => shape !== null && shape.length >= numPoints)\n-      .map(shape =>\n-        shape.map(coordinatePair => coordinatePair.replace(' ', ','))\n-      )\n-    return shapes.length === 0\n-      ? value\n-      : shapes.length === 1\n-        ? `[[${shapes[0].join('],[')}]]`\n-        : `[${shapes.map(shapeCoords => `[[${shapeCoords.join('],[')}]]`)}]`\n-  }\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState(geometryKey, undefined)\n+              } else {\n+                setState(geometryKey, JSON.parse(value))\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(testValidity())}", "originalCommit": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDc4OQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375374789", "bodyText": "this and validateLatLon are functionally the same and could be combined", "author": "hayleynorton", "createdAt": "2020-02-05T16:44:49Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {", "originalCommit": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "url": "https://github.com/codice/ddf/commit/3abcbef3c16a5cca26709b97cb0adfb4f1381545", "message": "DDF-5793 anyGeo search validation refactor and UX improvements", "committedDate": "2020-02-05T18:41:49Z", "type": "commit"}, {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "url": "https://github.com/codice/ddf/commit/3abcbef3c16a5cca26709b97cb0adfb4f1381545", "message": "DDF-5793 anyGeo search validation refactor and UX improvements", "committedDate": "2020-02-05T18:41:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzE1OA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467158", "bodyText": "this and the line above are the value of isNorthingInvalid", "author": "hayleynorton", "createdAt": "2020-02-05T19:39:35Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined", "originalCommit": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzcyOA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467728", "bodyText": "same here with isEastingInvalid", "author": "hayleynorton", "createdAt": "2020-02-05T19:40:43Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isNaN(utmUpsParts.easting) &&\n+    utmUpsEasting !== undefined", "originalCommit": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58e7c720aad396a916fb2b424f9f372044f7af34", "url": "https://github.com/codice/ddf/commit/58e7c720aad396a916fb2b424f9f372044f7af34", "message": "DDF-5793 move validation out of base line and add comments", "committedDate": "2020-02-05T19:45:55Z", "type": "commit"}, {"oid": "3e2426cccff27d550bf3f4d7778b2d76ccb369d2", "url": "https://github.com/codice/ddf/commit/3e2426cccff27d550bf3f4d7778b2d76ccb369d2", "message": "DDF-5793 refactoring", "committedDate": "2020-02-05T20:39:30Z", "type": "commit"}, {"oid": "14552330ddb958b98a7ccc67e76dcf6460547363", "url": "https://github.com/codice/ddf/commit/14552330ddb958b98a7ccc67e76dcf6460547363", "message": "DDF-5793 prevent console errors by ensuring line and poly are arrays", "committedDate": "2020-02-05T23:19:34Z", "type": "commit"}, {"oid": "0a8e87610d8ce1673cd9d5bfeb4d07cd6c85e3bd", "url": "https://github.com/codice/ddf/commit/0a8e87610d8ce1673cd9d5bfeb4d07cd6c85e3bd", "message": "DDF-5793 pull reused obj into a ocnstant", "committedDate": "2020-02-05T23:43:01Z", "type": "commit"}, {"oid": "bfcce8a79783be097b80763b5ba4a2d32aca8694", "url": "https://github.com/codice/ddf/commit/bfcce8a79783be097b80763b5ba4a2d32aca8694", "message": "DDF-5793 change setState para structure to comply with aoi", "committedDate": "2020-02-06T19:40:31Z", "type": "commit"}, {"oid": "33c47d16ef86299de054b606cfbee45770f1edf1", "url": "https://github.com/codice/ddf/commit/33c47d16ef86299de054b606cfbee45770f1edf1", "message": "DDF-5793 fix utm ups validation logic", "committedDate": "2020-02-06T22:12:31Z", "type": "commit"}, {"oid": "5a7c538cb7be7446e2a4a5b64e4033325487a011", "url": "https://github.com/codice/ddf/commit/5a7c538cb7be7446e2a4a5b64e4033325487a011", "message": "DDF-5793 fixed error messages not disappearing after drawing", "committedDate": "2020-02-06T22:37:28Z", "type": "commit"}, {"oid": "4500feb17d593406ad82091a503f13d2e998283f", "url": "https://github.com/codice/ddf/commit/4500feb17d593406ad82091a503f13d2e998283f", "message": "DDF-5793 prevent empty buffer when drawing line", "committedDate": "2020-02-06T22:41:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2ODIyNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377268227", "bodyText": "\u270f\ufe0f investigate need to pass in this", "author": "willwill96", "createdAt": "2020-02-10T19:26:33Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,14 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n-    store.get('content').turnOffDrawing()\n+    store.get('content').turnOffDrawing(this)", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377269201", "bodyText": "\u270f\ufe0f verify radius should be 0 and not ''", "author": "willwill96", "createdAt": "2020-02-10T19:28:28Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcwODI2Nw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377708267", "bodyText": "on the same note, width, above, and lineWidth, up in the LineString and MultiLineString definitions in this file, are currently set to 1. I'm wondering if I need to also change these.", "author": "cassandrabailey293", "createdAt": "2020-02-11T15:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxOTcyMA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377719720", "bodyText": "I changed it to '' here and everything seems to be fine. I'm going to wait to commit this change until after investigating what i mentioned above", "author": "cassandrabailey293", "createdAt": "2020-02-11T15:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0NzcwOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378347709", "bodyText": "it seems that, from the entry point of the anyGeo search, the radius will never be undefined (it's an empty string if you don't type anything in), so this default value never gets used. Not sure what we should put here, so I'll leave this open for now", "author": "cassandrabailey293", "createdAt": "2020-02-12T16:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3MzYwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377273606", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!linePoints || !linePoints[0]) {\n          \n          \n            \n                if (!linePoints || linePoints[0] === undefined) {", "author": "willwill96", "createdAt": "2020-02-10T19:37:22Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.line.js", "diffHunk": "@@ -53,7 +53,7 @@ class LineRenderView extends GeometryRenderView {\n         json.lineWidth,\n         model.get('lineUnits')\n       ) || 1\n-    if (!linePoints) {\n+    if (!linePoints || !linePoints[0]) {", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxNDk5Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377714993", "bodyText": "and I think we discussed the same for the other cases in cesium.polygon, openlayers.line and openlayers.polygon", "author": "hayleynorton", "createdAt": "2020-02-11T15:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3MzYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3NTk5Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377275992", "bodyText": "push changes to eliminate this function here", "author": "hayleynorton", "createdAt": "2020-02-10T19:42:08Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTYyNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377281627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n          \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState({ [unitKey]: value }) : setState({ [unitKey]: value })", "author": "hayleynorton", "createdAt": "2020-02-10T19:53:20Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Mzg0NA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377283844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })\n          \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState({ [widthKey]: value }) : setState({ [widthKey]: value })", "author": "hayleynorton", "createdAt": "2020-02-10T19:57:33Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n+          }}\n+        >\n           <TextField\n-            label={label}\n-            value={this.state.value}\n+            type=\"number\"\n+            label=\"Buffer width\"\n+            value={String(props[widthKey])}\n             onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n+              if (widthKey === 'lineWidth') {\n+                setBufferError(validateGeo('lineWidth', value))\n               }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n+              typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Njg4NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377286885", "bodyText": "delete", "author": "andrewzimmer", "createdAt": "2020-02-10T20:03:56Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NzY2MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377287660", "bodyText": "\u270f\ufe0f remove", "author": "willwill96", "createdAt": "2020-02-10T20:05:45Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODczOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377288739", "bodyText": "\u270f\ufe0f investigate converting getErrrorComponent to a functional component", "author": "willwill96", "createdAt": "2020-02-10T20:08:02Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)\n+    if(props.drawing) {\n+      setDmsError(initialErrorStateWithDefault)\n+    }\n+  }, [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth])\n+\n+  function validate(key, type, value) {\n+    const label =\n+      key.includes('East') || key.includes('West') ? 'dmsLon' : 'dmsLat'\n+    const { error, message, defaultValue } = validateGeo(label, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue ? setState({[key]: defaultValue}) : setState({[key]: value})\n+  }\n+\n+  return (\n+    <div className=\"input-location\">\n+      <DmsLongitude\n+        label=\"West\"\n+        value={dmsWest}\n+        onChange={(value, type) => validate('dmsWest', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsWestDirection}\n+          onChange={value => setState({['dmsWestDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"South\"\n+        value={dmsSouth}\n+        onChange={(value, type) => validate('dmsSouth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsSouthDirection}\n+          onChange={value => setState({['dmsSouthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"East\"\n+        value={dmsEast}\n+        onChange={(value, type) => validate('dmsEast', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsEastDirection}\n+          onChange={value => setState({['dmsEastDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"North\"\n+        value={dmsNorth}\n+        onChange={(value, type) => validate('dmsNorth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsNorthDirection}\n+          onChange={value => setState({['dmsNorthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      {getErrorComponent(dmsError)}", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjIwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377292206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      setBufferState={(key, value) => setState(key, value)}\n          \n          \n            \n                      setBufferState={(key, value) => setState({ [key]: value })}", "author": "hayleynorton", "createdAt": "2020-02-10T20:15:34Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -84,6 +55,7 @@ const inputs = plugin({\n           setState={({ value, ...data }) => {\n             setState({ keywordValue: value, ...data })\n           }}\n+          setBufferState={(key, value) => setState(key, value)}", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NTM2Ng==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377295366", "bodyText": "move function to this file?", "author": "andrewzimmer", "createdAt": "2020-02-10T20:22:12Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NjI1Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377296252", "bodyText": "\u270f\ufe0f rename or leave comment for significance of extra values", "author": "willwill96", "createdAt": "2020-02-10T20:24:09Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5ODQ3MQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377298471", "bodyText": "can just return whatever validateListOfPoints returns\nalso, \u270f\ufe0f switch order of args for validateListOfPoints for consistency's sake", "author": "hayleynorton", "createdAt": "2020-02-10T20:28:46Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) ", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5OTU5MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377299590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "author": "hayleynorton", "createdAt": "2020-02-10T20:31:11Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDU1NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300555", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth === 0) {\n          \n      \n    \n    \n  \n\nis this second check necessary though?", "author": "hayleynorton", "createdAt": "2020-02-10T20:33:16Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODY0Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377768643", "bodyText": "actually, didn't we talk about checking for negative values here as well @andrewzimmer @willwill96 ?", "author": "hayleynorton", "createdAt": "2020-02-11T17:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDc5Nw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300797", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Line buffer width must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Line buffer width must be greater than 0')", "author": "hayleynorton", "createdAt": "2020-02-10T20:33:49Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTAxMg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Radius must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Radius must be greater than 0')\n          \n      \n    \n    \n  \n\nsame for inline messages", "author": "hayleynorton", "createdAt": "2020-02-10T20:34:17Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTEyOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301129", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "author": "willwill96", "createdAt": "2020-02-10T20:34:33Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTgzMg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301832", "bodyText": "could pull filter.geojson.properties into a local variable since it's used in multiple places", "author": "hayleynorton", "createdAt": "2020-02-10T20:36:13Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTk4Ng==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301986", "bodyText": "\u270f\ufe0f verify 0 is not an edge case for these guys", "author": "willwill96", "createdAt": "2020-02-10T20:36:35Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNjk5MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377926990", "bodyText": "so, it seems like when you type a 0 into the text box, i.e., for east, then the value of east will be the string \"0\", which is truthy. When drawing, the values are numbers rather than strings. So the edge case does exist, if you managed to hit 0 exactly while drawing.\nWe want to show an error when any of these values are either empty, or undefined. so the new check would look something like\nif (box.east === undefined || box.east === '' || box.west === undefined... \nis there a better way?", "author": "cassandrabailey293", "createdAt": "2020-02-11T22:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTQ4NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305485", "bodyText": "\u270f\ufe0f I think you can use parseFloat to avoid this ternary, because that gives you NaN  for a blank string", "author": "willwill96", "createdAt": "2020-02-10T20:44:06Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4MzI3NA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377783274", "bodyText": "We were using parseFloat originally, but that would parse numbers out of strings with a mix of numbers and invalid characters (i.e. 23$%jdkk), making those kinds of entries valid. We didn't want to allow that, so we made a regex to test for non-numeric characters. But eventually we decided this way would be cleaner, because Number('23$%jdkk') results in NaN", "author": "hayleynorton", "createdAt": "2020-02-11T17:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTkwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305906", "bodyText": "\u270f\ufe0f can remove the second part of the ternary:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth) {", "author": "willwill96", "createdAt": "2020-02-10T20:45:00Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzI2NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307265", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (Number.isNaN(Number.parseFloat(point[0])) &&\n          \n          \n            \n                Number.isNaN(Number.parseFloat(point[0])) ||", "author": "hayleynorton", "createdAt": "2020-02-10T20:47:57Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzY5Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307693", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  message: label + 'cannot be less than 0.000001',\n          \n          \n            \n                  message: label + 'must be greater than 0',", "author": "hayleynorton", "createdAt": "2020-02-10T20:48:40Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\" \n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+   if (\n+    key === 'utmUpsNorthing' &&\n+    isNorthingInvalid && !isEastingInvalid\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid && !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n+    return {\n+      error: true,\n+      message: label + 'cannot be less than 0.000001',", "originalCommit": "4500feb17d593406ad82091a503f13d2e998283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f10b676a1596bd4e1e463af3c1a5af18f2f054a", "url": "https://github.com/codice/ddf/commit/5f10b676a1596bd4e1e463af3c1a5af18f2f054a", "message": "DDF-5793 format and refactor", "committedDate": "2020-02-10T22:53:00Z", "type": "commit"}, {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "url": "https://github.com/codice/ddf/commit/61f20c5e808783f71d91be9dd30437c4f33a2e82", "message": "DDF-5793 dont pass model into turnOffDrawing and add poly case", "committedDate": "2020-02-11T15:18:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMDU0OA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377710548", "bodyText": "Do we want to do the same thing here as we did with turnOffDrawing and move the setting of attributes on the model to location-old to be consistent?", "author": "hayleynorton", "createdAt": "2020-02-11T15:32:16Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/content/content.js", "diffHunk": "@@ -110,7 +110,11 @@ module.exports = Backbone.AssociatedModel.extend({\n   },\n   turnOnDrawing(model) {\n     this.set('drawing', true)\n+    model.set('drawing', true)\n     this.set('drawingModel', model)\n+    if (model.get('mode') === 'line' && !model.get('lineWidth')) {\n+      model.set('lineWidth', 1)\n+    }", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMzc4Ng==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377713786", "bodyText": "Is it really necessary to have this.drawing = false and this.set('drawing', false) here? If the goal of setting this.drawing was to affect the model, it obviously didn't achieve it since we also have to do this.set. I'm just not sure if that was the goal or if this.drawing serves another purpose", "author": "hayleynorton", "createdAt": "2020-02-11T15:37:10Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,15 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n+    this.set('drawing', false)", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzIyMg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377773222", "bodyText": "I wasn't sure either, it seems that this.drawing is checked in some places in the file - but maybe those checks could just be replaced with this.get('drawing'). I tried this and it seems to work fine so I'll push it up", "author": "cassandrabailey293", "createdAt": "2020-02-11T17:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMzc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxODU5OQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377718599", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  console.log(props.drawing)", "author": "hayleynorton", "createdAt": "2020-02-11T15:44:05Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMDc5MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377720790", "bodyText": "Could we conditionally set label as a local variable in this function instead of passing it as a param (to keep consistent with the dms version of this function)?", "author": "hayleynorton", "createdAt": "2020-02-11T15:47:20Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -30,22 +33,49 @@ const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n \n const minimumDifference = 0.0001\n \n-const BoundingBoxLatLon = props => {\n-  const { north, east, south, west, cursor } = props\n-\n-  const { mapEast, mapWest, mapSouth, mapNorth } = props\n-\n+const BoundingBoxLatLonDd = props => {\n+  const {\n+    north,\n+    east,\n+    south,\n+    west,\n+    setState,\n+    mapEast,\n+    mapWest,\n+    mapSouth,\n+    mapNorth,\n+  } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n   const westMax = parseFloat(mapEast) - minimumDifference\n   const eastMin = parseFloat(mapWest) + minimumDifference\n   const northMin = parseFloat(mapSouth) + minimumDifference\n   const southMax = parseFloat(mapNorth) - minimumDifference\n \n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.east, props.west, props.south, props.north]\n+  )\n+\n+  function onChangeDd(key, label, value) {", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MTU4Ng==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377761586", "bodyText": "good call \ud83d\udc4d", "author": "cassandrabailey293", "createdAt": "2020-02-11T16:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377721193", "bodyText": "for consistency with DD:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "author": "hayleynorton", "createdAt": "2020-02-11T15:47:55Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDEyOA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377764128", "bodyText": "I thought it might be confusing to call it onChange... because it's technically being called both in the onChange and the onBlur (even though we're only specifically invoking it from the onChange). If you think it isn't confusing then I'm okay with changing it", "author": "cassandrabailey293", "createdAt": "2020-02-11T16:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NDEyMw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377774123", "bodyText": "oh okay that makes sense, maybe we call them validateDd and validateDms?", "author": "hayleynorton", "createdAt": "2020-02-11T17:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyMDM5MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377820390", "bodyText": "yeah that sounds good to me", "author": "cassandrabailey293", "createdAt": "2020-02-11T18:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNDYxNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377724617", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      <Menu value={mode} onChange={value => setState('mode', value)}>\n          \n          \n            \n                      <Menu value={mode} onChange={value => setState({ ['mode']: value })}>", "author": "hayleynorton", "createdAt": "2020-02-11T15:53:10Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -103,35 +75,20 @@ const DrawButton = ({ onDraw }) => (\n   </Button>\n )\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n-\n const Root = styled.div`\n   height: ${props => (props.isOpen ? 'auto' : props.theme.minimumButtonSize)};\n `\n \n const Component = CustomElements.registerReact('location')\n-let errors = false\n-let inValidInput = ''\n-let inValidKey = ''\n-let defaultCoord = ''\n const LocationInput = props => {\n-  const { mode, setState, cursor } = props\n+  const { mode, setState } = props\n   const input = inputs[mode] || {}\n   const { Component: Input = null } = input\n-  const removeErrorBox = () => {\n-    setState((errors = false))\n-  }\n   return (\n     <Root isOpen={input.label !== undefined}>\n       <Component>\n         <Dropdown label={input.label || 'Select Location Option'}>\n-          <Menu value={mode} onChange={cursor('mode')}>\n+          <Menu value={mode} onChange={value => setState('mode', value)}>", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNzAwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377727006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "author": "hayleynorton", "createdAt": "2020-02-11T15:56:32Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMTY3Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377731672", "bodyText": "should type=\"number\" be added in here like all the other radius text fields?", "author": "hayleynorton", "createdAt": "2020-02-11T16:03:10Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue\n+      ? setState({ [key]: defaultValue })\n+      : setState({ [key]: value })\n   }\n+\n   return (\n     <div>\n-      <TextField label=\"USNG / MGRS\" value={usng} onChange={cursor('usng')} />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n+      <DmsLatitude\n+        label=\"Latitude\"\n+        value={dmsLat}\n+        onChange={(value, type) => validate('dmsLat', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsLatDirection}\n+          onChange={value => setState({ ['dmsLatDirection']: value })}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"Longitude\"\n+        value={dmsLon}\n+        onChange={(value, type) => validate('dmsLon', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsLonDirection}\n+          onChange={value => setState({ ['dmsLonDirection']: value })}\n+        />\n+      </DmsLongitude>\n+      {getErrorComponent(dmsError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"\n+          type=\"number\"\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n+        />\n       </Units>\n-      {error ? (\n-        <ErrorBlock>\n-          <WarningIcon className=\"fa fa-warning\" />\n-          <span>Invalid USNG / MGRS coords</span>\n-        </ErrorBlock>\n-      ) : null}\n+      {getErrorComponent(radiusError)}\n+    </div>\n+  )\n+}\n+\n+const PointRadiusUsngMgrs = props => {\n+  const { usng, radius, radiusUnits, setState } = props\n+  const [usngError, setUsngError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUsngError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.usng, props.radius]\n+  )\n+\n+  return (\n+    <div>\n+      <TextField\n+        label=\"USNG / MGRS\"\n+        value={usng}\n+        onChange={value => setState({ ['usng']: value })}\n+        onBlur={() => setUsngError(validateGeo('usng', usng))}\n+      />\n+      {getErrorComponent(usngError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NDMwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377784306", "bodyText": "yeah good catch \ud83d\udc4d", "author": "cassandrabailey293", "createdAt": "2020-02-11T17:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDg5Nw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377734897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      label=\"Radius\"\n          \n          \n            \n                      type=\"number\"\n          \n          \n            \n                      label=\"Radius\"", "author": "hayleynorton", "createdAt": "2020-02-11T16:08:13Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -108,85 +231,122 @@ const PointRadiusUtmUps = props => {\n     utmUpsHemisphere,\n     radius,\n     radiusUnits,\n-    cursor,\n+    setState,\n   } = props\n+  const [utmError, setUtmError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUtmError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [\n+      props.utmUpsEasting,\n+      props.utmUpsNorthing,\n+      props.utmUpsZone,\n+      props.utmUpsHemisphere,\n+      props.radius,\n+    ]\n+  )\n+\n   return (\n     <div>\n       <TextField\n         label=\"Easting\"\n-        value={utmUpsEasting}\n-        onChange={cursor('utmUpsEasting')}\n+        value={\n+          utmUpsEasting !== undefined ? String(utmUpsEasting) : utmUpsEasting\n+        }\n+        onChange={value => setState({ ['utmUpsEasting']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsEasting',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n       <TextField\n         label=\"Northing\"\n-        value={utmUpsNorthing}\n-        onChange={cursor('utmUpsNorthing')}\n+        value={\n+          utmUpsNorthing !== undefined ? String(utmUpsNorthing) : utmUpsNorthing\n+        }\n+        onChange={value => setState({ ['utmUpsNorthing']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsNorthing',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n-      <Zone value={utmUpsZone} onChange={cursor('utmUpsZone')} />\n+      <Zone\n+        value={utmUpsZone}\n+        onChange={value => setState({ ['utmUpsZone']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsZone',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n+      />\n       <Hemisphere\n         value={utmUpsHemisphere}\n-        onChange={cursor('utmUpsHemisphere')}\n+        onChange={value => setState({ ['utmUpsHemisphere']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsHemisphere',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n-      </Units>\n-    </div>\n-  )\n-}\n-\n-const PointRadiusDms = props => {\n-  const {\n-    dmsLat,\n-    dmsLon,\n-    dmsLatDirection,\n-    dmsLonDirection,\n-    radius,\n-    radiusUnits,\n-    cursor,\n-  } = props\n-  const latitudeDirections = [Direction.North, Direction.South]\n-  const longitudeDirections = [Direction.East, Direction.West]\n-\n-  return (\n-    <div>\n-      <DmsLatitude label=\"Latitude\" value={dmsLat} onChange={cursor('dmsLat')}>\n-        <DirectionInput\n-          options={latitudeDirections}\n-          value={dmsLatDirection}\n-          onChange={cursor('dmsLatDirection')}\n-        />\n-      </DmsLatitude>\n-      <DmsLongitude\n-        label=\"Longitude\"\n-        value={dmsLon}\n-        onChange={cursor('dmsLon')}\n+      {getErrorComponent(utmError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n       >\n-        <DirectionInput\n-          options={longitudeDirections}\n-          value={dmsLonDirection}\n-          onChange={cursor('dmsLonDirection')}\n-        />\n-      </DmsLongitude>\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n         <TextField\n           label=\"Radius\"", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDY2OQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377740669", "bodyText": "\u270f\ufe0f all caps variable names for constants", "author": "hayleynorton", "createdAt": "2020-02-11T16:17:03Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,\n+} = require('../../../component/location-new/utils/dms-utils')\n+const usngs = require('usng.js')\n+const converter = new usngs.Converter()\n+const northingOffset = 10000000\n+const latitude = 'latitude'\n+const longitude = 'longitude'", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjA1OQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742059", "bodyText": "\u270f\ufe0f arrow function", "author": "hayleynorton", "createdAt": "2020-02-11T16:19:10Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjE4Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742183", "bodyText": "\u270f\ufe0f arrow function", "author": "hayleynorton", "createdAt": "2020-02-11T16:19:23Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NTQzOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377745439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point.'\n          \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point'", "author": "hayleynorton", "createdAt": "2020-02-11T16:24:22Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzQ0NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753445", "bodyText": "There was some confusion on this when it first went in so I figured it'd be good to add a comment to explain it\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n          \n            \n                    // Handle the case where the user has selected a \"multi\" mode but one or more shapes were invalid and therefore eliminated\n          \n          \n            \n                    // User should then be prompted to switch to the single-shape mode for the same shape\n          \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n      \n    \n    \n  \n\nlet me know if that makes sense please \ud83d\ude04", "author": "hayleynorton", "createdAt": "2020-02-11T16:36:31Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzEwMQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377857101", "bodyText": "looks good to me!", "author": "cassandrabailey293", "createdAt": "2020-02-11T19:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzYwMA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753600", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point.'\n          \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point'", "author": "hayleynorton", "createdAt": "2020-02-11T16:36:46Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1Mzk4NA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753984", "bodyText": "should just return what validateListOfPoints returns", "author": "hayleynorton", "createdAt": "2020-02-11T16:37:23Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1ODQwNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377758407", "bodyText": "is2DArray is also doing a JSON.parse of the currentValue, and in the catch it returns false, causing this function to return { error: true, message: 'Not an acceptable value' }. I think we should do the same thing here", "author": "hayleynorton", "createdAt": "2020-02-11T16:44:12Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MDExNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377760116", "bodyText": "\u270f\ufe0f could just make this one giant return statement", "author": "hayleynorton", "createdAt": "2020-02-11T16:46:57Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false", "originalCommit": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "url": "https://github.com/codice/ddf/commit/4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "message": "DDF-5793 explictly check for undefined in arrays", "committedDate": "2020-02-11T16:47:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377764940", "bodyText": "\u2757\ufe0f The above code doesn't accept MultiPolygons but this will:\ncase 'Polygon':\n  if (geometry.coordinates[0].length < 4) {\n    // check for MultiPolygon\n    geometry.coordinates[0].forEach((shape: number[]) => {\n    if(shape.length < 4) {\n      errors.add(\n         'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n       )\n    }\n  })\n}\nbreak", "author": "hayleynorton", "createdAt": "2020-02-11T16:54:21Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjI1Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377932252", "bodyText": "i think i also still need the !geometry.coordinates[0].length part of the if statement, otherwise single numbers pass the check geometry.coordinates[0].length < 4, since geometry.coordinates[0].length  evaluates to undefined.", "author": "cassandrabailey293", "createdAt": "2020-02-11T22:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MDI4MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377940280", "bodyText": "I just tried testing, and it seems that (for both polygon and multipolygon), if you remove one of the points of a polygon, leaving only three points, that the model doesn't update with this value. it still has all 4 points, and the validation passes. maybe we can look at it more closely tomorrow.", "author": "cassandrabailey293", "createdAt": "2020-02-11T22:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377768134", "bodyText": "Since we're thinking about changing the error message to \"must be greater than 0\" should we also change this to 0?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth < 0.000001) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth <= 0) {", "author": "hayleynorton", "createdAt": "2020-02-11T16:59:17Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2MjgzNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377862836", "bodyText": "we're removing that check anyway, and just checking !bufferWidth", "author": "cassandrabailey293", "createdAt": "2020-02-11T19:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NTkxNw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377865917", "bodyText": "But doesn't that only cover the case of when bufferWidth === 0? What about if it's negative?", "author": "hayleynorton", "createdAt": "2020-02-11T19:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2OTM5NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377769395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n          \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) <= 0) {", "author": "hayleynorton", "createdAt": "2020-02-11T17:01:17Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if (key === 'utmUpsNorthing' && isNorthingInvalid && !isEastingInvalid) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid &&\n+    !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cd2227d38d99ea6f832643553c2bb915d5da2cd8", "url": "https://github.com/codice/ddf/commit/cd2227d38d99ea6f832643553c2bb915d5da2cd8", "message": "DDF-5793 refactoring, cleanup, remove this.drawing", "committedDate": "2020-02-11T17:12:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM2MA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777360", "bodyText": "\u270f\ufe0f could we switch the order of params here? I just like the concept of maintaining the same order for params that are shared across multiple functions and putting any extra params at the end\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n          \n          \n            \n            function validateDDLatLon(label: string, value: string, defaultCoord: number) {", "author": "hayleynorton", "createdAt": "2020-02-11T17:14:23Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzc1Ng==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777756", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(latitude, 90, value)\n          \n          \n            \n                  return validateDDLatLon(latitude, value, 90)", "author": "hayleynorton", "createdAt": "2020-02-11T17:15:09Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzk2Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777962", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(longitude, 180, value)\n          \n          \n            \n                  return validateDDLatLon(longitude, value, 180)", "author": "hayleynorton", "createdAt": "2020-02-11T17:15:32Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NTY2Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377785663", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n          \n          \n            \n                utmUpsNorthing === undefined || \n          \n          \n            \n                utmUpsEasting === undefined", "author": "hayleynorton", "createdAt": "2020-02-11T17:28:43Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377803239", "bodyText": "turns out we don't actually need to maintain state for the current value, so this can be removed", "author": "hayleynorton", "createdAt": "2020-02-11T18:01:30Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )", "originalCommit": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMjY1Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377832653", "bodyText": "actually, after further testing, I take that back \u261d\ufe0f\nIf I'm editing a polygon that starts with [[-97.438844,52.236694], and I delete up to the decimal of either of those values, JSON.parse throws an error when attempting to set the state of the location-old model and the model isn't set. currentValue is, however, because it's set with the plain string. So the value state is necessary to maintain intermediary values that don't parse into JSONs when manually editing. Line and Polygon are unique in this sense because of their structure", "author": "hayleynorton", "createdAt": "2020-02-11T18:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0ODQ0NA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379548444", "bodyText": "Eliminating the value state can be revisited now that the model is being set with invalid values", "author": "hayleynorton", "createdAt": "2020-02-14T17:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ=="}], "type": "inlineReview"}, {"oid": "6b6918c636c3a673913fe6da7595f9a4c40761a8", "url": "https://github.com/codice/ddf/commit/6b6918c636c3a673913fe6da7595f9a4c40761a8", "message": "DDF-5793 address comments and move dms validation into validation file", "committedDate": "2020-02-11T18:03:22Z", "type": "commit"}, {"oid": "c0c29e4c4da856d792d79c77d379516665cee4c1", "url": "https://github.com/codice/ddf/commit/c0c29e4c4da856d792d79c77d379516665cee4c1", "message": "DDF-5793 rename", "committedDate": "2020-02-11T19:15:46Z", "type": "commit"}, {"oid": "0a1e42ba11a599cf7e2beea9d53a9be58c1e3c2f", "url": "https://github.com/codice/ddf/commit/0a1e42ba11a599cf7e2beea9d53a9be58c1e3c2f", "message": "DDF-5793 small refactors and string changes", "committedDate": "2020-02-11T19:55:39Z", "type": "commit"}, {"oid": "dbb71c6f784d8b3225a867dba4c2686236d6918b", "url": "https://github.com/codice/ddf/commit/dbb71c6f784d8b3225a867dba4c2686236d6918b", "message": "DDF-5793 formatting", "committedDate": "2020-02-11T19:56:46Z", "type": "commit"}, {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5", "url": "https://github.com/codice/ddf/commit/1cbe3ae229717f43a32b63c40b193cd6e33739c5", "message": "Apply suggestions from code review\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>", "committedDate": "2020-02-11T20:08:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTA3Mw==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875073", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LATITUDE, 90, value)\n          \n          \n            \n                  return validateDDLatLon(LATITUDE, value, 90)", "author": "hayleynorton", "createdAt": "2020-02-11T20:18:54Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)", "originalCommit": "1cbe3ae229717f43a32b63c40b193cd6e33739c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTYwNg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875606", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LONGITUDE, 180, value)\n          \n          \n            \n                  return validateDDLatLon(LONGITUDE, value, 180)", "author": "hayleynorton", "createdAt": "2020-02-11T20:20:01Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, 180, value)", "originalCommit": "1cbe3ae229717f43a32b63c40b193cd6e33739c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4eaa55e2bd48aa62ccfe1df9743bed4467ccad1e", "url": "https://github.com/codice/ddf/commit/4eaa55e2bd48aa62ccfe1df9743bed4467ccad1e", "message": "DDF-5793 make ErrorComponent", "committedDate": "2020-02-11T21:31:25Z", "type": "commit"}, {"oid": "c3f281688a16398afbe2caa3fc9cdbfb3b4a9f0e", "url": "https://github.com/codice/ddf/commit/c3f281688a16398afbe2caa3fc9cdbfb3b4a9f0e", "message": "DDF-5793 make ErrorComponent", "committedDate": "2020-02-11T21:33:02Z", "type": "commit"}, {"oid": "78aa93f9ddf10d47c3c7e57533c9931a4c8227bb", "url": "https://github.com/codice/ddf/commit/78aa93f9ddf10d47c3c7e57533c9931a4c8227bb", "message": "DDF-5793 errorstate fixes and move model logic out of content.js", "committedDate": "2020-02-11T21:43:58Z", "type": "commit"}, {"oid": "3c87f69d2c000de84cf09b17711ae2e31d46f267", "url": "https://github.com/codice/ddf/commit/3c87f69d2c000de84cf09b17711ae2e31d46f267", "message": "Apply suggestions from code review\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>", "committedDate": "2020-02-11T21:47:15Z", "type": "commit"}, {"oid": "83b014fb4c46cf8306113c2888f69e3f4e999b16", "url": "https://github.com/codice/ddf/commit/83b014fb4c46cf8306113c2888f69e3f4e999b16", "message": "DDF-5793 suport multipolygon validation", "committedDate": "2020-02-11T22:47:56Z", "type": "commit"}, {"oid": "418b50ce3ebe9b09497f9d11d83c9ccca3569b9d", "url": "https://github.com/codice/ddf/commit/418b50ce3ebe9b09497f9d11d83c9ccca3569b9d", "message": "DDF-5793 explictly check for empty/undefined bbox", "committedDate": "2020-02-11T23:19:11Z", "type": "commit"}, {"oid": "b6ba413a9f606b6c99149d46f1bf59a834c0db56", "url": "https://github.com/codice/ddf/commit/b6ba413a9f606b6c99149d46f1bf59a834c0db56", "message": "DDF-5793 Merge branch 'DDF-5793-radius-ux-219' of github.com:cassandrabailey293/ddf into DDF-5793-radius-ux-219", "committedDate": "2020-02-12T15:30:46Z", "type": "commit"}, {"oid": "0ca72b69e218e778a0c6e25c6124fe9f1f3afb61", "url": "https://github.com/codice/ddf/commit/0ca72b69e218e778a0c6e25c6124fe9f1f3afb61", "message": "DDF-5793 change equality logic to account for message array", "committedDate": "2020-02-12T15:31:43Z", "type": "commit"}, {"oid": "8fca34e8929bda8989eb50b92bfbcd0ce59fcce2", "url": "https://github.com/codice/ddf/commit/8fca34e8929bda8989eb50b92bfbcd0ce59fcce2", "message": "DDF-5793 fix validation logic for line and radius width", "committedDate": "2020-02-12T15:47:17Z", "type": "commit"}, {"oid": "6ce1e431fd9d3452f78e60b07c9439b2d716a714", "url": "https://github.com/codice/ddf/commit/6ce1e431fd9d3452f78e60b07c9439b2d716a714", "message": "DDF-5793 refactor utm ups params", "committedDate": "2020-02-12T17:11:26Z", "type": "commit"}, {"oid": "ad5c7f47b8a0eb3b6ce65e09676e7ea8c0bb0fb4", "url": "https://github.com/codice/ddf/commit/ad5c7f47b8a0eb3b6ce65e09676e7ea8c0bb0fb4", "message": "DDF-5793 utmups validation refactor", "committedDate": "2020-02-12T18:01:38Z", "type": "commit"}, {"oid": "6e20740178ca264a9bf7b97099eb93e74f315d87", "url": "https://github.com/codice/ddf/commit/6e20740178ca264a9bf7b97099eb93e74f315d87", "message": "DDF-5793 add accidentally deleted function back and protect against negative values", "committedDate": "2020-02-12T18:10:14Z", "type": "commit"}, {"oid": "453380bdba970a6c6ee66a9a5bfe91d1b1e479c3", "url": "https://github.com/codice/ddf/commit/453380bdba970a6c6ee66a9a5bfe91d1b1e479c3", "message": "DDF-5793 formatting", "committedDate": "2020-02-12T18:34:33Z", "type": "commit"}, {"oid": "e2fb8a0b04b74e41438df08c895f5e54ead426e5", "url": "https://github.com/codice/ddf/commit/e2fb8a0b04b74e41438df08c895f5e54ead426e5", "message": "DDF-5793 default linewidth and allow invalid values in model to do proper validation", "committedDate": "2020-02-12T22:04:10Z", "type": "commit"}, {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4", "url": "https://github.com/codice/ddf/commit/7869c022fc1f53cc403556db3270b1cd78a0acd4", "message": "DDF-5793 move geo filter check earlier to fix non geo searches", "committedDate": "2020-02-13T00:28:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959209", "bodyText": "\u2753 do we want to correct possible negative inputs here?", "author": "hayleynorton", "createdAt": "2020-02-13T16:07:47Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {", "originalCommit": "7869c022fc1f53cc403556db3270b1cd78a0acd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODk4NA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379108984", "bodyText": "i think the solution here is to set a minimum on these text fields for both radius and buffer width - ill go ahead and do that", "author": "cassandrabailey293", "createdAt": "2020-02-13T20:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MjM1Mg==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379142352", "bodyText": "\ud83d\udc4d", "author": "hayleynorton", "createdAt": "2020-02-13T21:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTQ1NQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959455", "bodyText": "Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          // do nothing\n          \n          \n            \n                          // Set state with invalid value to trigger error messaging", "author": "hayleynorton", "createdAt": "2020-02-13T16:08:11Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })\n+              } else {\n+                setState({ [geometryKey]: JSON.parse(value) })\n+              }\n+            } catch (e) {\n+              // do nothing", "originalCommit": "7869c022fc1f53cc403556db3270b1cd78a0acd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4Mjc4OQ==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378982789", "bodyText": "\u270f\ufe0f just to match the label of the text field\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n          \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer width' : 'Radius '", "author": "hayleynorton", "createdAt": "2020-02-13T16:44:24Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,445 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}\n+\n+function validateDDLatLon(label: string, value: string, defaultCoord: number) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === LATITUDE ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  const dmsValidation = validateDmsInput(value, validator)\n+  if (dmsValidation.error) {\n+    defaultValue = dmsValidation.defaultValue\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(key: string, value: any) {\n+  let { utmUpsEasting, utmUpsNorthing, zoneNumber, hemisphere } = value\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  const isUps = zoneNumber === 0\n+  let error = { error: false, message: '' }\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  const isNorthingInvalid = isNaN(northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid = isNaN(easting) && utmUpsEasting !== undefined\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    utmUpsEasting !== undefined &&\n+    !isNorthingInvalid\n+  ) {\n+    return { error: true, message: 'Easting value is invalid' }\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+    northing =\n+      isUps || northernHemisphere ? northing : northing - NORTHING_OFFSET\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    utmUpsNorthing !== undefined &&\n+    !isEastingInvalid\n+  ) {\n+    return { error: true, message: 'Northing value is invalid' }\n+  }\n+  if (isUps && (!upsValidDistance(northing) || !upsValidDistance(easting))) {\n+    return { error: true, message: 'Invalid UPS distance' }\n+  }\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    utmUpsNorthing === undefined ||\n+    utmUpsEasting === undefined\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    return { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '", "originalCommit": "7869c022fc1f53cc403556db3270b1cd78a0acd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0d37cd5a18c4222c764bbca3ee332064d79b8ab", "url": "https://github.com/codice/ddf/commit/d0d37cd5a18c4222c764bbca3ee332064d79b8ab", "message": "DDF-5793 fix validation for line and polygon", "committedDate": "2020-02-13T18:15:29Z", "type": "commit"}, {"oid": "3ba685089da419b6aa2aecf2d7cc1a17ec7380e9", "url": "https://github.com/codice/ddf/commit/3ba685089da419b6aa2aecf2d7cc1a17ec7380e9", "message": "DDF-5793 allow undefined for dms", "committedDate": "2020-02-13T19:33:19Z", "type": "commit"}, {"oid": "3f3059bc7d31f3ad3e60d69636d856b0ab3c26b9", "url": "https://github.com/codice/ddf/commit/3f3059bc7d31f3ad3e60d69636d856b0ab3c26b9", "message": "DDF-5793 fix typo", "committedDate": "2020-02-13T19:51:06Z", "type": "commit"}, {"oid": "df22a1f466fb25f096c416eae40d1508289f7038", "url": "https://github.com/codice/ddf/commit/df22a1f466fb25f096c416eae40d1508289f7038", "message": "DDF-5793 usng allow undefined", "committedDate": "2020-02-13T20:05:28Z", "type": "commit"}, {"oid": "822082b1164f1574d78d7b9b3837603bd7e6250e", "url": "https://github.com/codice/ddf/commit/822082b1164f1574d78d7b9b3837603bd7e6250e", "message": "DDF-5793 only set default buffer width for line", "committedDate": "2020-02-13T20:39:41Z", "type": "commit"}, {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5", "url": "https://github.com/codice/ddf/commit/a3e38d57c2fa20caef917599a5833cea3d52eca5", "message": "DDF-5793 fix input to validate geo", "committedDate": "2020-02-13T20:47:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNTEyOA==", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379115128", "bodyText": "\u2757\ufe0f with polygon here, the error is true for lines with 3 or less points because A minimum of 4 points needed for polygon and the shape won't be drawn on the map\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {\n          \n          \n            \n                if (polygon !== undefined && !validateGeo('line', JSON.stringify(polygon.getCoordinates())).error) {", "author": "hayleynorton", "createdAt": "2020-02-13T20:59:19Z", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js", "diffHunk": "@@ -97,14 +98,14 @@ Draw.LineView = Marionette.View.extend({\n   updatePrimitive(model) {\n     const polygon = this.modelToPolygon(model)\n     // make sure the current model has width and height before drawing\n-    if (polygon && !_.isUndefined(polygon)) {\n+    if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {", "originalCommit": "a3e38d57c2fa20caef917599a5833cea3d52eca5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}