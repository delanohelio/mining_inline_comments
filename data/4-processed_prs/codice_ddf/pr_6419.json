{"pr_number": 6419, "pr_title": "[2.26.x] DDF-4729 adds WFS 1.1.0 sorting", "pr_createdAt": "2020-11-11T21:34:45Z", "pr_url": "https://github.com/codice/ddf/pull/6419", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MjQ5Nw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521652497", "bodyText": "Note: I thought it most appropriate to fail the query if the sort property can't be mapped.  GeoServer fails any query with a SortBy property that it doesn't know about.", "author": "jlcsmith", "createdAt": "2020-11-11T21:36:01Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {\n+            if (query.getSortBy() != null) {\n+              SortByType sortByType = buildSortBy(filterDelegateEntry.getKey(), query.getSortBy());\n+              if (sortByType != null\n+                  && sortByType.getSortProperty() != null\n+                  && sortByType.getSortProperty().size() > 0) {\n+                LOGGER.debug(\n+                    \"Sorting using sort property [{}] and sort order [{}].\",\n+                    sortByType.getSortProperty().get(0).getPropertyName(),\n+                    sortByType.getSortProperty().get(0).getSortOrder());\n+                wfsQuery.setSortBy(sortByType);\n+              } else {\n+                throw new UnsupportedQueryException(", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDAxMw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654013", "bodyText": "this was a small improvement I wanted to slip into this PR.  Empty string values shouldn't be considered invalid in a query.", "author": "jlcsmith", "createdAt": "2020-11-11T21:38:40Z", "path": "catalog/spatial/wfs/2.0.0/spatial-wfs-v2_0_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v2_0_0/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -1172,9 +1172,7 @@ private TimeInstantType createTimeInstantType(String type, String date) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    if (literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString())) {\n+    if (literal == null || StringUtils.isEmpty(propertyName)) {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654291", "bodyText": "this was a small improvement I wanted to slip into this PR. Empty string values shouldn't be considered invalid in a query.", "author": "jlcsmith", "createdAt": "2020-11-11T21:39:06Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -764,9 +764,7 @@ private FeatureIdType createFeatureIdFilter(final String id) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    return !(literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString()));\n+    return !(literal == null || StringUtils.isEmpty(propertyName));", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNTk1Mw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522315953", "bodyText": "Consider adding a unit test for this change.", "author": "jrnorth", "createdAt": "2020-11-12T18:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNzAwMg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522237002", "bodyText": "\u2753 How common is it for a WFS server to not support sorting? Since we're recommending unchecking this where possible, I wonder if it should default to false.", "author": "SmithJosh", "createdAt": "2020-11-12T16:24:08Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/resources/OSGI-INF/metatype/metatype.xml", "diffHunk": "@@ -88,6 +88,9 @@\n           name=\"Single-Character Wildcard Character\" id=\"singleChar\" required=\"false\" type=\"Char\" default=\"?\"/>\n         <AD description=\"Escape character to use in PropertyIsLike filters.\"\n           name=\"Escape Character\" id=\"escapeChar\" required=\"false\" type=\"Char\" default=\"\\\\\"/>\n+        <AD description=\"When selected, the system will not specify sort criteria with the query.  This should only be used if the remote source is unable to handle sorting.\"\n+            name=\"Disable Sorting\" id=\"disableSorting\" required=\"true\"\n+            type=\"Boolean\" default=\"true\"/>", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwMjA5Nw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522302097", "bodyText": "I debated on this to be honest.  My thinking is that the existing behavior doesn't support sorting, and if sorting is enabled but the proper mapping isn't set up (which is specific to each WFS source), queries are going to fail.  GeoServer at least will fail any query with a sort property it doesn't know about.  For example, if you fail to map the \"created\" attribute OR there is no proper mapping, all queries with a \"created\" sort will simply fail.  So I figured it was safer to leave it disabled by default.", "author": "jlcsmith", "createdAt": "2020-11-12T17:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNzAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3ODI5OA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522278298", "bodyText": "\u270f\ufe0f Suggestion: wrap these lines in a LOGGER.isDebugEnabled check", "author": "SmithJosh", "createdAt": "2020-11-12T17:19:51Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4OTc0Nw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522289747", "bodyText": "\u270f\ufe0f These two conditionals can be combined to reduce nesting:\nif (!disableSorting && query.getSortBy() != null) {", "author": "jrnorth", "createdAt": "2020-11-12T17:35:03Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDUxMA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522294510", "bodyText": "\u270f\ufe0f I find these kinds of configurations easier to understand when they're stated in terms of whether something is enabled rather than disabled.", "author": "jrnorth", "createdAt": "2020-11-12T17:41:56Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -248,6 +254,9 @@\n \n   private static final String FEATURE_MEMBER_ELEMENT = \"featureMember\";\n \n+  private static final String DISABLE_SORTING = \"disableSorting\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NzQ0NQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522387445", "bodyText": "I agree although I was trying to be consistent with the WFS 2.0 source config", "author": "jlcsmith", "createdAt": "2020-11-12T20:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NzYwMw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522297603", "bodyText": "\u270f\ufe0f Looks like this will fail checkstyle", "author": "jrnorth", "createdAt": "2020-11-12T17:46:47Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -1041,18 +1114,18 @@ private String handleClientException(Exception ce) {\n \n   private void logMessage(GetFeatureType getFeature) {\n     if (LOGGER.isDebugEnabled()) {\n-      try {\n-        StringWriter writer = new StringWriter();\n-        JAXBContext contextObj = JAXBContext.newInstance(GetFeatureType.class);\n+    try {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNjExNg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522306116", "bodyText": "\u270f\ufe0f All three: PROPERTY instead of PROEPRTY", "author": "jrnorth", "createdAt": "2020-11-12T17:59:52Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -235,6 +239,12 @@\n \n   private static final String LITERAL = \"literal\";\n \n+  private static final String MOCK_TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwODg4Mg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522308882", "bodyText": "Don't need a captor for this test (or for any of the following tests that expect an exception).", "author": "jrnorth", "createdAt": "2020-11-12T18:04:10Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwMjczNA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522402734", "bodyText": "looks like something I missed.  Cleaning it up", "author": "jlcsmith", "createdAt": "2020-11-12T20:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTcyNA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311724", "bodyText": "distanceSortProperty", "author": "jrnorth", "createdAt": "2020-11-12T18:08:55Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTgzMg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311832", "bodyText": "relevanceSortProperty", "author": "jrnorth", "createdAt": "2020-11-12T18:09:07Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);\n+    metacardMapper.setSortByRelevanceFeatureProperty(distanceSortProperty);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNDQ4MA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522314480", "bodyText": "\u270f\ufe0f Assertions on collection size should use the hasSize() matcher for more useful messages when the test fails.", "author": "jrnorth", "createdAt": "2020-11-12T18:12:57Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzYyMQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522317621", "bodyText": "\u270f\ufe0f proeprty -> property", "author": "jrnorth", "createdAt": "2020-11-12T18:18:05Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMjQ0NQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522322445", "bodyText": "\u270f\ufe0f Looks like a switch statement would be appropriate here.", "author": "jrnorth", "createdAt": "2020-11-12T18:25:51Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMzc0MQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522323741", "bodyText": "\u270f\ufe0f mappedPropertyName = StringUtils.defaultIfBlank(metacardToFeaturePropertyMapper.getSortByTemporalFeatureProperty(), null);", "author": "jrnorth", "createdAt": "2020-11-12T18:27:55Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)\n+          || org.apache.commons.lang.StringUtils.equals(Metacard.EFFECTIVE, incomingPropertyName)) {\n+        mappedPropertyName =", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTAxNg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522325016", "bodyText": "\u270f\ufe0f Same here. PROEPRTY -> PROPERTY", "author": "jrnorth", "createdAt": "2020-11-12T18:30:04Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package org.codice.ddf.spatial.ogc.wfs.catalog.common;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+\n+import ddf.catalog.data.ContentType;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResourceResponse;\n+import ddf.catalog.operation.SourceResponse;\n+import ddf.catalog.resource.ResourceNotFoundException;\n+import ddf.catalog.resource.ResourceNotSupportedException;\n+import ddf.catalog.source.SourceMonitor;\n+import ddf.catalog.source.UnsupportedQueryException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.namespace.QName;\n+import org.codice.ddf.spatial.ogc.wfs.catalog.mapper.MetacardMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AbstractWfsSourceTest {\n+  private AbstractWfsSource wfsSource;\n+  private static final String FEATURE_NAME = \"SampleFeature\";\n+  private static final String TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "url": "https://github.com/codice/ddf/commit/4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "message": "DDF-4729 adds WFS 1.1.0 sorting\n\n- adds flag to enable/disable sorting\n- adds mapping of DDF sort attributes to WFS attributes", "committedDate": "2020-11-12T20:59:34Z", "type": "commit"}, {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "message": "code cleanup", "committedDate": "2020-11-12T20:59:34Z", "type": "commit"}, {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "message": "code cleanup", "committedDate": "2020-11-12T20:59:34Z", "type": "forcePushed"}]}