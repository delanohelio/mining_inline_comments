{"pr_number": 856, "pr_title": "Implement \"before application start\" hooks", "pr_createdAt": "2020-05-14T14:33:02Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856", "timeline": [{"oid": "a50f3e4349b8d2a9b0b693e16a9e6f3874f2c977", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/a50f3e4349b8d2a9b0b693e16a9e6f3874f2c977", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-15T06:50:43Z", "type": "forcePushed"}, {"oid": "4aa982cc396b3ab0cd172d185e390e6ceee3a542", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/4aa982cc396b3ab0cd172d185e390e6ceee3a542", "message": "Implement \"before-application-start\" hooks", "committedDate": "2020-05-15T08:32:06Z", "type": "forcePushed"}, {"oid": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "message": "Add tests for before-application-hooks", "committedDate": "2020-05-15T09:15:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTgwMA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425685800", "bodyText": "Why do we need this and how does it help us?", "author": "enchobelezirev", "createdAt": "2020-05-15T09:39:10Z", "path": "com.sap.cloud.lm.sl.cf.core/src/main/java/com/sap/cloud/lm/sl/cf/core/model/Phase.java", "diffHunk": "@@ -1,5 +1,5 @@\n package com.sap.cloud.lm.sl.cf.core.model;\n \n public enum Phase {\n-    UNDEPLOY\n+    UNDEPLOY, RESUME", "originalCommit": "ae6ee33596371131b90e611a1e74f797a8567823", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzE5MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073190", "bodyText": "To determine whether the deployment is after the resume phase so the correct phase could be returned.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NjA1Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425686053", "bodyText": "if the resume phase is necessary, merge this commit with the previous one.", "author": "enchobelezirev", "createdAt": "2020-05-15T09:39:41Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/listeners/SetResumePhaseListenerTest.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.sap.cloud.lm.sl.cf.process.listeners;", "originalCommit": "ce0e571ef3be59b6df4918a0c35040b328e924cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4Nzg1Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425687853", "bodyText": "This is extracted from SyncFlowableStepWithHooks, right?", "author": "enchobelezirev", "createdAt": "2020-05-15T09:43:03Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {", "originalCommit": "fb85299c72dc1d91d349a37277bea7378255a5a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzIzMQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073231", "bodyText": "yes", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4Nzg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MDM0Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428050347", "bodyText": "I would try to make it @ Immutable", "author": "enchobelezirev", "createdAt": "2020-05-20T14:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4Nzg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MTA3Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428681072", "bodyText": "I do not like this Helper pattern because it is \"\u0441\u0431\u0438\u0440\u0449\u0430\u0439\u043d\" of different logics which are combined in a class and each of each logic has noting in common with the other ones. Maybe it would be great if we could extract these separate logics into different classes and check what will be result?", "author": "enchobelezirev", "createdAt": "2020-05-21T14:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4Nzg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4ODk5Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425688992", "bodyText": "Instead of using Supplier, I would suggest making two different interfaces:\n\nBeforeHookPhaseProvider\nAfterHookPhaseProvider\nThese two interfaces will be implemented by each step which requires to have hooks. Each step will implement either both or one of the interfaces based on the way what is required.", "author": "enchobelezirev", "createdAt": "2020-05-15T09:45:12Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepWithHooks.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+\n+public interface StepWithHooks {\n+\n+    default HookPhase getHookPhaseBeforeStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HookPhase getHookPhaseAfterStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HooksHelper.Builder getDefaultHooksHelperBuilder(ProcessContext context) {\n+        return new HooksHelper.Builder().withContext(context)\n+                                        .withHooksBeforeStep(() -> getHookPhaseBeforeStep(context))", "originalCommit": "fb85299c72dc1d91d349a37277bea7378255a5a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MjMwNA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425692304", "bodyText": "Something more, it will be tricky how the SyncFlowableStepWithHooks will handle the providers. It would be better if it is doing more abstract work and somehow not be related with the step. For instance, SyncFlowableStepWithHooks should be converted to some HookProcessor(or similar) and to use the new interfaces in order to aggregate the hooks.\nIf we manage to do this, the StopAppStep will look like this:\nStopAppStep extends TimeoutAsyncFlowableStep implements AffterHookPhaseProvider...", "author": "enchobelezirev", "createdAt": "2020-05-15T09:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4ODk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzI1MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073250", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4ODk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDEzOA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425690138", "bodyText": "I do not get this. Why is this needed?\nIt was put in the previous interface because the SyncFlowableStepWithHooks was extending the SyncFlowableStep and there was no way to use the same method name(executeStep).\nPlease, revise this.", "author": "enchobelezirev", "createdAt": "2020-05-15T09:47:23Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepWithHooks.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+\n+public interface StepWithHooks {\n+\n+    default HookPhase getHookPhaseBeforeStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HookPhase getHookPhaseAfterStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HooksHelper.Builder getDefaultHooksHelperBuilder(ProcessContext context) {\n+        return new HooksHelper.Builder().withContext(context)\n+                                        .withHooksBeforeStep(() -> getHookPhaseBeforeStep(context))\n+                                        .withHooksAfterStep(() -> getHookPhaseAfterStep(context));\n+    }\n+\n+    StepPhase executeStepInternal(ProcessContext context);", "originalCommit": "fb85299c72dc1d91d349a37277bea7378255a5a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDM3MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425690370", "bodyText": "Maybe extract this in BeforeHookPhaseProvider class. Check below comment.", "author": "enchobelezirev", "createdAt": "2020-05-15T09:47:49Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepWithHooks.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+\n+public interface StepWithHooks {\n+\n+    default HookPhase getHookPhaseBeforeStep(ProcessContext context) {", "originalCommit": "fb85299c72dc1d91d349a37277bea7378255a5a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMzUzMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425713532", "bodyText": "Actually, this is ATER_RESUME :)", "author": "enchobelezirev", "createdAt": "2020-05-15T10:33:02Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStep.java", "diffHunk": "@@ -81,6 +87,19 @@ private StartingInfo startApp(CloudControllerClient client, CloudApplication app\n         return client.startApplication(app.getName());\r\n     }\r\n \r\n+    @Override\r\n+    public HookPhase getHookPhaseBeforeStep(ProcessContext context) {\r\n+        ProcessType processType = processTypeParser.getProcessType(context.getExecution());\r\n+        if (ProcessType.BLUE_GREEN_DEPLOY.getName()\r\n+                                         .equals(processType.getName())) {\r\n+            if (context.getVariable(Variables.PHASE) == Phase.RESUME) {\r", "originalCommit": "833171bbacdf5e2f75944bdaeb8ede85b4c6b4b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMzk1MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425713951", "bodyText": "Merge this commit with the previous one.", "author": "enchobelezirev", "createdAt": "2020-05-15T10:33:56Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStepTest.java", "diffHunk": "@@ -4,26 +4,41 @@\n \r", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4ODc2MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425688760", "bodyText": "Can ProcessType.equals() be used here?\nComparing the names explicitly seems a bit redundant", "author": "radito3", "createdAt": "2020-05-15T09:44:47Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStep.java", "diffHunk": "@@ -81,6 +87,19 @@ private StartingInfo startApp(CloudControllerClient client, CloudApplication app\n         return client.startApplication(app.getName());\r\n     }\r\n \r\n+    @Override\r\n+    public HookPhase getHookPhaseBeforeStep(ProcessContext context) {\r\n+        ProcessType processType = processTypeParser.getProcessType(context.getExecution());\r\n+        if (ProcessType.BLUE_GREEN_DEPLOY.getName()\r", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDUwMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425690503", "bodyText": "Since this hook phase is only used here and the other 2 that can be returned from this method are the same, change the method like this\nif (BLUE_GREEN_DEPLOY.equals(processType) && getVariable(PHASE) != RESUME) {\n    return Before_start_Idle;\n}\nreturn Before_start_live", "author": "radito3", "createdAt": "2020-05-15T09:48:03Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStep.java", "diffHunk": "@@ -81,6 +87,19 @@ private StartingInfo startApp(CloudControllerClient client, CloudApplication app\n         return client.startApplication(app.getName());\r\n     }\r\n \r\n+    @Override\r\n+    public HookPhase getHookPhaseBeforeStep(ProcessContext context) {\r\n+        ProcessType processType = processTypeParser.getProcessType(context.getExecution());\r\n+        if (ProcessType.BLUE_GREEN_DEPLOY.getName()\r\n+                                         .equals(processType.getName())) {\r\n+            if (context.getVariable(Variables.PHASE) == Phase.RESUME) {\r\n+                return HookPhase.APPLICATION_BEFORE_START_LIVE;\r\n+            }\r\n+            return HookPhase.APPLICATION_BEFORE_START_IDLE;\r", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MTc3MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425691771", "bodyText": "Can we use the new Variable mechanism instead of this old one?", "author": "radito3", "createdAt": "2020-05-15T09:50:35Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepsUtil.java", "diffHunk": "@@ -220,11 +219,11 @@ public static boolean getIsServiceUpdatedExportedVariable(VariableScope scope, S\n         return getBoolean(scope, Constants.VAR_IS_SERVICE_UPDATED_VAR_PREFIX + serviceName, false);\r\n     }\r\n \r\n-    static void setExecutedHooksForModule(VariableScope scope, String moduleName, Map<String, List<String>> moduleHooks) {\r\n+    public static void setExecutedHooksForModule(VariableScope scope, String moduleName, Map<String, List<String>> moduleHooks) {\r", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzYzMQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073631", "bodyText": "I don't think so because the name of the executed hooks is dynamically calculated from the module's name.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5OTA2MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425699061", "bodyText": "I think it would be better if there was a method for returning the hooks for this module, then, if that list isn't empty -> execute them and return the current phase.\nThe executeHooksForStepPhase is doing 2 things at the moment, executing the hooks and returning them", "author": "radito3", "createdAt": "2020-05-15T10:04:31Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/TimeoutAsyncFlowableStepWithHooks.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public abstract class TimeoutAsyncFlowableStepWithHooks extends TimeoutAsyncFlowableStep implements StepWithHooks {\n+\n+    @Inject\n+    private MtaMetadataParser mtaMetadataParser;\n+\n+    @Inject\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n+\n+    @Override\n+    public StepPhase executeAsyncStep(ProcessContext context) {\n+        HooksHelper hooksHelper = getHooksHelper(context);\n+        Module moduleToDeploy = hooksHelper.determineModuleToDeploy(context);\n+        StepPhase currentStepPhase = context.getVariable(Variables.STEP_PHASE);\n+        List<Hook> executedHooks = hooksHelper.executeHooksForStepPhase(moduleToDeploy, currentStepPhase);", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMTAwMQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425701001", "bodyText": "Why is both the Builder and the object it's creating mutable?\nI would prefer the HooksHelper object be immutable and have a private constructor", "author": "radito3", "createdAt": "2020-05-15T10:08:19Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private MtaMetadataParser mtaMetadataParser;\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n+    private ProcessContext context;\n+    private Supplier<HookPhase> hooksBeforeStepSupplier;\n+    private Supplier<HookPhase> hooksAfterStepSupplier;\n+\n+    public List<Hook> executeHooksForStepPhase(Module moduleToDeploy, StepPhase currentStepPhase) {\n+        HookPhase currentHookPhaseForExecution = determineHookPhaseForCurrentStepPhase(currentStepPhase);\n+        List<Hook> hooksForCurrentPhase = getHooksForCurrentPhase(moduleToDeploy, currentHookPhaseForExecution);\n+        context.setVariable(Variables.HOOKS_FOR_EXECUTION, hooksForCurrentPhase);\n+        return hooksForCurrentPhase;\n+    }\n+\n+    public Module determineModuleToDeploy(ProcessContext context) {\n+        Module moduleToDeploy = context.getVariable(Variables.MODULE_TO_DEPLOY);\n+        return moduleToDeploy != null ? moduleToDeploy : determineModuleFromDescriptor(context);\n+    }\n+\n+    private Module determineModuleFromDescriptor(ProcessContext context) {\n+        DeploymentDescriptor deploymentDescriptor = context.getVariable(Variables.COMPLETE_DEPLOYMENT_DESCRIPTOR);\n+        if (deploymentDescriptor == null) {\n+            // This will be the case only when the process is undeploy.\n+            return null;\n+        }\n+\n+        CloudApplicationExtended cloudApplication = context.getVariable(Variables.APP_TO_PROCESS);\n+        if (cloudApplication.getModuleName() == null) {\n+            // This case handles the deletion of old applications when the process is blue-green deployment. Here the application is taken\n+            // from the\n+            // CloudController and thus we do not have moduleName in it.\n+            return determineModuleFromAppName(deploymentDescriptor, cloudApplication);\n+        }\n+\n+        HandlerFactory handlerFactory = StepsUtil.getHandlerFactory(context.getExecution());\n+        return findModuleByNameFromDeploymentDescriptor(handlerFactory, deploymentDescriptor, cloudApplication.getModuleName());\n+    }\n+\n+    private Module determineModuleFromAppName(DeploymentDescriptor deploymentDescriptor, CloudApplicationExtended cloudApplication) {\n+        String moduleNameFromApplicationEnvironment = getModuleName(cloudApplication);\n+        if (moduleNameFromApplicationEnvironment == null) {\n+            return null;\n+        }\n+        return deploymentDescriptor.getModules()\n+                                   .stream()\n+                                   .filter(module -> moduleNameFromApplicationEnvironment.equals(module.getName()))\n+                                   .findFirst()\n+                                   .orElse(null);\n+    }\n+\n+    protected String getModuleName(CloudApplicationExtended cloudApplication) {\n+        return getDeployedMtaApplication(cloudApplication).getModuleName();\n+    }\n+\n+    private DeployedMtaApplication getDeployedMtaApplication(CloudApplication app) {\n+        if (!MtaMetadataUtil.hasMtaMetadata(app)) {\n+            return envMtaMetadataParser.parseDeployedMtaApplication(app);\n+        }\n+        return mtaMetadataParser.parseDeployedMtaApplication(app);\n+    }\n+\n+    private Module findModuleByNameFromDeploymentDescriptor(HandlerFactory handlerFactory, DeploymentDescriptor deploymentDescriptor,\n+                                                            String moduleName) {\n+        return handlerFactory.getDescriptorHandler()\n+                             .findModule(deploymentDescriptor, moduleName);\n+    }\n+\n+    public List<Hook> getHooksForCurrentPhase(Module moduleToDeploy, HookPhase currentHookPhaseForExecution) {\n+        return getModuleHooksAggregator(moduleToDeploy).aggregateHooks(currentHookPhaseForExecution);\n+    }\n+\n+    protected ModuleHooksAggregator getModuleHooksAggregator(Module moduleToDeploy) {\n+        return new ModuleHooksAggregator(context.getExecution(), moduleToDeploy);\n+    }\n+\n+    private HookPhase determineHookPhaseForCurrentStepPhase(StepPhase currentStepPhase) {\n+        if (isInPreExecuteStepPhase(currentStepPhase)) {\n+            return hooksBeforeStepSupplier.get();\n+        }\n+        if (isInPostExecuteStepPhase(currentStepPhase)) {\n+            return hooksAfterStepSupplier.get();\n+        }\n+        return HookPhase.NONE;\n+    }\n+\n+    private boolean isInPreExecuteStepPhase(StepPhase currentStepPhase) {\n+        return currentStepPhase == StepPhase.EXECUTE || currentStepPhase == StepPhase.RETRY;\n+    }\n+\n+    public boolean isInPostExecuteStepPhase(StepPhase currentStepPhase) {\n+        return currentStepPhase == StepPhase.DONE;\n+    }\n+\n+    public void setMtaMetadataParser(MtaMetadataParser mtaMetadataParser) {\n+        this.mtaMetadataParser = mtaMetadataParser;\n+    }\n+\n+    public void setEnvMtaMetadataParser(EnvMtaMetadataParser envMtaMetadataParser) {\n+        this.envMtaMetadataParser = envMtaMetadataParser;\n+    }\n+\n+    public void setContext(ProcessContext context) {\n+        this.context = context;\n+    }\n+\n+    public void setHooksBeforeStepSupplier(Supplier<HookPhase> hooksBeforeStepSupplier) {\n+        this.hooksBeforeStepSupplier = hooksBeforeStepSupplier;\n+    }\n+\n+    public void setHooksAfterStepSupplier(Supplier<HookPhase> hooksAfterStepSupplier) {\n+        this.hooksAfterStepSupplier = hooksAfterStepSupplier;\n+    }\n+\n+    public static class Builder {\n+        private final HooksHelper hooksHelper = new HooksHelper();", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMTQ4MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425701481", "bodyText": "Why Suppliers and not regular objects?", "author": "radito3", "createdAt": "2020-05-15T10:09:16Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private MtaMetadataParser mtaMetadataParser;\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n+    private ProcessContext context;\n+    private Supplier<HookPhase> hooksBeforeStepSupplier;", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMTk3MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425701970", "bodyText": "Is the suffix from application environment necessary?", "author": "radito3", "createdAt": "2020-05-15T10:10:10Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private MtaMetadataParser mtaMetadataParser;\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n+    private ProcessContext context;\n+    private Supplier<HookPhase> hooksBeforeStepSupplier;\n+    private Supplier<HookPhase> hooksAfterStepSupplier;\n+\n+    public List<Hook> executeHooksForStepPhase(Module moduleToDeploy, StepPhase currentStepPhase) {\n+        HookPhase currentHookPhaseForExecution = determineHookPhaseForCurrentStepPhase(currentStepPhase);\n+        List<Hook> hooksForCurrentPhase = getHooksForCurrentPhase(moduleToDeploy, currentHookPhaseForExecution);\n+        context.setVariable(Variables.HOOKS_FOR_EXECUTION, hooksForCurrentPhase);\n+        return hooksForCurrentPhase;\n+    }\n+\n+    public Module determineModuleToDeploy(ProcessContext context) {\n+        Module moduleToDeploy = context.getVariable(Variables.MODULE_TO_DEPLOY);\n+        return moduleToDeploy != null ? moduleToDeploy : determineModuleFromDescriptor(context);\n+    }\n+\n+    private Module determineModuleFromDescriptor(ProcessContext context) {\n+        DeploymentDescriptor deploymentDescriptor = context.getVariable(Variables.COMPLETE_DEPLOYMENT_DESCRIPTOR);\n+        if (deploymentDescriptor == null) {\n+            // This will be the case only when the process is undeploy.\n+            return null;\n+        }\n+\n+        CloudApplicationExtended cloudApplication = context.getVariable(Variables.APP_TO_PROCESS);\n+        if (cloudApplication.getModuleName() == null) {\n+            // This case handles the deletion of old applications when the process is blue-green deployment. Here the application is taken\n+            // from the\n+            // CloudController and thus we do not have moduleName in it.\n+            return determineModuleFromAppName(deploymentDescriptor, cloudApplication);\n+        }\n+\n+        HandlerFactory handlerFactory = StepsUtil.getHandlerFactory(context.getExecution());\n+        return findModuleByNameFromDeploymentDescriptor(handlerFactory, deploymentDescriptor, cloudApplication.getModuleName());\n+    }\n+\n+    private Module determineModuleFromAppName(DeploymentDescriptor deploymentDescriptor, CloudApplicationExtended cloudApplication) {\n+        String moduleNameFromApplicationEnvironment = getModuleName(cloudApplication);", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNTQ5NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425705494", "bodyText": "The Hook object can only be created when the major schema version is 3, so this check seems a bit redundant", "author": "radito3", "createdAt": "2020-05-15T10:17:13Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzY1OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073658", "bodyText": "If the Major Schema Version is less than 3 an exception will be thrown while trying to invoke module.getHooks().", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwNTQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxNDA2MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425714061", "bodyText": "Isn't this always going to be a one-element list?\nThe only way it won't be is if there are repeating HookPhases of the same type?\nDo we support that by our specification?", "author": "radito3", "createdAt": "2020-05-15T10:34:09Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();\n+    }\n+\n+    private boolean shouldExecuteHook(List<String> hookPhases, HookPhase hookTypeForCurrentStepPhase) {\n+        List<HookPhase> resolvedHookPhases = mapToHookPhases(hookPhases);\n+        return resolvedHookPhases.contains(hookTypeForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> mapToHookPhases(List<String> hookPhases) {\n+        return hookPhases.stream()\n+                         .map(HookPhase::fromString)\n+                         .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                            HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> notExecutedHooks = getNonExecutedHooks(alreadyExecutedHooks, moduleHooksToBeExecuted);\n+        List<Hook> hooksWithNonExecutedPhases = getHooksWithNonExecutedPhases(alreadyExecutedHooks, moduleHooksToBeExecuted,\n+                                                                              hookPhaseForCurrentStepPhase);\n+        return ListUtils.union(notExecutedHooks, hooksWithNonExecutedPhases);\n+    }\n+\n+    private List<Hook> getNonExecutedHooks(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hook -> !alreadyExecutedHooks.containsKey(hook.getName()))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksWithNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                                     HookPhase hookPhaseForCurrentStepPhase) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hookToBeExecuted -> alreadyExecutedHooks.containsKey(hookToBeExecuted.getName()))\n+                                      .filter(hookToBeExecuted -> !hasNonExecutedPhases(alreadyExecutedHooks, hookToBeExecuted,\n+                                                                                        hookPhaseForCurrentStepPhase))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private boolean hasNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, Hook hookToBeExecuted,\n+                                         HookPhase hookPhaseForCurrentStepPhase) {\n+        List<HookPhase> executedHookPhasesForHook = getExecutedHookPhasesForHook(alreadyExecutedHooks, hookToBeExecuted.getName());\n+        return executedHookPhasesForHook.contains(hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> getExecutedHookPhasesForHook(Map<String, List<String>> alreadyExecutedHooks, String hookName) {\n+        List<String> executedHookPhasesForHook = alreadyExecutedHooks.get(hookName);\n+        return mapToHookPhases(executedHookPhasesForHook);\n+    }\n+\n+    private void updateExecutedHooksForModule(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution,\n+                                              List<Hook> hooksForExecution) {\n+        Map<String, List<String>> result = new HashMap<>(alreadyExecutedHooks);\n+        updateExecutedHooks(result, currentHookPhaseForExecution, hooksForExecution);\n+        StepsUtil.setExecutedHooksForModule(execution, moduleToDeploy.getName(), result);\n+    }\n+\n+    private void updateExecutedHooks(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution,\n+                                     List<Hook> hooksForExecution) {\n+        for (Hook hook : hooksForExecution) {\n+            updateHook(alreadyExecutedHooks, currentHookPhaseForExecution, hook);\n+        }\n+    }\n+\n+    private void updateHook(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution, Hook hook) {\n+        List<String> hookPhasesBasedOnCurrentHookPhase = getHookPhasesBasedOnCurrentHookPhase(currentHookPhaseForExecution,\n+                                                                                              hook.getPhases());\n+        if (alreadyExecutedHooks.containsKey(hook.getName())) {\n+            alreadyExecutedHooks.get(hook.getName())\n+                                .addAll(hookPhasesBasedOnCurrentHookPhase);\n+            return;\n+        }\n+        alreadyExecutedHooks.put(hook.getName(), hookPhasesBasedOnCurrentHookPhase);\n+    }\n+\n+    private List<String> getHookPhasesBasedOnCurrentHookPhase(HookPhase currentHookPhaseForExecution, List<String> hookPhases) {", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzY3NA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073674", "bodyText": "As you have noticed its only one element unless there are repeating hooks. But this also covers the case that the hook will be executed only one time even though it has repeating phases. In my opinion, it's safer this way.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxNDA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyMzQ1MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425723451", "bodyText": "This can be replaced with\nalreadyExecutedHooks.merge(hook.getName(), hookPhasesBasedOnCurrentHookPhase, ListUtils::union);\nThis will insert the hooks list, if that hook isn't present, or, it will add them to the existing ones, otherwise", "author": "radito3", "createdAt": "2020-05-15T10:54:36Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();\n+    }\n+\n+    private boolean shouldExecuteHook(List<String> hookPhases, HookPhase hookTypeForCurrentStepPhase) {\n+        List<HookPhase> resolvedHookPhases = mapToHookPhases(hookPhases);\n+        return resolvedHookPhases.contains(hookTypeForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> mapToHookPhases(List<String> hookPhases) {\n+        return hookPhases.stream()\n+                         .map(HookPhase::fromString)\n+                         .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                            HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> notExecutedHooks = getNonExecutedHooks(alreadyExecutedHooks, moduleHooksToBeExecuted);\n+        List<Hook> hooksWithNonExecutedPhases = getHooksWithNonExecutedPhases(alreadyExecutedHooks, moduleHooksToBeExecuted,\n+                                                                              hookPhaseForCurrentStepPhase);\n+        return ListUtils.union(notExecutedHooks, hooksWithNonExecutedPhases);\n+    }\n+\n+    private List<Hook> getNonExecutedHooks(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hook -> !alreadyExecutedHooks.containsKey(hook.getName()))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksWithNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                                     HookPhase hookPhaseForCurrentStepPhase) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hookToBeExecuted -> alreadyExecutedHooks.containsKey(hookToBeExecuted.getName()))\n+                                      .filter(hookToBeExecuted -> !hasNonExecutedPhases(alreadyExecutedHooks, hookToBeExecuted,\n+                                                                                        hookPhaseForCurrentStepPhase))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private boolean hasNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, Hook hookToBeExecuted,\n+                                         HookPhase hookPhaseForCurrentStepPhase) {\n+        List<HookPhase> executedHookPhasesForHook = getExecutedHookPhasesForHook(alreadyExecutedHooks, hookToBeExecuted.getName());\n+        return executedHookPhasesForHook.contains(hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> getExecutedHookPhasesForHook(Map<String, List<String>> alreadyExecutedHooks, String hookName) {\n+        List<String> executedHookPhasesForHook = alreadyExecutedHooks.get(hookName);\n+        return mapToHookPhases(executedHookPhasesForHook);\n+    }\n+\n+    private void updateExecutedHooksForModule(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution,\n+                                              List<Hook> hooksForExecution) {\n+        Map<String, List<String>> result = new HashMap<>(alreadyExecutedHooks);\n+        updateExecutedHooks(result, currentHookPhaseForExecution, hooksForExecution);\n+        StepsUtil.setExecutedHooksForModule(execution, moduleToDeploy.getName(), result);\n+    }\n+\n+    private void updateExecutedHooks(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution,\n+                                     List<Hook> hooksForExecution) {\n+        for (Hook hook : hooksForExecution) {\n+            updateHook(alreadyExecutedHooks, currentHookPhaseForExecution, hook);\n+        }\n+    }\n+\n+    private void updateHook(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution, Hook hook) {\n+        List<String> hookPhasesBasedOnCurrentHookPhase = getHookPhasesBasedOnCurrentHookPhase(currentHookPhaseForExecution,\n+                                                                                              hook.getPhases());\n+        if (alreadyExecutedHooks.containsKey(hook.getName())) {", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNDk3OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425724978", "bodyText": "Why are you creating a new map?", "author": "radito3", "createdAt": "2020-05-15T10:57:42Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();\n+    }\n+\n+    private boolean shouldExecuteHook(List<String> hookPhases, HookPhase hookTypeForCurrentStepPhase) {\n+        List<HookPhase> resolvedHookPhases = mapToHookPhases(hookPhases);\n+        return resolvedHookPhases.contains(hookTypeForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> mapToHookPhases(List<String> hookPhases) {\n+        return hookPhases.stream()\n+                         .map(HookPhase::fromString)\n+                         .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                            HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> notExecutedHooks = getNonExecutedHooks(alreadyExecutedHooks, moduleHooksToBeExecuted);\n+        List<Hook> hooksWithNonExecutedPhases = getHooksWithNonExecutedPhases(alreadyExecutedHooks, moduleHooksToBeExecuted,\n+                                                                              hookPhaseForCurrentStepPhase);\n+        return ListUtils.union(notExecutedHooks, hooksWithNonExecutedPhases);\n+    }\n+\n+    private List<Hook> getNonExecutedHooks(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hook -> !alreadyExecutedHooks.containsKey(hook.getName()))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksWithNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                                     HookPhase hookPhaseForCurrentStepPhase) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hookToBeExecuted -> alreadyExecutedHooks.containsKey(hookToBeExecuted.getName()))\n+                                      .filter(hookToBeExecuted -> !hasNonExecutedPhases(alreadyExecutedHooks, hookToBeExecuted,\n+                                                                                        hookPhaseForCurrentStepPhase))\n+                                      .collect(Collectors.toList());\n+    }\n+\n+    private boolean hasNonExecutedPhases(Map<String, List<String>> alreadyExecutedHooks, Hook hookToBeExecuted,\n+                                         HookPhase hookPhaseForCurrentStepPhase) {\n+        List<HookPhase> executedHookPhasesForHook = getExecutedHookPhasesForHook(alreadyExecutedHooks, hookToBeExecuted.getName());\n+        return executedHookPhasesForHook.contains(hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> getExecutedHookPhasesForHook(Map<String, List<String>> alreadyExecutedHooks, String hookName) {\n+        List<String> executedHookPhasesForHook = alreadyExecutedHooks.get(hookName);\n+        return mapToHookPhases(executedHookPhasesForHook);\n+    }\n+\n+    private void updateExecutedHooksForModule(Map<String, List<String>> alreadyExecutedHooks, HookPhase currentHookPhaseForExecution,\n+                                              List<Hook> hooksForExecution) {\n+        Map<String, List<String>> result = new HashMap<>(alreadyExecutedHooks);", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3MzY5NQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427073695", "bodyText": "I extracted this code, but I think because it's an immutable map when its fetched from the process' context.", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T07:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNDk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyODQ5MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425728490", "bodyText": "This method can be done with one stream().filter().collect() chain.\n hook -> !alreadyExecutedHooks.containsKey(hook.getName()) || !hasNonExecutedPhases(alreadyExecutedHooks, hook, hookPhaseForCurrentStepPhase)\nThat way, there is no need for the following 2 methods", "author": "radito3", "createdAt": "2020-05-15T11:05:18Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();\n+    }\n+\n+    private boolean shouldExecuteHook(List<String> hookPhases, HookPhase hookTypeForCurrentStepPhase) {\n+        List<HookPhase> resolvedHookPhases = mapToHookPhases(hookPhases);\n+        return resolvedHookPhases.contains(hookTypeForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> mapToHookPhases(List<String> hookPhases) {\n+        return hookPhases.stream()\n+                         .map(HookPhase::fromString)\n+                         .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMTA4OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425731088", "bodyText": "SyncFlowableStepTest already does this. Remove it", "author": "radito3", "createdAt": "2020-05-15T11:11:02Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStepTest.java", "diffHunk": "@@ -4,26 +4,41 @@\n \r\n import org.cloudfoundry.client.lib.StartingInfo;\r\n import org.cloudfoundry.client.lib.domain.CloudApplication.State;\r\n-import org.junit.Before;\r\n-import org.junit.Test;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.mockito.Mock;\r\n import org.mockito.Mockito;\r\n+import org.mockito.MockitoAnnotations;\r\n \r\n import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\r\n import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudApplicationExtended;\r\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\r\n+import com.sap.cloud.lm.sl.cf.core.model.Phase;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ProcessTypeParser;\r\n import com.sap.cloud.lm.sl.cf.process.variables.Variables;\r\n+import com.sap.cloud.lm.sl.cf.web.api.model.ProcessType;\r\n import com.sap.cloud.lm.sl.common.util.JsonUtil;\r\n \r\n public class RestartAppStepTest extends SyncFlowableStepTest<RestartAppStep> {\r\n \r\n     private static final String APP_NAME = \"foo\";\r\n \r\n-    @Before\r\n+    @Mock\r\n+    private ProcessTypeParser processTypeParser;\r\n+\r\n+    public RestartAppStepTest() {\r\n+        MockitoAnnotations.initMocks(this);\r", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMTc3Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425731772", "bodyText": "Sonar would most probably complain that this isn't a static inner class", "author": "radito3", "createdAt": "2020-05-15T11:12:33Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/steps/TimeoutAsyncFlowableStepWithHooksTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+import com.sap.cloud.lm.sl.cf.process.mock.MockDelegateExecution;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+import com.sap.cloud.lm.sl.cf.process.util.StepLogger;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class TimeoutAsyncFlowableStepWithHooksTest {\n+\n+    private final HooksHelper mockedHooksHelper = Mockito.mock(HooksHelper.class);\n+    private final ProcessContext context = new ProcessContext(MockDelegateExecution.createSpyInstance(),\n+                                                              Mockito.mock(StepLogger.class),\n+                                                              null);\n+\n+    @Test\n+    public void testWithNoExecutedHooks() throws Exception {\n+        Module moduleToDeploy = createModule(\"test-module\");\n+        Mockito.when(mockedHooksHelper.determineModuleToDeploy(context))\n+               .thenReturn(moduleToDeploy);\n+        context.setVariable(Variables.STEP_PHASE, StepPhase.DONE);\n+        StepPhase stepPhase = createStep().executeStep(context);\n+        Assertions.assertEquals(StepPhase.DONE, stepPhase);\n+        Mockito.verify(mockedHooksHelper)\n+               .executeHooksForStepPhase(moduleToDeploy, StepPhase.DONE);\n+    }\n+\n+    @Test\n+    public void testWithAlreadyExecutedHooks() throws Exception {\n+        List<Hook> executedHooks = createHooks(\"hook1\", \"hook2\");\n+        context.setVariable(Variables.STEP_PHASE, StepPhase.DONE);\n+        Mockito.when(mockedHooksHelper.executeHooksForStepPhase(any(), any()))\n+               .thenReturn(executedHooks);\n+        Module moduleToDeploy = createModule(\"some-module\");\n+        Mockito.when(mockedHooksHelper.determineModuleToDeploy(context))\n+               .thenReturn(moduleToDeploy);\n+        StepPhase actualStepPhase = createStep().executeAsyncStep(context);\n+        Assertions.assertEquals(StepPhase.DONE, actualStepPhase);\n+        Mockito.verify(mockedHooksHelper)\n+               .executeHooksForStepPhase(moduleToDeploy, StepPhase.DONE);\n+    }\n+\n+    private Module createModule(String name) {\n+        return Module.createV3()\n+                     .setName(name);\n+    }\n+\n+    private List<Hook> createHooks(String... names) {\n+        return Arrays.stream(names)\n+                     .map(this::createHook)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private Hook createHook(String name) {\n+        return Hook.createV3()\n+                   .setName(name);\n+    }\n+\n+    private TimeoutAsyncFlowableStepWithHooks createStep() {\n+        return new TimeoutAsyncFlowableStepWithHooksMock();\n+    }\n+\n+    private class TimeoutAsyncFlowableStepWithHooksMock extends TimeoutAsyncFlowableStepWithHooks {", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczMjg3MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r425732870", "bodyText": "I didn't see this method ever being overridden.\nChange it to a static method", "author": "radito3", "createdAt": "2020-05-15T11:14:56Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StepWithHooks.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.util.HooksHelper;\n+\n+public interface StepWithHooks {\n+\n+    default HookPhase getHookPhaseBeforeStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HookPhase getHookPhaseAfterStep(ProcessContext context) {\n+        return HookPhase.NONE;\n+    }\n+\n+    default HooksHelper.Builder getDefaultHooksHelperBuilder(ProcessContext context) {", "originalCommit": "5ba5e8916b51354c2468ff6fa60a9eccec1f53c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9cca1de5a46f6b25cc3e6e94b125933e09003d10", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/9cca1de5a46f6b25cc3e6e94b125933e09003d10", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-19T06:47:26Z", "type": "forcePushed"}, {"oid": "dcf131315adb32a41862022b0c46f2ad49d2649e", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/dcf131315adb32a41862022b0c46f2ad49d2649e", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-19T07:53:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNjQ0OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427106448", "bodyText": "There is no need for the extra parenthesis around the second condition", "author": "radito3", "createdAt": "2020-05-19T08:03:52Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStep.java", "diffHunk": "@@ -81,6 +99,15 @@ private StartingInfo startApp(CloudControllerClient client, CloudApplication app\n         return client.startApplication(app.getName());\r\n     }\r\n \r\n+    @Override\r\n+    public HookPhase getHookPhaseBeforeStep(ProcessContext context) {\r\n+        ProcessType processType = processTypeParser.getProcessType(context.getExecution());\r\n+        if (ProcessType.BLUE_GREEN_DEPLOY.equals(processType) && (context.getVariable(Variables.PHASE) != Phase.AFTER_RESUME)) {\r", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzI2Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427107267", "bodyText": "This does the same as DescriptorHandler::findModule", "author": "radito3", "createdAt": "2020-05-19T08:05:16Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private final MtaMetadataParser mtaMetadataParser;\n+    private final EnvMtaMetadataParser envMtaMetadataParser;\n+    private final ProcessContext context;\n+    private final HookPhase hookPhaseBeforeStep;\n+    private final HookPhase hookPhaseAfterStep;\n+\n+    private HooksHelper(Builder hooksHelperBuilder) {\n+        this.mtaMetadataParser = hooksHelperBuilder.mtaMetadataParser;\n+        this.envMtaMetadataParser = hooksHelperBuilder.envMtaMetadataParser;\n+        this.context = hooksHelperBuilder.context;\n+        this.hookPhaseBeforeStep = hooksHelperBuilder.hookPhaseBeforeStep;\n+        this.hookPhaseAfterStep = hooksHelperBuilder.hookPhaseAfterStep;\n+    }\n+\n+    public List<Hook> getHooksForStepPhase(Module moduleToDeploy, StepPhase currentStepPhase) {\n+        HookPhase currentHookPhaseForExecution = determineHookPhaseForCurrentStepPhase(currentStepPhase);\n+        return getHooksForCurrentPhase(moduleToDeploy, currentHookPhaseForExecution);\n+    }\n+\n+    public Module determineModuleToDeploy(ProcessContext context) {\n+        Module moduleToDeploy = context.getVariable(Variables.MODULE_TO_DEPLOY);\n+        return moduleToDeploy != null ? moduleToDeploy : determineModuleFromDescriptor(context);\n+    }\n+\n+    public void setHooksForExecution(List<Hook> hooksForExecution) {\n+        context.setVariable(Variables.HOOKS_FOR_EXECUTION, hooksForExecution);\n+    }\n+\n+    private Module determineModuleFromDescriptor(ProcessContext context) {\n+        DeploymentDescriptor deploymentDescriptor = context.getVariable(Variables.COMPLETE_DEPLOYMENT_DESCRIPTOR);\n+        if (deploymentDescriptor == null) {\n+            // This will be the case only when the process is undeploy.\n+            return null;\n+        }\n+\n+        CloudApplicationExtended cloudApplication = context.getVariable(Variables.APP_TO_PROCESS);\n+        if (cloudApplication.getModuleName() == null) {\n+            // This case handles the deletion of old applications when the process is blue-green deployment. Here the application is taken\n+            // from the\n+            // CloudController and thus we do not have moduleName in it.\n+            return determineModuleFromAppName(deploymentDescriptor, cloudApplication);\n+        }\n+\n+        HandlerFactory handlerFactory = StepsUtil.getHandlerFactory(context.getExecution());\n+        return findModuleByNameFromDeploymentDescriptor(handlerFactory, deploymentDescriptor, cloudApplication.getModuleName());\n+    }\n+\n+    private Module determineModuleFromAppName(DeploymentDescriptor deploymentDescriptor, CloudApplicationExtended cloudApplication) {\n+        String moduleName = getModuleName(cloudApplication);\n+        if (moduleName == null) {\n+            return null;\n+        }\n+        return deploymentDescriptor.getModules()", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwODkyMw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427108923", "bodyText": "We can use this in the determineModuleFromAppName method as well, so move it above the second if condition.\nAlso, since that determine method does the same as the findModuleByNameFromDeploymentDescriptor method only with one more processing of the module name, we can refactor this method so as to \"determine\" the module name that needs checking in the if statement (whether it's directly from the cloud application object, or after mta metadata / env parsing) and then passing it to the findModule method.\nSome renaming may be worthwhile and maybe some extracting into methods", "author": "radito3", "createdAt": "2020-05-19T08:08:04Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private final MtaMetadataParser mtaMetadataParser;\n+    private final EnvMtaMetadataParser envMtaMetadataParser;\n+    private final ProcessContext context;\n+    private final HookPhase hookPhaseBeforeStep;\n+    private final HookPhase hookPhaseAfterStep;\n+\n+    private HooksHelper(Builder hooksHelperBuilder) {\n+        this.mtaMetadataParser = hooksHelperBuilder.mtaMetadataParser;\n+        this.envMtaMetadataParser = hooksHelperBuilder.envMtaMetadataParser;\n+        this.context = hooksHelperBuilder.context;\n+        this.hookPhaseBeforeStep = hooksHelperBuilder.hookPhaseBeforeStep;\n+        this.hookPhaseAfterStep = hooksHelperBuilder.hookPhaseAfterStep;\n+    }\n+\n+    public List<Hook> getHooksForStepPhase(Module moduleToDeploy, StepPhase currentStepPhase) {\n+        HookPhase currentHookPhaseForExecution = determineHookPhaseForCurrentStepPhase(currentStepPhase);\n+        return getHooksForCurrentPhase(moduleToDeploy, currentHookPhaseForExecution);\n+    }\n+\n+    public Module determineModuleToDeploy(ProcessContext context) {\n+        Module moduleToDeploy = context.getVariable(Variables.MODULE_TO_DEPLOY);\n+        return moduleToDeploy != null ? moduleToDeploy : determineModuleFromDescriptor(context);\n+    }\n+\n+    public void setHooksForExecution(List<Hook> hooksForExecution) {\n+        context.setVariable(Variables.HOOKS_FOR_EXECUTION, hooksForExecution);\n+    }\n+\n+    private Module determineModuleFromDescriptor(ProcessContext context) {\n+        DeploymentDescriptor deploymentDescriptor = context.getVariable(Variables.COMPLETE_DEPLOYMENT_DESCRIPTOR);\n+        if (deploymentDescriptor == null) {\n+            // This will be the case only when the process is undeploy.\n+            return null;\n+        }\n+\n+        CloudApplicationExtended cloudApplication = context.getVariable(Variables.APP_TO_PROCESS);\n+        if (cloudApplication.getModuleName() == null) {\n+            // This case handles the deletion of old applications when the process is blue-green deployment. Here the application is taken\n+            // from the\n+            // CloudController and thus we do not have moduleName in it.\n+            return determineModuleFromAppName(deploymentDescriptor, cloudApplication);\n+        }\n+\n+        HandlerFactory handlerFactory = StepsUtil.getHandlerFactory(context.getExecution());", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNTEwNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427115107", "bodyText": "This method and the one before it differ only in one if condition. Is it possible to refactor them to remove the duplication?", "author": "radito3", "createdAt": "2020-05-19T08:18:04Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksProcessor.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.process.steps.AfterHooksPhaseProvider;\n+import com.sap.cloud.lm.sl.cf.process.steps.BeforeHooksPhaseProvider;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksProcessor {\n+\n+    private final ProcessContext context;\n+    private final MtaMetadataParser mtaMetadataParser;\n+    private final EnvMtaMetadataParser envMtaMetadataParser;\n+\n+    public HooksProcessor(ProcessContext context, MtaMetadataParser mtaMetadataParser, EnvMtaMetadataParser envMtaMetadataParser) {\n+        this.context = context;\n+        this.mtaMetadataParser = mtaMetadataParser;\n+        this.envMtaMetadataParser = envMtaMetadataParser;\n+    }\n+\n+    public boolean processBeforeHooks(BeforeHooksPhaseProvider beforeHooksPhaseProvider, StepPhase currentStepPhase) {\n+        HooksHelper hooksHelper = getHooksHelperBuilder().withHookPhaseBeforeStep(beforeHooksPhaseProvider.getHookPhaseBeforeStep(context))\n+                                                         .build();\n+        Module moduleToDeploy = hooksHelper.determineModuleToDeploy(context);\n+        return executeBeforeStepHooks(hooksHelper, currentStepPhase, moduleToDeploy);\n+    }\n+\n+    public boolean processAfterHooks(AfterHooksPhaseProvider afterHooksPhaseProvider, StepPhase currentStepPhase) {\n+        HooksHelper hooksHelper = getHooksHelperBuilder().withHookPhaseAfterStep(afterHooksPhaseProvider.getHookPhaseAfterStep(context))\n+                                                         .build();\n+        Module moduleToDeploy = hooksHelper.determineModuleToDeploy(context);\n+        return executeAfterStepHooks(hooksHelper, currentStepPhase, moduleToDeploy);\n+    }\n+\n+    private boolean executeBeforeStepHooks(HooksHelper hooksHelper, StepPhase currentStepPhase, Module moduleToDeploy) {\n+        if (moduleToDeploy == null) {\n+            return false;\n+        }\n+        if (!hooksHelper.isInPreExecuteStepPhase(currentStepPhase)) {\n+            return false;\n+        }\n+        List<Hook> hooksForExecution = hooksHelper.getHooksForStepPhase(moduleToDeploy, currentStepPhase);\n+        hooksHelper.setHooksForExecution(hooksForExecution);\n+        return !hooksForExecution.isEmpty();\n+    }\n+\n+    private boolean executeAfterStepHooks(HooksHelper hooksHelper, StepPhase currentStepPhase, Module moduleToDeploy) {", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNzE2Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427117167", "bodyText": "Why not just the @Mock annotation?", "author": "radito3", "createdAt": "2020-05-19T08:21:33Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteApplicationRoutesStepTest.java", "diffHunk": "@@ -8,9 +8,15 @@\n import java.util.Collections;\r\n \r\n import org.cloudfoundry.client.lib.domain.CloudApplication;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.mockito.Mockito;\r\n+\r\n+import com.sap.cloud.lm.sl.cf.process.util.HooksProcessor;\r\n \r\n public class DeleteApplicationRoutesStepTest extends UndeployAppStepTest {\r\n \r\n+    private final HooksProcessor hooksProcessor = Mockito.mock(HooksProcessor.class);\r", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNzcwOA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427117708", "bodyText": "Use @Mock instead of Mockito::mock in this and all following instances", "author": "radito3", "createdAt": "2020-05-19T08:22:24Z", "path": "com.sap.cloud.lm.sl.cf.process/src/test/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStepTest.java", "diffHunk": "@@ -4,26 +4,37 @@\n \r\n import org.cloudfoundry.client.lib.StartingInfo;\r\n import org.cloudfoundry.client.lib.domain.CloudApplication.State;\r\n-import org.junit.Before;\r\n-import org.junit.Test;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.mockito.Mock;\r\n import org.mockito.Mockito;\r\n \r\n import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\r\n import com.sap.cloud.lm.sl.cf.client.lib.domain.ImmutableCloudApplicationExtended;\r\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\r\n+import com.sap.cloud.lm.sl.cf.core.model.Phase;\r\n+import com.sap.cloud.lm.sl.cf.process.util.HooksProcessor;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ProcessTypeParser;\r\n import com.sap.cloud.lm.sl.cf.process.variables.Variables;\r\n+import com.sap.cloud.lm.sl.cf.web.api.model.ProcessType;\r\n import com.sap.cloud.lm.sl.common.util.JsonUtil;\r\n \r\n public class RestartAppStepTest extends SyncFlowableStepTest<RestartAppStep> {\r\n \r\n     private static final String APP_NAME = \"foo\";\r\n+    private final HooksProcessor hooksProcessor = Mockito.mock(HooksProcessor.class);\r", "originalCommit": "dcf131315adb32a41862022b0c46f2ad49d2649e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbe75e7ab6873c921c950ab1769acf822b96be0f", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/bbe75e7ab6873c921c950ab1769acf822b96be0f", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-19T09:33:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTUyMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427185522", "bodyText": "I was thinking more along the lines of\nModule determineModuleFromDescriptor(...){\n   HandlerFactory handlerFactory = getHandlerFactory();\n   String moduleName = computeModuleName(...);\n   return findModuleByName(...);\n}\n\nString computeModuleName(...) {\n   if (cloudApp.getModuleName() == null {\n      return parseModuleName(); //use getDeployedMtaApplication().getModuleName() here\n   }\n   return cloudApp.getModuleName();\n}\n\nBut your solution is good as well", "author": "radito3", "createdAt": "2020-05-19T10:08:26Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksHelper.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.List;\n+\n+import org.cloudfoundry.client.lib.domain.CloudApplication;\n+\n+import com.sap.cloud.lm.sl.cf.client.lib.domain.CloudApplicationExtended;\n+import com.sap.cloud.lm.sl.cf.core.cf.HandlerFactory;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.util.MtaMetadataUtil;\n+import com.sap.cloud.lm.sl.cf.core.model.DeployedMtaApplication;\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.ProcessContext;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+import com.sap.cloud.lm.sl.mta.model.DeploymentDescriptor;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class HooksHelper {\n+\n+    private final MtaMetadataParser mtaMetadataParser;\n+    private final EnvMtaMetadataParser envMtaMetadataParser;\n+    private final ProcessContext context;\n+    private final HookPhase hookPhaseBeforeStep;\n+    private final HookPhase hookPhaseAfterStep;\n+\n+    private HooksHelper(Builder hooksHelperBuilder) {\n+        this.mtaMetadataParser = hooksHelperBuilder.mtaMetadataParser;\n+        this.envMtaMetadataParser = hooksHelperBuilder.envMtaMetadataParser;\n+        this.context = hooksHelperBuilder.context;\n+        this.hookPhaseBeforeStep = hooksHelperBuilder.hookPhaseBeforeStep;\n+        this.hookPhaseAfterStep = hooksHelperBuilder.hookPhaseAfterStep;\n+    }\n+\n+    public List<Hook> getHooksForStepPhase(Module moduleToDeploy, StepPhase currentStepPhase) {\n+        HookPhase currentHookPhaseForExecution = determineHookPhaseForCurrentStepPhase(currentStepPhase);\n+        return getHooksForCurrentPhase(moduleToDeploy, currentHookPhaseForExecution);\n+    }\n+\n+    public Module determineModuleToDeploy(ProcessContext context) {\n+        Module moduleToDeploy = context.getVariable(Variables.MODULE_TO_DEPLOY);\n+        return moduleToDeploy != null ? moduleToDeploy : determineModule(context);\n+    }\n+\n+    public void setHooksForExecution(List<Hook> hooksForExecution) {\n+        context.setVariable(Variables.HOOKS_FOR_EXECUTION, hooksForExecution);\n+    }\n+\n+    private Module determineModule(ProcessContext context) {\n+        DeploymentDescriptor deploymentDescriptor = context.getVariable(Variables.COMPLETE_DEPLOYMENT_DESCRIPTOR);\n+        if (deploymentDescriptor == null) {\n+            // This will be the case only when the process is undeploy.\n+            return null;\n+        }\n+        return determineModuleFromDeploymentDescriptor(context.getVariable(Variables.APP_TO_PROCESS), deploymentDescriptor);\n+    }\n+\n+    private Module determineModuleFromDeploymentDescriptor(CloudApplicationExtended cloudApplication,\n+                                                           DeploymentDescriptor deploymentDescriptor) {\n+        HandlerFactory handlerFactory = StepsUtil.getHandlerFactory(context.getExecution());\n+        if (cloudApplication.getModuleName() == null) {", "originalCommit": "bbe75e7ab6873c921c950ab1769acf822b96be0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNTE5MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427205191", "bodyText": "Looks better. Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-19T10:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTUyMg=="}], "type": "inlineReview"}, {"oid": "d3006972f66a3b4c56ce6c4bee9b4931a8df8247", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/d3006972f66a3b4c56ce6c4bee9b4931a8df8247", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-19T10:43:34Z", "type": "forcePushed"}, {"oid": "e698e3276d60d1ff885b2bc27e6b310c0e8b9013", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/e698e3276d60d1ff885b2bc27e6b310c0e8b9013", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-19T10:47:01Z", "type": "forcePushed"}, {"oid": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "message": "Fix sonar findings", "committedDate": "2020-05-19T11:14:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0MTY5Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427841692", "bodyText": "Maybe we could rename this to \"SetAfterResumePhaseListnere\"?\nThis way it will better describe what it is doing.", "author": "enchobelezirev", "createdAt": "2020-05-20T08:44:26Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/listeners/SetResumePhaseListener.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.sap.cloud.lm.sl.cf.process.listeners;\n+\n+import javax.inject.Named;\n+\n+import org.flowable.engine.delegate.DelegateExecution;\n+import org.flowable.engine.delegate.ExecutionListener;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.Phase;\n+import com.sap.cloud.lm.sl.cf.process.variables.VariableHandling;\n+import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n+\n+@Named(\"setResumePhase\")\n+public class SetResumePhaseListener implements ExecutionListener {", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDE0Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614143", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0MzM0MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427843341", "bodyText": "Sorry for this but reading this now brings some complexitiy in my head.\nCould we rename this to \"AfterStepHookPhaseProvider\"? Again, this will better tell what this is doing.", "author": "enchobelezirev", "createdAt": "2020-05-20T08:46:57Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/AfterHooksPhaseProvider.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+\n+public interface AfterHooksPhaseProvider {", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDQ1Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614452", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0MzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDI0Mw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427844243", "bodyText": "If you agree to the above comment, this could only be \"get(ProcessContext context)\"?", "author": "enchobelezirev", "createdAt": "2020-05-20T08:48:15Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/AfterHooksPhaseProvider.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+\n+public interface AfterHooksPhaseProvider {\n+\n+    HookPhase getHookPhaseAfterStep(ProcessContext context);", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDczNw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427844737", "bodyText": "Something more, is it possible, in future, this to return List?", "author": "enchobelezirev", "createdAt": "2020-05-20T08:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDE5MQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614191", "bodyText": "get methods will conflict with each other if a step implements both interfaces\nDone", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDg3Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r427844876", "bodyText": "Apply same naming here.", "author": "enchobelezirev", "createdAt": "2020-05-20T08:49:09Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/BeforeHooksPhaseProvider.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.sap.cloud.lm.sl.cf.process.steps;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+\n+public interface BeforeHooksPhaseProvider {", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDIzOA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614238", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NDg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA0ODk1OQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428048959", "bodyText": "This refactoring introduces a lot of copy-pasted code. Meaning that if I want to enable the hooks in another step, I need to copy-paste this code which does all the magic. My point is that we need to make external logic which should handles this before and after step hooks calculation. Also this logic should use the newly introduced interfaces in order to operate. Meaning that when some step is started, if it is \"specified\" that it supports hooks, the hook building logic should understand that this step is either of type \"AfterStepHookPhaseProvider\" and/or \"BeforeStepHookPhaseProvider\" and calculate the hooks based on the current step phase.\nWe could discuss it - the design and the whole concept.\nTry thinking of a pattern which is executing some logic by calling some delegates in order to do its job.", "author": "enchobelezirev", "createdAt": "2020-05-20T14:16:57Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/DeleteApplicationRoutesStep.java", "diffHunk": "@@ -25,19 +27,24 @@\n \n @Named(\"deleteApplicationRoutesStep\")\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n-public class DeleteApplicationRoutesStep extends UndeployAppStep {\n+public class DeleteApplicationRoutesStep extends UndeployAppStep implements BeforeHooksPhaseProvider {\n \n+    @Inject\n     private ApplicationRoutesGetter applicationRoutesGetter;\n-\n     @Inject\n-    public DeleteApplicationRoutesStep(ApplicationRoutesGetter applicationRoutesGetter) {\n-        this.applicationRoutesGetter = applicationRoutesGetter;\n-    }\n+    private MtaMetadataParser mtaMetadataParser;\n+    @Inject\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n \n     @Override\n-    protected StepPhase undeployApplication(CloudControllerClient client, CloudApplication cloudApplicationToUndeploy) {\n+    protected StepPhase undeployApplication(CloudControllerClient client, CloudApplication cloudApplicationToUndeploy,\n+                                            ProcessContext context) {\n+        HooksProcessor hooksProcessor = getHooksProcessor(context);", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MzMyNQ==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428053325", "bodyText": "I am concerned about this. First, why is this here? Second, this brings notation for the before start hook phases which is not correct from the Object point of view. It's purpose is to get some hooks, calculate some hooks for execution and return them.", "author": "enchobelezirev", "createdAt": "2020-05-20T14:22:07Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDI4Mg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614282", "bodyText": "Removed. RestartAppStep will return the required phases", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1MzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1NTk1OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428055958", "bodyText": "I would extract this condition in a separate method", "author": "enchobelezirev", "createdAt": "2020-05-20T14:25:24Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/ModuleHooksAggregator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.flowable.engine.delegate.DelegateExecution;\n+\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n+import com.sap.cloud.lm.sl.cf.process.steps.StepsUtil;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+public class ModuleHooksAggregator {\n+\n+    private static final byte MAJOR_SCHEMA_VERSION_THREE = 3;\n+\n+    private final DelegateExecution execution;\n+    private final Module moduleToDeploy;\n+\n+    public ModuleHooksAggregator(DelegateExecution execution, Module moduleToDeploy) {\n+        this.execution = execution;\n+        this.moduleToDeploy = moduleToDeploy;\n+    }\n+\n+    public List<Hook> aggregateHooks(HookPhase currentHookPhaseForExecution) {\n+        substituteBeforeStartHooksPhases();\n+        Map<String, List<String>> alreadyExecutedHooksForModule = getAlreadyExecutedHooks();\n+        List<Hook> hooksCalculatedForExecution = determineHooksForExecution(alreadyExecutedHooksForModule, currentHookPhaseForExecution);\n+        updateExecutedHooksForModule(alreadyExecutedHooksForModule, currentHookPhaseForExecution, hooksCalculatedForExecution);\n+        return hooksCalculatedForExecution;\n+    }\n+\n+    private void substituteBeforeStartHooksPhases() {\n+        for (Hook hook : getModuleHooks(moduleToDeploy)) {\n+            List<String> phases = new ArrayList<>(hook.getPhases());\n+            if (phases.contains(HookPhase.APPLICATION_BEFORE_START.getValue())) {\n+                phases.remove(HookPhase.APPLICATION_BEFORE_START.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_LIVE.getValue());\n+                phases.add(HookPhase.APPLICATION_BEFORE_START_IDLE.getValue());\n+                hook.setPhases(phases);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<String>> getAlreadyExecutedHooks() {\n+        return StepsUtil.getExecutedHooksForModule(execution, moduleToDeploy.getName());\n+    }\n+\n+    private List<Hook> determineHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, HookPhase hookPhaseForCurrentStepPhase) {\n+        List<Hook> moduleHooksToExecuteOnCurrentStepPhase = collectHooksWithPhase(moduleToDeploy, hookPhaseForCurrentStepPhase);\n+        return getHooksForExecution(alreadyExecutedHooks, moduleHooksToExecuteOnCurrentStepPhase, hookPhaseForCurrentStepPhase);\n+    }\n+\n+    private List<Hook> collectHooksWithPhase(Module moduleToDeploy, HookPhase hookTypeForCurrentStepPhase) {\n+        return getModuleHooks(moduleToDeploy).stream()\n+                                             .filter(hook -> shouldExecuteHook(hook.getPhases(), hookTypeForCurrentStepPhase))\n+                                             .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getModuleHooks(Module moduleToDeploy) {\n+        return moduleToDeploy.getMajorSchemaVersion() < MAJOR_SCHEMA_VERSION_THREE ? Collections.emptyList() : moduleToDeploy.getHooks();\n+    }\n+\n+    private boolean shouldExecuteHook(List<String> hookPhases, HookPhase hookTypeForCurrentStepPhase) {\n+        List<HookPhase> resolvedHookPhases = mapToHookPhases(hookPhases);\n+        return resolvedHookPhases.contains(hookTypeForCurrentStepPhase);\n+    }\n+\n+    private List<HookPhase> mapToHookPhases(List<String> hookPhases) {\n+        return hookPhases.stream()\n+                         .map(HookPhase::fromString)\n+                         .collect(Collectors.toList());\n+    }\n+\n+    private List<Hook> getHooksForExecution(Map<String, List<String>> alreadyExecutedHooks, List<Hook> moduleHooksToBeExecuted,\n+                                            HookPhase hookPhaseForCurrentStepPhase) {\n+        return moduleHooksToBeExecuted.stream()\n+                                      .filter(hook -> !alreadyExecutedHooks.containsKey(hook.getName())\n+                                          || !hasAllPhasesExecuted(alreadyExecutedHooks, hook, hookPhaseForCurrentStepPhase))", "originalCommit": "78aa79e8c7f3f8b0d5ec3ed09ef50d61339b90f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYxNDMzNg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428614336", "bodyText": "Done", "author": "IvanBorislavovDimitrov", "createdAt": "2020-05-21T12:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1NTk1OA=="}], "type": "inlineReview"}, {"oid": "c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-21T12:06:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NDE3Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428674176", "bodyText": "Do we need these lines of code here?", "author": "enchobelezirev", "createdAt": "2020-05-21T14:08:02Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/RestartAppStep.java", "diffHunk": "@@ -17,18 +17,30 @@\n import org.springframework.http.HttpStatus;\r\n \r\n import com.sap.cloud.lm.sl.cf.core.cf.clients.RecentLogsRetriever;\r\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\r\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\r\n+import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\r\n+import com.sap.cloud.lm.sl.cf.core.model.Phase;\r\n import com.sap.cloud.lm.sl.cf.process.Messages;\r\n+import com.sap.cloud.lm.sl.cf.process.util.ProcessTypeParser;\r\n import com.sap.cloud.lm.sl.cf.process.variables.Variables;\r\n+import com.sap.cloud.lm.sl.cf.web.api.model.ProcessType;\r\n \r\n @Named(\"restartAppStep\")\r\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n-public class RestartAppStep extends TimeoutAsyncFlowableStep {\r\n+public class RestartAppStep extends TimeoutAsyncFlowableStepWithHooks implements BeforeStepHookPhaseProvider {\r\n \r\n     @Inject\r\n     protected RecentLogsRetriever recentLogsRetriever;\r\n+    @Inject\r\n+    private ProcessTypeParser processTypeParser;\r\n+    @Inject\r\n+    private MtaMetadataParser mtaMetadataParser;\r\n+    @Inject\r\n+    private EnvMtaMetadataParser envMtaMetadataParser;\r", "originalCommit": "c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NDU5Ng==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428674596", "bodyText": "Again, do we need these lines of code here?", "author": "enchobelezirev", "createdAt": "2020-05-21T14:08:44Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StopAppStep.java", "diffHunk": "@@ -20,13 +23,17 @@\n \r\n @Named(\"stopAppStep\")\r\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\r\n-public class StopAppStep extends SyncFlowableStepWithHooks {\r\n+public class StopAppStep extends SyncFlowableStepWithHooks implements BeforeStepHookPhaseProvider, AfterStepHookPhaseProvider {\r\n \r\n     @Inject\r\n     private ProcessTypeParser processTypeParser;\r\n+    @Inject\r\n+    private MtaMetadataParser mtaMetadataParser;\r\n+    @Inject\r\n+    private EnvMtaMetadataParser envMtaMetadataParser;\r", "originalCommit": "c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3NDgwMg==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428674802", "bodyText": "Same", "author": "enchobelezirev", "createdAt": "2020-05-21T14:09:05Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/steps/StopApplicationUndeploymentStep.java", "diffHunk": "@@ -1,29 +1,38 @@\n package com.sap.cloud.lm.sl.cf.process.steps;\n \n import java.text.MessageFormat;\n+import java.util.Collections;\n+import java.util.List;\n \n+import javax.inject.Inject;\n import javax.inject.Named;\n \n import org.cloudfoundry.client.lib.CloudControllerClient;\n import org.cloudfoundry.client.lib.domain.CloudApplication;\n-import org.flowable.engine.delegate.DelegateExecution;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.context.annotation.Scope;\n \n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.EnvMtaMetadataParser;\n+import com.sap.cloud.lm.sl.cf.core.cf.metadata.processor.MtaMetadataParser;\n import com.sap.cloud.lm.sl.cf.core.model.HookPhase;\n import com.sap.cloud.lm.sl.cf.process.Messages;\n import com.sap.cloud.lm.sl.cf.process.variables.Variables;\n \n @Named(\"stopApplicationUndeploymentStep\")\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n-public class StopApplicationUndeploymentStep extends UndeployAppStep {\n+public class StopApplicationUndeploymentStep extends UndeployAppStep implements BeforeStepHookPhaseProvider, AfterStepHookPhaseProvider {\n+\n+    @Inject\n+    private EnvMtaMetadataParser envMtaMetadataParser;\n+    @Inject\n+    private MtaMetadataParser mtaMetadataParser;", "originalCommit": "c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3Nzc4Nw==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/856#discussion_r428677787", "bodyText": "I would say that this is HooksExecutor class as there are only execute* methods in it.", "author": "enchobelezirev", "createdAt": "2020-05-21T14:14:09Z", "path": "com.sap.cloud.lm.sl.cf.process/src/main/java/com/sap/cloud/lm/sl/cf/process/util/HooksProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.sap.cloud.lm.sl.cf.process.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.inject.Named;\n+\n+import com.sap.cloud.lm.sl.cf.process.steps.StepPhase;\n+import com.sap.cloud.lm.sl.mta.model.Hook;\n+import com.sap.cloud.lm.sl.mta.model.Module;\n+\n+@Named\n+public class HooksProcessor {", "originalCommit": "c71d0d0b706b1f6d3d0ef6de75dea4105045db09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2dfb239e0b71a5e11289fd7dbce8eec55de7d941", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/2dfb239e0b71a5e11289fd7dbce8eec55de7d941", "message": "Fix comments", "committedDate": "2020-05-21T15:59:44Z", "type": "forcePushed"}, {"oid": "e58ae0ffcd93ceba7533a3b9e237be525ed5e045", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/e58ae0ffcd93ceba7533a3b9e237be525ed5e045", "message": "Fix comments", "committedDate": "2020-05-21T19:50:25Z", "type": "forcePushed"}, {"oid": "66acecf8b03a513206fdf2727a78fb4efd6ae9db", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/66acecf8b03a513206fdf2727a78fb4efd6ae9db", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-22T07:13:16Z", "type": "forcePushed"}, {"oid": "558499056b3bfcb1297b26c31a20a56addaf6b2a", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/558499056b3bfcb1297b26c31a20a56addaf6b2a", "message": "Refactor hooks classes", "committedDate": "2020-05-22T07:34:23Z", "type": "commit"}, {"oid": "55726c2e18511360a77b087b267a3ff984842cbf", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/55726c2e18511360a77b087b267a3ff984842cbf", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-22T07:34:31Z", "type": "commit"}, {"oid": "55726c2e18511360a77b087b267a3ff984842cbf", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/55726c2e18511360a77b087b267a3ff984842cbf", "message": "Implement \"before application start\" hooks", "committedDate": "2020-05-22T07:34:31Z", "type": "forcePushed"}]}