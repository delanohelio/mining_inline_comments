{"pr_number": 979, "pr_title": "Remove backward compatability logic for bind/unbind services", "pr_createdAt": "2020-10-13T15:56:47Z", "pr_url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/979", "timeline": [{"oid": "467d3a9b0822904a9c7ded9721447ba22ff11bd0", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/467d3a9b0822904a9c7ded9721447ba22ff11bd0", "message": "Remove backward compatability logic for bind/unbind services\n\nDue to previously started processes it was necessary to keep old logic\nfor binding/unbinding services. With this change old logic is removed\nand unit tests are refactored.", "committedDate": "2020-10-27T14:48:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2Mzk2MA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/979#discussion_r513263960", "bodyText": "Wouldn't it be simpler to do existingAppEnv.putAll(newAppEnv) (or vice versa) and return the map?\nOr just put them in a new map", "author": "radito3", "createdAt": "2020-10-28T08:39:02Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/steps/CreateOrUpdateStepWithExistingAppTest.java", "diffHunk": "@@ -1,388 +1,305 @@\n package org.cloudfoundry.multiapps.controller.process.steps;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.ArgumentMatchers.anyMap;\n import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.UUID;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n-import org.apache.commons.collections4.ListUtils;\n-import org.cloudfoundry.multiapps.common.test.GenericArgumentMatcher;\n-import org.cloudfoundry.multiapps.common.test.TestUtil;\n-import org.cloudfoundry.multiapps.common.util.JsonUtil;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.CloudApplicationExtended;\n-import org.cloudfoundry.multiapps.controller.client.lib.domain.CloudServiceInstanceExtended;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.ImmutableCloudApplicationExtended;\n-import org.cloudfoundry.multiapps.controller.client.lib.domain.ImmutableCloudServiceInstanceExtended;\n-import org.cloudfoundry.multiapps.controller.client.lib.domain.ServiceKeyToInject;\n-import org.cloudfoundry.multiapps.controller.core.util.NameUtil;\n+import org.cloudfoundry.multiapps.controller.core.Constants;\n import org.cloudfoundry.multiapps.controller.process.variables.Variables;\n-import org.flowable.engine.ProcessEngine;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n-import org.mockito.Mock;\n-import org.mockito.Mockito;\n-\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.sap.cloudfoundry.client.facade.ApplicationServicesUpdateCallback;\n-import com.sap.cloudfoundry.client.facade.domain.CloudApplication.State;\n-import com.sap.cloudfoundry.client.facade.domain.CloudServiceBinding;\n-import com.sap.cloudfoundry.client.facade.domain.CloudServiceInstance;\n-import com.sap.cloudfoundry.client.facade.domain.CloudServiceKey;\n-import com.sap.cloudfoundry.client.facade.domain.ImmutableCloudMetadata;\n-import com.sap.cloudfoundry.client.facade.domain.ImmutableCloudServiceBinding;\n+\n+import com.sap.cloudfoundry.client.facade.domain.CloudApplication;\n+import com.sap.cloudfoundry.client.facade.domain.ImmutableDockerInfo;\n import com.sap.cloudfoundry.client.facade.domain.ImmutableStaging;\n+import com.sap.cloudfoundry.client.facade.domain.Staging;\n+import com.sap.cloudfoundry.client.facade.util.JsonUtil;\n \n class CreateOrUpdateStepWithExistingAppTest extends SyncFlowableStepTest<CreateOrUpdateAppStep> {\n \n-    private static final ApplicationServicesUpdateCallback CALLBACK = ApplicationServicesUpdateCallback.DEFAULT_APPLICATION_SERVICES_UPDATE_CALLBACK;\n-\n-    @Mock\n-    private ProcessEngine processEngine;\n-\n-    private StepInput input;\n-\n-    private List<String> notRequiredServices;\n-    private List<String> expectedServicesToBind;\n-\n-    static Stream<Arguments> testExecute() {\n-        return Stream.of(Arguments.of(\"update-app-step-input-1.json\", null), Arguments.of(\"update-app-step-input-2.json\", null),\n-                         Arguments.of(\"update-app-step-input-3.json\", null), Arguments.of(\"update-app-step-input-4.json\", null),\n-                         Arguments.of(\"update-app-step-input-5.json\", null), Arguments.of(\"update-app-step-input-6.json\", null),\n-                         Arguments.of(\"update-app-step-input-7.json\", null), Arguments.of(\"update-app-step-input-8.json\", null),\n-                         Arguments.of(\"update-app-step-input-9.json\", null), Arguments.of(\"update-app-step-input-10.json\", null),\n-                         Arguments.of(\"update-app-step-input-11.json\", null),\n-                         // Existing app has binding with null parameters and defined service binding is without parameters\n-                         Arguments.of(\"update-app-step-input-12.json\", null),\n-                         // Existing app has binding with empty parameters and defined service binding is without parameters\n-                         Arguments.of(\"update-app-step-input-13.json\", null),\n-                         // Existing app has binding with parameters and defined service binding is without parameters\n-                         Arguments.of(\"update-app-step-input-14.json\", null),\n-                         // Existing app has binding with null parameters and defined service binding is with defined parameters\n-                         Arguments.of(\"update-app-step-input-15.json\", null),\n-                         // Service keys to inject are specified\n-                         Arguments.of(\"update-app-step-input-16.json\", null),\n-                         // Service keys to inject are specified but does not exist\n-                         Arguments.of(\"update-app-step-input-17.json\",\n-                                      \"Unable to retrieve required service key element \\\"expected-service-key\\\" for service \\\"existing-service-1\\\"\"),\n-                         // Test enable-ssh parameter\n-                         Arguments.of(\"update-app-step-input-18.json\", null),\n-                         // Test if healthCheckType parameter is updated\n-                         Arguments.of(\"update-app-step-input-19.json\", null),\n-                         // Test if healthCheckHttpEndpoint parameter is updated\n-                         Arguments.of(\"update-app-step-input-20.json\", null),\n-                         // Test if healthCheckHttpEndpoint parameter is updated\n-                         Arguments.of(\"update-app-step-input-21.json\", null));\n-    }\n-\n-    @BeforeEach\n-    void setUp() {\n-        notRequiredServices = new ArrayList<>();\n-        expectedServicesToBind = new ArrayList<>();\n-    }\n-\n-    @Test\n-    void testSkipRebindOfServices() {\n-        this.input = JsonUtil.fromJson(TestUtil.getResourceAsString(\"update-app-step-input-1.json\", getClass()), StepInput.class);\n-        prepareContext();\n-        context.setVariable(Variables.SHOULD_SKIP_SERVICE_REBINDING, true);\n-        prepareClient();\n-\n-        Assertions.assertDoesNotThrow(() -> step.execute(execution));\n-\n-        assertStepFinishedSuccessfully();\n-        validateUpdateComponents();\n-\n-        Mockito.verify(client, Mockito.never())\n-               .bindServiceInstance(Mockito.anyString(), Mockito.anyString(), Mockito.anyMap(), Mockito.any());\n-        Mockito.verify(client, Mockito.never())\n-               .unbindServiceInstance(Mockito.anyString(), Mockito.anyString());\n+    private static final String APP_DIGEST = \"12345\";\n+    private static final String APP_NAME_ENV_KEY = \"APP_NAME\";\n+    private static final String APP_NAME = \"test-application\";\n+\n+    static Stream<Arguments> testHandleStagingApplicationAttributes() {\n+        return Stream.of(\n+//@formatter:off\n+                         Arguments.of(ImmutableStaging.builder().addBuildpack(\"buildpack-1\").command(\"command1\").build(),\n+                                      ImmutableStaging.builder().addBuildpack(\"buildpack-1\").command(\"command2\").build(),\n+                                      true),\n+                         Arguments.of(ImmutableStaging.builder().addBuildpack(\"buildpack-1\").build(),\n+                                      ImmutableStaging.builder().addBuildpack(\"buildpack-1\").build(),\n+                                      false),\n+                         Arguments.of(ImmutableStaging.builder().addBuildpack(\"buildpack-1\").command(\"command1\").stack(\"stack1\").\n+                                      healthCheckTimeout(5).healthCheckType(\"process\").isSshEnabled(false)\n+                                                      .build(),\n+                                      ImmutableStaging.builder().addBuildpack(\"buildpack-2\").command(\"command2\").stack(\"stack2\")\n+                                                      .healthCheckTimeout(10).healthCheckType(\"web\").healthCheckHttpEndpoint(\"/test\")\n+                                                      .isSshEnabled(true)\n+                                                      .build(),\n+                                      true),\n+                         Arguments.of(ImmutableStaging.builder().addBuildpack(\"buildpack-2\").command(\"command2\").stack(\"stack2\")\n+                                                      .healthCheckTimeout(10).healthCheckType(\"web\").healthCheckHttpEndpoint(\"/test\")\n+                                                      .isSshEnabled(true)\n+                                                      .build(),\n+                                      ImmutableStaging.builder().addBuildpack(\"buildpack-2\").command(\"command2\").stack(\"stack2\")\n+                                                      .healthCheckTimeout(10).healthCheckType(\"web\").healthCheckHttpEndpoint(\"/test\")\n+                                                      .isSshEnabled(true)\n+                                                      .build(),\n+                                      false),\n+                         Arguments.of(ImmutableStaging.builder().dockerInfo(ImmutableDockerInfo.builder().image(\"cloudfoundry/test-app\").build()).build(),\n+                                      ImmutableStaging.builder().dockerInfo(ImmutableDockerInfo.builder().image(\"cloudfoundry/test-app2\").build()).build(),\n+                                      true),\n+                         Arguments.of(ImmutableStaging.builder().dockerInfo(ImmutableDockerInfo.builder().image(\"cloudfoundry/test-app\").build()).build(),\n+                                      ImmutableStaging.builder().dockerInfo(ImmutableDockerInfo.builder().image(\"cloudfoundry/test-app\").build()).build(),\n+                                      false));\n+//@formatter:on\n     }\n \n     @ParameterizedTest\n     @MethodSource\n-    void testExecute(String input, String expectedExceptionMessage) {\n-        this.input = JsonUtil.fromJson(TestUtil.getResourceAsString(input, getClass()), StepInput.class);\n-        prepareContext();\n-        prepareClient();\n+    void testHandleStagingApplicationAttributes(Staging existingStaging, Staging staging, boolean expectedPropertiesChanged) {\n+        CloudApplication existingApplication = getApplicationBuilder(false).staging(existingStaging)\n+                                                                           .build();\n+        CloudApplicationExtended application = getApplicationBuilder(false).staging(staging)\n+                                                                           .build();\n+        prepareContext(application, false);\n+        prepareClient(existingApplication);\n \n-        if (expectedExceptionMessage != null) {\n-            Assertions.assertThrows(Exception.class, () -> step.execute(execution), expectedExceptionMessage);\n-            return;\n-        }\n-\n-        Assertions.assertDoesNotThrow(() -> step.execute(execution));\n+        step.execute(execution);\n \n         assertStepFinishedSuccessfully();\n-\n-        validateUnbindServices();\n-        validateBindServices();\n-        validateUpdateComponents();\n-    }\n-\n-    private void validateUpdateComponents() {\n-        String appName = input.application.name;\n-        CloudApplicationExtended cloudApp = input.application.toCloudApp();\n-        if (input.updateStaging) {\n-            Mockito.verify(client)\n-                   .updateApplicationStaging(Mockito.eq(appName), Mockito.argThat(GenericArgumentMatcher.forObject(cloudApp.getStaging())));\n-        }\n-        if (input.updateMemory) {\n-            Mockito.verify(client)\n-                   .updateApplicationMemory(appName, cloudApp.getMemory());\n-        }\n-        if (input.updateDiskQuota) {\n-            Mockito.verify(client)\n-                   .updateApplicationDiskQuota(appName, cloudApp.getDiskQuota());\n-        }\n-        if (input.updateUris) {\n-            Mockito.verify(client)\n-                   .updateApplicationUris(appName, cloudApp.getUris());\n-        }\n-        if (input.updateEnv) {\n-            Mockito.verify(client)\n-                   .updateApplicationEnv(appName, cloudApp.getEnv());\n+        assertEquals(expectedPropertiesChanged, context.getVariable(Variables.VCAP_APP_PROPERTIES_CHANGED));\n+        if (expectedPropertiesChanged) {\n+            verify(client).updateApplicationStaging(APP_NAME, staging);\n+            return;\n         }\n+        verify(client, never()).updateApplicationStaging(eq(APP_NAME), any());\n     }\n \n-    private void validateBindServices() {\n-        Map<String, Map<String, Object>> currentBindingParameters = input.application.toCloudApp()\n-                                                                                     .getBindingParameters();\n-        for (String serviceToBind : expectedServicesToBind) {\n-            Mockito.verify(client)\n-                   .bindServiceInstance(input.application.toCloudApp()\n-                                                         .getName(),\n-                                        serviceToBind, getBindingParametersForService(currentBindingParameters, serviceToBind),\n-                                        step.getApplicationServicesUpdateCallback(context));\n-        }\n+    private ImmutableCloudApplicationExtended.Builder getApplicationBuilder(boolean shouldKeepExistingEnv) {\n+        return ImmutableCloudApplicationExtended.builder()\n+                                                .name(APP_NAME)\n+                                                .staging(ImmutableStaging.builder()\n+                                                                         .build())\n+                                                .attributesUpdateStrategy(ImmutableCloudApplicationExtended.AttributeUpdateStrategy.builder()\n+                                                                                                                                   .shouldKeepExistingEnv(shouldKeepExistingEnv)\n+                                                                                                                                   .build());\n     }\n \n-    private Map<String, Object> getBindingParametersForService(Map<String, Map<String, Object>> bindingParameters, String serviceName) {\n-        return bindingParameters == null ? Collections.emptyMap() : bindingParameters.getOrDefault(serviceName, Collections.emptyMap());\n+    private void prepareContext(CloudApplicationExtended application, boolean shouldSkipServiceRebinding) {\n+        context.setVariable(Variables.APP_TO_PROCESS, application);\n+        context.setVariable(Variables.SERVICE_KEYS_CREDENTIALS_TO_INJECT, Collections.emptyMap());\n+        context.setVariable(Variables.SHOULD_SKIP_SERVICE_REBINDING, shouldSkipServiceRebinding);\n     }\n \n-    private void validateUnbindServices() {\n-        for (String notRequiredService : notRequiredServices) {\n-            Mockito.verify(client)\n-                   .unbindServiceInstance(input.existingApplication.name, notRequiredService);\n-        }\n+    private void prepareClient(CloudApplication application) {\n+        when(client.getApplication(APP_NAME, false)).thenReturn(application);\n     }\n \n-    private void prepareClient() {\n-        prepareDiscontinuedServices();\n-\n-        expectedServicesToBind = prepareServicesToBind();\n+    static Stream<Arguments> testHandleMemoryApplicationAttributes() {\n+        return Stream.of(Arguments.of(128, 256, true), Arguments.of(512, 128, true), Arguments.of(1024, 0, false),\n+                         Arguments.of(1024, 1024, false));\n+    }\n \n-        prepareExistingServiceBindings();\n-        for (String service : input.application.services) {\n-            mockServiceRetrieval(service);\n-        }\n+    @ParameterizedTest\n+    @MethodSource\n+    void testHandleMemoryApplicationAttributes(int existingMemorySize, int memorySize, boolean expectedPropertiesChanged) {\n+        CloudApplication existingApplication = getApplicationBuilder(false).memory(existingMemorySize)\n+                                                                           .build();\n+        CloudApplicationExtended application = getApplicationBuilder(false).memory(memorySize)\n+                                                                           .build();\n+        prepareContext(application, false);\n+        prepareClient(existingApplication);\n \n-        for (String service : input.existingApplication.services) {\n-            mockServiceRetrieval(service);\n-        }\n+        step.execute(execution);\n \n-        for (String service : expectedServicesToBind) {\n-            mockServiceRetrieval(service);\n+        assertStepFinishedSuccessfully();\n+        assertEquals(expectedPropertiesChanged, context.getVariable(Variables.VCAP_APP_PROPERTIES_CHANGED));\n+        if (expectedPropertiesChanged) {\n+            verify(client).updateApplicationMemory(APP_NAME, memorySize);\n+            return;\n         }\n-\n+        verify(client, never()).updateApplicationMemory(eq(APP_NAME), anyInt());\n     }\n \n-    private void mockServiceRetrieval(String service) {\n-        Mockito.when(client.getServiceInstance(service))\n-               .thenReturn(mapToCloudService(service));\n+    static Stream<Arguments> testHandleDiskQuotaApplicationAttributes() {\n+        return Stream.of(Arguments.of(128, 256, true), Arguments.of(512, 128, true), Arguments.of(1024, 0, false),\n+                         Arguments.of(1024, 1024, false));\n     }\n \n-    private void prepareExistingServiceBindings() {\n-        for (String serviceName : input.existingServiceBindings.keySet()) {\n-            CloudServiceInstance cloudServiceInstance = Mockito.mock(CloudServiceInstance.class);\n-            List<CloudServiceBinding> serviceBindings = new ArrayList<>();\n-            for (SimpleBinding simpleBinding : input.existingServiceBindings.get(serviceName)) {\n-                serviceBindings.add(simpleBinding.toCloudServiceBinding());\n-            }\n-            Mockito.when(client.getServiceBindingParameters(Mockito.any()))\n-                   .thenReturn(null);\n-            Mockito.when(client.getServiceBindings(Mockito.any()))\n-                   .thenReturn(serviceBindings);\n-            Mockito.when(cloudServiceInstance.getName())\n-                   .thenReturn(serviceName);\n-            Mockito.when(cloudServiceInstance.getMetadata())\n-                   .thenReturn(ImmutableCloudMetadata.builder()\n-                                                     .guid(NameUtil.getUUID(serviceName))\n-                                                     .build());\n-            Mockito.when(client.getServiceInstance(serviceName))\n-                   .thenReturn(cloudServiceInstance);\n-        }\n+    @ParameterizedTest\n+    @MethodSource\n+    void testHandleDiskQuotaApplicationAttributes(int existingDiskQuotaSize, int diskQuotaSize, boolean expectedPropertiesChanged) {\n+        CloudApplication existingApplication = getApplicationBuilder(false).diskQuota(existingDiskQuotaSize)\n+                                                                           .build();\n+        CloudApplicationExtended application = getApplicationBuilder(false).diskQuota(diskQuotaSize)\n+                                                                           .build();\n+        prepareContext(application, false);\n+        prepareClient(existingApplication);\n \n-        for (String serviceName : input.existingServiceKeys.keySet()) {\n-            List<CloudServiceKey> serviceKeys = input.existingServiceKeys.get(serviceName);\n-            Mockito.when(client.getServiceKeys(eq(serviceName)))\n-                   .thenReturn(serviceKeys);\n+        step.execute(execution);\n+\n+        assertStepFinishedSuccessfully();\n+        assertEquals(expectedPropertiesChanged, context.getVariable(Variables.VCAP_APP_PROPERTIES_CHANGED));\n+        if (expectedPropertiesChanged) {\n+            verify(client).updateApplicationDiskQuota(APP_NAME, diskQuotaSize);\n+            return;\n         }\n+        verify(client, never()).updateApplicationDiskQuota(eq(APP_NAME), anyInt());\n     }\n \n-    private List<CloudServiceInstanceExtended> mapToCloudServices() {\n-        return input.application.services.stream()\n-                                         .map(this::mapToCloudService)\n-                                         .collect(Collectors.toList());\n+    static Stream<Arguments> testHandleUrisApplicationAttributes() {\n+        return Stream.of(Arguments.of(Collections.emptyList(), List.of(\"example.com\"), true),\n+                         Arguments.of(List.of(\"example.com\"), Collections.emptyList(), true),\n+                         Arguments.of(List.of(\"example.com\"), List.of(\"example.com\", \"example1.com\"), true),\n+                         Arguments.of(List.of(\"example.com\"), List.of(\"example.com\"), false));\n     }\n \n-    private CloudServiceInstanceExtended mapToCloudService(String serviceName) {\n-        return new SimpleService(serviceName).toCloudService();\n-    }\n+    @ParameterizedTest\n+    @MethodSource\n+    void testHandleUrisApplicationAttributes(List<String> existingUris, List<String> uris, boolean expectedPropertiesChanged) {\n+        CloudApplication existingApplication = getApplicationBuilder(false).uris(existingUris)\n+                                                                           .build();\n+        CloudApplicationExtended application = getApplicationBuilder(false).uris(uris)\n+                                                                           .build();\n+        prepareContext(application, false);\n+        prepareClient(existingApplication);\n+\n+        step.execute(execution);\n \n-    private List<String> prepareServicesToBind() {\n-        if (input.application.shouldKeepServiceBindings) {\n-            return ListUtils.union(input.application.services, input.existingApplication.services);\n+        assertStepFinishedSuccessfully();\n+        assertEquals(expectedPropertiesChanged, context.getVariable(Variables.VCAP_APP_PROPERTIES_CHANGED));\n+        if (expectedPropertiesChanged) {\n+            verify(client).updateApplicationUris(APP_NAME, uris);\n+            return;\n         }\n-        return input.application.services;\n+        verify(client, never()).updateApplicationUris(eq(APP_NAME), anyList());\n     }\n \n-    private void prepareDiscontinuedServices() {\n-        List<String> discontinuedServices = input.existingApplication.services.stream()\n-                                                                              .filter((service) -> !input.application.services.contains(service))\n-                                                                              .collect(Collectors.toList());\n-        notRequiredServices.addAll(discontinuedServices);\n+    static Stream<Arguments> testHandleApplicationServices() {\n+        return Stream.of(Arguments.of(List.of(\"service-1\"), List.of(\"service-1\", \"service-2\"), false, List.of(\"service-1\", \"service-2\")),\n+                         Arguments.of(Collections.emptyList(), List.of(\"service-1\"), false, List.of(\"service-1\")),\n+                         Arguments.of(List.of(\"service-1\", \"service-2\"), Collections.emptyList(), true, null),\n+                         Arguments.of(List.of(\"service-1\"), List.of(\"service-2\"), false, List.of(\"service-1\", \"service-2\")),\n+                         Arguments.of(List.of(\"service-1\"), Collections.emptyList(), false, List.of(\"service-1\")),\n+                         Arguments.of(Collections.emptyList(), List.of(\"service-1\", \"service-2\"), true, null));\n     }\n \n-    private void prepareContext() {\n-        Mockito.when(client.getApplication(eq(input.existingApplication.name), eq(false)))\n-               .thenReturn(input.existingApplication.toCloudApp());\n-        Mockito.when(client.getApplication(eq(input.existingApplication.name)))\n-               .thenReturn(input.existingApplication.toCloudApp());\n-        CloudApplicationExtended cloudApp = input.application.toCloudApp();\n-        // TODO\n-        context.setVariable(Variables.APPS_TO_DEPLOY, Collections.emptyList());\n-        StepsTestUtil.mockApplicationsToDeploy(List.of(cloudApp), execution);\n-        context.setVariable(Variables.SERVICES_TO_BIND, mapToCloudServices());\n-        context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, Collections.emptyMap());\n-        context.setVariable(Variables.MODULES_INDEX, 0);\n-        context.setVariable(Variables.APP_ARCHIVE_ID, \"dummy\");\n-        context.setVariable(Variables.SERVICE_KEYS_CREDENTIALS_TO_INJECT, new HashMap<>());\n-    }\n+    @ParameterizedTest\n+    @MethodSource\n+    void testHandleApplicationServices(List<String> existingServices, List<String> services, boolean shouldSkipServiceRebinding,\n+                                       List<String> expectedServicestoUpdate) {\n+        CloudApplication existingApplication = getApplicationBuilder(false).services(existingServices)\n+                                                                           .build();\n+        CloudApplicationExtended application = getApplicationBuilder(false).services(services)\n+                                                                           .build();\n+        prepareContext(application, shouldSkipServiceRebinding);\n+        prepareClient(existingApplication);\n \n-    private static class StepInput {\n-        SimpleApplication application;\n-        SimpleApplication existingApplication;\n-        Map<String, List<SimpleBinding>> existingServiceBindings;\n-        final Map<String, List<CloudServiceKey>> existingServiceKeys = new HashMap<>();\n-        boolean updateStaging;\n-        boolean updateMemory;\n-        boolean updateDiskQuota;\n-        boolean updateUris;\n-        boolean updateEnv;\n-    }\n+        step.execute(execution);\n \n-    private static class SimpleBinding {\n-        String applicationName;\n-        Map<String, Object> bindingOptions;\n-\n-        CloudServiceBinding toCloudServiceBinding() {\n-            return ImmutableCloudServiceBinding.builder()\n-                                               .metadata(ImmutableCloudMetadata.builder()\n-                                                                               .guid(UUID.randomUUID())\n-                                                                               .build())\n-                                               .applicationGuid(NameUtil.getUUID(applicationName))\n-                                               .bindingOptions(bindingOptions)\n-                                               .build();\n+        assertStepFinishedSuccessfully();\n+        if (shouldSkipServiceRebinding) {\n+            assertTrue(context.getVariable(Variables.SERVICES_TO_UNBIND_BIND)\n+                              .isEmpty());\n+            return;\n         }\n+        assertTrue(expectedServicestoUpdate.containsAll(context.getVariable(Variables.SERVICES_TO_UNBIND_BIND)));\n     }\n \n-    private static class SimpleApplication {\n-        String name;\n-        final List<String> services = Collections.emptyList();\n-        final Map<String, Map<String, Object>> bindingParameters = Collections.emptyMap();\n-        final Map<String, String> env = Collections.emptyMap();\n-        final List<ServiceKeyToInject> serviceKeysToInject = Collections.emptyList();\n-        String command;\n-        final List<String> uris = Collections.emptyList();\n-        String buildpackUrl;\n-        int memory;\n-        int instances;\n-        int diskQuota;\n-        String healthCheckType;\n-        String healthCheckHttpEndpoint;\n-        Boolean sshEnabled;\n-        boolean shouldKeepServiceBindings;\n-\n-        CloudApplicationExtended toCloudApp() {\n-            return ImmutableCloudApplicationExtended.builder()\n-                                                    .attributesUpdateStrategy(ImmutableCloudApplicationExtended.AttributeUpdateStrategy.builder()\n-                                                                                                                                       .shouldKeepExistingServiceBindings(shouldKeepServiceBindings)\n-                                                                                                                                       .build())\n-                                                    .name(name)\n-                                                    .moduleName(\"test\")\n-                                                    .staging(ImmutableStaging.builder()\n-                                                                             .command(command)\n-                                                                             .buildpacks(Collections.singleton(buildpackUrl))\n-                                                                             .healthCheckTimeout(0)\n-                                                                             .detectedBuildpack(\"none\")\n-                                                                             .healthCheckType(healthCheckType)\n-                                                                             .healthCheckHttpEndpoint(healthCheckHttpEndpoint)\n-                                                                             .isSshEnabled(sshEnabled)\n-                                                                             .build())\n-                                                    .memory(memory)\n-                                                    .instances(instances)\n-                                                    .uris(uris)\n-                                                    .env(env)\n-                                                    .services(services)\n-                                                    .state(State.STARTED)\n-                                                    .diskQuota(diskQuota)\n-                                                    .bindingParameters(bindingParameters)\n-                                                    .serviceKeysToInject(serviceKeysToInject)\n-                                                    .metadata(ImmutableCloudMetadata.builder()\n-                                                                                    .guid(NameUtil.getUUID(name))\n-                                                                                    .build())\n-                                                    .build();\n-        }\n-\n+    static Stream<Arguments> testHandleApplicationEnv() {\n+        return Stream.of(Arguments.of(Map.of(\"foo\", \"bar\"), Map.of(\"foo1\", \"bar2\"), true, true),\n+                         Arguments.of(Map.of(\"foo\", \"bar\"), Map.of(\"foo1\", \"bar2\"), false, true),\n+                         Arguments.of(Map.of(\"foo\", \"bar\"), Map.of(\"foo\", \"bar\"), true, false),\n+                         Arguments.of(Map.of(\"foo\", \"bar\"), Map.of(\"foo\", \"bar\"), false, false));\n     }\n \n-    private static class SimpleService {\n-        final String name;\n+    @ParameterizedTest\n+    @MethodSource\n+    void testHandleApplicationEnv(Map<String, String> existingAppEnv, Map<String, String> newAppEnv, boolean keepExistingEnv,\n+                                  boolean expectedUserPropertiesChanged) {\n+        CloudApplication existingApplication = getApplicationBuilder(keepExistingEnv).env(existingAppEnv)\n+                                                                                     .build();\n+        CloudApplicationExtended application = getApplicationBuilder(keepExistingEnv).env(newAppEnv)\n+                                                                                     .build();\n+        prepareContext(application, false);\n+        prepareClient(existingApplication);\n+\n+        step.shouldPrettyPrint = () -> false;\n+        step.execute(execution);\n \n-        SimpleService(String name) {\n-            this.name = name;\n+        assertStepFinishedSuccessfully();\n+        assertEquals(expectedUserPropertiesChanged, context.getVariable(Variables.USER_PROPERTIES_CHANGED));\n+        if (expectedUserPropertiesChanged) {\n+            Map<String, String> expectedEnvMap = buildExpectedEnvMap(existingAppEnv, newAppEnv, keepExistingEnv);\n+            verify(client).updateApplicationEnv(eq(APP_NAME), eq(expectedEnvMap));\n+            return;\n         }\n+        verify(client, never()).updateApplicationEnv(eq(APP_NAME), anyMap());\n+    }\n \n-        CloudServiceInstanceExtended toCloudService() {\n-            return ImmutableCloudServiceInstanceExtended.builder()\n-                                                        .metadata(ImmutableCloudMetadata.builder()\n-                                                                                        .guid(NameUtil.getUUID(name))\n-                                                                                        .build())\n-                                                        .name(name)\n-                                                        .build();\n+    private Map<String, String> buildExpectedEnvMap(Map<String, String> existingAppEnv, Map<String, String> newAppEnv,\n+                                                    boolean keepExistingEnv) {\n+        if (!keepExistingEnv) {\n+            return newAppEnv;\n         }\n+        return Stream.concat(existingAppEnv.entrySet()", "originalCommit": "467d3a9b0822904a9c7ded9721447ba22ff11bd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MDI4OA==", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/979#discussion_r513270288", "bodyText": "This line is a bit hard to read. Extract the disk quota and memory into variables", "author": "radito3", "createdAt": "2020-10-28T08:49:35Z", "path": "multiapps-controller-process/src/test/java/org/cloudfoundry/multiapps/controller/process/steps/CreateOrUpdateAppStepTest.java", "diffHunk": "@@ -1,226 +1,180 @@\n package org.cloudfoundry.multiapps.controller.process.steps;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.mockito.ArgumentMatchers.argThat;\n-import static org.mockito.ArgumentMatchers.eq;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.UUID;\n-import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import org.cloudfoundry.multiapps.common.SLException;\n-import org.cloudfoundry.multiapps.common.test.GenericArgumentMatcher;\n-import org.cloudfoundry.multiapps.common.test.TestUtil;\n import org.cloudfoundry.multiapps.common.util.JsonUtil;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.CloudApplicationExtended;\n-import org.cloudfoundry.multiapps.controller.client.lib.domain.CloudServiceInstanceExtended;\n import org.cloudfoundry.multiapps.controller.client.lib.domain.ImmutableCloudApplicationExtended;\n-import org.cloudfoundry.multiapps.controller.client.lib.domain.ImmutableCloudServiceInstanceExtended;\n+import org.cloudfoundry.multiapps.controller.client.lib.domain.ServiceKeyToInject;\n+import org.cloudfoundry.multiapps.controller.process.Messages;\n import org.cloudfoundry.multiapps.controller.process.variables.Variables;\n-import org.flowable.engine.ProcessEngine;\n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n-import org.mockito.Mock;\n-import org.mockito.Mockito;\n-import org.springframework.http.HttpStatus;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.sap.cloudfoundry.client.facade.ApplicationServicesUpdateCallback;\n-import com.sap.cloudfoundry.client.facade.CloudOperationException;\n-import com.sap.cloudfoundry.client.facade.domain.CloudServiceKey;\n-import com.sap.cloudfoundry.client.facade.domain.ImmutableCloudApplication;\n-import com.sap.cloudfoundry.client.facade.domain.ImmutableCloudMetadata;\n+import com.sap.cloudfoundry.client.facade.domain.DockerInfo;\n+import com.sap.cloudfoundry.client.facade.domain.ImmutableCloudServiceKey;\n+import com.sap.cloudfoundry.client.facade.domain.ImmutableDockerCredentials;\n+import com.sap.cloudfoundry.client.facade.domain.ImmutableDockerInfo;\n+import com.sap.cloudfoundry.client.facade.domain.ImmutableStaging;\n+import com.sap.cloudfoundry.client.facade.domain.Staging;\n \n-class CreateOrUpdateAppStepTest extends CreateOrUpdateAppStepBaseTest {\n+class CreateOrUpdateAppStepTest extends SyncFlowableStepTest<CreateOrUpdateAppStep> {\n \n-    @Mock\n-    private ProcessEngine processEngine;\n+    private static final String APP_NAME = \"test-application\";\n+    private static final String SERVICE_NAME = \"test-service\";\n+    private static final String SERVICE_KEY_NAME = \"test-service-key\";\n+    private static final String SERVICE_KEY_ENV_NAME = \"test-service-key-env\";\n \n-    private String expectedExceptionMessage;\n-    private ApplicationServicesUpdateCallback callback;\n-\n-    public static Stream<Arguments> testExecute() {\n+    static Stream<Arguments> testHandleApplicationAttributes() {\n         return Stream.of(\n-// @formatter:off\n-            // (0) Disk quota is 0:\n-            Arguments.of(\"create-app-step-input-00.json\", null),\n-            // (1) Memory is 0:\n-            Arguments.of(\"create-app-step-input-01.json\", null),\n-            // (2) Everything is specified properly:\n-            Arguments.of(\"create-app-step-input-02.json\", null),\n-            // (3) Binding parameters exist, and the services do too:\n-            Arguments.of(\"create-app-step-input-03.json\", null),\n-            // (4) Binding parameters exist, but the services do not:\n-            Arguments.of(\"create-app-step-input-04.json\", \"Could not bind service \\\"application\\\" to application \\\"service-2\\\": 500 Internal Server Error: Something happened!\"),\n-            // (5) Binding parameters exist, but the services do not and service-2 is optional - so no exception should be thrown:\n-            Arguments.of(\"create-app-step-input-05.json\", null),\n-            // (6) Service keys to inject are specified:\n-            Arguments.of(\"create-app-step-input-06.json\", null),\n-            // (7) Service keys to inject are specified but not exist:\n-            Arguments.of(\"create-app-step-input-07.json\",\n-                    \"Unable to retrieve required service key element \\\"expected-service-key\\\" for service \\\"existing-service\\\"\")\n-// @formatter:on\n+//@formatter:off\n+                         // (1) Everything is specified properly:\n+                         Arguments.of(ImmutableStaging.builder().command(\"command1\").healthCheckType(\"none\").addBuildpack(\"buildpackUrl\").build(),\n+                                      128, 256, List.of(\"example.com\", \"foo-bar.xyz\")),\n+                         // (2) Disk quota is 0:\n+                         Arguments.of(null, 0, 256, Collections.emptyList()),\n+                         // (3) Memory is 0:\n+                         Arguments.of(null, 1024, 0, Collections.emptyList())\n+//@formatter:on             \n         );\n     }\n \n     @ParameterizedTest\n     @MethodSource\n-    void testExecute(String stepInput, String expectedExceptionMessage) {\n-        initializeParameters(stepInput, expectedExceptionMessage);\n-        if (expectedExceptionMessage != null) {\n-            assertThrows(SLException.class, () -> step.execute(execution));\n-            return;\n-        }\n+    void testHandleApplicationAttributes(Staging staging, int diskQuota, int memory, List<String> uris) {\n+        CloudApplicationExtended application = buildApplication(staging, diskQuota, memory, uris);\n+        prepareContext(application, Collections.emptyMap());\n+\n         step.execute(execution);\n-        assertStepFinishedSuccessfully();\n \n-        validateClient();\n+        assertStepFinishedSuccessfully();\n+        verify(client).createApplication(APP_NAME, staging, diskQuota == 0 ? null : diskQuota, memory == 0 ? null : memory, uris, null);", "originalCommit": "467d3a9b0822904a9c7ded9721447ba22ff11bd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74c69a2088c8c2da53d31782bf4ff6a25d1ddd45", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/74c69a2088c8c2da53d31782bf4ff6a25d1ddd45", "message": "Remove backward compatability logic for bind/unbind services\n\nDue to previously started processes it was necessary to keep old logic\nfor binding/unbinding services. With this change old logic is removed\nand unit tests are refactored.", "committedDate": "2020-10-28T09:26:03Z", "type": "commit"}, {"oid": "74c69a2088c8c2da53d31782bf4ff6a25d1ddd45", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/commit/74c69a2088c8c2da53d31782bf4ff6a25d1ddd45", "message": "Remove backward compatability logic for bind/unbind services\n\nDue to previously started processes it was necessary to keep old logic\nfor binding/unbinding services. With this change old logic is removed\nand unit tests are refactored.", "committedDate": "2020-10-28T09:26:03Z", "type": "forcePushed"}]}